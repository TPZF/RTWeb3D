(function (root, factory) {		    if (typeof define === 'function' && define.amd) {			define(['jquery', 'underscore'], factory);		    } else {			root.MizarWidget = factory(root.$, root._);		    }		}(this, function ($, _) {
/**
 * @license almond 0.2.9 Copyright (c) 2011-2014, The Dojo Foundation All Rights Reserved.
 * Available via the MIT or new BSD license.
 * see: http://github.com/jrburke/almond for details
 */
//Going sloppy to avoid 'use strict' string cost, but strict practices should
//be followed.
/*jslint sloppy: true */
/*global setTimeout: false */

var requirejs, require, define;
(function (undef) {
    var main, req, makeMap, handlers,
        defined = {},
        waiting = {},
        config = {},
        defining = {},
        hasOwn = Object.prototype.hasOwnProperty,
        aps = [].slice,
        jsSuffixRegExp = /\.js$/;

    function hasProp(obj, prop) {
        return hasOwn.call(obj, prop);
    }

    /**
     * Given a relative module name, like ./something, normalize it to
     * a real name that can be mapped to a path.
     * @param {String} name the relative name
     * @param {String} baseName a real name that the name arg is relative
     * to.
     * @returns {String} normalized name
     */
    function normalize(name, baseName) {
        var nameParts, nameSegment, mapValue, foundMap, lastIndex,
            foundI, foundStarMap, starI, i, j, part,
            baseParts = baseName && baseName.split("/"),
            map = config.map,
            starMap = (map && map['*']) || {};

        //Adjust any relative paths.
        if (name && name.charAt(0) === ".") {
            //If have a base name, try to normalize against it,
            //otherwise, assume it is a top-level require that will
            //be relative to baseUrl in the end.
            if (baseName) {
                //Convert baseName to array, and lop off the last part,
                //so that . matches that "directory" and not name of the baseName's
                //module. For instance, baseName of "one/two/three", maps to
                //"one/two/three.js", but we want the directory, "one/two" for
                //this normalization.
                baseParts = baseParts.slice(0, baseParts.length - 1);
                name = name.split('/');
                lastIndex = name.length - 1;

                // Node .js allowance:
                if (config.nodeIdCompat && jsSuffixRegExp.test(name[lastIndex])) {
                    name[lastIndex] = name[lastIndex].replace(jsSuffixRegExp, '');
                }

                name = baseParts.concat(name);

                //start trimDots
                for (i = 0; i < name.length; i += 1) {
                    part = name[i];
                    if (part === ".") {
                        name.splice(i, 1);
                        i -= 1;
                    } else if (part === "..") {
                        if (i === 1 && (name[2] === '..' || name[0] === '..')) {
                            //End of the line. Keep at least one non-dot
                            //path segment at the front so it can be mapped
                            //correctly to disk. Otherwise, there is likely
                            //no path mapping for a path starting with '..'.
                            //This can still fail, but catches the most reasonable
                            //uses of ..
                            break;
                        } else if (i > 0) {
                            name.splice(i - 1, 2);
                            i -= 2;
                        }
                    }
                }
                //end trimDots

                name = name.join("/");
            } else if (name.indexOf('./') === 0) {
                // No baseName, so this is ID is resolved relative
                // to baseUrl, pull off the leading dot.
                name = name.substring(2);
            }
        }

        //Apply map config if available.
        if ((baseParts || starMap) && map) {
            nameParts = name.split('/');

            for (i = nameParts.length; i > 0; i -= 1) {
                nameSegment = nameParts.slice(0, i).join("/");

                if (baseParts) {
                    //Find the longest baseName segment match in the config.
                    //So, do joins on the biggest to smallest lengths of baseParts.
                    for (j = baseParts.length; j > 0; j -= 1) {
                        mapValue = map[baseParts.slice(0, j).join('/')];

                        //baseName segment has  config, find if it has one for
                        //this name.
                        if (mapValue) {
                            mapValue = mapValue[nameSegment];
                            if (mapValue) {
                                //Match, update name to the new value.
                                foundMap = mapValue;
                                foundI = i;
                                break;
                            }
                        }
                    }
                }

                if (foundMap) {
                    break;
                }

                //Check for a star map match, but just hold on to it,
                //if there is a shorter segment match later in a matching
                //config, then favor over this star map.
                if (!foundStarMap && starMap && starMap[nameSegment]) {
                    foundStarMap = starMap[nameSegment];
                    starI = i;
                }
            }

            if (!foundMap && foundStarMap) {
                foundMap = foundStarMap;
                foundI = starI;
            }

            if (foundMap) {
                nameParts.splice(0, foundI, foundMap);
                name = nameParts.join('/');
            }
        }

        return name;
    }

    function makeRequire(relName, forceSync) {
        return function () {
            //A version of a require function that passes a moduleName
            //value for items that may need to
            //look up paths relative to the moduleName
            return req.apply(undef, aps.call(arguments, 0).concat([relName, forceSync]));
        };
    }

    function makeNormalize(relName) {
        return function (name) {
            return normalize(name, relName);
        };
    }

    function makeLoad(depName) {
        return function (value) {
            defined[depName] = value;
        };
    }

    function callDep(name) {
        if (hasProp(waiting, name)) {
            var args = waiting[name];
            delete waiting[name];
            defining[name] = true;
            main.apply(undef, args);
        }

        if (!hasProp(defined, name) && !hasProp(defining, name)) {
            throw new Error('No ' + name);
        }
        return defined[name];
    }

    //Turns a plugin!resource to [plugin, resource]
    //with the plugin being undefined if the name
    //did not have a plugin prefix.
    function splitPrefix(name) {
        var prefix,
            index = name ? name.indexOf('!') : -1;
        if (index > -1) {
            prefix = name.substring(0, index);
            name = name.substring(index + 1, name.length);
        }
        return [prefix, name];
    }

    /**
     * Makes a name map, normalizing the name, and using a plugin
     * for normalization if necessary. Grabs a ref to plugin
     * too, as an optimization.
     */
    makeMap = function (name, relName) {
        var plugin,
            parts = splitPrefix(name),
            prefix = parts[0];

        name = parts[1];

        if (prefix) {
            prefix = normalize(prefix, relName);
            plugin = callDep(prefix);
        }

        //Normalize according
        if (prefix) {
            if (plugin && plugin.normalize) {
                name = plugin.normalize(name, makeNormalize(relName));
            } else {
                name = normalize(name, relName);
            }
        } else {
            name = normalize(name, relName);
            parts = splitPrefix(name);
            prefix = parts[0];
            name = parts[1];
            if (prefix) {
                plugin = callDep(prefix);
            }
        }

        //Using ridiculous property names for space reasons
        return {
            f: prefix ? prefix + '!' + name : name, //fullName
            n: name,
            pr: prefix,
            p: plugin
        };
    };

    function makeConfig(name) {
        return function () {
            return (config && config.config && config.config[name]) || {};
        };
    }

    handlers = {
        require: function (name) {
            return makeRequire(name);
        },
        exports: function (name) {
            var e = defined[name];
            if (typeof e !== 'undefined') {
                return e;
            } else {
                return (defined[name] = {});
            }
        },
        module: function (name) {
            return {
                id: name,
                uri: '',
                exports: defined[name],
                config: makeConfig(name)
            };
        }
    };

    main = function (name, deps, callback, relName) {
        var cjsModule, depName, ret, map, i,
            args = [],
            callbackType = typeof callback,
            usingExports;

        //Use name if no relName
        relName = relName || name;

        //Call the callback to define the module, if necessary.
        if (callbackType === 'undefined' || callbackType === 'function') {
            //Pull out the defined dependencies and pass the ordered
            //values to the callback.
            //Default to [require, exports, module] if no deps
            deps = !deps.length && callback.length ? ['require', 'exports', 'module'] : deps;
            for (i = 0; i < deps.length; i += 1) {
                map = makeMap(deps[i], relName);
                depName = map.f;

                //Fast path CommonJS standard dependencies.
                if (depName === "require") {
                    args[i] = handlers.require(name);
                } else if (depName === "exports") {
                    //CommonJS module spec 1.1
                    args[i] = handlers.exports(name);
                    usingExports = true;
                } else if (depName === "module") {
                    //CommonJS module spec 1.1
                    cjsModule = args[i] = handlers.module(name);
                } else if (hasProp(defined, depName) ||
                           hasProp(waiting, depName) ||
                           hasProp(defining, depName)) {
                    args[i] = callDep(depName);
                } else if (map.p) {
                    map.p.load(map.n, makeRequire(relName, true), makeLoad(depName), {});
                    args[i] = defined[depName];
                } else {
                    throw new Error(name + ' missing ' + depName);
                }
            }

            ret = callback ? callback.apply(defined[name], args) : undefined;

            if (name) {
                //If setting exports via "module" is in play,
                //favor that over return value and exports. After that,
                //favor a non-undefined return value over exports use.
                if (cjsModule && cjsModule.exports !== undef &&
                        cjsModule.exports !== defined[name]) {
                    defined[name] = cjsModule.exports;
                } else if (ret !== undef || !usingExports) {
                    //Use the return value from the function.
                    defined[name] = ret;
                }
            }
        } else if (name) {
            //May just be an object definition for the module. Only
            //worry about defining if have a module name.
            defined[name] = callback;
        }
    };

    requirejs = require = req = function (deps, callback, relName, forceSync, alt) {
        if (typeof deps === "string") {
            if (handlers[deps]) {
                //callback in this case is really relName
                return handlers[deps](callback);
            }
            //Just return the module wanted. In this scenario, the
            //deps arg is the module name, and second arg (if passed)
            //is just the relName.
            //Normalize module name, if it contains . or ..
            return callDep(makeMap(deps, callback).f);
        } else if (!deps.splice) {
            //deps is a config object, not an array.
            config = deps;
            if (config.deps) {
                req(config.deps, config.callback);
            }
            if (!callback) {
                return;
            }

            if (callback.splice) {
                //callback is an array, which means it is a dependency list.
                //Adjust args if there are dependencies
                deps = callback;
                callback = relName;
                relName = null;
            } else {
                deps = undef;
            }
        }

        //Support require(['a'])
        callback = callback || function () {};

        //If relName is a function, it is an errback handler,
        //so remove it.
        if (typeof relName === 'function') {
            relName = forceSync;
            forceSync = alt;
        }

        //Simulate async callback;
        if (forceSync) {
            main(undef, deps, callback, relName);
        } else {
            //Using a non-zero value because of concern for what old browsers
            //do, and latest browsers "upgrade" to 4 if lower value is used:
            //http://www.whatwg.org/specs/web-apps/current-work/multipage/timers.html#dom-windowtimers-settimeout:
            //If want a value immediately, use require('id') instead -- something
            //that works in almond on the global level, but not guaranteed and
            //unlikely to work in other AMD implementations.
            setTimeout(function () {
                main(undef, deps, callback, relName);
            }, 4);
        }

        return req;
    };

    /**
     * Just drops the config on the floor, but returns req in case
     * the config return value is used.
     */
    req.config = function (cfg) {
        return req(cfg);
    };

    /**
     * Expose module registry for debugging and tooling
     */
    requirejs._defined = defined;

    define = function (name, deps, callback) {

        //This module may not have dependencies
        if (!deps.splice) {
            //deps is not an array, so probably means
            //an object literal or factory function for
            //the value. Adjust args.
            callback = deps;
            deps = [];
        }

        if (!hasProp(defined, name) && !hasProp(waiting, name)) {
            waiting[name] = [name, deps, callback];
        }
    };

    define.amd = {
        jQuery: true
    };
}());

define("../build/almond", function(){});

/*! jQuery v1.11.1 | (c) 2005, 2014 jQuery Foundation, Inc. | jquery.org/license */
!function(a,b){"object"==typeof module&&"object"==typeof module.exports?module.exports=a.document?b(a,!0):function(a){if(!a.document)throw new Error("jQuery requires a window with a document");return b(a)}:b(a)}("undefined"!=typeof window?window:this,function(a,b){var c=[],d=c.slice,e=c.concat,f=c.push,g=c.indexOf,h={},i=h.toString,j=h.hasOwnProperty,k={},l="1.11.1",m=function(a,b){return new m.fn.init(a,b)},n=/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,o=/^-ms-/,p=/-([\da-z])/gi,q=function(a,b){return b.toUpperCase()};m.fn=m.prototype={jquery:l,constructor:m,selector:"",length:0,toArray:function(){return d.call(this)},get:function(a){return null!=a?0>a?this[a+this.length]:this[a]:d.call(this)},pushStack:function(a){var b=m.merge(this.constructor(),a);return b.prevObject=this,b.context=this.context,b},each:function(a,b){return m.each(this,a,b)},map:function(a){return this.pushStack(m.map(this,function(b,c){return a.call(b,c,b)}))},slice:function(){return this.pushStack(d.apply(this,arguments))},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},eq:function(a){var b=this.length,c=+a+(0>a?b:0);return this.pushStack(c>=0&&b>c?[this[c]]:[])},end:function(){return this.prevObject||this.constructor(null)},push:f,sort:c.sort,splice:c.splice},m.extend=m.fn.extend=function(){var a,b,c,d,e,f,g=arguments[0]||{},h=1,i=arguments.length,j=!1;for("boolean"==typeof g&&(j=g,g=arguments[h]||{},h++),"object"==typeof g||m.isFunction(g)||(g={}),h===i&&(g=this,h--);i>h;h++)if(null!=(e=arguments[h]))for(d in e)a=g[d],c=e[d],g!==c&&(j&&c&&(m.isPlainObject(c)||(b=m.isArray(c)))?(b?(b=!1,f=a&&m.isArray(a)?a:[]):f=a&&m.isPlainObject(a)?a:{},g[d]=m.extend(j,f,c)):void 0!==c&&(g[d]=c));return g},m.extend({expando:"jQuery"+(l+Math.random()).replace(/\D/g,""),isReady:!0,error:function(a){throw new Error(a)},noop:function(){},isFunction:function(a){return"function"===m.type(a)},isArray:Array.isArray||function(a){return"array"===m.type(a)},isWindow:function(a){return null!=a&&a==a.window},isNumeric:function(a){return!m.isArray(a)&&a-parseFloat(a)>=0},isEmptyObject:function(a){var b;for(b in a)return!1;return!0},isPlainObject:function(a){var b;if(!a||"object"!==m.type(a)||a.nodeType||m.isWindow(a))return!1;try{if(a.constructor&&!j.call(a,"constructor")&&!j.call(a.constructor.prototype,"isPrototypeOf"))return!1}catch(c){return!1}if(k.ownLast)for(b in a)return j.call(a,b);for(b in a);return void 0===b||j.call(a,b)},type:function(a){return null==a?a+"":"object"==typeof a||"function"==typeof a?h[i.call(a)]||"object":typeof a},globalEval:function(b){b&&m.trim(b)&&(a.execScript||function(b){a.eval.call(a,b)})(b)},camelCase:function(a){return a.replace(o,"ms-").replace(p,q)},nodeName:function(a,b){return a.nodeName&&a.nodeName.toLowerCase()===b.toLowerCase()},each:function(a,b,c){var d,e=0,f=a.length,g=r(a);if(c){if(g){for(;f>e;e++)if(d=b.apply(a[e],c),d===!1)break}else for(e in a)if(d=b.apply(a[e],c),d===!1)break}else if(g){for(;f>e;e++)if(d=b.call(a[e],e,a[e]),d===!1)break}else for(e in a)if(d=b.call(a[e],e,a[e]),d===!1)break;return a},trim:function(a){return null==a?"":(a+"").replace(n,"")},makeArray:function(a,b){var c=b||[];return null!=a&&(r(Object(a))?m.merge(c,"string"==typeof a?[a]:a):f.call(c,a)),c},inArray:function(a,b,c){var d;if(b){if(g)return g.call(b,a,c);for(d=b.length,c=c?0>c?Math.max(0,d+c):c:0;d>c;c++)if(c in b&&b[c]===a)return c}return-1},merge:function(a,b){var c=+b.length,d=0,e=a.length;while(c>d)a[e++]=b[d++];if(c!==c)while(void 0!==b[d])a[e++]=b[d++];return a.length=e,a},grep:function(a,b,c){for(var d,e=[],f=0,g=a.length,h=!c;g>f;f++)d=!b(a[f],f),d!==h&&e.push(a[f]);return e},map:function(a,b,c){var d,f=0,g=a.length,h=r(a),i=[];if(h)for(;g>f;f++)d=b(a[f],f,c),null!=d&&i.push(d);else for(f in a)d=b(a[f],f,c),null!=d&&i.push(d);return e.apply([],i)},guid:1,proxy:function(a,b){var c,e,f;return"string"==typeof b&&(f=a[b],b=a,a=f),m.isFunction(a)?(c=d.call(arguments,2),e=function(){return a.apply(b||this,c.concat(d.call(arguments)))},e.guid=a.guid=a.guid||m.guid++,e):void 0},now:function(){return+new Date},support:k}),m.each("Boolean Number String Function Array Date RegExp Object Error".split(" "),function(a,b){h["[object "+b+"]"]=b.toLowerCase()});function r(a){var b=a.length,c=m.type(a);return"function"===c||m.isWindow(a)?!1:1===a.nodeType&&b?!0:"array"===c||0===b||"number"==typeof b&&b>0&&b-1 in a}var s=function(a){var b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u="sizzle"+-new Date,v=a.document,w=0,x=0,y=gb(),z=gb(),A=gb(),B=function(a,b){return a===b&&(l=!0),0},C="undefined",D=1<<31,E={}.hasOwnProperty,F=[],G=F.pop,H=F.push,I=F.push,J=F.slice,K=F.indexOf||function(a){for(var b=0,c=this.length;c>b;b++)if(this[b]===a)return b;return-1},L="checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",M="[\\x20\\t\\r\\n\\f]",N="(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",O=N.replace("w","w#"),P="\\["+M+"*("+N+")(?:"+M+"*([*^$|!~]?=)"+M+"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|("+O+"))|)"+M+"*\\]",Q=":("+N+")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|"+P+")*)|.*)\\)|)",R=new RegExp("^"+M+"+|((?:^|[^\\\\])(?:\\\\.)*)"+M+"+$","g"),S=new RegExp("^"+M+"*,"+M+"*"),T=new RegExp("^"+M+"*([>+~]|"+M+")"+M+"*"),U=new RegExp("="+M+"*([^\\]'\"]*?)"+M+"*\\]","g"),V=new RegExp(Q),W=new RegExp("^"+O+"$"),X={ID:new RegExp("^#("+N+")"),CLASS:new RegExp("^\\.("+N+")"),TAG:new RegExp("^("+N.replace("w","w*")+")"),ATTR:new RegExp("^"+P),PSEUDO:new RegExp("^"+Q),CHILD:new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\("+M+"*(even|odd|(([+-]|)(\\d*)n|)"+M+"*(?:([+-]|)"+M+"*(\\d+)|))"+M+"*\\)|)","i"),bool:new RegExp("^(?:"+L+")$","i"),needsContext:new RegExp("^"+M+"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\("+M+"*((?:-\\d)?\\d*)"+M+"*\\)|)(?=[^-]|$)","i")},Y=/^(?:input|select|textarea|button)$/i,Z=/^h\d$/i,$=/^[^{]+\{\s*\[native \w/,_=/^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,ab=/[+~]/,bb=/'|\\/g,cb=new RegExp("\\\\([\\da-f]{1,6}"+M+"?|("+M+")|.)","ig"),db=function(a,b,c){var d="0x"+b-65536;return d!==d||c?b:0>d?String.fromCharCode(d+65536):String.fromCharCode(d>>10|55296,1023&d|56320)};try{I.apply(F=J.call(v.childNodes),v.childNodes),F[v.childNodes.length].nodeType}catch(eb){I={apply:F.length?function(a,b){H.apply(a,J.call(b))}:function(a,b){var c=a.length,d=0;while(a[c++]=b[d++]);a.length=c-1}}}function fb(a,b,d,e){var f,h,j,k,l,o,r,s,w,x;if((b?b.ownerDocument||b:v)!==n&&m(b),b=b||n,d=d||[],!a||"string"!=typeof a)return d;if(1!==(k=b.nodeType)&&9!==k)return[];if(p&&!e){if(f=_.exec(a))if(j=f[1]){if(9===k){if(h=b.getElementById(j),!h||!h.parentNode)return d;if(h.id===j)return d.push(h),d}else if(b.ownerDocument&&(h=b.ownerDocument.getElementById(j))&&t(b,h)&&h.id===j)return d.push(h),d}else{if(f[2])return I.apply(d,b.getElementsByTagName(a)),d;if((j=f[3])&&c.getElementsByClassName&&b.getElementsByClassName)return I.apply(d,b.getElementsByClassName(j)),d}if(c.qsa&&(!q||!q.test(a))){if(s=r=u,w=b,x=9===k&&a,1===k&&"object"!==b.nodeName.toLowerCase()){o=g(a),(r=b.getAttribute("id"))?s=r.replace(bb,"\\$&"):b.setAttribute("id",s),s="[id='"+s+"'] ",l=o.length;while(l--)o[l]=s+qb(o[l]);w=ab.test(a)&&ob(b.parentNode)||b,x=o.join(",")}if(x)try{return I.apply(d,w.querySelectorAll(x)),d}catch(y){}finally{r||b.removeAttribute("id")}}}return i(a.replace(R,"$1"),b,d,e)}function gb(){var a=[];function b(c,e){return a.push(c+" ")>d.cacheLength&&delete b[a.shift()],b[c+" "]=e}return b}function hb(a){return a[u]=!0,a}function ib(a){var b=n.createElement("div");try{return!!a(b)}catch(c){return!1}finally{b.parentNode&&b.parentNode.removeChild(b),b=null}}function jb(a,b){var c=a.split("|"),e=a.length;while(e--)d.attrHandle[c[e]]=b}function kb(a,b){var c=b&&a,d=c&&1===a.nodeType&&1===b.nodeType&&(~b.sourceIndex||D)-(~a.sourceIndex||D);if(d)return d;if(c)while(c=c.nextSibling)if(c===b)return-1;return a?1:-1}function lb(a){return function(b){var c=b.nodeName.toLowerCase();return"input"===c&&b.type===a}}function mb(a){return function(b){var c=b.nodeName.toLowerCase();return("input"===c||"button"===c)&&b.type===a}}function nb(a){return hb(function(b){return b=+b,hb(function(c,d){var e,f=a([],c.length,b),g=f.length;while(g--)c[e=f[g]]&&(c[e]=!(d[e]=c[e]))})})}function ob(a){return a&&typeof a.getElementsByTagName!==C&&a}c=fb.support={},f=fb.isXML=function(a){var b=a&&(a.ownerDocument||a).documentElement;return b?"HTML"!==b.nodeName:!1},m=fb.setDocument=function(a){var b,e=a?a.ownerDocument||a:v,g=e.defaultView;return e!==n&&9===e.nodeType&&e.documentElement?(n=e,o=e.documentElement,p=!f(e),g&&g!==g.top&&(g.addEventListener?g.addEventListener("unload",function(){m()},!1):g.attachEvent&&g.attachEvent("onunload",function(){m()})),c.attributes=ib(function(a){return a.className="i",!a.getAttribute("className")}),c.getElementsByTagName=ib(function(a){return a.appendChild(e.createComment("")),!a.getElementsByTagName("*").length}),c.getElementsByClassName=$.test(e.getElementsByClassName)&&ib(function(a){return a.innerHTML="<div class='a'></div><div class='a i'></div>",a.firstChild.className="i",2===a.getElementsByClassName("i").length}),c.getById=ib(function(a){return o.appendChild(a).id=u,!e.getElementsByName||!e.getElementsByName(u).length}),c.getById?(d.find.ID=function(a,b){if(typeof b.getElementById!==C&&p){var c=b.getElementById(a);return c&&c.parentNode?[c]:[]}},d.filter.ID=function(a){var b=a.replace(cb,db);return function(a){return a.getAttribute("id")===b}}):(delete d.find.ID,d.filter.ID=function(a){var b=a.replace(cb,db);return function(a){var c=typeof a.getAttributeNode!==C&&a.getAttributeNode("id");return c&&c.value===b}}),d.find.TAG=c.getElementsByTagName?function(a,b){return typeof b.getElementsByTagName!==C?b.getElementsByTagName(a):void 0}:function(a,b){var c,d=[],e=0,f=b.getElementsByTagName(a);if("*"===a){while(c=f[e++])1===c.nodeType&&d.push(c);return d}return f},d.find.CLASS=c.getElementsByClassName&&function(a,b){return typeof b.getElementsByClassName!==C&&p?b.getElementsByClassName(a):void 0},r=[],q=[],(c.qsa=$.test(e.querySelectorAll))&&(ib(function(a){a.innerHTML="<select msallowclip=''><option selected=''></option></select>",a.querySelectorAll("[msallowclip^='']").length&&q.push("[*^$]="+M+"*(?:''|\"\")"),a.querySelectorAll("[selected]").length||q.push("\\["+M+"*(?:value|"+L+")"),a.querySelectorAll(":checked").length||q.push(":checked")}),ib(function(a){var b=e.createElement("input");b.setAttribute("type","hidden"),a.appendChild(b).setAttribute("name","D"),a.querySelectorAll("[name=d]").length&&q.push("name"+M+"*[*^$|!~]?="),a.querySelectorAll(":enabled").length||q.push(":enabled",":disabled"),a.querySelectorAll("*,:x"),q.push(",.*:")})),(c.matchesSelector=$.test(s=o.matches||o.webkitMatchesSelector||o.mozMatchesSelector||o.oMatchesSelector||o.msMatchesSelector))&&ib(function(a){c.disconnectedMatch=s.call(a,"div"),s.call(a,"[s!='']:x"),r.push("!=",Q)}),q=q.length&&new RegExp(q.join("|")),r=r.length&&new RegExp(r.join("|")),b=$.test(o.compareDocumentPosition),t=b||$.test(o.contains)?function(a,b){var c=9===a.nodeType?a.documentElement:a,d=b&&b.parentNode;return a===d||!(!d||1!==d.nodeType||!(c.contains?c.contains(d):a.compareDocumentPosition&&16&a.compareDocumentPosition(d)))}:function(a,b){if(b)while(b=b.parentNode)if(b===a)return!0;return!1},B=b?function(a,b){if(a===b)return l=!0,0;var d=!a.compareDocumentPosition-!b.compareDocumentPosition;return d?d:(d=(a.ownerDocument||a)===(b.ownerDocument||b)?a.compareDocumentPosition(b):1,1&d||!c.sortDetached&&b.compareDocumentPosition(a)===d?a===e||a.ownerDocument===v&&t(v,a)?-1:b===e||b.ownerDocument===v&&t(v,b)?1:k?K.call(k,a)-K.call(k,b):0:4&d?-1:1)}:function(a,b){if(a===b)return l=!0,0;var c,d=0,f=a.parentNode,g=b.parentNode,h=[a],i=[b];if(!f||!g)return a===e?-1:b===e?1:f?-1:g?1:k?K.call(k,a)-K.call(k,b):0;if(f===g)return kb(a,b);c=a;while(c=c.parentNode)h.unshift(c);c=b;while(c=c.parentNode)i.unshift(c);while(h[d]===i[d])d++;return d?kb(h[d],i[d]):h[d]===v?-1:i[d]===v?1:0},e):n},fb.matches=function(a,b){return fb(a,null,null,b)},fb.matchesSelector=function(a,b){if((a.ownerDocument||a)!==n&&m(a),b=b.replace(U,"='$1']"),!(!c.matchesSelector||!p||r&&r.test(b)||q&&q.test(b)))try{var d=s.call(a,b);if(d||c.disconnectedMatch||a.document&&11!==a.document.nodeType)return d}catch(e){}return fb(b,n,null,[a]).length>0},fb.contains=function(a,b){return(a.ownerDocument||a)!==n&&m(a),t(a,b)},fb.attr=function(a,b){(a.ownerDocument||a)!==n&&m(a);var e=d.attrHandle[b.toLowerCase()],f=e&&E.call(d.attrHandle,b.toLowerCase())?e(a,b,!p):void 0;return void 0!==f?f:c.attributes||!p?a.getAttribute(b):(f=a.getAttributeNode(b))&&f.specified?f.value:null},fb.error=function(a){throw new Error("Syntax error, unrecognized expression: "+a)},fb.uniqueSort=function(a){var b,d=[],e=0,f=0;if(l=!c.detectDuplicates,k=!c.sortStable&&a.slice(0),a.sort(B),l){while(b=a[f++])b===a[f]&&(e=d.push(f));while(e--)a.splice(d[e],1)}return k=null,a},e=fb.getText=function(a){var b,c="",d=0,f=a.nodeType;if(f){if(1===f||9===f||11===f){if("string"==typeof a.textContent)return a.textContent;for(a=a.firstChild;a;a=a.nextSibling)c+=e(a)}else if(3===f||4===f)return a.nodeValue}else while(b=a[d++])c+=e(b);return c},d=fb.selectors={cacheLength:50,createPseudo:hb,match:X,attrHandle:{},find:{},relative:{">":{dir:"parentNode",first:!0}," ":{dir:"parentNode"},"+":{dir:"previousSibling",first:!0},"~":{dir:"previousSibling"}},preFilter:{ATTR:function(a){return a[1]=a[1].replace(cb,db),a[3]=(a[3]||a[4]||a[5]||"").replace(cb,db),"~="===a[2]&&(a[3]=" "+a[3]+" "),a.slice(0,4)},CHILD:function(a){return a[1]=a[1].toLowerCase(),"nth"===a[1].slice(0,3)?(a[3]||fb.error(a[0]),a[4]=+(a[4]?a[5]+(a[6]||1):2*("even"===a[3]||"odd"===a[3])),a[5]=+(a[7]+a[8]||"odd"===a[3])):a[3]&&fb.error(a[0]),a},PSEUDO:function(a){var b,c=!a[6]&&a[2];return X.CHILD.test(a[0])?null:(a[3]?a[2]=a[4]||a[5]||"":c&&V.test(c)&&(b=g(c,!0))&&(b=c.indexOf(")",c.length-b)-c.length)&&(a[0]=a[0].slice(0,b),a[2]=c.slice(0,b)),a.slice(0,3))}},filter:{TAG:function(a){var b=a.replace(cb,db).toLowerCase();return"*"===a?function(){return!0}:function(a){return a.nodeName&&a.nodeName.toLowerCase()===b}},CLASS:function(a){var b=y[a+" "];return b||(b=new RegExp("(^|"+M+")"+a+"("+M+"|$)"))&&y(a,function(a){return b.test("string"==typeof a.className&&a.className||typeof a.getAttribute!==C&&a.getAttribute("class")||"")})},ATTR:function(a,b,c){return function(d){var e=fb.attr(d,a);return null==e?"!="===b:b?(e+="","="===b?e===c:"!="===b?e!==c:"^="===b?c&&0===e.indexOf(c):"*="===b?c&&e.indexOf(c)>-1:"$="===b?c&&e.slice(-c.length)===c:"~="===b?(" "+e+" ").indexOf(c)>-1:"|="===b?e===c||e.slice(0,c.length+1)===c+"-":!1):!0}},CHILD:function(a,b,c,d,e){var f="nth"!==a.slice(0,3),g="last"!==a.slice(-4),h="of-type"===b;return 1===d&&0===e?function(a){return!!a.parentNode}:function(b,c,i){var j,k,l,m,n,o,p=f!==g?"nextSibling":"previousSibling",q=b.parentNode,r=h&&b.nodeName.toLowerCase(),s=!i&&!h;if(q){if(f){while(p){l=b;while(l=l[p])if(h?l.nodeName.toLowerCase()===r:1===l.nodeType)return!1;o=p="only"===a&&!o&&"nextSibling"}return!0}if(o=[g?q.firstChild:q.lastChild],g&&s){k=q[u]||(q[u]={}),j=k[a]||[],n=j[0]===w&&j[1],m=j[0]===w&&j[2],l=n&&q.childNodes[n];while(l=++n&&l&&l[p]||(m=n=0)||o.pop())if(1===l.nodeType&&++m&&l===b){k[a]=[w,n,m];break}}else if(s&&(j=(b[u]||(b[u]={}))[a])&&j[0]===w)m=j[1];else while(l=++n&&l&&l[p]||(m=n=0)||o.pop())if((h?l.nodeName.toLowerCase()===r:1===l.nodeType)&&++m&&(s&&((l[u]||(l[u]={}))[a]=[w,m]),l===b))break;return m-=e,m===d||m%d===0&&m/d>=0}}},PSEUDO:function(a,b){var c,e=d.pseudos[a]||d.setFilters[a.toLowerCase()]||fb.error("unsupported pseudo: "+a);return e[u]?e(b):e.length>1?(c=[a,a,"",b],d.setFilters.hasOwnProperty(a.toLowerCase())?hb(function(a,c){var d,f=e(a,b),g=f.length;while(g--)d=K.call(a,f[g]),a[d]=!(c[d]=f[g])}):function(a){return e(a,0,c)}):e}},pseudos:{not:hb(function(a){var b=[],c=[],d=h(a.replace(R,"$1"));return d[u]?hb(function(a,b,c,e){var f,g=d(a,null,e,[]),h=a.length;while(h--)(f=g[h])&&(a[h]=!(b[h]=f))}):function(a,e,f){return b[0]=a,d(b,null,f,c),!c.pop()}}),has:hb(function(a){return function(b){return fb(a,b).length>0}}),contains:hb(function(a){return function(b){return(b.textContent||b.innerText||e(b)).indexOf(a)>-1}}),lang:hb(function(a){return W.test(a||"")||fb.error("unsupported lang: "+a),a=a.replace(cb,db).toLowerCase(),function(b){var c;do if(c=p?b.lang:b.getAttribute("xml:lang")||b.getAttribute("lang"))return c=c.toLowerCase(),c===a||0===c.indexOf(a+"-");while((b=b.parentNode)&&1===b.nodeType);return!1}}),target:function(b){var c=a.location&&a.location.hash;return c&&c.slice(1)===b.id},root:function(a){return a===o},focus:function(a){return a===n.activeElement&&(!n.hasFocus||n.hasFocus())&&!!(a.type||a.href||~a.tabIndex)},enabled:function(a){return a.disabled===!1},disabled:function(a){return a.disabled===!0},checked:function(a){var b=a.nodeName.toLowerCase();return"input"===b&&!!a.checked||"option"===b&&!!a.selected},selected:function(a){return a.parentNode&&a.parentNode.selectedIndex,a.selected===!0},empty:function(a){for(a=a.firstChild;a;a=a.nextSibling)if(a.nodeType<6)return!1;return!0},parent:function(a){return!d.pseudos.empty(a)},header:function(a){return Z.test(a.nodeName)},input:function(a){return Y.test(a.nodeName)},button:function(a){var b=a.nodeName.toLowerCase();return"input"===b&&"button"===a.type||"button"===b},text:function(a){var b;return"input"===a.nodeName.toLowerCase()&&"text"===a.type&&(null==(b=a.getAttribute("type"))||"text"===b.toLowerCase())},first:nb(function(){return[0]}),last:nb(function(a,b){return[b-1]}),eq:nb(function(a,b,c){return[0>c?c+b:c]}),even:nb(function(a,b){for(var c=0;b>c;c+=2)a.push(c);return a}),odd:nb(function(a,b){for(var c=1;b>c;c+=2)a.push(c);return a}),lt:nb(function(a,b,c){for(var d=0>c?c+b:c;--d>=0;)a.push(d);return a}),gt:nb(function(a,b,c){for(var d=0>c?c+b:c;++d<b;)a.push(d);return a})}},d.pseudos.nth=d.pseudos.eq;for(b in{radio:!0,checkbox:!0,file:!0,password:!0,image:!0})d.pseudos[b]=lb(b);for(b in{submit:!0,reset:!0})d.pseudos[b]=mb(b);function pb(){}pb.prototype=d.filters=d.pseudos,d.setFilters=new pb,g=fb.tokenize=function(a,b){var c,e,f,g,h,i,j,k=z[a+" "];if(k)return b?0:k.slice(0);h=a,i=[],j=d.preFilter;while(h){(!c||(e=S.exec(h)))&&(e&&(h=h.slice(e[0].length)||h),i.push(f=[])),c=!1,(e=T.exec(h))&&(c=e.shift(),f.push({value:c,type:e[0].replace(R," ")}),h=h.slice(c.length));for(g in d.filter)!(e=X[g].exec(h))||j[g]&&!(e=j[g](e))||(c=e.shift(),f.push({value:c,type:g,matches:e}),h=h.slice(c.length));if(!c)break}return b?h.length:h?fb.error(a):z(a,i).slice(0)};function qb(a){for(var b=0,c=a.length,d="";c>b;b++)d+=a[b].value;return d}function rb(a,b,c){var d=b.dir,e=c&&"parentNode"===d,f=x++;return b.first?function(b,c,f){while(b=b[d])if(1===b.nodeType||e)return a(b,c,f)}:function(b,c,g){var h,i,j=[w,f];if(g){while(b=b[d])if((1===b.nodeType||e)&&a(b,c,g))return!0}else while(b=b[d])if(1===b.nodeType||e){if(i=b[u]||(b[u]={}),(h=i[d])&&h[0]===w&&h[1]===f)return j[2]=h[2];if(i[d]=j,j[2]=a(b,c,g))return!0}}}function sb(a){return a.length>1?function(b,c,d){var e=a.length;while(e--)if(!a[e](b,c,d))return!1;return!0}:a[0]}function tb(a,b,c){for(var d=0,e=b.length;e>d;d++)fb(a,b[d],c);return c}function ub(a,b,c,d,e){for(var f,g=[],h=0,i=a.length,j=null!=b;i>h;h++)(f=a[h])&&(!c||c(f,d,e))&&(g.push(f),j&&b.push(h));return g}function vb(a,b,c,d,e,f){return d&&!d[u]&&(d=vb(d)),e&&!e[u]&&(e=vb(e,f)),hb(function(f,g,h,i){var j,k,l,m=[],n=[],o=g.length,p=f||tb(b||"*",h.nodeType?[h]:h,[]),q=!a||!f&&b?p:ub(p,m,a,h,i),r=c?e||(f?a:o||d)?[]:g:q;if(c&&c(q,r,h,i),d){j=ub(r,n),d(j,[],h,i),k=j.length;while(k--)(l=j[k])&&(r[n[k]]=!(q[n[k]]=l))}if(f){if(e||a){if(e){j=[],k=r.length;while(k--)(l=r[k])&&j.push(q[k]=l);e(null,r=[],j,i)}k=r.length;while(k--)(l=r[k])&&(j=e?K.call(f,l):m[k])>-1&&(f[j]=!(g[j]=l))}}else r=ub(r===g?r.splice(o,r.length):r),e?e(null,g,r,i):I.apply(g,r)})}function wb(a){for(var b,c,e,f=a.length,g=d.relative[a[0].type],h=g||d.relative[" "],i=g?1:0,k=rb(function(a){return a===b},h,!0),l=rb(function(a){return K.call(b,a)>-1},h,!0),m=[function(a,c,d){return!g&&(d||c!==j)||((b=c).nodeType?k(a,c,d):l(a,c,d))}];f>i;i++)if(c=d.relative[a[i].type])m=[rb(sb(m),c)];else{if(c=d.filter[a[i].type].apply(null,a[i].matches),c[u]){for(e=++i;f>e;e++)if(d.relative[a[e].type])break;return vb(i>1&&sb(m),i>1&&qb(a.slice(0,i-1).concat({value:" "===a[i-2].type?"*":""})).replace(R,"$1"),c,e>i&&wb(a.slice(i,e)),f>e&&wb(a=a.slice(e)),f>e&&qb(a))}m.push(c)}return sb(m)}function xb(a,b){var c=b.length>0,e=a.length>0,f=function(f,g,h,i,k){var l,m,o,p=0,q="0",r=f&&[],s=[],t=j,u=f||e&&d.find.TAG("*",k),v=w+=null==t?1:Math.random()||.1,x=u.length;for(k&&(j=g!==n&&g);q!==x&&null!=(l=u[q]);q++){if(e&&l){m=0;while(o=a[m++])if(o(l,g,h)){i.push(l);break}k&&(w=v)}c&&((l=!o&&l)&&p--,f&&r.push(l))}if(p+=q,c&&q!==p){m=0;while(o=b[m++])o(r,s,g,h);if(f){if(p>0)while(q--)r[q]||s[q]||(s[q]=G.call(i));s=ub(s)}I.apply(i,s),k&&!f&&s.length>0&&p+b.length>1&&fb.uniqueSort(i)}return k&&(w=v,j=t),r};return c?hb(f):f}return h=fb.compile=function(a,b){var c,d=[],e=[],f=A[a+" "];if(!f){b||(b=g(a)),c=b.length;while(c--)f=wb(b[c]),f[u]?d.push(f):e.push(f);f=A(a,xb(e,d)),f.selector=a}return f},i=fb.select=function(a,b,e,f){var i,j,k,l,m,n="function"==typeof a&&a,o=!f&&g(a=n.selector||a);if(e=e||[],1===o.length){if(j=o[0]=o[0].slice(0),j.length>2&&"ID"===(k=j[0]).type&&c.getById&&9===b.nodeType&&p&&d.relative[j[1].type]){if(b=(d.find.ID(k.matches[0].replace(cb,db),b)||[])[0],!b)return e;n&&(b=b.parentNode),a=a.slice(j.shift().value.length)}i=X.needsContext.test(a)?0:j.length;while(i--){if(k=j[i],d.relative[l=k.type])break;if((m=d.find[l])&&(f=m(k.matches[0].replace(cb,db),ab.test(j[0].type)&&ob(b.parentNode)||b))){if(j.splice(i,1),a=f.length&&qb(j),!a)return I.apply(e,f),e;break}}}return(n||h(a,o))(f,b,!p,e,ab.test(a)&&ob(b.parentNode)||b),e},c.sortStable=u.split("").sort(B).join("")===u,c.detectDuplicates=!!l,m(),c.sortDetached=ib(function(a){return 1&a.compareDocumentPosition(n.createElement("div"))}),ib(function(a){return a.innerHTML="<a href='#'></a>","#"===a.firstChild.getAttribute("href")})||jb("type|href|height|width",function(a,b,c){return c?void 0:a.getAttribute(b,"type"===b.toLowerCase()?1:2)}),c.attributes&&ib(function(a){return a.innerHTML="<input/>",a.firstChild.setAttribute("value",""),""===a.firstChild.getAttribute("value")})||jb("value",function(a,b,c){return c||"input"!==a.nodeName.toLowerCase()?void 0:a.defaultValue}),ib(function(a){return null==a.getAttribute("disabled")})||jb(L,function(a,b,c){var d;return c?void 0:a[b]===!0?b.toLowerCase():(d=a.getAttributeNode(b))&&d.specified?d.value:null}),fb}(a);m.find=s,m.expr=s.selectors,m.expr[":"]=m.expr.pseudos,m.unique=s.uniqueSort,m.text=s.getText,m.isXMLDoc=s.isXML,m.contains=s.contains;var t=m.expr.match.needsContext,u=/^<(\w+)\s*\/?>(?:<\/\1>|)$/,v=/^.[^:#\[\.,]*$/;function w(a,b,c){if(m.isFunction(b))return m.grep(a,function(a,d){return!!b.call(a,d,a)!==c});if(b.nodeType)return m.grep(a,function(a){return a===b!==c});if("string"==typeof b){if(v.test(b))return m.filter(b,a,c);b=m.filter(b,a)}return m.grep(a,function(a){return m.inArray(a,b)>=0!==c})}m.filter=function(a,b,c){var d=b[0];return c&&(a=":not("+a+")"),1===b.length&&1===d.nodeType?m.find.matchesSelector(d,a)?[d]:[]:m.find.matches(a,m.grep(b,function(a){return 1===a.nodeType}))},m.fn.extend({find:function(a){var b,c=[],d=this,e=d.length;if("string"!=typeof a)return this.pushStack(m(a).filter(function(){for(b=0;e>b;b++)if(m.contains(d[b],this))return!0}));for(b=0;e>b;b++)m.find(a,d[b],c);return c=this.pushStack(e>1?m.unique(c):c),c.selector=this.selector?this.selector+" "+a:a,c},filter:function(a){return this.pushStack(w(this,a||[],!1))},not:function(a){return this.pushStack(w(this,a||[],!0))},is:function(a){return!!w(this,"string"==typeof a&&t.test(a)?m(a):a||[],!1).length}});var x,y=a.document,z=/^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,A=m.fn.init=function(a,b){var c,d;if(!a)return this;if("string"==typeof a){if(c="<"===a.charAt(0)&&">"===a.charAt(a.length-1)&&a.length>=3?[null,a,null]:z.exec(a),!c||!c[1]&&b)return!b||b.jquery?(b||x).find(a):this.constructor(b).find(a);if(c[1]){if(b=b instanceof m?b[0]:b,m.merge(this,m.parseHTML(c[1],b&&b.nodeType?b.ownerDocument||b:y,!0)),u.test(c[1])&&m.isPlainObject(b))for(c in b)m.isFunction(this[c])?this[c](b[c]):this.attr(c,b[c]);return this}if(d=y.getElementById(c[2]),d&&d.parentNode){if(d.id!==c[2])return x.find(a);this.length=1,this[0]=d}return this.context=y,this.selector=a,this}return a.nodeType?(this.context=this[0]=a,this.length=1,this):m.isFunction(a)?"undefined"!=typeof x.ready?x.ready(a):a(m):(void 0!==a.selector&&(this.selector=a.selector,this.context=a.context),m.makeArray(a,this))};A.prototype=m.fn,x=m(y);var B=/^(?:parents|prev(?:Until|All))/,C={children:!0,contents:!0,next:!0,prev:!0};m.extend({dir:function(a,b,c){var d=[],e=a[b];while(e&&9!==e.nodeType&&(void 0===c||1!==e.nodeType||!m(e).is(c)))1===e.nodeType&&d.push(e),e=e[b];return d},sibling:function(a,b){for(var c=[];a;a=a.nextSibling)1===a.nodeType&&a!==b&&c.push(a);return c}}),m.fn.extend({has:function(a){var b,c=m(a,this),d=c.length;return this.filter(function(){for(b=0;d>b;b++)if(m.contains(this,c[b]))return!0})},closest:function(a,b){for(var c,d=0,e=this.length,f=[],g=t.test(a)||"string"!=typeof a?m(a,b||this.context):0;e>d;d++)for(c=this[d];c&&c!==b;c=c.parentNode)if(c.nodeType<11&&(g?g.index(c)>-1:1===c.nodeType&&m.find.matchesSelector(c,a))){f.push(c);break}return this.pushStack(f.length>1?m.unique(f):f)},index:function(a){return a?"string"==typeof a?m.inArray(this[0],m(a)):m.inArray(a.jquery?a[0]:a,this):this[0]&&this[0].parentNode?this.first().prevAll().length:-1},add:function(a,b){return this.pushStack(m.unique(m.merge(this.get(),m(a,b))))},addBack:function(a){return this.add(null==a?this.prevObject:this.prevObject.filter(a))}});function D(a,b){do a=a[b];while(a&&1!==a.nodeType);return a}m.each({parent:function(a){var b=a.parentNode;return b&&11!==b.nodeType?b:null},parents:function(a){return m.dir(a,"parentNode")},parentsUntil:function(a,b,c){return m.dir(a,"parentNode",c)},next:function(a){return D(a,"nextSibling")},prev:function(a){return D(a,"previousSibling")},nextAll:function(a){return m.dir(a,"nextSibling")},prevAll:function(a){return m.dir(a,"previousSibling")},nextUntil:function(a,b,c){return m.dir(a,"nextSibling",c)},prevUntil:function(a,b,c){return m.dir(a,"previousSibling",c)},siblings:function(a){return m.sibling((a.parentNode||{}).firstChild,a)},children:function(a){return m.sibling(a.firstChild)},contents:function(a){return m.nodeName(a,"iframe")?a.contentDocument||a.contentWindow.document:m.merge([],a.childNodes)}},function(a,b){m.fn[a]=function(c,d){var e=m.map(this,b,c);return"Until"!==a.slice(-5)&&(d=c),d&&"string"==typeof d&&(e=m.filter(d,e)),this.length>1&&(C[a]||(e=m.unique(e)),B.test(a)&&(e=e.reverse())),this.pushStack(e)}});var E=/\S+/g,F={};function G(a){var b=F[a]={};return m.each(a.match(E)||[],function(a,c){b[c]=!0}),b}m.Callbacks=function(a){a="string"==typeof a?F[a]||G(a):m.extend({},a);var b,c,d,e,f,g,h=[],i=!a.once&&[],j=function(l){for(c=a.memory&&l,d=!0,f=g||0,g=0,e=h.length,b=!0;h&&e>f;f++)if(h[f].apply(l[0],l[1])===!1&&a.stopOnFalse){c=!1;break}b=!1,h&&(i?i.length&&j(i.shift()):c?h=[]:k.disable())},k={add:function(){if(h){var d=h.length;!function f(b){m.each(b,function(b,c){var d=m.type(c);"function"===d?a.unique&&k.has(c)||h.push(c):c&&c.length&&"string"!==d&&f(c)})}(arguments),b?e=h.length:c&&(g=d,j(c))}return this},remove:function(){return h&&m.each(arguments,function(a,c){var d;while((d=m.inArray(c,h,d))>-1)h.splice(d,1),b&&(e>=d&&e--,f>=d&&f--)}),this},has:function(a){return a?m.inArray(a,h)>-1:!(!h||!h.length)},empty:function(){return h=[],e=0,this},disable:function(){return h=i=c=void 0,this},disabled:function(){return!h},lock:function(){return i=void 0,c||k.disable(),this},locked:function(){return!i},fireWith:function(a,c){return!h||d&&!i||(c=c||[],c=[a,c.slice?c.slice():c],b?i.push(c):j(c)),this},fire:function(){return k.fireWith(this,arguments),this},fired:function(){return!!d}};return k},m.extend({Deferred:function(a){var b=[["resolve","done",m.Callbacks("once memory"),"resolved"],["reject","fail",m.Callbacks("once memory"),"rejected"],["notify","progress",m.Callbacks("memory")]],c="pending",d={state:function(){return c},always:function(){return e.done(arguments).fail(arguments),this},then:function(){var a=arguments;return m.Deferred(function(c){m.each(b,function(b,f){var g=m.isFunction(a[b])&&a[b];e[f[1]](function(){var a=g&&g.apply(this,arguments);a&&m.isFunction(a.promise)?a.promise().done(c.resolve).fail(c.reject).progress(c.notify):c[f[0]+"With"](this===d?c.promise():this,g?[a]:arguments)})}),a=null}).promise()},promise:function(a){return null!=a?m.extend(a,d):d}},e={};return d.pipe=d.then,m.each(b,function(a,f){var g=f[2],h=f[3];d[f[1]]=g.add,h&&g.add(function(){c=h},b[1^a][2].disable,b[2][2].lock),e[f[0]]=function(){return e[f[0]+"With"](this===e?d:this,arguments),this},e[f[0]+"With"]=g.fireWith}),d.promise(e),a&&a.call(e,e),e},when:function(a){var b=0,c=d.call(arguments),e=c.length,f=1!==e||a&&m.isFunction(a.promise)?e:0,g=1===f?a:m.Deferred(),h=function(a,b,c){return function(e){b[a]=this,c[a]=arguments.length>1?d.call(arguments):e,c===i?g.notifyWith(b,c):--f||g.resolveWith(b,c)}},i,j,k;if(e>1)for(i=new Array(e),j=new Array(e),k=new Array(e);e>b;b++)c[b]&&m.isFunction(c[b].promise)?c[b].promise().done(h(b,k,c)).fail(g.reject).progress(h(b,j,i)):--f;return f||g.resolveWith(k,c),g.promise()}});var H;m.fn.ready=function(a){return m.ready.promise().done(a),this},m.extend({isReady:!1,readyWait:1,holdReady:function(a){a?m.readyWait++:m.ready(!0)},ready:function(a){if(a===!0?!--m.readyWait:!m.isReady){if(!y.body)return setTimeout(m.ready);m.isReady=!0,a!==!0&&--m.readyWait>0||(H.resolveWith(y,[m]),m.fn.triggerHandler&&(m(y).triggerHandler("ready"),m(y).off("ready")))}}});function I(){y.addEventListener?(y.removeEventListener("DOMContentLoaded",J,!1),a.removeEventListener("load",J,!1)):(y.detachEvent("onreadystatechange",J),a.detachEvent("onload",J))}function J(){(y.addEventListener||"load"===event.type||"complete"===y.readyState)&&(I(),m.ready())}m.ready.promise=function(b){if(!H)if(H=m.Deferred(),"complete"===y.readyState)setTimeout(m.ready);else if(y.addEventListener)y.addEventListener("DOMContentLoaded",J,!1),a.addEventListener("load",J,!1);else{y.attachEvent("onreadystatechange",J),a.attachEvent("onload",J);var c=!1;try{c=null==a.frameElement&&y.documentElement}catch(d){}c&&c.doScroll&&!function e(){if(!m.isReady){try{c.doScroll("left")}catch(a){return setTimeout(e,50)}I(),m.ready()}}()}return H.promise(b)};var K="undefined",L;for(L in m(k))break;k.ownLast="0"!==L,k.inlineBlockNeedsLayout=!1,m(function(){var a,b,c,d;c=y.getElementsByTagName("body")[0],c&&c.style&&(b=y.createElement("div"),d=y.createElement("div"),d.style.cssText="position:absolute;border:0;width:0;height:0;top:0;left:-9999px",c.appendChild(d).appendChild(b),typeof b.style.zoom!==K&&(b.style.cssText="display:inline;margin:0;border:0;padding:1px;width:1px;zoom:1",k.inlineBlockNeedsLayout=a=3===b.offsetWidth,a&&(c.style.zoom=1)),c.removeChild(d))}),function(){var a=y.createElement("div");if(null==k.deleteExpando){k.deleteExpando=!0;try{delete a.test}catch(b){k.deleteExpando=!1}}a=null}(),m.acceptData=function(a){var b=m.noData[(a.nodeName+" ").toLowerCase()],c=+a.nodeType||1;return 1!==c&&9!==c?!1:!b||b!==!0&&a.getAttribute("classid")===b};var M=/^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,N=/([A-Z])/g;function O(a,b,c){if(void 0===c&&1===a.nodeType){var d="data-"+b.replace(N,"-$1").toLowerCase();if(c=a.getAttribute(d),"string"==typeof c){try{c="true"===c?!0:"false"===c?!1:"null"===c?null:+c+""===c?+c:M.test(c)?m.parseJSON(c):c}catch(e){}m.data(a,b,c)}else c=void 0}return c}function P(a){var b;for(b in a)if(("data"!==b||!m.isEmptyObject(a[b]))&&"toJSON"!==b)return!1;return!0}function Q(a,b,d,e){if(m.acceptData(a)){var f,g,h=m.expando,i=a.nodeType,j=i?m.cache:a,k=i?a[h]:a[h]&&h;
if(k&&j[k]&&(e||j[k].data)||void 0!==d||"string"!=typeof b)return k||(k=i?a[h]=c.pop()||m.guid++:h),j[k]||(j[k]=i?{}:{toJSON:m.noop}),("object"==typeof b||"function"==typeof b)&&(e?j[k]=m.extend(j[k],b):j[k].data=m.extend(j[k].data,b)),g=j[k],e||(g.data||(g.data={}),g=g.data),void 0!==d&&(g[m.camelCase(b)]=d),"string"==typeof b?(f=g[b],null==f&&(f=g[m.camelCase(b)])):f=g,f}}function R(a,b,c){if(m.acceptData(a)){var d,e,f=a.nodeType,g=f?m.cache:a,h=f?a[m.expando]:m.expando;if(g[h]){if(b&&(d=c?g[h]:g[h].data)){m.isArray(b)?b=b.concat(m.map(b,m.camelCase)):b in d?b=[b]:(b=m.camelCase(b),b=b in d?[b]:b.split(" ")),e=b.length;while(e--)delete d[b[e]];if(c?!P(d):!m.isEmptyObject(d))return}(c||(delete g[h].data,P(g[h])))&&(f?m.cleanData([a],!0):k.deleteExpando||g!=g.window?delete g[h]:g[h]=null)}}}m.extend({cache:{},noData:{"applet ":!0,"embed ":!0,"object ":"clsid:D27CDB6E-AE6D-11cf-96B8-444553540000"},hasData:function(a){return a=a.nodeType?m.cache[a[m.expando]]:a[m.expando],!!a&&!P(a)},data:function(a,b,c){return Q(a,b,c)},removeData:function(a,b){return R(a,b)},_data:function(a,b,c){return Q(a,b,c,!0)},_removeData:function(a,b){return R(a,b,!0)}}),m.fn.extend({data:function(a,b){var c,d,e,f=this[0],g=f&&f.attributes;if(void 0===a){if(this.length&&(e=m.data(f),1===f.nodeType&&!m._data(f,"parsedAttrs"))){c=g.length;while(c--)g[c]&&(d=g[c].name,0===d.indexOf("data-")&&(d=m.camelCase(d.slice(5)),O(f,d,e[d])));m._data(f,"parsedAttrs",!0)}return e}return"object"==typeof a?this.each(function(){m.data(this,a)}):arguments.length>1?this.each(function(){m.data(this,a,b)}):f?O(f,a,m.data(f,a)):void 0},removeData:function(a){return this.each(function(){m.removeData(this,a)})}}),m.extend({queue:function(a,b,c){var d;return a?(b=(b||"fx")+"queue",d=m._data(a,b),c&&(!d||m.isArray(c)?d=m._data(a,b,m.makeArray(c)):d.push(c)),d||[]):void 0},dequeue:function(a,b){b=b||"fx";var c=m.queue(a,b),d=c.length,e=c.shift(),f=m._queueHooks(a,b),g=function(){m.dequeue(a,b)};"inprogress"===e&&(e=c.shift(),d--),e&&("fx"===b&&c.unshift("inprogress"),delete f.stop,e.call(a,g,f)),!d&&f&&f.empty.fire()},_queueHooks:function(a,b){var c=b+"queueHooks";return m._data(a,c)||m._data(a,c,{empty:m.Callbacks("once memory").add(function(){m._removeData(a,b+"queue"),m._removeData(a,c)})})}}),m.fn.extend({queue:function(a,b){var c=2;return"string"!=typeof a&&(b=a,a="fx",c--),arguments.length<c?m.queue(this[0],a):void 0===b?this:this.each(function(){var c=m.queue(this,a,b);m._queueHooks(this,a),"fx"===a&&"inprogress"!==c[0]&&m.dequeue(this,a)})},dequeue:function(a){return this.each(function(){m.dequeue(this,a)})},clearQueue:function(a){return this.queue(a||"fx",[])},promise:function(a,b){var c,d=1,e=m.Deferred(),f=this,g=this.length,h=function(){--d||e.resolveWith(f,[f])};"string"!=typeof a&&(b=a,a=void 0),a=a||"fx";while(g--)c=m._data(f[g],a+"queueHooks"),c&&c.empty&&(d++,c.empty.add(h));return h(),e.promise(b)}});var S=/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,T=["Top","Right","Bottom","Left"],U=function(a,b){return a=b||a,"none"===m.css(a,"display")||!m.contains(a.ownerDocument,a)},V=m.access=function(a,b,c,d,e,f,g){var h=0,i=a.length,j=null==c;if("object"===m.type(c)){e=!0;for(h in c)m.access(a,b,h,c[h],!0,f,g)}else if(void 0!==d&&(e=!0,m.isFunction(d)||(g=!0),j&&(g?(b.call(a,d),b=null):(j=b,b=function(a,b,c){return j.call(m(a),c)})),b))for(;i>h;h++)b(a[h],c,g?d:d.call(a[h],h,b(a[h],c)));return e?a:j?b.call(a):i?b(a[0],c):f},W=/^(?:checkbox|radio)$/i;!function(){var a=y.createElement("input"),b=y.createElement("div"),c=y.createDocumentFragment();if(b.innerHTML="  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>",k.leadingWhitespace=3===b.firstChild.nodeType,k.tbody=!b.getElementsByTagName("tbody").length,k.htmlSerialize=!!b.getElementsByTagName("link").length,k.html5Clone="<:nav></:nav>"!==y.createElement("nav").cloneNode(!0).outerHTML,a.type="checkbox",a.checked=!0,c.appendChild(a),k.appendChecked=a.checked,b.innerHTML="<textarea>x</textarea>",k.noCloneChecked=!!b.cloneNode(!0).lastChild.defaultValue,c.appendChild(b),b.innerHTML="<input type='radio' checked='checked' name='t'/>",k.checkClone=b.cloneNode(!0).cloneNode(!0).lastChild.checked,k.noCloneEvent=!0,b.attachEvent&&(b.attachEvent("onclick",function(){k.noCloneEvent=!1}),b.cloneNode(!0).click()),null==k.deleteExpando){k.deleteExpando=!0;try{delete b.test}catch(d){k.deleteExpando=!1}}}(),function(){var b,c,d=y.createElement("div");for(b in{submit:!0,change:!0,focusin:!0})c="on"+b,(k[b+"Bubbles"]=c in a)||(d.setAttribute(c,"t"),k[b+"Bubbles"]=d.attributes[c].expando===!1);d=null}();var X=/^(?:input|select|textarea)$/i,Y=/^key/,Z=/^(?:mouse|pointer|contextmenu)|click/,$=/^(?:focusinfocus|focusoutblur)$/,_=/^([^.]*)(?:\.(.+)|)$/;function ab(){return!0}function bb(){return!1}function cb(){try{return y.activeElement}catch(a){}}m.event={global:{},add:function(a,b,c,d,e){var f,g,h,i,j,k,l,n,o,p,q,r=m._data(a);if(r){c.handler&&(i=c,c=i.handler,e=i.selector),c.guid||(c.guid=m.guid++),(g=r.events)||(g=r.events={}),(k=r.handle)||(k=r.handle=function(a){return typeof m===K||a&&m.event.triggered===a.type?void 0:m.event.dispatch.apply(k.elem,arguments)},k.elem=a),b=(b||"").match(E)||[""],h=b.length;while(h--)f=_.exec(b[h])||[],o=q=f[1],p=(f[2]||"").split(".").sort(),o&&(j=m.event.special[o]||{},o=(e?j.delegateType:j.bindType)||o,j=m.event.special[o]||{},l=m.extend({type:o,origType:q,data:d,handler:c,guid:c.guid,selector:e,needsContext:e&&m.expr.match.needsContext.test(e),namespace:p.join(".")},i),(n=g[o])||(n=g[o]=[],n.delegateCount=0,j.setup&&j.setup.call(a,d,p,k)!==!1||(a.addEventListener?a.addEventListener(o,k,!1):a.attachEvent&&a.attachEvent("on"+o,k))),j.add&&(j.add.call(a,l),l.handler.guid||(l.handler.guid=c.guid)),e?n.splice(n.delegateCount++,0,l):n.push(l),m.event.global[o]=!0);a=null}},remove:function(a,b,c,d,e){var f,g,h,i,j,k,l,n,o,p,q,r=m.hasData(a)&&m._data(a);if(r&&(k=r.events)){b=(b||"").match(E)||[""],j=b.length;while(j--)if(h=_.exec(b[j])||[],o=q=h[1],p=(h[2]||"").split(".").sort(),o){l=m.event.special[o]||{},o=(d?l.delegateType:l.bindType)||o,n=k[o]||[],h=h[2]&&new RegExp("(^|\\.)"+p.join("\\.(?:.*\\.|)")+"(\\.|$)"),i=f=n.length;while(f--)g=n[f],!e&&q!==g.origType||c&&c.guid!==g.guid||h&&!h.test(g.namespace)||d&&d!==g.selector&&("**"!==d||!g.selector)||(n.splice(f,1),g.selector&&n.delegateCount--,l.remove&&l.remove.call(a,g));i&&!n.length&&(l.teardown&&l.teardown.call(a,p,r.handle)!==!1||m.removeEvent(a,o,r.handle),delete k[o])}else for(o in k)m.event.remove(a,o+b[j],c,d,!0);m.isEmptyObject(k)&&(delete r.handle,m._removeData(a,"events"))}},trigger:function(b,c,d,e){var f,g,h,i,k,l,n,o=[d||y],p=j.call(b,"type")?b.type:b,q=j.call(b,"namespace")?b.namespace.split("."):[];if(h=l=d=d||y,3!==d.nodeType&&8!==d.nodeType&&!$.test(p+m.event.triggered)&&(p.indexOf(".")>=0&&(q=p.split("."),p=q.shift(),q.sort()),g=p.indexOf(":")<0&&"on"+p,b=b[m.expando]?b:new m.Event(p,"object"==typeof b&&b),b.isTrigger=e?2:3,b.namespace=q.join("."),b.namespace_re=b.namespace?new RegExp("(^|\\.)"+q.join("\\.(?:.*\\.|)")+"(\\.|$)"):null,b.result=void 0,b.target||(b.target=d),c=null==c?[b]:m.makeArray(c,[b]),k=m.event.special[p]||{},e||!k.trigger||k.trigger.apply(d,c)!==!1)){if(!e&&!k.noBubble&&!m.isWindow(d)){for(i=k.delegateType||p,$.test(i+p)||(h=h.parentNode);h;h=h.parentNode)o.push(h),l=h;l===(d.ownerDocument||y)&&o.push(l.defaultView||l.parentWindow||a)}n=0;while((h=o[n++])&&!b.isPropagationStopped())b.type=n>1?i:k.bindType||p,f=(m._data(h,"events")||{})[b.type]&&m._data(h,"handle"),f&&f.apply(h,c),f=g&&h[g],f&&f.apply&&m.acceptData(h)&&(b.result=f.apply(h,c),b.result===!1&&b.preventDefault());if(b.type=p,!e&&!b.isDefaultPrevented()&&(!k._default||k._default.apply(o.pop(),c)===!1)&&m.acceptData(d)&&g&&d[p]&&!m.isWindow(d)){l=d[g],l&&(d[g]=null),m.event.triggered=p;try{d[p]()}catch(r){}m.event.triggered=void 0,l&&(d[g]=l)}return b.result}},dispatch:function(a){a=m.event.fix(a);var b,c,e,f,g,h=[],i=d.call(arguments),j=(m._data(this,"events")||{})[a.type]||[],k=m.event.special[a.type]||{};if(i[0]=a,a.delegateTarget=this,!k.preDispatch||k.preDispatch.call(this,a)!==!1){h=m.event.handlers.call(this,a,j),b=0;while((f=h[b++])&&!a.isPropagationStopped()){a.currentTarget=f.elem,g=0;while((e=f.handlers[g++])&&!a.isImmediatePropagationStopped())(!a.namespace_re||a.namespace_re.test(e.namespace))&&(a.handleObj=e,a.data=e.data,c=((m.event.special[e.origType]||{}).handle||e.handler).apply(f.elem,i),void 0!==c&&(a.result=c)===!1&&(a.preventDefault(),a.stopPropagation()))}return k.postDispatch&&k.postDispatch.call(this,a),a.result}},handlers:function(a,b){var c,d,e,f,g=[],h=b.delegateCount,i=a.target;if(h&&i.nodeType&&(!a.button||"click"!==a.type))for(;i!=this;i=i.parentNode||this)if(1===i.nodeType&&(i.disabled!==!0||"click"!==a.type)){for(e=[],f=0;h>f;f++)d=b[f],c=d.selector+" ",void 0===e[c]&&(e[c]=d.needsContext?m(c,this).index(i)>=0:m.find(c,this,null,[i]).length),e[c]&&e.push(d);e.length&&g.push({elem:i,handlers:e})}return h<b.length&&g.push({elem:this,handlers:b.slice(h)}),g},fix:function(a){if(a[m.expando])return a;var b,c,d,e=a.type,f=a,g=this.fixHooks[e];g||(this.fixHooks[e]=g=Z.test(e)?this.mouseHooks:Y.test(e)?this.keyHooks:{}),d=g.props?this.props.concat(g.props):this.props,a=new m.Event(f),b=d.length;while(b--)c=d[b],a[c]=f[c];return a.target||(a.target=f.srcElement||y),3===a.target.nodeType&&(a.target=a.target.parentNode),a.metaKey=!!a.metaKey,g.filter?g.filter(a,f):a},props:"altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),fixHooks:{},keyHooks:{props:"char charCode key keyCode".split(" "),filter:function(a,b){return null==a.which&&(a.which=null!=b.charCode?b.charCode:b.keyCode),a}},mouseHooks:{props:"button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement".split(" "),filter:function(a,b){var c,d,e,f=b.button,g=b.fromElement;return null==a.pageX&&null!=b.clientX&&(d=a.target.ownerDocument||y,e=d.documentElement,c=d.body,a.pageX=b.clientX+(e&&e.scrollLeft||c&&c.scrollLeft||0)-(e&&e.clientLeft||c&&c.clientLeft||0),a.pageY=b.clientY+(e&&e.scrollTop||c&&c.scrollTop||0)-(e&&e.clientTop||c&&c.clientTop||0)),!a.relatedTarget&&g&&(a.relatedTarget=g===a.target?b.toElement:g),a.which||void 0===f||(a.which=1&f?1:2&f?3:4&f?2:0),a}},special:{load:{noBubble:!0},focus:{trigger:function(){if(this!==cb()&&this.focus)try{return this.focus(),!1}catch(a){}},delegateType:"focusin"},blur:{trigger:function(){return this===cb()&&this.blur?(this.blur(),!1):void 0},delegateType:"focusout"},click:{trigger:function(){return m.nodeName(this,"input")&&"checkbox"===this.type&&this.click?(this.click(),!1):void 0},_default:function(a){return m.nodeName(a.target,"a")}},beforeunload:{postDispatch:function(a){void 0!==a.result&&a.originalEvent&&(a.originalEvent.returnValue=a.result)}}},simulate:function(a,b,c,d){var e=m.extend(new m.Event,c,{type:a,isSimulated:!0,originalEvent:{}});d?m.event.trigger(e,null,b):m.event.dispatch.call(b,e),e.isDefaultPrevented()&&c.preventDefault()}},m.removeEvent=y.removeEventListener?function(a,b,c){a.removeEventListener&&a.removeEventListener(b,c,!1)}:function(a,b,c){var d="on"+b;a.detachEvent&&(typeof a[d]===K&&(a[d]=null),a.detachEvent(d,c))},m.Event=function(a,b){return this instanceof m.Event?(a&&a.type?(this.originalEvent=a,this.type=a.type,this.isDefaultPrevented=a.defaultPrevented||void 0===a.defaultPrevented&&a.returnValue===!1?ab:bb):this.type=a,b&&m.extend(this,b),this.timeStamp=a&&a.timeStamp||m.now(),void(this[m.expando]=!0)):new m.Event(a,b)},m.Event.prototype={isDefaultPrevented:bb,isPropagationStopped:bb,isImmediatePropagationStopped:bb,preventDefault:function(){var a=this.originalEvent;this.isDefaultPrevented=ab,a&&(a.preventDefault?a.preventDefault():a.returnValue=!1)},stopPropagation:function(){var a=this.originalEvent;this.isPropagationStopped=ab,a&&(a.stopPropagation&&a.stopPropagation(),a.cancelBubble=!0)},stopImmediatePropagation:function(){var a=this.originalEvent;this.isImmediatePropagationStopped=ab,a&&a.stopImmediatePropagation&&a.stopImmediatePropagation(),this.stopPropagation()}},m.each({mouseenter:"mouseover",mouseleave:"mouseout",pointerenter:"pointerover",pointerleave:"pointerout"},function(a,b){m.event.special[a]={delegateType:b,bindType:b,handle:function(a){var c,d=this,e=a.relatedTarget,f=a.handleObj;return(!e||e!==d&&!m.contains(d,e))&&(a.type=f.origType,c=f.handler.apply(this,arguments),a.type=b),c}}}),k.submitBubbles||(m.event.special.submit={setup:function(){return m.nodeName(this,"form")?!1:void m.event.add(this,"click._submit keypress._submit",function(a){var b=a.target,c=m.nodeName(b,"input")||m.nodeName(b,"button")?b.form:void 0;c&&!m._data(c,"submitBubbles")&&(m.event.add(c,"submit._submit",function(a){a._submit_bubble=!0}),m._data(c,"submitBubbles",!0))})},postDispatch:function(a){a._submit_bubble&&(delete a._submit_bubble,this.parentNode&&!a.isTrigger&&m.event.simulate("submit",this.parentNode,a,!0))},teardown:function(){return m.nodeName(this,"form")?!1:void m.event.remove(this,"._submit")}}),k.changeBubbles||(m.event.special.change={setup:function(){return X.test(this.nodeName)?(("checkbox"===this.type||"radio"===this.type)&&(m.event.add(this,"propertychange._change",function(a){"checked"===a.originalEvent.propertyName&&(this._just_changed=!0)}),m.event.add(this,"click._change",function(a){this._just_changed&&!a.isTrigger&&(this._just_changed=!1),m.event.simulate("change",this,a,!0)})),!1):void m.event.add(this,"beforeactivate._change",function(a){var b=a.target;X.test(b.nodeName)&&!m._data(b,"changeBubbles")&&(m.event.add(b,"change._change",function(a){!this.parentNode||a.isSimulated||a.isTrigger||m.event.simulate("change",this.parentNode,a,!0)}),m._data(b,"changeBubbles",!0))})},handle:function(a){var b=a.target;return this!==b||a.isSimulated||a.isTrigger||"radio"!==b.type&&"checkbox"!==b.type?a.handleObj.handler.apply(this,arguments):void 0},teardown:function(){return m.event.remove(this,"._change"),!X.test(this.nodeName)}}),k.focusinBubbles||m.each({focus:"focusin",blur:"focusout"},function(a,b){var c=function(a){m.event.simulate(b,a.target,m.event.fix(a),!0)};m.event.special[b]={setup:function(){var d=this.ownerDocument||this,e=m._data(d,b);e||d.addEventListener(a,c,!0),m._data(d,b,(e||0)+1)},teardown:function(){var d=this.ownerDocument||this,e=m._data(d,b)-1;e?m._data(d,b,e):(d.removeEventListener(a,c,!0),m._removeData(d,b))}}}),m.fn.extend({on:function(a,b,c,d,e){var f,g;if("object"==typeof a){"string"!=typeof b&&(c=c||b,b=void 0);for(f in a)this.on(f,b,c,a[f],e);return this}if(null==c&&null==d?(d=b,c=b=void 0):null==d&&("string"==typeof b?(d=c,c=void 0):(d=c,c=b,b=void 0)),d===!1)d=bb;else if(!d)return this;return 1===e&&(g=d,d=function(a){return m().off(a),g.apply(this,arguments)},d.guid=g.guid||(g.guid=m.guid++)),this.each(function(){m.event.add(this,a,d,c,b)})},one:function(a,b,c,d){return this.on(a,b,c,d,1)},off:function(a,b,c){var d,e;if(a&&a.preventDefault&&a.handleObj)return d=a.handleObj,m(a.delegateTarget).off(d.namespace?d.origType+"."+d.namespace:d.origType,d.selector,d.handler),this;if("object"==typeof a){for(e in a)this.off(e,b,a[e]);return this}return(b===!1||"function"==typeof b)&&(c=b,b=void 0),c===!1&&(c=bb),this.each(function(){m.event.remove(this,a,c,b)})},trigger:function(a,b){return this.each(function(){m.event.trigger(a,b,this)})},triggerHandler:function(a,b){var c=this[0];return c?m.event.trigger(a,b,c,!0):void 0}});function db(a){var b=eb.split("|"),c=a.createDocumentFragment();if(c.createElement)while(b.length)c.createElement(b.pop());return c}var eb="abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|header|hgroup|mark|meter|nav|output|progress|section|summary|time|video",fb=/ jQuery\d+="(?:null|\d+)"/g,gb=new RegExp("<(?:"+eb+")[\\s/>]","i"),hb=/^\s+/,ib=/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,jb=/<([\w:]+)/,kb=/<tbody/i,lb=/<|&#?\w+;/,mb=/<(?:script|style|link)/i,nb=/checked\s*(?:[^=]|=\s*.checked.)/i,ob=/^$|\/(?:java|ecma)script/i,pb=/^true\/(.*)/,qb=/^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,rb={option:[1,"<select multiple='multiple'>","</select>"],legend:[1,"<fieldset>","</fieldset>"],area:[1,"<map>","</map>"],param:[1,"<object>","</object>"],thead:[1,"<table>","</table>"],tr:[2,"<table><tbody>","</tbody></table>"],col:[2,"<table><tbody></tbody><colgroup>","</colgroup></table>"],td:[3,"<table><tbody><tr>","</tr></tbody></table>"],_default:k.htmlSerialize?[0,"",""]:[1,"X<div>","</div>"]},sb=db(y),tb=sb.appendChild(y.createElement("div"));rb.optgroup=rb.option,rb.tbody=rb.tfoot=rb.colgroup=rb.caption=rb.thead,rb.th=rb.td;function ub(a,b){var c,d,e=0,f=typeof a.getElementsByTagName!==K?a.getElementsByTagName(b||"*"):typeof a.querySelectorAll!==K?a.querySelectorAll(b||"*"):void 0;if(!f)for(f=[],c=a.childNodes||a;null!=(d=c[e]);e++)!b||m.nodeName(d,b)?f.push(d):m.merge(f,ub(d,b));return void 0===b||b&&m.nodeName(a,b)?m.merge([a],f):f}function vb(a){W.test(a.type)&&(a.defaultChecked=a.checked)}function wb(a,b){return m.nodeName(a,"table")&&m.nodeName(11!==b.nodeType?b:b.firstChild,"tr")?a.getElementsByTagName("tbody")[0]||a.appendChild(a.ownerDocument.createElement("tbody")):a}function xb(a){return a.type=(null!==m.find.attr(a,"type"))+"/"+a.type,a}function yb(a){var b=pb.exec(a.type);return b?a.type=b[1]:a.removeAttribute("type"),a}function zb(a,b){for(var c,d=0;null!=(c=a[d]);d++)m._data(c,"globalEval",!b||m._data(b[d],"globalEval"))}function Ab(a,b){if(1===b.nodeType&&m.hasData(a)){var c,d,e,f=m._data(a),g=m._data(b,f),h=f.events;if(h){delete g.handle,g.events={};for(c in h)for(d=0,e=h[c].length;e>d;d++)m.event.add(b,c,h[c][d])}g.data&&(g.data=m.extend({},g.data))}}function Bb(a,b){var c,d,e;if(1===b.nodeType){if(c=b.nodeName.toLowerCase(),!k.noCloneEvent&&b[m.expando]){e=m._data(b);for(d in e.events)m.removeEvent(b,d,e.handle);b.removeAttribute(m.expando)}"script"===c&&b.text!==a.text?(xb(b).text=a.text,yb(b)):"object"===c?(b.parentNode&&(b.outerHTML=a.outerHTML),k.html5Clone&&a.innerHTML&&!m.trim(b.innerHTML)&&(b.innerHTML=a.innerHTML)):"input"===c&&W.test(a.type)?(b.defaultChecked=b.checked=a.checked,b.value!==a.value&&(b.value=a.value)):"option"===c?b.defaultSelected=b.selected=a.defaultSelected:("input"===c||"textarea"===c)&&(b.defaultValue=a.defaultValue)}}m.extend({clone:function(a,b,c){var d,e,f,g,h,i=m.contains(a.ownerDocument,a);if(k.html5Clone||m.isXMLDoc(a)||!gb.test("<"+a.nodeName+">")?f=a.cloneNode(!0):(tb.innerHTML=a.outerHTML,tb.removeChild(f=tb.firstChild)),!(k.noCloneEvent&&k.noCloneChecked||1!==a.nodeType&&11!==a.nodeType||m.isXMLDoc(a)))for(d=ub(f),h=ub(a),g=0;null!=(e=h[g]);++g)d[g]&&Bb(e,d[g]);if(b)if(c)for(h=h||ub(a),d=d||ub(f),g=0;null!=(e=h[g]);g++)Ab(e,d[g]);else Ab(a,f);return d=ub(f,"script"),d.length>0&&zb(d,!i&&ub(a,"script")),d=h=e=null,f},buildFragment:function(a,b,c,d){for(var e,f,g,h,i,j,l,n=a.length,o=db(b),p=[],q=0;n>q;q++)if(f=a[q],f||0===f)if("object"===m.type(f))m.merge(p,f.nodeType?[f]:f);else if(lb.test(f)){h=h||o.appendChild(b.createElement("div")),i=(jb.exec(f)||["",""])[1].toLowerCase(),l=rb[i]||rb._default,h.innerHTML=l[1]+f.replace(ib,"<$1></$2>")+l[2],e=l[0];while(e--)h=h.lastChild;if(!k.leadingWhitespace&&hb.test(f)&&p.push(b.createTextNode(hb.exec(f)[0])),!k.tbody){f="table"!==i||kb.test(f)?"<table>"!==l[1]||kb.test(f)?0:h:h.firstChild,e=f&&f.childNodes.length;while(e--)m.nodeName(j=f.childNodes[e],"tbody")&&!j.childNodes.length&&f.removeChild(j)}m.merge(p,h.childNodes),h.textContent="";while(h.firstChild)h.removeChild(h.firstChild);h=o.lastChild}else p.push(b.createTextNode(f));h&&o.removeChild(h),k.appendChecked||m.grep(ub(p,"input"),vb),q=0;while(f=p[q++])if((!d||-1===m.inArray(f,d))&&(g=m.contains(f.ownerDocument,f),h=ub(o.appendChild(f),"script"),g&&zb(h),c)){e=0;while(f=h[e++])ob.test(f.type||"")&&c.push(f)}return h=null,o},cleanData:function(a,b){for(var d,e,f,g,h=0,i=m.expando,j=m.cache,l=k.deleteExpando,n=m.event.special;null!=(d=a[h]);h++)if((b||m.acceptData(d))&&(f=d[i],g=f&&j[f])){if(g.events)for(e in g.events)n[e]?m.event.remove(d,e):m.removeEvent(d,e,g.handle);j[f]&&(delete j[f],l?delete d[i]:typeof d.removeAttribute!==K?d.removeAttribute(i):d[i]=null,c.push(f))}}}),m.fn.extend({text:function(a){return V(this,function(a){return void 0===a?m.text(this):this.empty().append((this[0]&&this[0].ownerDocument||y).createTextNode(a))},null,a,arguments.length)},append:function(){return this.domManip(arguments,function(a){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var b=wb(this,a);b.appendChild(a)}})},prepend:function(){return this.domManip(arguments,function(a){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var b=wb(this,a);b.insertBefore(a,b.firstChild)}})},before:function(){return this.domManip(arguments,function(a){this.parentNode&&this.parentNode.insertBefore(a,this)})},after:function(){return this.domManip(arguments,function(a){this.parentNode&&this.parentNode.insertBefore(a,this.nextSibling)})},remove:function(a,b){for(var c,d=a?m.filter(a,this):this,e=0;null!=(c=d[e]);e++)b||1!==c.nodeType||m.cleanData(ub(c)),c.parentNode&&(b&&m.contains(c.ownerDocument,c)&&zb(ub(c,"script")),c.parentNode.removeChild(c));return this},empty:function(){for(var a,b=0;null!=(a=this[b]);b++){1===a.nodeType&&m.cleanData(ub(a,!1));while(a.firstChild)a.removeChild(a.firstChild);a.options&&m.nodeName(a,"select")&&(a.options.length=0)}return this},clone:function(a,b){return a=null==a?!1:a,b=null==b?a:b,this.map(function(){return m.clone(this,a,b)})},html:function(a){return V(this,function(a){var b=this[0]||{},c=0,d=this.length;if(void 0===a)return 1===b.nodeType?b.innerHTML.replace(fb,""):void 0;if(!("string"!=typeof a||mb.test(a)||!k.htmlSerialize&&gb.test(a)||!k.leadingWhitespace&&hb.test(a)||rb[(jb.exec(a)||["",""])[1].toLowerCase()])){a=a.replace(ib,"<$1></$2>");try{for(;d>c;c++)b=this[c]||{},1===b.nodeType&&(m.cleanData(ub(b,!1)),b.innerHTML=a);b=0}catch(e){}}b&&this.empty().append(a)},null,a,arguments.length)},replaceWith:function(){var a=arguments[0];return this.domManip(arguments,function(b){a=this.parentNode,m.cleanData(ub(this)),a&&a.replaceChild(b,this)}),a&&(a.length||a.nodeType)?this:this.remove()},detach:function(a){return this.remove(a,!0)},domManip:function(a,b){a=e.apply([],a);var c,d,f,g,h,i,j=0,l=this.length,n=this,o=l-1,p=a[0],q=m.isFunction(p);if(q||l>1&&"string"==typeof p&&!k.checkClone&&nb.test(p))return this.each(function(c){var d=n.eq(c);q&&(a[0]=p.call(this,c,d.html())),d.domManip(a,b)});if(l&&(i=m.buildFragment(a,this[0].ownerDocument,!1,this),c=i.firstChild,1===i.childNodes.length&&(i=c),c)){for(g=m.map(ub(i,"script"),xb),f=g.length;l>j;j++)d=i,j!==o&&(d=m.clone(d,!0,!0),f&&m.merge(g,ub(d,"script"))),b.call(this[j],d,j);if(f)for(h=g[g.length-1].ownerDocument,m.map(g,yb),j=0;f>j;j++)d=g[j],ob.test(d.type||"")&&!m._data(d,"globalEval")&&m.contains(h,d)&&(d.src?m._evalUrl&&m._evalUrl(d.src):m.globalEval((d.text||d.textContent||d.innerHTML||"").replace(qb,"")));i=c=null}return this}}),m.each({appendTo:"append",prependTo:"prepend",insertBefore:"before",insertAfter:"after",replaceAll:"replaceWith"},function(a,b){m.fn[a]=function(a){for(var c,d=0,e=[],g=m(a),h=g.length-1;h>=d;d++)c=d===h?this:this.clone(!0),m(g[d])[b](c),f.apply(e,c.get());return this.pushStack(e)}});var Cb,Db={};function Eb(b,c){var d,e=m(c.createElement(b)).appendTo(c.body),f=a.getDefaultComputedStyle&&(d=a.getDefaultComputedStyle(e[0]))?d.display:m.css(e[0],"display");return e.detach(),f}function Fb(a){var b=y,c=Db[a];return c||(c=Eb(a,b),"none"!==c&&c||(Cb=(Cb||m("<iframe frameborder='0' width='0' height='0'/>")).appendTo(b.documentElement),b=(Cb[0].contentWindow||Cb[0].contentDocument).document,b.write(),b.close(),c=Eb(a,b),Cb.detach()),Db[a]=c),c}!function(){var a;k.shrinkWrapBlocks=function(){if(null!=a)return a;a=!1;var b,c,d;return c=y.getElementsByTagName("body")[0],c&&c.style?(b=y.createElement("div"),d=y.createElement("div"),d.style.cssText="position:absolute;border:0;width:0;height:0;top:0;left:-9999px",c.appendChild(d).appendChild(b),typeof b.style.zoom!==K&&(b.style.cssText="-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;display:block;margin:0;border:0;padding:1px;width:1px;zoom:1",b.appendChild(y.createElement("div")).style.width="5px",a=3!==b.offsetWidth),c.removeChild(d),a):void 0}}();var Gb=/^margin/,Hb=new RegExp("^("+S+")(?!px)[a-z%]+$","i"),Ib,Jb,Kb=/^(top|right|bottom|left)$/;a.getComputedStyle?(Ib=function(a){return a.ownerDocument.defaultView.getComputedStyle(a,null)},Jb=function(a,b,c){var d,e,f,g,h=a.style;return c=c||Ib(a),g=c?c.getPropertyValue(b)||c[b]:void 0,c&&(""!==g||m.contains(a.ownerDocument,a)||(g=m.style(a,b)),Hb.test(g)&&Gb.test(b)&&(d=h.width,e=h.minWidth,f=h.maxWidth,h.minWidth=h.maxWidth=h.width=g,g=c.width,h.width=d,h.minWidth=e,h.maxWidth=f)),void 0===g?g:g+""}):y.documentElement.currentStyle&&(Ib=function(a){return a.currentStyle},Jb=function(a,b,c){var d,e,f,g,h=a.style;return c=c||Ib(a),g=c?c[b]:void 0,null==g&&h&&h[b]&&(g=h[b]),Hb.test(g)&&!Kb.test(b)&&(d=h.left,e=a.runtimeStyle,f=e&&e.left,f&&(e.left=a.currentStyle.left),h.left="fontSize"===b?"1em":g,g=h.pixelLeft+"px",h.left=d,f&&(e.left=f)),void 0===g?g:g+""||"auto"});function Lb(a,b){return{get:function(){var c=a();if(null!=c)return c?void delete this.get:(this.get=b).apply(this,arguments)}}}!function(){var b,c,d,e,f,g,h;if(b=y.createElement("div"),b.innerHTML="  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>",d=b.getElementsByTagName("a")[0],c=d&&d.style){c.cssText="float:left;opacity:.5",k.opacity="0.5"===c.opacity,k.cssFloat=!!c.cssFloat,b.style.backgroundClip="content-box",b.cloneNode(!0).style.backgroundClip="",k.clearCloneStyle="content-box"===b.style.backgroundClip,k.boxSizing=""===c.boxSizing||""===c.MozBoxSizing||""===c.WebkitBoxSizing,m.extend(k,{reliableHiddenOffsets:function(){return null==g&&i(),g},boxSizingReliable:function(){return null==f&&i(),f},pixelPosition:function(){return null==e&&i(),e},reliableMarginRight:function(){return null==h&&i(),h}});function i(){var b,c,d,i;c=y.getElementsByTagName("body")[0],c&&c.style&&(b=y.createElement("div"),d=y.createElement("div"),d.style.cssText="position:absolute;border:0;width:0;height:0;top:0;left:-9999px",c.appendChild(d).appendChild(b),b.style.cssText="-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;display:block;margin-top:1%;top:1%;border:1px;padding:1px;width:4px;position:absolute",e=f=!1,h=!0,a.getComputedStyle&&(e="1%"!==(a.getComputedStyle(b,null)||{}).top,f="4px"===(a.getComputedStyle(b,null)||{width:"4px"}).width,i=b.appendChild(y.createElement("div")),i.style.cssText=b.style.cssText="-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;display:block;margin:0;border:0;padding:0",i.style.marginRight=i.style.width="0",b.style.width="1px",h=!parseFloat((a.getComputedStyle(i,null)||{}).marginRight)),b.innerHTML="<table><tr><td></td><td>t</td></tr></table>",i=b.getElementsByTagName("td"),i[0].style.cssText="margin:0;border:0;padding:0;display:none",g=0===i[0].offsetHeight,g&&(i[0].style.display="",i[1].style.display="none",g=0===i[0].offsetHeight),c.removeChild(d))}}}(),m.swap=function(a,b,c,d){var e,f,g={};for(f in b)g[f]=a.style[f],a.style[f]=b[f];e=c.apply(a,d||[]);for(f in b)a.style[f]=g[f];return e};var Mb=/alpha\([^)]*\)/i,Nb=/opacity\s*=\s*([^)]*)/,Ob=/^(none|table(?!-c[ea]).+)/,Pb=new RegExp("^("+S+")(.*)$","i"),Qb=new RegExp("^([+-])=("+S+")","i"),Rb={position:"absolute",visibility:"hidden",display:"block"},Sb={letterSpacing:"0",fontWeight:"400"},Tb=["Webkit","O","Moz","ms"];function Ub(a,b){if(b in a)return b;var c=b.charAt(0).toUpperCase()+b.slice(1),d=b,e=Tb.length;while(e--)if(b=Tb[e]+c,b in a)return b;return d}function Vb(a,b){for(var c,d,e,f=[],g=0,h=a.length;h>g;g++)d=a[g],d.style&&(f[g]=m._data(d,"olddisplay"),c=d.style.display,b?(f[g]||"none"!==c||(d.style.display=""),""===d.style.display&&U(d)&&(f[g]=m._data(d,"olddisplay",Fb(d.nodeName)))):(e=U(d),(c&&"none"!==c||!e)&&m._data(d,"olddisplay",e?c:m.css(d,"display"))));for(g=0;h>g;g++)d=a[g],d.style&&(b&&"none"!==d.style.display&&""!==d.style.display||(d.style.display=b?f[g]||"":"none"));return a}function Wb(a,b,c){var d=Pb.exec(b);return d?Math.max(0,d[1]-(c||0))+(d[2]||"px"):b}function Xb(a,b,c,d,e){for(var f=c===(d?"border":"content")?4:"width"===b?1:0,g=0;4>f;f+=2)"margin"===c&&(g+=m.css(a,c+T[f],!0,e)),d?("content"===c&&(g-=m.css(a,"padding"+T[f],!0,e)),"margin"!==c&&(g-=m.css(a,"border"+T[f]+"Width",!0,e))):(g+=m.css(a,"padding"+T[f],!0,e),"padding"!==c&&(g+=m.css(a,"border"+T[f]+"Width",!0,e)));return g}function Yb(a,b,c){var d=!0,e="width"===b?a.offsetWidth:a.offsetHeight,f=Ib(a),g=k.boxSizing&&"border-box"===m.css(a,"boxSizing",!1,f);if(0>=e||null==e){if(e=Jb(a,b,f),(0>e||null==e)&&(e=a.style[b]),Hb.test(e))return e;d=g&&(k.boxSizingReliable()||e===a.style[b]),e=parseFloat(e)||0}return e+Xb(a,b,c||(g?"border":"content"),d,f)+"px"}m.extend({cssHooks:{opacity:{get:function(a,b){if(b){var c=Jb(a,"opacity");return""===c?"1":c}}}},cssNumber:{columnCount:!0,fillOpacity:!0,flexGrow:!0,flexShrink:!0,fontWeight:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,widows:!0,zIndex:!0,zoom:!0},cssProps:{"float":k.cssFloat?"cssFloat":"styleFloat"},style:function(a,b,c,d){if(a&&3!==a.nodeType&&8!==a.nodeType&&a.style){var e,f,g,h=m.camelCase(b),i=a.style;if(b=m.cssProps[h]||(m.cssProps[h]=Ub(i,h)),g=m.cssHooks[b]||m.cssHooks[h],void 0===c)return g&&"get"in g&&void 0!==(e=g.get(a,!1,d))?e:i[b];if(f=typeof c,"string"===f&&(e=Qb.exec(c))&&(c=(e[1]+1)*e[2]+parseFloat(m.css(a,b)),f="number"),null!=c&&c===c&&("number"!==f||m.cssNumber[h]||(c+="px"),k.clearCloneStyle||""!==c||0!==b.indexOf("background")||(i[b]="inherit"),!(g&&"set"in g&&void 0===(c=g.set(a,c,d)))))try{i[b]=c}catch(j){}}},css:function(a,b,c,d){var e,f,g,h=m.camelCase(b);return b=m.cssProps[h]||(m.cssProps[h]=Ub(a.style,h)),g=m.cssHooks[b]||m.cssHooks[h],g&&"get"in g&&(f=g.get(a,!0,c)),void 0===f&&(f=Jb(a,b,d)),"normal"===f&&b in Sb&&(f=Sb[b]),""===c||c?(e=parseFloat(f),c===!0||m.isNumeric(e)?e||0:f):f}}),m.each(["height","width"],function(a,b){m.cssHooks[b]={get:function(a,c,d){return c?Ob.test(m.css(a,"display"))&&0===a.offsetWidth?m.swap(a,Rb,function(){return Yb(a,b,d)}):Yb(a,b,d):void 0},set:function(a,c,d){var e=d&&Ib(a);return Wb(a,c,d?Xb(a,b,d,k.boxSizing&&"border-box"===m.css(a,"boxSizing",!1,e),e):0)}}}),k.opacity||(m.cssHooks.opacity={get:function(a,b){return Nb.test((b&&a.currentStyle?a.currentStyle.filter:a.style.filter)||"")?.01*parseFloat(RegExp.$1)+"":b?"1":""},set:function(a,b){var c=a.style,d=a.currentStyle,e=m.isNumeric(b)?"alpha(opacity="+100*b+")":"",f=d&&d.filter||c.filter||"";c.zoom=1,(b>=1||""===b)&&""===m.trim(f.replace(Mb,""))&&c.removeAttribute&&(c.removeAttribute("filter"),""===b||d&&!d.filter)||(c.filter=Mb.test(f)?f.replace(Mb,e):f+" "+e)}}),m.cssHooks.marginRight=Lb(k.reliableMarginRight,function(a,b){return b?m.swap(a,{display:"inline-block"},Jb,[a,"marginRight"]):void 0}),m.each({margin:"",padding:"",border:"Width"},function(a,b){m.cssHooks[a+b]={expand:function(c){for(var d=0,e={},f="string"==typeof c?c.split(" "):[c];4>d;d++)e[a+T[d]+b]=f[d]||f[d-2]||f[0];return e}},Gb.test(a)||(m.cssHooks[a+b].set=Wb)}),m.fn.extend({css:function(a,b){return V(this,function(a,b,c){var d,e,f={},g=0;if(m.isArray(b)){for(d=Ib(a),e=b.length;e>g;g++)f[b[g]]=m.css(a,b[g],!1,d);return f}return void 0!==c?m.style(a,b,c):m.css(a,b)},a,b,arguments.length>1)},show:function(){return Vb(this,!0)},hide:function(){return Vb(this)},toggle:function(a){return"boolean"==typeof a?a?this.show():this.hide():this.each(function(){U(this)?m(this).show():m(this).hide()})}});function Zb(a,b,c,d,e){return new Zb.prototype.init(a,b,c,d,e)}m.Tween=Zb,Zb.prototype={constructor:Zb,init:function(a,b,c,d,e,f){this.elem=a,this.prop=c,this.easing=e||"swing",this.options=b,this.start=this.now=this.cur(),this.end=d,this.unit=f||(m.cssNumber[c]?"":"px")
},cur:function(){var a=Zb.propHooks[this.prop];return a&&a.get?a.get(this):Zb.propHooks._default.get(this)},run:function(a){var b,c=Zb.propHooks[this.prop];return this.pos=b=this.options.duration?m.easing[this.easing](a,this.options.duration*a,0,1,this.options.duration):a,this.now=(this.end-this.start)*b+this.start,this.options.step&&this.options.step.call(this.elem,this.now,this),c&&c.set?c.set(this):Zb.propHooks._default.set(this),this}},Zb.prototype.init.prototype=Zb.prototype,Zb.propHooks={_default:{get:function(a){var b;return null==a.elem[a.prop]||a.elem.style&&null!=a.elem.style[a.prop]?(b=m.css(a.elem,a.prop,""),b&&"auto"!==b?b:0):a.elem[a.prop]},set:function(a){m.fx.step[a.prop]?m.fx.step[a.prop](a):a.elem.style&&(null!=a.elem.style[m.cssProps[a.prop]]||m.cssHooks[a.prop])?m.style(a.elem,a.prop,a.now+a.unit):a.elem[a.prop]=a.now}}},Zb.propHooks.scrollTop=Zb.propHooks.scrollLeft={set:function(a){a.elem.nodeType&&a.elem.parentNode&&(a.elem[a.prop]=a.now)}},m.easing={linear:function(a){return a},swing:function(a){return.5-Math.cos(a*Math.PI)/2}},m.fx=Zb.prototype.init,m.fx.step={};var $b,_b,ac=/^(?:toggle|show|hide)$/,bc=new RegExp("^(?:([+-])=|)("+S+")([a-z%]*)$","i"),cc=/queueHooks$/,dc=[ic],ec={"*":[function(a,b){var c=this.createTween(a,b),d=c.cur(),e=bc.exec(b),f=e&&e[3]||(m.cssNumber[a]?"":"px"),g=(m.cssNumber[a]||"px"!==f&&+d)&&bc.exec(m.css(c.elem,a)),h=1,i=20;if(g&&g[3]!==f){f=f||g[3],e=e||[],g=+d||1;do h=h||".5",g/=h,m.style(c.elem,a,g+f);while(h!==(h=c.cur()/d)&&1!==h&&--i)}return e&&(g=c.start=+g||+d||0,c.unit=f,c.end=e[1]?g+(e[1]+1)*e[2]:+e[2]),c}]};function fc(){return setTimeout(function(){$b=void 0}),$b=m.now()}function gc(a,b){var c,d={height:a},e=0;for(b=b?1:0;4>e;e+=2-b)c=T[e],d["margin"+c]=d["padding"+c]=a;return b&&(d.opacity=d.width=a),d}function hc(a,b,c){for(var d,e=(ec[b]||[]).concat(ec["*"]),f=0,g=e.length;g>f;f++)if(d=e[f].call(c,b,a))return d}function ic(a,b,c){var d,e,f,g,h,i,j,l,n=this,o={},p=a.style,q=a.nodeType&&U(a),r=m._data(a,"fxshow");c.queue||(h=m._queueHooks(a,"fx"),null==h.unqueued&&(h.unqueued=0,i=h.empty.fire,h.empty.fire=function(){h.unqueued||i()}),h.unqueued++,n.always(function(){n.always(function(){h.unqueued--,m.queue(a,"fx").length||h.empty.fire()})})),1===a.nodeType&&("height"in b||"width"in b)&&(c.overflow=[p.overflow,p.overflowX,p.overflowY],j=m.css(a,"display"),l="none"===j?m._data(a,"olddisplay")||Fb(a.nodeName):j,"inline"===l&&"none"===m.css(a,"float")&&(k.inlineBlockNeedsLayout&&"inline"!==Fb(a.nodeName)?p.zoom=1:p.display="inline-block")),c.overflow&&(p.overflow="hidden",k.shrinkWrapBlocks()||n.always(function(){p.overflow=c.overflow[0],p.overflowX=c.overflow[1],p.overflowY=c.overflow[2]}));for(d in b)if(e=b[d],ac.exec(e)){if(delete b[d],f=f||"toggle"===e,e===(q?"hide":"show")){if("show"!==e||!r||void 0===r[d])continue;q=!0}o[d]=r&&r[d]||m.style(a,d)}else j=void 0;if(m.isEmptyObject(o))"inline"===("none"===j?Fb(a.nodeName):j)&&(p.display=j);else{r?"hidden"in r&&(q=r.hidden):r=m._data(a,"fxshow",{}),f&&(r.hidden=!q),q?m(a).show():n.done(function(){m(a).hide()}),n.done(function(){var b;m._removeData(a,"fxshow");for(b in o)m.style(a,b,o[b])});for(d in o)g=hc(q?r[d]:0,d,n),d in r||(r[d]=g.start,q&&(g.end=g.start,g.start="width"===d||"height"===d?1:0))}}function jc(a,b){var c,d,e,f,g;for(c in a)if(d=m.camelCase(c),e=b[d],f=a[c],m.isArray(f)&&(e=f[1],f=a[c]=f[0]),c!==d&&(a[d]=f,delete a[c]),g=m.cssHooks[d],g&&"expand"in g){f=g.expand(f),delete a[d];for(c in f)c in a||(a[c]=f[c],b[c]=e)}else b[d]=e}function kc(a,b,c){var d,e,f=0,g=dc.length,h=m.Deferred().always(function(){delete i.elem}),i=function(){if(e)return!1;for(var b=$b||fc(),c=Math.max(0,j.startTime+j.duration-b),d=c/j.duration||0,f=1-d,g=0,i=j.tweens.length;i>g;g++)j.tweens[g].run(f);return h.notifyWith(a,[j,f,c]),1>f&&i?c:(h.resolveWith(a,[j]),!1)},j=h.promise({elem:a,props:m.extend({},b),opts:m.extend(!0,{specialEasing:{}},c),originalProperties:b,originalOptions:c,startTime:$b||fc(),duration:c.duration,tweens:[],createTween:function(b,c){var d=m.Tween(a,j.opts,b,c,j.opts.specialEasing[b]||j.opts.easing);return j.tweens.push(d),d},stop:function(b){var c=0,d=b?j.tweens.length:0;if(e)return this;for(e=!0;d>c;c++)j.tweens[c].run(1);return b?h.resolveWith(a,[j,b]):h.rejectWith(a,[j,b]),this}}),k=j.props;for(jc(k,j.opts.specialEasing);g>f;f++)if(d=dc[f].call(j,a,k,j.opts))return d;return m.map(k,hc,j),m.isFunction(j.opts.start)&&j.opts.start.call(a,j),m.fx.timer(m.extend(i,{elem:a,anim:j,queue:j.opts.queue})),j.progress(j.opts.progress).done(j.opts.done,j.opts.complete).fail(j.opts.fail).always(j.opts.always)}m.Animation=m.extend(kc,{tweener:function(a,b){m.isFunction(a)?(b=a,a=["*"]):a=a.split(" ");for(var c,d=0,e=a.length;e>d;d++)c=a[d],ec[c]=ec[c]||[],ec[c].unshift(b)},prefilter:function(a,b){b?dc.unshift(a):dc.push(a)}}),m.speed=function(a,b,c){var d=a&&"object"==typeof a?m.extend({},a):{complete:c||!c&&b||m.isFunction(a)&&a,duration:a,easing:c&&b||b&&!m.isFunction(b)&&b};return d.duration=m.fx.off?0:"number"==typeof d.duration?d.duration:d.duration in m.fx.speeds?m.fx.speeds[d.duration]:m.fx.speeds._default,(null==d.queue||d.queue===!0)&&(d.queue="fx"),d.old=d.complete,d.complete=function(){m.isFunction(d.old)&&d.old.call(this),d.queue&&m.dequeue(this,d.queue)},d},m.fn.extend({fadeTo:function(a,b,c,d){return this.filter(U).css("opacity",0).show().end().animate({opacity:b},a,c,d)},animate:function(a,b,c,d){var e=m.isEmptyObject(a),f=m.speed(b,c,d),g=function(){var b=kc(this,m.extend({},a),f);(e||m._data(this,"finish"))&&b.stop(!0)};return g.finish=g,e||f.queue===!1?this.each(g):this.queue(f.queue,g)},stop:function(a,b,c){var d=function(a){var b=a.stop;delete a.stop,b(c)};return"string"!=typeof a&&(c=b,b=a,a=void 0),b&&a!==!1&&this.queue(a||"fx",[]),this.each(function(){var b=!0,e=null!=a&&a+"queueHooks",f=m.timers,g=m._data(this);if(e)g[e]&&g[e].stop&&d(g[e]);else for(e in g)g[e]&&g[e].stop&&cc.test(e)&&d(g[e]);for(e=f.length;e--;)f[e].elem!==this||null!=a&&f[e].queue!==a||(f[e].anim.stop(c),b=!1,f.splice(e,1));(b||!c)&&m.dequeue(this,a)})},finish:function(a){return a!==!1&&(a=a||"fx"),this.each(function(){var b,c=m._data(this),d=c[a+"queue"],e=c[a+"queueHooks"],f=m.timers,g=d?d.length:0;for(c.finish=!0,m.queue(this,a,[]),e&&e.stop&&e.stop.call(this,!0),b=f.length;b--;)f[b].elem===this&&f[b].queue===a&&(f[b].anim.stop(!0),f.splice(b,1));for(b=0;g>b;b++)d[b]&&d[b].finish&&d[b].finish.call(this);delete c.finish})}}),m.each(["toggle","show","hide"],function(a,b){var c=m.fn[b];m.fn[b]=function(a,d,e){return null==a||"boolean"==typeof a?c.apply(this,arguments):this.animate(gc(b,!0),a,d,e)}}),m.each({slideDown:gc("show"),slideUp:gc("hide"),slideToggle:gc("toggle"),fadeIn:{opacity:"show"},fadeOut:{opacity:"hide"},fadeToggle:{opacity:"toggle"}},function(a,b){m.fn[a]=function(a,c,d){return this.animate(b,a,c,d)}}),m.timers=[],m.fx.tick=function(){var a,b=m.timers,c=0;for($b=m.now();c<b.length;c++)a=b[c],a()||b[c]!==a||b.splice(c--,1);b.length||m.fx.stop(),$b=void 0},m.fx.timer=function(a){m.timers.push(a),a()?m.fx.start():m.timers.pop()},m.fx.interval=13,m.fx.start=function(){_b||(_b=setInterval(m.fx.tick,m.fx.interval))},m.fx.stop=function(){clearInterval(_b),_b=null},m.fx.speeds={slow:600,fast:200,_default:400},m.fn.delay=function(a,b){return a=m.fx?m.fx.speeds[a]||a:a,b=b||"fx",this.queue(b,function(b,c){var d=setTimeout(b,a);c.stop=function(){clearTimeout(d)}})},function(){var a,b,c,d,e;b=y.createElement("div"),b.setAttribute("className","t"),b.innerHTML="  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>",d=b.getElementsByTagName("a")[0],c=y.createElement("select"),e=c.appendChild(y.createElement("option")),a=b.getElementsByTagName("input")[0],d.style.cssText="top:1px",k.getSetAttribute="t"!==b.className,k.style=/top/.test(d.getAttribute("style")),k.hrefNormalized="/a"===d.getAttribute("href"),k.checkOn=!!a.value,k.optSelected=e.selected,k.enctype=!!y.createElement("form").enctype,c.disabled=!0,k.optDisabled=!e.disabled,a=y.createElement("input"),a.setAttribute("value",""),k.input=""===a.getAttribute("value"),a.value="t",a.setAttribute("type","radio"),k.radioValue="t"===a.value}();var lc=/\r/g;m.fn.extend({val:function(a){var b,c,d,e=this[0];{if(arguments.length)return d=m.isFunction(a),this.each(function(c){var e;1===this.nodeType&&(e=d?a.call(this,c,m(this).val()):a,null==e?e="":"number"==typeof e?e+="":m.isArray(e)&&(e=m.map(e,function(a){return null==a?"":a+""})),b=m.valHooks[this.type]||m.valHooks[this.nodeName.toLowerCase()],b&&"set"in b&&void 0!==b.set(this,e,"value")||(this.value=e))});if(e)return b=m.valHooks[e.type]||m.valHooks[e.nodeName.toLowerCase()],b&&"get"in b&&void 0!==(c=b.get(e,"value"))?c:(c=e.value,"string"==typeof c?c.replace(lc,""):null==c?"":c)}}}),m.extend({valHooks:{option:{get:function(a){var b=m.find.attr(a,"value");return null!=b?b:m.trim(m.text(a))}},select:{get:function(a){for(var b,c,d=a.options,e=a.selectedIndex,f="select-one"===a.type||0>e,g=f?null:[],h=f?e+1:d.length,i=0>e?h:f?e:0;h>i;i++)if(c=d[i],!(!c.selected&&i!==e||(k.optDisabled?c.disabled:null!==c.getAttribute("disabled"))||c.parentNode.disabled&&m.nodeName(c.parentNode,"optgroup"))){if(b=m(c).val(),f)return b;g.push(b)}return g},set:function(a,b){var c,d,e=a.options,f=m.makeArray(b),g=e.length;while(g--)if(d=e[g],m.inArray(m.valHooks.option.get(d),f)>=0)try{d.selected=c=!0}catch(h){d.scrollHeight}else d.selected=!1;return c||(a.selectedIndex=-1),e}}}}),m.each(["radio","checkbox"],function(){m.valHooks[this]={set:function(a,b){return m.isArray(b)?a.checked=m.inArray(m(a).val(),b)>=0:void 0}},k.checkOn||(m.valHooks[this].get=function(a){return null===a.getAttribute("value")?"on":a.value})});var mc,nc,oc=m.expr.attrHandle,pc=/^(?:checked|selected)$/i,qc=k.getSetAttribute,rc=k.input;m.fn.extend({attr:function(a,b){return V(this,m.attr,a,b,arguments.length>1)},removeAttr:function(a){return this.each(function(){m.removeAttr(this,a)})}}),m.extend({attr:function(a,b,c){var d,e,f=a.nodeType;if(a&&3!==f&&8!==f&&2!==f)return typeof a.getAttribute===K?m.prop(a,b,c):(1===f&&m.isXMLDoc(a)||(b=b.toLowerCase(),d=m.attrHooks[b]||(m.expr.match.bool.test(b)?nc:mc)),void 0===c?d&&"get"in d&&null!==(e=d.get(a,b))?e:(e=m.find.attr(a,b),null==e?void 0:e):null!==c?d&&"set"in d&&void 0!==(e=d.set(a,c,b))?e:(a.setAttribute(b,c+""),c):void m.removeAttr(a,b))},removeAttr:function(a,b){var c,d,e=0,f=b&&b.match(E);if(f&&1===a.nodeType)while(c=f[e++])d=m.propFix[c]||c,m.expr.match.bool.test(c)?rc&&qc||!pc.test(c)?a[d]=!1:a[m.camelCase("default-"+c)]=a[d]=!1:m.attr(a,c,""),a.removeAttribute(qc?c:d)},attrHooks:{type:{set:function(a,b){if(!k.radioValue&&"radio"===b&&m.nodeName(a,"input")){var c=a.value;return a.setAttribute("type",b),c&&(a.value=c),b}}}}}),nc={set:function(a,b,c){return b===!1?m.removeAttr(a,c):rc&&qc||!pc.test(c)?a.setAttribute(!qc&&m.propFix[c]||c,c):a[m.camelCase("default-"+c)]=a[c]=!0,c}},m.each(m.expr.match.bool.source.match(/\w+/g),function(a,b){var c=oc[b]||m.find.attr;oc[b]=rc&&qc||!pc.test(b)?function(a,b,d){var e,f;return d||(f=oc[b],oc[b]=e,e=null!=c(a,b,d)?b.toLowerCase():null,oc[b]=f),e}:function(a,b,c){return c?void 0:a[m.camelCase("default-"+b)]?b.toLowerCase():null}}),rc&&qc||(m.attrHooks.value={set:function(a,b,c){return m.nodeName(a,"input")?void(a.defaultValue=b):mc&&mc.set(a,b,c)}}),qc||(mc={set:function(a,b,c){var d=a.getAttributeNode(c);return d||a.setAttributeNode(d=a.ownerDocument.createAttribute(c)),d.value=b+="","value"===c||b===a.getAttribute(c)?b:void 0}},oc.id=oc.name=oc.coords=function(a,b,c){var d;return c?void 0:(d=a.getAttributeNode(b))&&""!==d.value?d.value:null},m.valHooks.button={get:function(a,b){var c=a.getAttributeNode(b);return c&&c.specified?c.value:void 0},set:mc.set},m.attrHooks.contenteditable={set:function(a,b,c){mc.set(a,""===b?!1:b,c)}},m.each(["width","height"],function(a,b){m.attrHooks[b]={set:function(a,c){return""===c?(a.setAttribute(b,"auto"),c):void 0}}})),k.style||(m.attrHooks.style={get:function(a){return a.style.cssText||void 0},set:function(a,b){return a.style.cssText=b+""}});var sc=/^(?:input|select|textarea|button|object)$/i,tc=/^(?:a|area)$/i;m.fn.extend({prop:function(a,b){return V(this,m.prop,a,b,arguments.length>1)},removeProp:function(a){return a=m.propFix[a]||a,this.each(function(){try{this[a]=void 0,delete this[a]}catch(b){}})}}),m.extend({propFix:{"for":"htmlFor","class":"className"},prop:function(a,b,c){var d,e,f,g=a.nodeType;if(a&&3!==g&&8!==g&&2!==g)return f=1!==g||!m.isXMLDoc(a),f&&(b=m.propFix[b]||b,e=m.propHooks[b]),void 0!==c?e&&"set"in e&&void 0!==(d=e.set(a,c,b))?d:a[b]=c:e&&"get"in e&&null!==(d=e.get(a,b))?d:a[b]},propHooks:{tabIndex:{get:function(a){var b=m.find.attr(a,"tabindex");return b?parseInt(b,10):sc.test(a.nodeName)||tc.test(a.nodeName)&&a.href?0:-1}}}}),k.hrefNormalized||m.each(["href","src"],function(a,b){m.propHooks[b]={get:function(a){return a.getAttribute(b,4)}}}),k.optSelected||(m.propHooks.selected={get:function(a){var b=a.parentNode;return b&&(b.selectedIndex,b.parentNode&&b.parentNode.selectedIndex),null}}),m.each(["tabIndex","readOnly","maxLength","cellSpacing","cellPadding","rowSpan","colSpan","useMap","frameBorder","contentEditable"],function(){m.propFix[this.toLowerCase()]=this}),k.enctype||(m.propFix.enctype="encoding");var uc=/[\t\r\n\f]/g;m.fn.extend({addClass:function(a){var b,c,d,e,f,g,h=0,i=this.length,j="string"==typeof a&&a;if(m.isFunction(a))return this.each(function(b){m(this).addClass(a.call(this,b,this.className))});if(j)for(b=(a||"").match(E)||[];i>h;h++)if(c=this[h],d=1===c.nodeType&&(c.className?(" "+c.className+" ").replace(uc," "):" ")){f=0;while(e=b[f++])d.indexOf(" "+e+" ")<0&&(d+=e+" ");g=m.trim(d),c.className!==g&&(c.className=g)}return this},removeClass:function(a){var b,c,d,e,f,g,h=0,i=this.length,j=0===arguments.length||"string"==typeof a&&a;if(m.isFunction(a))return this.each(function(b){m(this).removeClass(a.call(this,b,this.className))});if(j)for(b=(a||"").match(E)||[];i>h;h++)if(c=this[h],d=1===c.nodeType&&(c.className?(" "+c.className+" ").replace(uc," "):"")){f=0;while(e=b[f++])while(d.indexOf(" "+e+" ")>=0)d=d.replace(" "+e+" "," ");g=a?m.trim(d):"",c.className!==g&&(c.className=g)}return this},toggleClass:function(a,b){var c=typeof a;return"boolean"==typeof b&&"string"===c?b?this.addClass(a):this.removeClass(a):this.each(m.isFunction(a)?function(c){m(this).toggleClass(a.call(this,c,this.className,b),b)}:function(){if("string"===c){var b,d=0,e=m(this),f=a.match(E)||[];while(b=f[d++])e.hasClass(b)?e.removeClass(b):e.addClass(b)}else(c===K||"boolean"===c)&&(this.className&&m._data(this,"__className__",this.className),this.className=this.className||a===!1?"":m._data(this,"__className__")||"")})},hasClass:function(a){for(var b=" "+a+" ",c=0,d=this.length;d>c;c++)if(1===this[c].nodeType&&(" "+this[c].className+" ").replace(uc," ").indexOf(b)>=0)return!0;return!1}}),m.each("blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu".split(" "),function(a,b){m.fn[b]=function(a,c){return arguments.length>0?this.on(b,null,a,c):this.trigger(b)}}),m.fn.extend({hover:function(a,b){return this.mouseenter(a).mouseleave(b||a)},bind:function(a,b,c){return this.on(a,null,b,c)},unbind:function(a,b){return this.off(a,null,b)},delegate:function(a,b,c,d){return this.on(b,a,c,d)},undelegate:function(a,b,c){return 1===arguments.length?this.off(a,"**"):this.off(b,a||"**",c)}});var vc=m.now(),wc=/\?/,xc=/(,)|(\[|{)|(}|])|"(?:[^"\\\r\n]|\\["\\\/bfnrt]|\\u[\da-fA-F]{4})*"\s*:?|true|false|null|-?(?!0\d)\d+(?:\.\d+|)(?:[eE][+-]?\d+|)/g;m.parseJSON=function(b){if(a.JSON&&a.JSON.parse)return a.JSON.parse(b+"");var c,d=null,e=m.trim(b+"");return e&&!m.trim(e.replace(xc,function(a,b,e,f){return c&&b&&(d=0),0===d?a:(c=e||b,d+=!f-!e,"")}))?Function("return "+e)():m.error("Invalid JSON: "+b)},m.parseXML=function(b){var c,d;if(!b||"string"!=typeof b)return null;try{a.DOMParser?(d=new DOMParser,c=d.parseFromString(b,"text/xml")):(c=new ActiveXObject("Microsoft.XMLDOM"),c.async="false",c.loadXML(b))}catch(e){c=void 0}return c&&c.documentElement&&!c.getElementsByTagName("parsererror").length||m.error("Invalid XML: "+b),c};var yc,zc,Ac=/#.*$/,Bc=/([?&])_=[^&]*/,Cc=/^(.*?):[ \t]*([^\r\n]*)\r?$/gm,Dc=/^(?:about|app|app-storage|.+-extension|file|res|widget):$/,Ec=/^(?:GET|HEAD)$/,Fc=/^\/\//,Gc=/^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/,Hc={},Ic={},Jc="*/".concat("*");try{zc=location.href}catch(Kc){zc=y.createElement("a"),zc.href="",zc=zc.href}yc=Gc.exec(zc.toLowerCase())||[];function Lc(a){return function(b,c){"string"!=typeof b&&(c=b,b="*");var d,e=0,f=b.toLowerCase().match(E)||[];if(m.isFunction(c))while(d=f[e++])"+"===d.charAt(0)?(d=d.slice(1)||"*",(a[d]=a[d]||[]).unshift(c)):(a[d]=a[d]||[]).push(c)}}function Mc(a,b,c,d){var e={},f=a===Ic;function g(h){var i;return e[h]=!0,m.each(a[h]||[],function(a,h){var j=h(b,c,d);return"string"!=typeof j||f||e[j]?f?!(i=j):void 0:(b.dataTypes.unshift(j),g(j),!1)}),i}return g(b.dataTypes[0])||!e["*"]&&g("*")}function Nc(a,b){var c,d,e=m.ajaxSettings.flatOptions||{};for(d in b)void 0!==b[d]&&((e[d]?a:c||(c={}))[d]=b[d]);return c&&m.extend(!0,a,c),a}function Oc(a,b,c){var d,e,f,g,h=a.contents,i=a.dataTypes;while("*"===i[0])i.shift(),void 0===e&&(e=a.mimeType||b.getResponseHeader("Content-Type"));if(e)for(g in h)if(h[g]&&h[g].test(e)){i.unshift(g);break}if(i[0]in c)f=i[0];else{for(g in c){if(!i[0]||a.converters[g+" "+i[0]]){f=g;break}d||(d=g)}f=f||d}return f?(f!==i[0]&&i.unshift(f),c[f]):void 0}function Pc(a,b,c,d){var e,f,g,h,i,j={},k=a.dataTypes.slice();if(k[1])for(g in a.converters)j[g.toLowerCase()]=a.converters[g];f=k.shift();while(f)if(a.responseFields[f]&&(c[a.responseFields[f]]=b),!i&&d&&a.dataFilter&&(b=a.dataFilter(b,a.dataType)),i=f,f=k.shift())if("*"===f)f=i;else if("*"!==i&&i!==f){if(g=j[i+" "+f]||j["* "+f],!g)for(e in j)if(h=e.split(" "),h[1]===f&&(g=j[i+" "+h[0]]||j["* "+h[0]])){g===!0?g=j[e]:j[e]!==!0&&(f=h[0],k.unshift(h[1]));break}if(g!==!0)if(g&&a["throws"])b=g(b);else try{b=g(b)}catch(l){return{state:"parsererror",error:g?l:"No conversion from "+i+" to "+f}}}return{state:"success",data:b}}m.extend({active:0,lastModified:{},etag:{},ajaxSettings:{url:zc,type:"GET",isLocal:Dc.test(yc[1]),global:!0,processData:!0,async:!0,contentType:"application/x-www-form-urlencoded; charset=UTF-8",accepts:{"*":Jc,text:"text/plain",html:"text/html",xml:"application/xml, text/xml",json:"application/json, text/javascript"},contents:{xml:/xml/,html:/html/,json:/json/},responseFields:{xml:"responseXML",text:"responseText",json:"responseJSON"},converters:{"* text":String,"text html":!0,"text json":m.parseJSON,"text xml":m.parseXML},flatOptions:{url:!0,context:!0}},ajaxSetup:function(a,b){return b?Nc(Nc(a,m.ajaxSettings),b):Nc(m.ajaxSettings,a)},ajaxPrefilter:Lc(Hc),ajaxTransport:Lc(Ic),ajax:function(a,b){"object"==typeof a&&(b=a,a=void 0),b=b||{};var c,d,e,f,g,h,i,j,k=m.ajaxSetup({},b),l=k.context||k,n=k.context&&(l.nodeType||l.jquery)?m(l):m.event,o=m.Deferred(),p=m.Callbacks("once memory"),q=k.statusCode||{},r={},s={},t=0,u="canceled",v={readyState:0,getResponseHeader:function(a){var b;if(2===t){if(!j){j={};while(b=Cc.exec(f))j[b[1].toLowerCase()]=b[2]}b=j[a.toLowerCase()]}return null==b?null:b},getAllResponseHeaders:function(){return 2===t?f:null},setRequestHeader:function(a,b){var c=a.toLowerCase();return t||(a=s[c]=s[c]||a,r[a]=b),this},overrideMimeType:function(a){return t||(k.mimeType=a),this},statusCode:function(a){var b;if(a)if(2>t)for(b in a)q[b]=[q[b],a[b]];else v.always(a[v.status]);return this},abort:function(a){var b=a||u;return i&&i.abort(b),x(0,b),this}};if(o.promise(v).complete=p.add,v.success=v.done,v.error=v.fail,k.url=((a||k.url||zc)+"").replace(Ac,"").replace(Fc,yc[1]+"//"),k.type=b.method||b.type||k.method||k.type,k.dataTypes=m.trim(k.dataType||"*").toLowerCase().match(E)||[""],null==k.crossDomain&&(c=Gc.exec(k.url.toLowerCase()),k.crossDomain=!(!c||c[1]===yc[1]&&c[2]===yc[2]&&(c[3]||("http:"===c[1]?"80":"443"))===(yc[3]||("http:"===yc[1]?"80":"443")))),k.data&&k.processData&&"string"!=typeof k.data&&(k.data=m.param(k.data,k.traditional)),Mc(Hc,k,b,v),2===t)return v;h=k.global,h&&0===m.active++&&m.event.trigger("ajaxStart"),k.type=k.type.toUpperCase(),k.hasContent=!Ec.test(k.type),e=k.url,k.hasContent||(k.data&&(e=k.url+=(wc.test(e)?"&":"?")+k.data,delete k.data),k.cache===!1&&(k.url=Bc.test(e)?e.replace(Bc,"$1_="+vc++):e+(wc.test(e)?"&":"?")+"_="+vc++)),k.ifModified&&(m.lastModified[e]&&v.setRequestHeader("If-Modified-Since",m.lastModified[e]),m.etag[e]&&v.setRequestHeader("If-None-Match",m.etag[e])),(k.data&&k.hasContent&&k.contentType!==!1||b.contentType)&&v.setRequestHeader("Content-Type",k.contentType),v.setRequestHeader("Accept",k.dataTypes[0]&&k.accepts[k.dataTypes[0]]?k.accepts[k.dataTypes[0]]+("*"!==k.dataTypes[0]?", "+Jc+"; q=0.01":""):k.accepts["*"]);for(d in k.headers)v.setRequestHeader(d,k.headers[d]);if(k.beforeSend&&(k.beforeSend.call(l,v,k)===!1||2===t))return v.abort();u="abort";for(d in{success:1,error:1,complete:1})v[d](k[d]);if(i=Mc(Ic,k,b,v)){v.readyState=1,h&&n.trigger("ajaxSend",[v,k]),k.async&&k.timeout>0&&(g=setTimeout(function(){v.abort("timeout")},k.timeout));try{t=1,i.send(r,x)}catch(w){if(!(2>t))throw w;x(-1,w)}}else x(-1,"No Transport");function x(a,b,c,d){var j,r,s,u,w,x=b;2!==t&&(t=2,g&&clearTimeout(g),i=void 0,f=d||"",v.readyState=a>0?4:0,j=a>=200&&300>a||304===a,c&&(u=Oc(k,v,c)),u=Pc(k,u,v,j),j?(k.ifModified&&(w=v.getResponseHeader("Last-Modified"),w&&(m.lastModified[e]=w),w=v.getResponseHeader("etag"),w&&(m.etag[e]=w)),204===a||"HEAD"===k.type?x="nocontent":304===a?x="notmodified":(x=u.state,r=u.data,s=u.error,j=!s)):(s=x,(a||!x)&&(x="error",0>a&&(a=0))),v.status=a,v.statusText=(b||x)+"",j?o.resolveWith(l,[r,x,v]):o.rejectWith(l,[v,x,s]),v.statusCode(q),q=void 0,h&&n.trigger(j?"ajaxSuccess":"ajaxError",[v,k,j?r:s]),p.fireWith(l,[v,x]),h&&(n.trigger("ajaxComplete",[v,k]),--m.active||m.event.trigger("ajaxStop")))}return v},getJSON:function(a,b,c){return m.get(a,b,c,"json")},getScript:function(a,b){return m.get(a,void 0,b,"script")}}),m.each(["get","post"],function(a,b){m[b]=function(a,c,d,e){return m.isFunction(c)&&(e=e||d,d=c,c=void 0),m.ajax({url:a,type:b,dataType:e,data:c,success:d})}}),m.each(["ajaxStart","ajaxStop","ajaxComplete","ajaxError","ajaxSuccess","ajaxSend"],function(a,b){m.fn[b]=function(a){return this.on(b,a)}}),m._evalUrl=function(a){return m.ajax({url:a,type:"GET",dataType:"script",async:!1,global:!1,"throws":!0})},m.fn.extend({wrapAll:function(a){if(m.isFunction(a))return this.each(function(b){m(this).wrapAll(a.call(this,b))});if(this[0]){var b=m(a,this[0].ownerDocument).eq(0).clone(!0);this[0].parentNode&&b.insertBefore(this[0]),b.map(function(){var a=this;while(a.firstChild&&1===a.firstChild.nodeType)a=a.firstChild;return a}).append(this)}return this},wrapInner:function(a){return this.each(m.isFunction(a)?function(b){m(this).wrapInner(a.call(this,b))}:function(){var b=m(this),c=b.contents();c.length?c.wrapAll(a):b.append(a)})},wrap:function(a){var b=m.isFunction(a);return this.each(function(c){m(this).wrapAll(b?a.call(this,c):a)})},unwrap:function(){return this.parent().each(function(){m.nodeName(this,"body")||m(this).replaceWith(this.childNodes)}).end()}}),m.expr.filters.hidden=function(a){return a.offsetWidth<=0&&a.offsetHeight<=0||!k.reliableHiddenOffsets()&&"none"===(a.style&&a.style.display||m.css(a,"display"))},m.expr.filters.visible=function(a){return!m.expr.filters.hidden(a)};var Qc=/%20/g,Rc=/\[\]$/,Sc=/\r?\n/g,Tc=/^(?:submit|button|image|reset|file)$/i,Uc=/^(?:input|select|textarea|keygen)/i;function Vc(a,b,c,d){var e;if(m.isArray(b))m.each(b,function(b,e){c||Rc.test(a)?d(a,e):Vc(a+"["+("object"==typeof e?b:"")+"]",e,c,d)});else if(c||"object"!==m.type(b))d(a,b);else for(e in b)Vc(a+"["+e+"]",b[e],c,d)}m.param=function(a,b){var c,d=[],e=function(a,b){b=m.isFunction(b)?b():null==b?"":b,d[d.length]=encodeURIComponent(a)+"="+encodeURIComponent(b)};if(void 0===b&&(b=m.ajaxSettings&&m.ajaxSettings.traditional),m.isArray(a)||a.jquery&&!m.isPlainObject(a))m.each(a,function(){e(this.name,this.value)});else for(c in a)Vc(c,a[c],b,e);return d.join("&").replace(Qc,"+")},m.fn.extend({serialize:function(){return m.param(this.serializeArray())},serializeArray:function(){return this.map(function(){var a=m.prop(this,"elements");return a?m.makeArray(a):this}).filter(function(){var a=this.type;return this.name&&!m(this).is(":disabled")&&Uc.test(this.nodeName)&&!Tc.test(a)&&(this.checked||!W.test(a))}).map(function(a,b){var c=m(this).val();return null==c?null:m.isArray(c)?m.map(c,function(a){return{name:b.name,value:a.replace(Sc,"\r\n")}}):{name:b.name,value:c.replace(Sc,"\r\n")}}).get()}}),m.ajaxSettings.xhr=void 0!==a.ActiveXObject?function(){return!this.isLocal&&/^(get|post|head|put|delete|options)$/i.test(this.type)&&Zc()||$c()}:Zc;var Wc=0,Xc={},Yc=m.ajaxSettings.xhr();a.ActiveXObject&&m(a).on("unload",function(){for(var a in Xc)Xc[a](void 0,!0)}),k.cors=!!Yc&&"withCredentials"in Yc,Yc=k.ajax=!!Yc,Yc&&m.ajaxTransport(function(a){if(!a.crossDomain||k.cors){var b;return{send:function(c,d){var e,f=a.xhr(),g=++Wc;if(f.open(a.type,a.url,a.async,a.username,a.password),a.xhrFields)for(e in a.xhrFields)f[e]=a.xhrFields[e];a.mimeType&&f.overrideMimeType&&f.overrideMimeType(a.mimeType),a.crossDomain||c["X-Requested-With"]||(c["X-Requested-With"]="XMLHttpRequest");for(e in c)void 0!==c[e]&&f.setRequestHeader(e,c[e]+"");f.send(a.hasContent&&a.data||null),b=function(c,e){var h,i,j;if(b&&(e||4===f.readyState))if(delete Xc[g],b=void 0,f.onreadystatechange=m.noop,e)4!==f.readyState&&f.abort();else{j={},h=f.status,"string"==typeof f.responseText&&(j.text=f.responseText);try{i=f.statusText}catch(k){i=""}h||!a.isLocal||a.crossDomain?1223===h&&(h=204):h=j.text?200:404}j&&d(h,i,j,f.getAllResponseHeaders())},a.async?4===f.readyState?setTimeout(b):f.onreadystatechange=Xc[g]=b:b()},abort:function(){b&&b(void 0,!0)}}}});function Zc(){try{return new a.XMLHttpRequest}catch(b){}}function $c(){try{return new a.ActiveXObject("Microsoft.XMLHTTP")}catch(b){}}m.ajaxSetup({accepts:{script:"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"},contents:{script:/(?:java|ecma)script/},converters:{"text script":function(a){return m.globalEval(a),a}}}),m.ajaxPrefilter("script",function(a){void 0===a.cache&&(a.cache=!1),a.crossDomain&&(a.type="GET",a.global=!1)}),m.ajaxTransport("script",function(a){if(a.crossDomain){var b,c=y.head||m("head")[0]||y.documentElement;return{send:function(d,e){b=y.createElement("script"),b.async=!0,a.scriptCharset&&(b.charset=a.scriptCharset),b.src=a.url,b.onload=b.onreadystatechange=function(a,c){(c||!b.readyState||/loaded|complete/.test(b.readyState))&&(b.onload=b.onreadystatechange=null,b.parentNode&&b.parentNode.removeChild(b),b=null,c||e(200,"success"))},c.insertBefore(b,c.firstChild)},abort:function(){b&&b.onload(void 0,!0)}}}});var _c=[],ad=/(=)\?(?=&|$)|\?\?/;m.ajaxSetup({jsonp:"callback",jsonpCallback:function(){var a=_c.pop()||m.expando+"_"+vc++;return this[a]=!0,a}}),m.ajaxPrefilter("json jsonp",function(b,c,d){var e,f,g,h=b.jsonp!==!1&&(ad.test(b.url)?"url":"string"==typeof b.data&&!(b.contentType||"").indexOf("application/x-www-form-urlencoded")&&ad.test(b.data)&&"data");return h||"jsonp"===b.dataTypes[0]?(e=b.jsonpCallback=m.isFunction(b.jsonpCallback)?b.jsonpCallback():b.jsonpCallback,h?b[h]=b[h].replace(ad,"$1"+e):b.jsonp!==!1&&(b.url+=(wc.test(b.url)?"&":"?")+b.jsonp+"="+e),b.converters["script json"]=function(){return g||m.error(e+" was not called"),g[0]},b.dataTypes[0]="json",f=a[e],a[e]=function(){g=arguments},d.always(function(){a[e]=f,b[e]&&(b.jsonpCallback=c.jsonpCallback,_c.push(e)),g&&m.isFunction(f)&&f(g[0]),g=f=void 0}),"script"):void 0}),m.parseHTML=function(a,b,c){if(!a||"string"!=typeof a)return null;"boolean"==typeof b&&(c=b,b=!1),b=b||y;var d=u.exec(a),e=!c&&[];return d?[b.createElement(d[1])]:(d=m.buildFragment([a],b,e),e&&e.length&&m(e).remove(),m.merge([],d.childNodes))};var bd=m.fn.load;m.fn.load=function(a,b,c){if("string"!=typeof a&&bd)return bd.apply(this,arguments);var d,e,f,g=this,h=a.indexOf(" ");return h>=0&&(d=m.trim(a.slice(h,a.length)),a=a.slice(0,h)),m.isFunction(b)?(c=b,b=void 0):b&&"object"==typeof b&&(f="POST"),g.length>0&&m.ajax({url:a,type:f,dataType:"html",data:b}).done(function(a){e=arguments,g.html(d?m("<div>").append(m.parseHTML(a)).find(d):a)}).complete(c&&function(a,b){g.each(c,e||[a.responseText,b,a])}),this},m.expr.filters.animated=function(a){return m.grep(m.timers,function(b){return a===b.elem}).length};var cd=a.document.documentElement;function dd(a){return m.isWindow(a)?a:9===a.nodeType?a.defaultView||a.parentWindow:!1}m.offset={setOffset:function(a,b,c){var d,e,f,g,h,i,j,k=m.css(a,"position"),l=m(a),n={};"static"===k&&(a.style.position="relative"),h=l.offset(),f=m.css(a,"top"),i=m.css(a,"left"),j=("absolute"===k||"fixed"===k)&&m.inArray("auto",[f,i])>-1,j?(d=l.position(),g=d.top,e=d.left):(g=parseFloat(f)||0,e=parseFloat(i)||0),m.isFunction(b)&&(b=b.call(a,c,h)),null!=b.top&&(n.top=b.top-h.top+g),null!=b.left&&(n.left=b.left-h.left+e),"using"in b?b.using.call(a,n):l.css(n)}},m.fn.extend({offset:function(a){if(arguments.length)return void 0===a?this:this.each(function(b){m.offset.setOffset(this,a,b)});var b,c,d={top:0,left:0},e=this[0],f=e&&e.ownerDocument;if(f)return b=f.documentElement,m.contains(b,e)?(typeof e.getBoundingClientRect!==K&&(d=e.getBoundingClientRect()),c=dd(f),{top:d.top+(c.pageYOffset||b.scrollTop)-(b.clientTop||0),left:d.left+(c.pageXOffset||b.scrollLeft)-(b.clientLeft||0)}):d},position:function(){if(this[0]){var a,b,c={top:0,left:0},d=this[0];return"fixed"===m.css(d,"position")?b=d.getBoundingClientRect():(a=this.offsetParent(),b=this.offset(),m.nodeName(a[0],"html")||(c=a.offset()),c.top+=m.css(a[0],"borderTopWidth",!0),c.left+=m.css(a[0],"borderLeftWidth",!0)),{top:b.top-c.top-m.css(d,"marginTop",!0),left:b.left-c.left-m.css(d,"marginLeft",!0)}}},offsetParent:function(){return this.map(function(){var a=this.offsetParent||cd;while(a&&!m.nodeName(a,"html")&&"static"===m.css(a,"position"))a=a.offsetParent;return a||cd})}}),m.each({scrollLeft:"pageXOffset",scrollTop:"pageYOffset"},function(a,b){var c=/Y/.test(b);m.fn[a]=function(d){return V(this,function(a,d,e){var f=dd(a);return void 0===e?f?b in f?f[b]:f.document.documentElement[d]:a[d]:void(f?f.scrollTo(c?m(f).scrollLeft():e,c?e:m(f).scrollTop()):a[d]=e)},a,d,arguments.length,null)}}),m.each(["top","left"],function(a,b){m.cssHooks[b]=Lb(k.pixelPosition,function(a,c){return c?(c=Jb(a,b),Hb.test(c)?m(a).position()[b]+"px":c):void 0})}),m.each({Height:"height",Width:"width"},function(a,b){m.each({padding:"inner"+a,content:b,"":"outer"+a},function(c,d){m.fn[d]=function(d,e){var f=arguments.length&&(c||"boolean"!=typeof d),g=c||(d===!0||e===!0?"margin":"border");return V(this,function(b,c,d){var e;return m.isWindow(b)?b.document.documentElement["client"+a]:9===b.nodeType?(e=b.documentElement,Math.max(b.body["scroll"+a],e["scroll"+a],b.body["offset"+a],e["offset"+a],e["client"+a])):void 0===d?m.css(b,c,g):m.style(b,c,d,g)},b,f?d:void 0,f,null)}})}),m.fn.size=function(){return this.length},m.fn.andSelf=m.fn.addBack,"function"==typeof define&&define.amd&&define("jquery",[],function(){return m});var ed=a.jQuery,fd=a.$;return m.noConflict=function(b){return a.$===m&&(a.$=fd),b&&a.jQuery===m&&(a.jQuery=ed),m},typeof b===K&&(a.jQuery=a.$=m),m});

//     Underscore.js 1.6.0
//     http://underscorejs.org
//     (c) 2009-2014 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
//     Underscore may be freely distributed under the MIT license.
(function(){var n=this,t=n._,r={},e=Array.prototype,u=Object.prototype,i=Function.prototype,a=e.push,o=e.slice,c=e.concat,l=u.toString,f=u.hasOwnProperty,s=e.forEach,p=e.map,h=e.reduce,v=e.reduceRight,g=e.filter,d=e.every,m=e.some,y=e.indexOf,b=e.lastIndexOf,x=Array.isArray,w=Object.keys,_=i.bind,j=function(n){return n instanceof j?n:this instanceof j?void(this._wrapped=n):new j(n)};"undefined"!=typeof exports?("undefined"!=typeof module&&module.exports&&(exports=module.exports=j),exports._=j):n._=j,j.VERSION="1.6.0";var A=j.each=j.forEach=function(n,t,e){if(null==n)return n;if(s&&n.forEach===s)n.forEach(t,e);else if(n.length===+n.length){for(var u=0,i=n.length;i>u;u++)if(t.call(e,n[u],u,n)===r)return}else for(var a=j.keys(n),u=0,i=a.length;i>u;u++)if(t.call(e,n[a[u]],a[u],n)===r)return;return n};j.map=j.collect=function(n,t,r){var e=[];return null==n?e:p&&n.map===p?n.map(t,r):(A(n,function(n,u,i){e.push(t.call(r,n,u,i))}),e)};var O="Reduce of empty array with no initial value";j.reduce=j.foldl=j.inject=function(n,t,r,e){var u=arguments.length>2;if(null==n&&(n=[]),h&&n.reduce===h)return e&&(t=j.bind(t,e)),u?n.reduce(t,r):n.reduce(t);if(A(n,function(n,i,a){u?r=t.call(e,r,n,i,a):(r=n,u=!0)}),!u)throw new TypeError(O);return r},j.reduceRight=j.foldr=function(n,t,r,e){var u=arguments.length>2;if(null==n&&(n=[]),v&&n.reduceRight===v)return e&&(t=j.bind(t,e)),u?n.reduceRight(t,r):n.reduceRight(t);var i=n.length;if(i!==+i){var a=j.keys(n);i=a.length}if(A(n,function(o,c,l){c=a?a[--i]:--i,u?r=t.call(e,r,n[c],c,l):(r=n[c],u=!0)}),!u)throw new TypeError(O);return r},j.find=j.detect=function(n,t,r){var e;return k(n,function(n,u,i){return t.call(r,n,u,i)?(e=n,!0):void 0}),e},j.filter=j.select=function(n,t,r){var e=[];return null==n?e:g&&n.filter===g?n.filter(t,r):(A(n,function(n,u,i){t.call(r,n,u,i)&&e.push(n)}),e)},j.reject=function(n,t,r){return j.filter(n,function(n,e,u){return!t.call(r,n,e,u)},r)},j.every=j.all=function(n,t,e){t||(t=j.identity);var u=!0;return null==n?u:d&&n.every===d?n.every(t,e):(A(n,function(n,i,a){return(u=u&&t.call(e,n,i,a))?void 0:r}),!!u)};var k=j.some=j.any=function(n,t,e){t||(t=j.identity);var u=!1;return null==n?u:m&&n.some===m?n.some(t,e):(A(n,function(n,i,a){return u||(u=t.call(e,n,i,a))?r:void 0}),!!u)};j.contains=j.include=function(n,t){return null==n?!1:y&&n.indexOf===y?n.indexOf(t)!=-1:k(n,function(n){return n===t})},j.invoke=function(n,t){var r=o.call(arguments,2),e=j.isFunction(t);return j.map(n,function(n){return(e?t:n[t]).apply(n,r)})},j.pluck=function(n,t){return j.map(n,j.property(t))},j.where=function(n,t){return j.filter(n,j.matches(t))},j.findWhere=function(n,t){return j.find(n,j.matches(t))},j.max=function(n,t,r){if(!t&&j.isArray(n)&&n[0]===+n[0]&&n.length<65535)return Math.max.apply(Math,n);var e=-1/0,u=-1/0;return A(n,function(n,i,a){var o=t?t.call(r,n,i,a):n;o>u&&(e=n,u=o)}),e},j.min=function(n,t,r){if(!t&&j.isArray(n)&&n[0]===+n[0]&&n.length<65535)return Math.min.apply(Math,n);var e=1/0,u=1/0;return A(n,function(n,i,a){var o=t?t.call(r,n,i,a):n;u>o&&(e=n,u=o)}),e},j.shuffle=function(n){var t,r=0,e=[];return A(n,function(n){t=j.random(r++),e[r-1]=e[t],e[t]=n}),e},j.sample=function(n,t,r){return null==t||r?(n.length!==+n.length&&(n=j.values(n)),n[j.random(n.length-1)]):j.shuffle(n).slice(0,Math.max(0,t))};var E=function(n){return null==n?j.identity:j.isFunction(n)?n:j.property(n)};j.sortBy=function(n,t,r){return t=E(t),j.pluck(j.map(n,function(n,e,u){return{value:n,index:e,criteria:t.call(r,n,e,u)}}).sort(function(n,t){var r=n.criteria,e=t.criteria;if(r!==e){if(r>e||r===void 0)return 1;if(e>r||e===void 0)return-1}return n.index-t.index}),"value")};var F=function(n){return function(t,r,e){var u={};return r=E(r),A(t,function(i,a){var o=r.call(e,i,a,t);n(u,o,i)}),u}};j.groupBy=F(function(n,t,r){j.has(n,t)?n[t].push(r):n[t]=[r]}),j.indexBy=F(function(n,t,r){n[t]=r}),j.countBy=F(function(n,t){j.has(n,t)?n[t]++:n[t]=1}),j.sortedIndex=function(n,t,r,e){r=E(r);for(var u=r.call(e,t),i=0,a=n.length;a>i;){var o=i+a>>>1;r.call(e,n[o])<u?i=o+1:a=o}return i},j.toArray=function(n){return n?j.isArray(n)?o.call(n):n.length===+n.length?j.map(n,j.identity):j.values(n):[]},j.size=function(n){return null==n?0:n.length===+n.length?n.length:j.keys(n).length},j.first=j.head=j.take=function(n,t,r){return null==n?void 0:null==t||r?n[0]:0>t?[]:o.call(n,0,t)},j.initial=function(n,t,r){return o.call(n,0,n.length-(null==t||r?1:t))},j.last=function(n,t,r){return null==n?void 0:null==t||r?n[n.length-1]:o.call(n,Math.max(n.length-t,0))},j.rest=j.tail=j.drop=function(n,t,r){return o.call(n,null==t||r?1:t)},j.compact=function(n){return j.filter(n,j.identity)};var M=function(n,t,r){return t&&j.every(n,j.isArray)?c.apply(r,n):(A(n,function(n){j.isArray(n)||j.isArguments(n)?t?a.apply(r,n):M(n,t,r):r.push(n)}),r)};j.flatten=function(n,t){return M(n,t,[])},j.without=function(n){return j.difference(n,o.call(arguments,1))},j.partition=function(n,t){var r=[],e=[];return A(n,function(n){(t(n)?r:e).push(n)}),[r,e]},j.uniq=j.unique=function(n,t,r,e){j.isFunction(t)&&(e=r,r=t,t=!1);var u=r?j.map(n,r,e):n,i=[],a=[];return A(u,function(r,e){(t?e&&a[a.length-1]===r:j.contains(a,r))||(a.push(r),i.push(n[e]))}),i},j.union=function(){return j.uniq(j.flatten(arguments,!0))},j.intersection=function(n){var t=o.call(arguments,1);return j.filter(j.uniq(n),function(n){return j.every(t,function(t){return j.contains(t,n)})})},j.difference=function(n){var t=c.apply(e,o.call(arguments,1));return j.filter(n,function(n){return!j.contains(t,n)})},j.zip=function(){for(var n=j.max(j.pluck(arguments,"length").concat(0)),t=new Array(n),r=0;n>r;r++)t[r]=j.pluck(arguments,""+r);return t},j.object=function(n,t){if(null==n)return{};for(var r={},e=0,u=n.length;u>e;e++)t?r[n[e]]=t[e]:r[n[e][0]]=n[e][1];return r},j.indexOf=function(n,t,r){if(null==n)return-1;var e=0,u=n.length;if(r){if("number"!=typeof r)return e=j.sortedIndex(n,t),n[e]===t?e:-1;e=0>r?Math.max(0,u+r):r}if(y&&n.indexOf===y)return n.indexOf(t,r);for(;u>e;e++)if(n[e]===t)return e;return-1},j.lastIndexOf=function(n,t,r){if(null==n)return-1;var e=null!=r;if(b&&n.lastIndexOf===b)return e?n.lastIndexOf(t,r):n.lastIndexOf(t);for(var u=e?r:n.length;u--;)if(n[u]===t)return u;return-1},j.range=function(n,t,r){arguments.length<=1&&(t=n||0,n=0),r=arguments[2]||1;for(var e=Math.max(Math.ceil((t-n)/r),0),u=0,i=new Array(e);e>u;)i[u++]=n,n+=r;return i};var R=function(){};j.bind=function(n,t){var r,e;if(_&&n.bind===_)return _.apply(n,o.call(arguments,1));if(!j.isFunction(n))throw new TypeError;return r=o.call(arguments,2),e=function(){if(!(this instanceof e))return n.apply(t,r.concat(o.call(arguments)));R.prototype=n.prototype;var u=new R;R.prototype=null;var i=n.apply(u,r.concat(o.call(arguments)));return Object(i)===i?i:u}},j.partial=function(n){var t=o.call(arguments,1);return function(){for(var r=0,e=t.slice(),u=0,i=e.length;i>u;u++)e[u]===j&&(e[u]=arguments[r++]);for(;r<arguments.length;)e.push(arguments[r++]);return n.apply(this,e)}},j.bindAll=function(n){var t=o.call(arguments,1);if(0===t.length)throw new Error("bindAll must be passed function names");return A(t,function(t){n[t]=j.bind(n[t],n)}),n},j.memoize=function(n,t){var r={};return t||(t=j.identity),function(){var e=t.apply(this,arguments);return j.has(r,e)?r[e]:r[e]=n.apply(this,arguments)}},j.delay=function(n,t){var r=o.call(arguments,2);return setTimeout(function(){return n.apply(null,r)},t)},j.defer=function(n){return j.delay.apply(j,[n,1].concat(o.call(arguments,1)))},j.throttle=function(n,t,r){var e,u,i,a=null,o=0;r||(r={});var c=function(){o=r.leading===!1?0:j.now(),a=null,i=n.apply(e,u),e=u=null};return function(){var l=j.now();o||r.leading!==!1||(o=l);var f=t-(l-o);return e=this,u=arguments,0>=f?(clearTimeout(a),a=null,o=l,i=n.apply(e,u),e=u=null):a||r.trailing===!1||(a=setTimeout(c,f)),i}},j.debounce=function(n,t,r){var e,u,i,a,o,c=function(){var l=j.now()-a;t>l?e=setTimeout(c,t-l):(e=null,r||(o=n.apply(i,u),i=u=null))};return function(){i=this,u=arguments,a=j.now();var l=r&&!e;return e||(e=setTimeout(c,t)),l&&(o=n.apply(i,u),i=u=null),o}},j.once=function(n){var t,r=!1;return function(){return r?t:(r=!0,t=n.apply(this,arguments),n=null,t)}},j.wrap=function(n,t){return j.partial(t,n)},j.compose=function(){var n=arguments;return function(){for(var t=arguments,r=n.length-1;r>=0;r--)t=[n[r].apply(this,t)];return t[0]}},j.after=function(n,t){return function(){return--n<1?t.apply(this,arguments):void 0}},j.keys=function(n){if(!j.isObject(n))return[];if(w)return w(n);var t=[];for(var r in n)j.has(n,r)&&t.push(r);return t},j.values=function(n){for(var t=j.keys(n),r=t.length,e=new Array(r),u=0;r>u;u++)e[u]=n[t[u]];return e},j.pairs=function(n){for(var t=j.keys(n),r=t.length,e=new Array(r),u=0;r>u;u++)e[u]=[t[u],n[t[u]]];return e},j.invert=function(n){for(var t={},r=j.keys(n),e=0,u=r.length;u>e;e++)t[n[r[e]]]=r[e];return t},j.functions=j.methods=function(n){var t=[];for(var r in n)j.isFunction(n[r])&&t.push(r);return t.sort()},j.extend=function(n){return A(o.call(arguments,1),function(t){if(t)for(var r in t)n[r]=t[r]}),n},j.pick=function(n){var t={},r=c.apply(e,o.call(arguments,1));return A(r,function(r){r in n&&(t[r]=n[r])}),t},j.omit=function(n){var t={},r=c.apply(e,o.call(arguments,1));for(var u in n)j.contains(r,u)||(t[u]=n[u]);return t},j.defaults=function(n){return A(o.call(arguments,1),function(t){if(t)for(var r in t)n[r]===void 0&&(n[r]=t[r])}),n},j.clone=function(n){return j.isObject(n)?j.isArray(n)?n.slice():j.extend({},n):n},j.tap=function(n,t){return t(n),n};var S=function(n,t,r,e){if(n===t)return 0!==n||1/n==1/t;if(null==n||null==t)return n===t;n instanceof j&&(n=n._wrapped),t instanceof j&&(t=t._wrapped);var u=l.call(n);if(u!=l.call(t))return!1;switch(u){case"[object String]":return n==String(t);case"[object Number]":return n!=+n?t!=+t:0==n?1/n==1/t:n==+t;case"[object Date]":case"[object Boolean]":return+n==+t;case"[object RegExp]":return n.source==t.source&&n.global==t.global&&n.multiline==t.multiline&&n.ignoreCase==t.ignoreCase}if("object"!=typeof n||"object"!=typeof t)return!1;for(var i=r.length;i--;)if(r[i]==n)return e[i]==t;var a=n.constructor,o=t.constructor;if(a!==o&&!(j.isFunction(a)&&a instanceof a&&j.isFunction(o)&&o instanceof o)&&"constructor"in n&&"constructor"in t)return!1;r.push(n),e.push(t);var c=0,f=!0;if("[object Array]"==u){if(c=n.length,f=c==t.length)for(;c--&&(f=S(n[c],t[c],r,e)););}else{for(var s in n)if(j.has(n,s)&&(c++,!(f=j.has(t,s)&&S(n[s],t[s],r,e))))break;if(f){for(s in t)if(j.has(t,s)&&!c--)break;f=!c}}return r.pop(),e.pop(),f};j.isEqual=function(n,t){return S(n,t,[],[])},j.isEmpty=function(n){if(null==n)return!0;if(j.isArray(n)||j.isString(n))return 0===n.length;for(var t in n)if(j.has(n,t))return!1;return!0},j.isElement=function(n){return!(!n||1!==n.nodeType)},j.isArray=x||function(n){return"[object Array]"==l.call(n)},j.isObject=function(n){return n===Object(n)},A(["Arguments","Function","String","Number","Date","RegExp"],function(n){j["is"+n]=function(t){return l.call(t)=="[object "+n+"]"}}),j.isArguments(arguments)||(j.isArguments=function(n){return!(!n||!j.has(n,"callee"))}),"function"!=typeof/./&&(j.isFunction=function(n){return"function"==typeof n}),j.isFinite=function(n){return isFinite(n)&&!isNaN(parseFloat(n))},j.isNaN=function(n){return j.isNumber(n)&&n!=+n},j.isBoolean=function(n){return n===!0||n===!1||"[object Boolean]"==l.call(n)},j.isNull=function(n){return null===n},j.isUndefined=function(n){return n===void 0},j.has=function(n,t){return f.call(n,t)},j.noConflict=function(){return n._=t,this},j.identity=function(n){return n},j.constant=function(n){return function(){return n}},j.property=function(n){return function(t){return t[n]}},j.matches=function(n){return function(t){if(t===n)return!0;for(var r in n)if(n[r]!==t[r])return!1;return!0}},j.times=function(n,t,r){for(var e=Array(Math.max(0,n)),u=0;n>u;u++)e[u]=t.call(r,u);return e},j.random=function(n,t){return null==t&&(t=n,n=0),n+Math.floor(Math.random()*(t-n+1))},j.now=Date.now||function(){return(new Date).getTime()};var T={escape:{"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#x27;"}};T.unescape=j.invert(T.escape);var I={escape:new RegExp("["+j.keys(T.escape).join("")+"]","g"),unescape:new RegExp("("+j.keys(T.unescape).join("|")+")","g")};j.each(["escape","unescape"],function(n){j[n]=function(t){return null==t?"":(""+t).replace(I[n],function(t){return T[n][t]})}}),j.result=function(n,t){if(null==n)return void 0;var r=n[t];return j.isFunction(r)?r.call(n):r},j.mixin=function(n){A(j.functions(n),function(t){var r=j[t]=n[t];j.prototype[t]=function(){var n=[this._wrapped];return a.apply(n,arguments),z.call(this,r.apply(j,n))}})};var N=0;j.uniqueId=function(n){var t=++N+"";return n?n+t:t},j.templateSettings={evaluate:/<%([\s\S]+?)%>/g,interpolate:/<%=([\s\S]+?)%>/g,escape:/<%-([\s\S]+?)%>/g};var q=/(.)^/,B={"'":"'","\\":"\\","\r":"r","\n":"n","	":"t","\u2028":"u2028","\u2029":"u2029"},D=/\\|'|\r|\n|\t|\u2028|\u2029/g;j.template=function(n,t,r){var e;r=j.defaults({},r,j.templateSettings);var u=new RegExp([(r.escape||q).source,(r.interpolate||q).source,(r.evaluate||q).source].join("|")+"|$","g"),i=0,a="__p+='";n.replace(u,function(t,r,e,u,o){return a+=n.slice(i,o).replace(D,function(n){return"\\"+B[n]}),r&&(a+="'+\n((__t=("+r+"))==null?'':_.escape(__t))+\n'"),e&&(a+="'+\n((__t=("+e+"))==null?'':__t)+\n'"),u&&(a+="';\n"+u+"\n__p+='"),i=o+t.length,t}),a+="';\n",r.variable||(a="with(obj||{}){\n"+a+"}\n"),a="var __t,__p='',__j=Array.prototype.join,"+"print=function(){__p+=__j.call(arguments,'');};\n"+a+"return __p;\n";try{e=new Function(r.variable||"obj","_",a)}catch(o){throw o.source=a,o}if(t)return e(t,j);var c=function(n){return e.call(this,n,j)};return c.source="function("+(r.variable||"obj")+"){\n"+a+"}",c},j.chain=function(n){return j(n).chain()};var z=function(n){return this._chain?j(n).chain():n};j.mixin(j),A(["pop","push","reverse","shift","sort","splice","unshift"],function(n){var t=e[n];j.prototype[n]=function(){var r=this._wrapped;return t.apply(r,arguments),"shift"!=n&&"splice"!=n||0!==r.length||delete r[0],z.call(this,r)}}),A(["concat","join","slice"],function(n){var t=e[n];j.prototype[n]=function(){return z.call(this,t.apply(this._wrapped,arguments))}}),j.extend(j.prototype,{chain:function(){return this._chain=!0,this},value:function(){return this._wrapped}}),"function"==typeof define&&define.amd&&define("underscore",[],function(){return j})}).call(this);
//# sourceMappingURL=underscore-min.map
;
define("underscore-min", ["jquery"], (function (global) {
    return function () {
        var ret, fn;
        return ret || global._;
    };
}(this)));

/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('gw/Numeric',[], function() {

/**************************************************************************************************************/

/**
	Declare namespace for Numeric functions.
	TODO : Should be put into GlobWeb
 */
var Numeric = {};

/**************************************************************************************************************/

/**
  Linear interpolation between [a, b], t must be [0, 1]
*/
Numeric.lerp = function(t, a, b)
{
    return a + ((b - a) * t);
}

/**************************************************************************************************************/

/**
 Cubic interpolation between [a, b], t must be [0, 1]
*/
Numeric.cubicInterpolation = function(t, startPos, startVel, endPos, endVel)
{
	var t2 = t * t;
	var t3 = t2 * t; 
	
	// Evaluate the position
	
	var M00 = 2 * startPos[0] - 2 * endPos[0] + startVel[0] + endVel[0];
	var M10 = 2 * startPos[1] - 2 * endPos[1] + startVel[1] + endVel[1];
	var M20 = 2 * startPos[2] - 2 * endPos[2] + startVel[2] + endVel[2];

	var M01 = -3 * startPos[0] + 3 * endPos[0] - 2 * startVel[0] - endVel[0];
	var M11 = -3 * startPos[1] + 3 * endPos[1] - 2 * startVel[1] - endVel[1];
	var M21 = -3 * startPos[2] + 3 * endPos[2] - 2 * startVel[2] - endVel[2];
	
	var position = vec3.create();
	position[0] = M00 * t3 + M01 * t2 + startVel[0] * t + startPos[0];
	position[1] = M10 * t3 + M11 * t2 + startVel[1] * t + startPos[1];
	position[2] = M20 * t3 + M21 * t2 + startVel[2] * t + startPos[2];
	
	return position;
}

/**************************************************************************************************************/

/**
 Cubic interpolation between [a, b], t must be [0, 1]
*/
Numeric.cubicInterpolationDerivative = function(t, startPos, startVel, endPos, endVel)
{
	var t2 = t * t;
	
	// Evaluates the direction

	var M01 = 6 * startPos[0] - 6 * endPos[0] + 3 * startVel[0] + 3 * endVel[0];
	var M11 = 6 * startPos[1] - 6 * endPos[1] + 3 * startVel[1] + 3 * endVel[1];
	var M21 = 6 * startPos[2] - 6 * endPos[2] + 3 * startVel[2] + 3 * endVel[2];

	var M02 = -6 * startPos[0] + 6 * endPos[0] - 4 * startVel[0] - 2 * endVel[0];
	var M12 = -6 * startPos[1] + 6 * endPos[1] - 4 * startVel[1] - 2 * endVel[1];
	var M22 = -6 * startPos[2] + 6 * endPos[2] - 4 * startVel[2] - 2 * endVel[2];

	var direction = vec3.create();
	direction[0] = M01 * t2 + M02 * t + startVel[0];
	direction[1] = M11 * t2 + M12 * t + startVel[1];
	direction[2] = M21 * t2 + M22 * t + startVel[2];
	
	return direction;
}

/**************************************************************************************************************/

/**
  Map x between [xMin, xMax] to [0, 1]
*/
Numeric.map01 = function(x, xMin, xMax)
{
    return (xMin != xMax) ? (x - xMin) / (xMax - xMin) : 0;
}

/**************************************************************************************************************/

/*
  Map x between [xMin, xMax] to [outMin, outMax]
*/
Numeric.mapLinear = function(x, xMin, xMax, outMin, outMax)
{
    return Numeric.lerp(Numeric.map01(x, xMin, xMax), outMin, outMax);
}

/**************************************************************************************************************/

Numeric.easeInQuad = function(t)
{
    return t*t;
}

/**************************************************************************************************************/

Numeric.easeOutQuad = function(t)
{
    // use 1-(t^2) with input [-1, 0]
    var v = t - 1; // map [0 1] to [-1 0]
    return 1.0-(v*v);
}

/**************************************************************************************************************/

/**
  Remap input t ([0, 1]) to a curve starting slowly
  and accelerating till 0.5 an decelerating till 1
*/
Numeric.easeInOutQuad = function(t)
{
    var out = t;
    if (out < 0.5)
    {
        // use (0.5*t^2) with input [0, 1]
        out = out+out; // map [0 0.5] outo [0 1]
        out = 0.5*(out*out);
    }
    else
    {
        // use (0.5*(1-t)^2) with input [-1, 0]
        out = (out+out) - 2.0; // map [0.5 1] to [-1 0]
        out = 0.5*(1.0-(out*out));
        out = 0.5 + out;
    }
    return out;
}

/**************************************************************************************************************/

/*
 */
Numeric.easeOutInQuad = function(t)
{
    var out = t;
    if (out < 0.5)
    {
        // use (0.5*(1-t)^2) with input [-1, 0]
        out = (out+out) - 1.0; // map [0 0.5] to [-1 0]
        out = 0.5*(1.0-(out*out));
    }
    else
    {
        // use (0.5*t^2) with input [0, 1]
        out = (out+out) - 1.0; // map [0.5 1] outo [0 1]
        out = 0.5*(out*out);
        out = 0.5 + out;
    }
    return out;
}

/**************************************************************************************************************/

/**
  Convert the given degree value in radian
*/
Numeric.toRadian = function(degree)
{
    return degree * Math.PI / 180.0;
}

/**************************************************************************************************************/

/**
  Convert the given radian value in degree
*/
Numeric.toDegree = function(radian)
{
    return radian * 180.0 / Math.PI;
}

/**************************************************************************************************************/

/**
  Computes point on a ray
*/
Numeric.pointOnRay = function(rayOrigin, rayDirection, t, dest)
{
    if (!dest) { dest = vec3.create(); }

    vec3.scale(rayDirection, t, dest);
    vec3.add(dest, rayOrigin, dest);

    return dest;
}

/**************************************************************************************************************/

/**
  Line-line intersection
  rayDirection must be normalized.
  Returns t at which intersection occurs or -1 if no intersection.
*/

Numeric.lineIntersection = function( x1, y1, x2, y2, x3, y3, x4, y4 )
{
	var det = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);
	if ( det == 0 )
	{
		return [-1,-1];
	}
	
	var ua = (x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3);
	var ub = (x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3);
	
	ua /= det;
	ub /= det;
	
	return [ ua, ub ];
	//return ua > 0.0 && ua < 1.0 && ub > 0.0 && ub < 1.0;
}

/**************************************************************************************************************/

/**
  Ray sphere intersection
  rayDirection must be normalized.
  Returns t at which intersection occurs or -1 if no intersection.
*/
Numeric.raySphereIntersection = function(rayOrigin, rayDirection, sphereCenter, sphereRadius)
{
    // cf. http://wiki.cgsociety.org/index.php/Ray_Sphere_Intersection

    var rs = vec3.subtract( rayOrigin, sphereCenter, vec3.create() );
    // rayDirection is normalized so a = 1
    // var a = vec3.dot(rayDirection, rayDirection);
    var b = 2.0 * vec3.dot(rayDirection, rs);
    var c = vec3.dot(rs, rs) - sphereRadius*sphereRadius;

    // as a == 1, discriminant = b^2 - (4*c)
    // var discr = (b*b) - (4*a*c);
    var discr = (b*b) - (4*c);
    if (discr < 0)
        return -1;

    // t0 = (-b - sqrt(discr)) / 2a, t1 = (-b + sqrt(discr)) / 2a, a == 1
    discr = Math.sqrt(discr);
    var tNear = (-b - discr) / 2;
    var tFar  = (-b + discr) / 2;
    if (tNear > tFar) // Swap t values
    {
        var tmp = tNear;
        tNear = tFar;
        tFar = tmp;
    }

    if (tFar < 0) // Hit is beyond ray origin
        return -1;
    
    return tNear < 0 ? tFar : tNear;
}

/**************************************************************************************************************/

/**
 * 	Round the given number
 * 
 * 	@param num Number to round
 * 	@param dec Number of decimals
 */
Numeric.roundNumber = function (num, dec)
{
	var result = Math.round(num*Math.pow(10,dec))/Math.pow(10,dec);
	return result;
}

/**************************************************************************************************************/

return Numeric;

});


/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('gw/CoordinateSystem', ['./Numeric' ], function(Numeric) {
 
var CoordinateSystem = { radius: 1.0, heightScale: 1.0 / 6356752.3142, realEarthRadius: 6356752.3142  };

/**************************************************************************************************************/

/*
	Convert a geographic position to 3D
 */
CoordinateSystem.fromGeoTo3D = function(geo, dest)
{
    if (!dest) { dest = new Array(3); }

	var longInRad = Numeric.toRadian(geo[0]);
	var latInRad = Numeric.toRadian(geo[1]);
	var cosLat = Math.cos(latInRad);
	
	// Take height into account
	var height = geo.length > 2 ? CoordinateSystem.heightScale * geo[2] : 0;
	var radius = CoordinateSystem.radius + height;

    dest[0] = radius * Math.cos(longInRad) * cosLat;
    dest[1] = radius * Math.sin(longInRad) * cosLat;
    dest[2] = radius * Math.sin(latInRad);

    return dest;
}

/**************************************************************************************************************/

/*
	Convert a 3D position to geographic
    Returns 3 values [long, lat, distance from earth surface]
 */
CoordinateSystem.from3DToGeo = function(position3d, dest)
{
    if (!dest) { dest = new Array(3); }

    var r = Math.sqrt(position3d[0]*position3d[0] +
                      position3d[1]*position3d[1] +
                      position3d[2]*position3d[2]);
    var lon = Math.atan2(position3d[1] / r, position3d[0] / r);
    var lat = Math.asin(position3d[2] / r);

    dest[0] = Numeric.toDegree(lon);
    dest[1] = Numeric.toDegree(lat);
    dest[2] = CoordinateSystem.realEarthRadius * (r - CoordinateSystem.radius);

    return dest;
}

/**************************************************************************************************************/

/*
	Get local transformation
 */
CoordinateSystem.getLocalTransform = function(geo, dest)
{
    if (!dest) { dest = mat4.create(); }

	var longitude = geo[0] * Math.PI / 180.0;
	var latitude = geo[1] * Math.PI / 180.0;
	
	var up = [  Math.cos(longitude)*Math.cos(latitude), Math.sin(longitude)*Math.cos(latitude), Math.sin(latitude) ];
	var east = [ -Math.sin(longitude), Math.cos(longitude), 0 ];
	var north = vec3.create();
	vec3.cross( up, east, north );
	
	dest[0] = east[0];
	dest[1] = east[1];
	dest[2] = east[2];
	dest[3] = 0.0;
		
	dest[4] = north[0];
	dest[5] = north[1];
	dest[6] = north[2];
	dest[7] = 0.0;
		
	dest[8] = up[0];
	dest[9] = up[1];
	dest[10] = up[2];
	dest[11] = 0.0;

	dest[12] = 0.0;
	dest[13] = 0.0;
	dest[14] = 0.0;
	dest[15] = 1.0;

	return dest;
}

/**************************************************************************************************************/

/*
	Get local transformation
 */
CoordinateSystem.getLHVTransform = function(geo, dest)
{
    if (!dest) { dest = mat4.create(); }

	var longitude = geo[0] * Math.PI / 180.0;
	var latitude = geo[1] * Math.PI / 180.0;
	
	var up = [  Math.cos(longitude)*Math.cos(latitude), Math.sin(longitude)*Math.cos(latitude), Math.sin(latitude) ];
	var east = [ -Math.sin(longitude), Math.cos(longitude), 0 ];
	var north = vec3.create();
	vec3.cross( up, east, north );
	
	var pt = CoordinateSystem.fromGeoTo3D(geo);
	
	dest[0] = east[0];
	dest[1] = east[1];
	dest[2] = east[2];
	dest[3] = 0.0;
		
	dest[4] = north[0];
	dest[5] = north[1];
	dest[6] = north[2];
	dest[7] = 0.0;
		
	dest[8] = up[0];
	dest[9] = up[1];
	dest[10] = up[2];
	dest[11] = 0.0;

	dest[12] = pt[0];
	dest[13] = pt[1];
	dest[14] = pt[2];
	dest[15] = 1.0;

	return dest;
}

/**************************************************************************************************************/

/*
	Get the side (i.e. X) vector from a local transformation
 */
CoordinateSystem.getSideVector = function( matrix, v )
{
	v[0] = matrix[0];
	v[1] = matrix[1];
	v[2] = matrix[2];
	
    return v;
}

/**************************************************************************************************************/

/*
	Get the front (i.e. Y) vector from a local transformation
 */
CoordinateSystem.getFrontVector = function( matrix, v )
{
	v[0] = matrix[4];
	v[1] = matrix[5];
	v[2] = matrix[6];
	
    return v;
}

/**************************************************************************************************************/

/*
	Get the up (i.e. Z) vector from a local transformation
 */
CoordinateSystem.getUpVector = function( matrix, v )
{
	v[0] = matrix[8];
	v[1] = matrix[9];
	v[2] = matrix[10];
	
    return v;
}

/**************************************************************************************************************/

return CoordinateSystem;

});
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *  Ported from HEALPix Java code supported by the Gaia project.
 * 	Copyright (C) 2006-2011 Gaia Data Processing and Analysis Consortium
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('gw/AstroCoordTransform',[],function() {

/**************************************************************************************************************/

/** The Constant twoPi. */
var twoPi=2.*Math.PI;

/** The Constant fourPi. */
var fourPi=4.*Math.PI;

/** The Constant degToRad. */
var degToRad=180.0/Math.PI;

/** The Constant psi. */
var psi = [
	[0.57595865315,4.92619181360,0.00000000000,0.00000000000,0.11129056012,4.70053728340],
	[0.57477043300,4.93682924650,0.00000000000,0.00000000000,0.11142137093,4.71279419371]
];

/** The Constant stheta. */
var stheta = [
	[0.88781538514,-0.88781538514, 0.39788119938,-0.39788119938, 0.86766174755,-0.86766174755],
	[0.88998808748,-0.88998808748, 0.39777715593,-0.39777715593, 0.86766622025,-0.86766622025]
];

/** The Constant ctheta. */
var ctheta = [
	[0.46019978478,0.46019978478,0.91743694670,0.91743694670,0.49715499774,0.49715499774],
	[0.45598377618,0.45598377618,0.91748206207,0.91748206207,0.49714719172,0.49714719172]
];

/** The Constant phi. */
var phi = [
	[4.92619181360,0.57595865315,0.00000000000,0.00000000000,4.70053728340,0.11129056012],
	[4.93682924650,0.57477043300,0.00000000000,0.00000000000,4.71279419371,0.11142137093]
];

var AstroCoordTransform = {

	/**Transforms an angular position in radians in a given coordinate system to a position
	   in an other coordinate system, also in radians. RA-Dec position are intended in 
	   Equinox J2000
	   
	   @param {Float[]} pos Angular position [phi, theta]
	   @param trType Transform type
	 */
    transform: function(pos, trType) 
	{
		var ao,bo,a,b,sb,cb,cbsa;
		var J2000 = 1;
		//by setting J2000 = 0, RA-Dec are intended in Equinox 1950.

		a= pos[0] - phi[J2000][trType];
		b= pos[1];
		sb=Math.sin(b);
		cb=Math.cos(b);
		cbsa=cb*Math.sin(a);
		b=-stheta[J2000][trType] * cbsa + ctheta[J2000][trType]*sb;
		b=Math.max(-1.0,Math.min(b,1.0));
		bo=Math.asin(b);
		
		a=Math.atan2(ctheta[J2000][trType] * cbsa+ stheta[J2000][trType]*sb,cb*Math.cos(a));
		ao=(a+psi[J2000][trType]+fourPi)%twoPi;

		return [ao, bo]; // phi, theta
    },

    /**Transforms an angular position in degrees in a given coordinate system to a position
       in an other coordinate systems, also in degrees. RA-Dec position are intended in 
       Equinox J2000

       @param {Float[]} pos Angular position [phi, theta]
       @param trType Transform type
       */
    transformInDeg: function(pos, trType) 
	{
		var ao,bo,a,b,sb,cb,cbsa;
		var J2000 = 1;
		//by setting J2000 = 0, RA-Dec are intended in Equinox 1950.

		a= pos[0]/degToRad - phi[J2000][trType];
		b= pos[1]/degToRad;
		sb=Math.sin(b);
		cb=Math.cos(b);
		cbsa=cb*Math.sin(a);
		b=-stheta[J2000][trType] * cbsa + ctheta[J2000][trType]*sb;
		b=Math.max(-1.0,Math.min(b,1.0));
		bo=Math.asin(b)*degToRad;
		
		a=Math.atan2(ctheta[J2000][trType] * cbsa+ stheta[J2000][trType]*sb,cb*Math.cos(a));
		ao= ((a+psi[J2000][trType]+fourPi)%twoPi)*degToRad;

		return [ao, bo];		      
    }
};

/**
 *	Transform type enumerations
 */
AstroCoordTransform.Type = 
{
	EQ2GAL: 0,		//RA-Dec (2000) -> Galactic
	GAL2EQ: 1,		//Galactic      -> RA-Dec
	EQ2ECL: 2,		//RA-Dec        -> Ecliptic
	ECL2EQ: 3,		//Ecliptic      -> RA-Dec
	ECL2GAL: 4,		//Ecliptic      -> Galactic
	GAL2ECL: 5 		//Galactic      -> Ecliptic
};

/**************************************************************************************************************/

return AstroCoordTransform;

});

/**
 * @fileoverview gl-matrix - High performance matrix and vector operations for WebGL
 * @author Brandon Jones
 * @author Colin MacKenzie IV
 * @version 1.3.7
 */

/*
 * Copyright (c) 2012 Brandon Jones, Colin MacKenzie IV
 *
 * This software is provided 'as-is', without any express or implied
 * warranty. In no event will the authors be held liable for any damages
 * arising from the use of this software.
 *
 * Permission is granted to anyone to use this software for any purpose,
 * including commercial applications, and to alter it and redistribute it
 * freely, subject to the following restrictions:
 *
 *    1. The origin of this software must not be misrepresented; you must not
 *    claim that you wrote the original software. If you use this software
 *    in a product, an acknowledgment in the product documentation would be
 *    appreciated but is not required.
 *
 *    2. Altered source versions must be plainly marked as such, and must not
 *    be misrepresented as being the original software.
 *
 *    3. This notice may not be removed or altered from any source
 *    distribution.
 */

// Modification to plain glMatrix
//	- Always use Array for MatrixType
//	- Remove export management
//	- Remove vec2, mat2, mat3, vec4
//	- Comments some not needed functions
//	- Add mat4.project and mat4.rotateVec3

define('gw/glMatrix',[], function () {

    // Tweak to your liking
    var FLOAT_EPSILON = 0.000001;

    /**
     * @class System-specific optimal array type
     * @name MatrixArray
     */
    var MatrixArray = Array;
    
    /**
     * @class 3 Dimensional Vector
     * @name vec3
     */
    var vec3 = {};
     
    /**
     * Creates a new instance of a vec3 using the default array type
     * Any javascript array-like objects containing at least 3 numeric elements can serve as a vec3
     *
     * @param {vec3} [vec] vec3 containing values to initialize with
     *
     * @returns {vec3} New vec3
     */
    vec3.create = function (vec) {
        var dest = new MatrixArray(3);

        if (vec) {
            dest[0] = vec[0];
            dest[1] = vec[1];
            dest[2] = vec[2];
        } else {
            dest[0] = dest[1] = dest[2] = 0;
        }

        return dest;
    };

    /**
     * Creates a new instance of a vec3, initializing it with the given arguments
     *
     * @param {number} x X value
     * @param {number} y Y value
     * @param {number} z Z value

     * @returns {vec3} New vec3
     */
    vec3.createFrom = function (x, y, z) {
        var dest = new MatrixArray(3);

        dest[0] = x;
        dest[1] = y;
        dest[2] = z;

        return dest;
    };

    /**
     * Copies the values of one vec3 to another
     *
     * @param {vec3} vec vec3 containing values to copy
     * @param {vec3} dest vec3 receiving copied values
     *
     * @returns {vec3} dest
     */
    vec3.set = function (vec, dest) {
        dest[0] = vec[0];
        dest[1] = vec[1];
        dest[2] = vec[2];

        return dest;
    };

    /**
     * Compares two vectors for equality within a certain margin of error
     *
     * @param {vec3} a First vector
     * @param {vec3} b Second vector
     *
     * @returns {Boolean} True if a is equivalent to b
     */
    vec3.equal = function (a, b) {
        return a === b || (
            Math.abs(a[0] - b[0]) < FLOAT_EPSILON &&
            Math.abs(a[1] - b[1]) < FLOAT_EPSILON &&
            Math.abs(a[2] - b[2]) < FLOAT_EPSILON
        );
    };

    /**
     * Performs a vector addition
     *
     * @param {vec3} vec First operand
     * @param {vec3} vec2 Second operand
     * @param {vec3} [dest] vec3 receiving operation result. If not specified result is written to vec
     *
     * @returns {vec3} dest if specified, vec otherwise
     */
    vec3.add = function (vec, vec2, dest) {
        if (!dest || vec === dest) {
            vec[0] += vec2[0];
            vec[1] += vec2[1];
            vec[2] += vec2[2];
            return vec;
        }

        dest[0] = vec[0] + vec2[0];
        dest[1] = vec[1] + vec2[1];
        dest[2] = vec[2] + vec2[2];
        return dest;
    };

    /**
     * Performs a vector subtraction
     *
     * @param {vec3} vec First operand
     * @param {vec3} vec2 Second operand
     * @param {vec3} [dest] vec3 receiving operation result. If not specified result is written to vec
     *
     * @returns {vec3} dest if specified, vec otherwise
     */
    vec3.subtract = function (vec, vec2, dest) {
        if (!dest || vec === dest) {
            vec[0] -= vec2[0];
            vec[1] -= vec2[1];
            vec[2] -= vec2[2];
            return vec;
        }

        dest[0] = vec[0] - vec2[0];
        dest[1] = vec[1] - vec2[1];
        dest[2] = vec[2] - vec2[2];
        return dest;
    };

    /**
     * Performs a vector multiplication
     *
     * @param {vec3} vec First operand
     * @param {vec3} vec2 Second operand
     * @param {vec3} [dest] vec3 receiving operation result. If not specified result is written to vec
     *
     * @returns {vec3} dest if specified, vec otherwise
     */
    vec3.multiply = function (vec, vec2, dest) {
        if (!dest || vec === dest) {
            vec[0] *= vec2[0];
            vec[1] *= vec2[1];
            vec[2] *= vec2[2];
            return vec;
        }

        dest[0] = vec[0] * vec2[0];
        dest[1] = vec[1] * vec2[1];
        dest[2] = vec[2] * vec2[2];
        return dest;
    };

    /**
     * Negates the components of a vec3
     *
     * @param {vec3} vec vec3 to negate
     * @param {vec3} [dest] vec3 receiving operation result. If not specified result is written to vec
     *
     * @returns {vec3} dest if specified, vec otherwise
     */
    vec3.negate = function (vec, dest) {
        if (!dest) { dest = vec; }

        dest[0] = -vec[0];
        dest[1] = -vec[1];
        dest[2] = -vec[2];
        return dest;
    };

    /**
     * Multiplies the components of a vec3 by a scalar value
     *
     * @param {vec3} vec vec3 to scale
     * @param {number} val Value to scale by
     * @param {vec3} [dest] vec3 receiving operation result. If not specified result is written to vec
     *
     * @returns {vec3} dest if specified, vec otherwise
     */
    vec3.scale = function (vec, val, dest) {
        if (!dest || vec === dest) {
            vec[0] *= val;
            vec[1] *= val;
            vec[2] *= val;
            return vec;
        }

        dest[0] = vec[0] * val;
        dest[1] = vec[1] * val;
        dest[2] = vec[2] * val;
        return dest;
    };

    /**
     * Generates a unit vector of the same direction as the provided vec3
     * If vector length is 0, returns [0, 0, 0]
     *
     * @param {vec3} vec vec3 to normalize
     * @param {vec3} [dest] vec3 receiving operation result. If not specified result is written to vec
     *
     * @returns {vec3} dest if specified, vec otherwise
     */
    vec3.normalize = function (vec, dest) {
        if (!dest) { dest = vec; }

        var x = vec[0], y = vec[1], z = vec[2],
            len = Math.sqrt(x * x + y * y + z * z);

        if (!len) {
            dest[0] = 0;
            dest[1] = 0;
            dest[2] = 0;
            return dest;
        } else if (len === 1) {
            dest[0] = x;
            dest[1] = y;
            dest[2] = z;
            return dest;
        }

        len = 1 / len;
        dest[0] = x * len;
        dest[1] = y * len;
        dest[2] = z * len;
        return dest;
    };

    /**
     * Generates the cross product of two vec3s
     *
     * @param {vec3} vec First operand
     * @param {vec3} vec2 Second operand
     * @param {vec3} [dest] vec3 receiving operation result. If not specified result is written to vec
     *
     * @returns {vec3} dest if specified, vec otherwise
     */
    vec3.cross = function (vec, vec2, dest) {
        if (!dest) { dest = vec; }

        var x = vec[0], y = vec[1], z = vec[2],
            x2 = vec2[0], y2 = vec2[1], z2 = vec2[2];

        dest[0] = y * z2 - z * y2;
        dest[1] = z * x2 - x * z2;
        dest[2] = x * y2 - y * x2;
        return dest;
    };

    /**
     * Caclulates the length of a vec3
     *
     * @param {vec3} vec vec3 to calculate length of
     *
     * @returns {number} Length of vec
     */
    vec3.length = function (vec) {
        var x = vec[0], y = vec[1], z = vec[2];
        return Math.sqrt(x * x + y * y + z * z);
    };

    /**
     * Caclulates the squared length of a vec3
     *
     * @param {vec3} vec vec3 to calculate squared length of
     *
     * @returns {number} Squared Length of vec
     */
    vec3.squaredLength = function (vec) {
        var x = vec[0], y = vec[1], z = vec[2];
        return x * x + y * y + z * z;
    };

    /**
     * Caclulates the dot product of two vec3s
     *
     * @param {vec3} vec First operand
     * @param {vec3} vec2 Second operand
     *
     * @returns {number} Dot product of vec and vec2
     */
    vec3.dot = function (vec, vec2) {
        return vec[0] * vec2[0] + vec[1] * vec2[1] + vec[2] * vec2[2];
    };

    /**
     * Generates a unit vector pointing from one vector to another
     *
     * @param {vec3} vec Origin vec3
     * @param {vec3} vec2 vec3 to point to
     * @param {vec3} [dest] vec3 receiving operation result. If not specified result is written to vec
     *
     * @returns {vec3} dest if specified, vec otherwise
     */
/*   vec3.direction = function (vec, vec2, dest) {
        if (!dest) { dest = vec; }

        var x = vec[0] - vec2[0],
            y = vec[1] - vec2[1],
            z = vec[2] - vec2[2],
            len = Math.sqrt(x * x + y * y + z * z);

        if (!len) {
            dest[0] = 0;
            dest[1] = 0;
            dest[2] = 0;
            return dest;
        }

        len = 1 / len;
        dest[0] = x * len;
        dest[1] = y * len;
        dest[2] = z * len;
        return dest;
    };*/

    /**
     * Performs a linear interpolation between two vec3
     *
     * @param {vec3} vec First vector
     * @param {vec3} vec2 Second vector
     * @param {number} lerp Interpolation amount between the two inputs
     * @param {vec3} [dest] vec3 receiving operation result. If not specified result is written to vec
     *
     * @returns {vec3} dest if specified, vec otherwise
     */
    vec3.lerp = function (vec, vec2, lerp, dest) {
        if (!dest) { dest = vec; }

        dest[0] = vec[0] + lerp * (vec2[0] - vec[0]);
        dest[1] = vec[1] + lerp * (vec2[1] - vec[1]);
        dest[2] = vec[2] + lerp * (vec2[2] - vec[2]);

        return dest;
    };

    /**
     * Calculates the euclidian distance between two vec3
     *
     * Params:
     * @param {vec3} vec First vector
     * @param {vec3} vec2 Second vector
     *
     * @returns {number} Distance between vec and vec2
     */
    vec3.dist = function (vec, vec2) {
        var x = vec2[0] - vec[0],
            y = vec2[1] - vec[1],
            z = vec2[2] - vec[2];
            
        return Math.sqrt(x*x + y*y + z*z);
    };

    // Pre-allocated to prevent unecessary garbage collection
    //var unprojectMat = null;
    //var unprojectVec = new MatrixArray(4);
    /**
     * Projects the specified vec3 from screen space into object space
     * Based on the <a href="http://webcvs.freedesktop.org/mesa/Mesa/src/glu/mesa/project.c?revision=1.4&view=markup">Mesa gluUnProject implementation</a>
     *
     * @param {vec3} vec Screen-space vector to project
     * @param {mat4} view View matrix
     * @param {mat4} proj Projection matrix
     * @param {vec4} viewport Viewport as given to gl.viewport [x, y, width, height]
     * @param {vec3} [dest] vec3 receiving unprojected result. If not specified result is written to vec
     *
     * @returns {vec3} dest if specified, vec otherwise
     */
 /*   vec3.unproject = function (vec, view, proj, viewport, dest) {
        if (!dest) { dest = vec; }

        if(!unprojectMat) {
            unprojectMat = mat4.create();
        }

        var m = unprojectMat;
        var v = unprojectVec;
        
        v[0] = (vec[0] - viewport[0]) * 2.0 / viewport[2] - 1.0;
        v[1] = (vec[1] - viewport[1]) * 2.0 / viewport[3] - 1.0;
        v[2] = 2.0 * vec[2] - 1.0;
        v[3] = 1.0;
        
        mat4.multiply(proj, view, m);
        if(!mat4.inverse(m)) { return null; }
        
        mat4.multiplyVec4(m, v);
        if(v[3] === 0.0) { return null; }

        dest[0] = v[0] / v[3];
        dest[1] = v[1] / v[3];
        dest[2] = v[2] / v[3];
        
        return dest;
    };*/

/*    var xUnitVec3 = vec3.createFrom(1,0,0);
    var yUnitVec3 = vec3.createFrom(0,1,0);
    var zUnitVec3 = vec3.createFrom(0,0,1);

    var tmpvec3 = vec3.create();*/
    /**
     * Generates a quaternion of rotation between two given normalized vectors
     *
     * @param {vec3} a Normalized source vector
     * @param {vec3} b Normalized target vector
     * @param {quat4} [dest] quat4 receiving operation result.
     *
     * @returns {quat4} dest if specified, a new quat4 otherwise
     */
/*    vec3.rotationTo = function (a, b, dest) {
        if (!dest) { dest = quat4.create(); }
        
        var d = vec3.dot(a, b);
        var axis = tmpvec3;
        if (d >= 1.0) {
            quat4.set(identityQuat4, dest);
        } else if (d < (0.000001 - 1.0)) {
            vec3.cross(xUnitVec3, a, axis);
            if (vec3.length(axis) < 0.000001)
                vec3.cross(yUnitVec3, a, axis);
            if (vec3.length(axis) < 0.000001)
                vec3.cross(zUnitVec3, a, axis);
            vec3.normalize(axis);
            quat4.fromAngleAxis(Math.PI, axis, dest);
        } else {
            var s = Math.sqrt((1.0 + d) * 2.0);
            var sInv = 1.0 / s;
            vec3.cross(a, b, axis);
            dest[0] = axis[0] * sInv;
            dest[1] = axis[1] * sInv;
            dest[2] = axis[2] * sInv;
            dest[3] = s * 0.5;
            quat4.normalize(dest);
        }
        if (dest[3] > 1.0) dest[3] = 1.0;
        else if (dest[3] < -1.0) dest[3] = -1.0;
        return dest;
    };*/

    /**
     * Returns a string representation of a vector
     *
     * @param {vec3} vec Vector to represent as a string
     *
     * @returns {string} String representation of vec
     */
    vec3.str = function (vec) {
        return '[' + vec[0] + ', ' + vec[1] + ', ' + vec[2] + ']';
    };

    /**
     * @class 4x4 Matrix
     * @name mat4
     */
    var mat4 = {};

    /**
     * Creates a new instance of a mat4 using the default array type
     * Any javascript array-like object containing at least 16 numeric elements can serve as a mat4
     *
     * @param {mat4} [mat] mat4 containing values to initialize with
     *
     * @returns {mat4} New mat4
     */
    mat4.create = function (mat) {
        var dest = new MatrixArray(16);

        if (mat) {
            dest[0] = mat[0];
            dest[1] = mat[1];
            dest[2] = mat[2];
            dest[3] = mat[3];
            dest[4] = mat[4];
            dest[5] = mat[5];
            dest[6] = mat[6];
            dest[7] = mat[7];
            dest[8] = mat[8];
            dest[9] = mat[9];
            dest[10] = mat[10];
            dest[11] = mat[11];
            dest[12] = mat[12];
            dest[13] = mat[13];
            dest[14] = mat[14];
            dest[15] = mat[15];
        }

        return dest;
    };

    /**
     * Creates a new instance of a mat4, initializing it with the given arguments
     *
     * @param {number} m00
     * @param {number} m01
     * @param {number} m02
     * @param {number} m03
     * @param {number} m10
     * @param {number} m11
     * @param {number} m12
     * @param {number} m13
     * @param {number} m20
     * @param {number} m21
     * @param {number} m22
     * @param {number} m23
     * @param {number} m30
     * @param {number} m31
     * @param {number} m32
     * @param {number} m33

     * @returns {mat4} New mat4
     */
 /*   mat4.createFrom = function (m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
        var dest = new MatrixArray(16);

        dest[0] = m00;
        dest[1] = m01;
        dest[2] = m02;
        dest[3] = m03;
        dest[4] = m10;
        dest[5] = m11;
        dest[6] = m12;
        dest[7] = m13;
        dest[8] = m20;
        dest[9] = m21;
        dest[10] = m22;
        dest[11] = m23;
        dest[12] = m30;
        dest[13] = m31;
        dest[14] = m32;
        dest[15] = m33;

        return dest;
    };*/

    /**
     * Copies the values of one mat4 to another
     *
     * @param {mat4} mat mat4 containing values to copy
     * @param {mat4} dest mat4 receiving copied values
     *
     * @returns {mat4} dest
     */
    mat4.set = function (mat, dest) {
        dest[0] = mat[0];
        dest[1] = mat[1];
        dest[2] = mat[2];
        dest[3] = mat[3];
        dest[4] = mat[4];
        dest[5] = mat[5];
        dest[6] = mat[6];
        dest[7] = mat[7];
        dest[8] = mat[8];
        dest[9] = mat[9];
        dest[10] = mat[10];
        dest[11] = mat[11];
        dest[12] = mat[12];
        dest[13] = mat[13];
        dest[14] = mat[14];
        dest[15] = mat[15];
        return dest;
    };

    /**
     * Compares two matrices for equality within a certain margin of error
     *
     * @param {mat4} a First matrix
     * @param {mat4} b Second matrix
     *
     * @returns {Boolean} True if a is equivalent to b
     */
/*    mat4.equal = function (a, b) {
        return a === b || (
            Math.abs(a[0] - b[0]) < FLOAT_EPSILON &&
            Math.abs(a[1] - b[1]) < FLOAT_EPSILON &&
            Math.abs(a[2] - b[2]) < FLOAT_EPSILON &&
            Math.abs(a[3] - b[3]) < FLOAT_EPSILON &&
            Math.abs(a[4] - b[4]) < FLOAT_EPSILON &&
            Math.abs(a[5] - b[5]) < FLOAT_EPSILON &&
            Math.abs(a[6] - b[6]) < FLOAT_EPSILON &&
            Math.abs(a[7] - b[7]) < FLOAT_EPSILON &&
            Math.abs(a[8] - b[8]) < FLOAT_EPSILON &&
            Math.abs(a[9] - b[9]) < FLOAT_EPSILON &&
            Math.abs(a[10] - b[10]) < FLOAT_EPSILON &&
            Math.abs(a[11] - b[11]) < FLOAT_EPSILON &&
            Math.abs(a[12] - b[12]) < FLOAT_EPSILON &&
            Math.abs(a[13] - b[13]) < FLOAT_EPSILON &&
            Math.abs(a[14] - b[14]) < FLOAT_EPSILON &&
            Math.abs(a[15] - b[15]) < FLOAT_EPSILON
        );
    };*/

    /**
     * Sets a mat4 to an identity matrix
     *
     * @param {mat4} dest mat4 to set
     *
     * @returns {mat4} dest
     */
    mat4.identity = function (dest) {
        if (!dest) { dest = mat4.create(); }
        dest[0] = 1;
        dest[1] = 0;
        dest[2] = 0;
        dest[3] = 0;
        dest[4] = 0;
        dest[5] = 1;
        dest[6] = 0;
        dest[7] = 0;
        dest[8] = 0;
        dest[9] = 0;
        dest[10] = 1;
        dest[11] = 0;
        dest[12] = 0;
        dest[13] = 0;
        dest[14] = 0;
        dest[15] = 1;
        return dest;
    };

    /**
     * Transposes a mat4 (flips the values over the diagonal)
     *
     * @param {mat4} mat mat4 to transpose
     * @param {mat4} [dest] mat4 receiving transposed values. If not specified result is written to mat
     *
     * @param {mat4} dest is specified, mat otherwise
     */
    mat4.transpose = function (mat, dest) {
        // If we are transposing ourselves we can skip a few steps but have to cache some values
        if (!dest || mat === dest) {
            var a01 = mat[1], a02 = mat[2], a03 = mat[3],
                a12 = mat[6], a13 = mat[7],
                a23 = mat[11];

            mat[1] = mat[4];
            mat[2] = mat[8];
            mat[3] = mat[12];
            mat[4] = a01;
            mat[6] = mat[9];
            mat[7] = mat[13];
            mat[8] = a02;
            mat[9] = a12;
            mat[11] = mat[14];
            mat[12] = a03;
            mat[13] = a13;
            mat[14] = a23;
            return mat;
        }

        dest[0] = mat[0];
        dest[1] = mat[4];
        dest[2] = mat[8];
        dest[3] = mat[12];
        dest[4] = mat[1];
        dest[5] = mat[5];
        dest[6] = mat[9];
        dest[7] = mat[13];
        dest[8] = mat[2];
        dest[9] = mat[6];
        dest[10] = mat[10];
        dest[11] = mat[14];
        dest[12] = mat[3];
        dest[13] = mat[7];
        dest[14] = mat[11];
        dest[15] = mat[15];
        return dest;
    };

    /**
     * Calculates the determinant of a mat4
     *
     * @param {mat4} mat mat4 to calculate determinant of
     *
     * @returns {number} determinant of mat
     */
    mat4.determinant = function (mat) {
        // Cache the matrix values (makes for huge speed increases!)
        var a00 = mat[0], a01 = mat[1], a02 = mat[2], a03 = mat[3],
            a10 = mat[4], a11 = mat[5], a12 = mat[6], a13 = mat[7],
            a20 = mat[8], a21 = mat[9], a22 = mat[10], a23 = mat[11],
            a30 = mat[12], a31 = mat[13], a32 = mat[14], a33 = mat[15];

        return (a30 * a21 * a12 * a03 - a20 * a31 * a12 * a03 - a30 * a11 * a22 * a03 + a10 * a31 * a22 * a03 +
                a20 * a11 * a32 * a03 - a10 * a21 * a32 * a03 - a30 * a21 * a02 * a13 + a20 * a31 * a02 * a13 +
                a30 * a01 * a22 * a13 - a00 * a31 * a22 * a13 - a20 * a01 * a32 * a13 + a00 * a21 * a32 * a13 +
                a30 * a11 * a02 * a23 - a10 * a31 * a02 * a23 - a30 * a01 * a12 * a23 + a00 * a31 * a12 * a23 +
                a10 * a01 * a32 * a23 - a00 * a11 * a32 * a23 - a20 * a11 * a02 * a33 + a10 * a21 * a02 * a33 +
                a20 * a01 * a12 * a33 - a00 * a21 * a12 * a33 - a10 * a01 * a22 * a33 + a00 * a11 * a22 * a33);
    };

    /**
     * Calculates the inverse matrix of a mat4
     *
     * @param {mat4} mat mat4 to calculate inverse of
     * @param {mat4} [dest] mat4 receiving inverse matrix. If not specified result is written to mat
     *
     * @param {mat4} dest is specified, mat otherwise, null if matrix cannot be inverted
     */
    mat4.inverse = function (mat, dest) {
        if (!dest) { dest = mat; }

        // Cache the matrix values (makes for huge speed increases!)
        var a00 = mat[0], a01 = mat[1], a02 = mat[2], a03 = mat[3],
            a10 = mat[4], a11 = mat[5], a12 = mat[6], a13 = mat[7],
            a20 = mat[8], a21 = mat[9], a22 = mat[10], a23 = mat[11],
            a30 = mat[12], a31 = mat[13], a32 = mat[14], a33 = mat[15],

            b00 = a00 * a11 - a01 * a10,
            b01 = a00 * a12 - a02 * a10,
            b02 = a00 * a13 - a03 * a10,
            b03 = a01 * a12 - a02 * a11,
            b04 = a01 * a13 - a03 * a11,
            b05 = a02 * a13 - a03 * a12,
            b06 = a20 * a31 - a21 * a30,
            b07 = a20 * a32 - a22 * a30,
            b08 = a20 * a33 - a23 * a30,
            b09 = a21 * a32 - a22 * a31,
            b10 = a21 * a33 - a23 * a31,
            b11 = a22 * a33 - a23 * a32,

            d = (b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06),
            invDet;

            // Calculate the determinant
            if (!d) { return null; }
            invDet = 1 / d;

        dest[0] = (a11 * b11 - a12 * b10 + a13 * b09) * invDet;
        dest[1] = (-a01 * b11 + a02 * b10 - a03 * b09) * invDet;
        dest[2] = (a31 * b05 - a32 * b04 + a33 * b03) * invDet;
        dest[3] = (-a21 * b05 + a22 * b04 - a23 * b03) * invDet;
        dest[4] = (-a10 * b11 + a12 * b08 - a13 * b07) * invDet;
        dest[5] = (a00 * b11 - a02 * b08 + a03 * b07) * invDet;
        dest[6] = (-a30 * b05 + a32 * b02 - a33 * b01) * invDet;
        dest[7] = (a20 * b05 - a22 * b02 + a23 * b01) * invDet;
        dest[8] = (a10 * b10 - a11 * b08 + a13 * b06) * invDet;
        dest[9] = (-a00 * b10 + a01 * b08 - a03 * b06) * invDet;
        dest[10] = (a30 * b04 - a31 * b02 + a33 * b00) * invDet;
        dest[11] = (-a20 * b04 + a21 * b02 - a23 * b00) * invDet;
        dest[12] = (-a10 * b09 + a11 * b07 - a12 * b06) * invDet;
        dest[13] = (a00 * b09 - a01 * b07 + a02 * b06) * invDet;
        dest[14] = (-a30 * b03 + a31 * b01 - a32 * b00) * invDet;
        dest[15] = (a20 * b03 - a21 * b01 + a22 * b00) * invDet;

        return dest;
    };

    /**
     * Copies the upper 3x3 elements of a mat4 into another mat4
     *
     * @param {mat4} mat mat4 containing values to copy
     * @param {mat4} [dest] mat4 receiving copied values
     *
     * @returns {mat4} dest is specified, a new mat4 otherwise
     */
    mat4.toRotationMat = function (mat, dest) {
        if (!dest) { dest = mat4.create(); }

        dest[0] = mat[0];
        dest[1] = mat[1];
        dest[2] = mat[2];
        dest[3] = mat[3];
        dest[4] = mat[4];
        dest[5] = mat[5];
        dest[6] = mat[6];
        dest[7] = mat[7];
        dest[8] = mat[8];
        dest[9] = mat[9];
        dest[10] = mat[10];
        dest[11] = mat[11];
        dest[12] = 0;
        dest[13] = 0;
        dest[14] = 0;
        dest[15] = 1;

        return dest;
    };

    /**
     * Copies the upper 3x3 elements of a mat4 into a mat3
     *
     * @param {mat4} mat mat4 containing values to copy
     * @param {mat3} [dest] mat3 receiving copied values
     *
     * @returns {mat3} dest is specified, a new mat3 otherwise
     */
    mat4.toMat3 = function (mat, dest) {
        if (!dest) { dest = mat3.create(); }

        dest[0] = mat[0];
        dest[1] = mat[1];
        dest[2] = mat[2];
        dest[3] = mat[4];
        dest[4] = mat[5];
        dest[5] = mat[6];
        dest[6] = mat[8];
        dest[7] = mat[9];
        dest[8] = mat[10];

        return dest;
    };

    /**
     * Calculates the inverse of the upper 3x3 elements of a mat4 and copies the result into a mat3
     * The resulting matrix is useful for calculating transformed normals
     *
     * Params:
     * @param {mat4} mat mat4 containing values to invert and copy
     * @param {mat3} [dest] mat3 receiving values
     *
     * @returns {mat3} dest is specified, a new mat3 otherwise, null if the matrix cannot be inverted
     */
 /*   mat4.toInverseMat3 = function (mat, dest) {
        // Cache the matrix values (makes for huge speed increases!)
        var a00 = mat[0], a01 = mat[1], a02 = mat[2],
            a10 = mat[4], a11 = mat[5], a12 = mat[6],
            a20 = mat[8], a21 = mat[9], a22 = mat[10],

            b01 = a22 * a11 - a12 * a21,
            b11 = -a22 * a10 + a12 * a20,
            b21 = a21 * a10 - a11 * a20,

            d = a00 * b01 + a01 * b11 + a02 * b21,
            id;

        if (!d) { return null; }
        id = 1 / d;

        if (!dest) { dest = mat3.create(); }

        dest[0] = b01 * id;
        dest[1] = (-a22 * a01 + a02 * a21) * id;
        dest[2] = (a12 * a01 - a02 * a11) * id;
        dest[3] = b11 * id;
        dest[4] = (a22 * a00 - a02 * a20) * id;
        dest[5] = (-a12 * a00 + a02 * a10) * id;
        dest[6] = b21 * id;
        dest[7] = (-a21 * a00 + a01 * a20) * id;
        dest[8] = (a11 * a00 - a01 * a10) * id;

        return dest;
    };*/

    /**
     * Performs a matrix multiplication
     *
     * @param {mat4} mat First operand
     * @param {mat4} mat2 Second operand
     * @param {mat4} [dest] mat4 receiving operation result. If not specified result is written to mat
     *
     * @returns {mat4} dest if specified, mat otherwise
     */
    mat4.multiply = function (mat, mat2, dest) {
        if (!dest) { dest = mat; }

        // Cache the matrix values (makes for huge speed increases!)
        var a00 = mat[ 0], a01 = mat[ 1], a02 = mat[ 2], a03 = mat[3];
        var a10 = mat[ 4], a11 = mat[ 5], a12 = mat[ 6], a13 = mat[7];
        var a20 = mat[ 8], a21 = mat[ 9], a22 = mat[10], a23 = mat[11];
        var a30 = mat[12], a31 = mat[13], a32 = mat[14], a33 = mat[15];

        // Cache only the current line of the second matrix
        var b0  = mat2[0], b1 = mat2[1], b2 = mat2[2], b3 = mat2[3];  
        dest[0] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
        dest[1] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
        dest[2] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
        dest[3] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

        b0 = mat2[4];
        b1 = mat2[5];
        b2 = mat2[6];
        b3 = mat2[7];
        dest[4] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
        dest[5] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
        dest[6] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
        dest[7] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

        b0 = mat2[8];
        b1 = mat2[9];
        b2 = mat2[10];
        b3 = mat2[11];
        dest[8] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
        dest[9] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
        dest[10] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
        dest[11] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

        b0 = mat2[12];
        b1 = mat2[13];
        b2 = mat2[14];
        b3 = mat2[15];
        dest[12] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
        dest[13] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
        dest[14] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
        dest[15] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

        return dest;
    };

    /**
     * Transforms a vec3 with the given matrix
     * 4th vector component is implicitly '1'
     *
     * @param {mat4} mat mat4 to transform the vector with
     * @param {vec3} vec vec3 to transform
     * @param {vec3} [dest] vec3 receiving operation result. If not specified result is written to vec
     *
     * @returns {vec3} dest if specified, vec otherwise
     */
    mat4.multiplyVec3 = function (mat, vec, dest) {
        if (!dest) { dest = vec; }

        var x = vec[0], y = vec[1], z = vec[2];

        dest[0] = mat[0] * x + mat[4] * y + mat[8] * z + mat[12];
        dest[1] = mat[1] * x + mat[5] * y + mat[9] * z + mat[13];
        dest[2] = mat[2] * x + mat[6] * y + mat[10] * z + mat[14];

        return dest;
    };

    /**
     * Transforms a vec4 with the given matrix
     *
     * @param {mat4} mat mat4 to transform the vector with
     * @param {vec4} vec vec4 to transform
     * @param {vec4} [dest] vec4 receiving operation result. If not specified result is written to vec
     *
     * @returns {vec4} dest if specified, vec otherwise
     */
    mat4.multiplyVec4 = function (mat, vec, dest) {
        if (!dest) { dest = vec; }

        var x = vec[0], y = vec[1], z = vec[2], w = vec[3];

        dest[0] = mat[0] * x + mat[4] * y + mat[8] * z + mat[12] * w;
        dest[1] = mat[1] * x + mat[5] * y + mat[9] * z + mat[13] * w;
        dest[2] = mat[2] * x + mat[6] * y + mat[10] * z + mat[14] * w;
        dest[3] = mat[3] * x + mat[7] * y + mat[11] * z + mat[15] * w;

        return dest;
    };

	/**
	  Project a vec3
	*/
	mat4.project = function(mat, vec, dest)
	{
		if(!dest) { dest = vec }
		mat4.multiplyVec4( mat, vec, dest );
		var iw = 1.0 / dest[3];
		dest[0] *= iw;
		dest[1] *= iw;
		dest[2] *= iw;
		return dest;
	}

	/**
	 * mat4.rotateVec3
	 * Rotate a vec3 with the given matrix
	 *
	 * Params:
	 * mat - mat4 to transform the vector with
	 * vec - vec3 to transform
	 * dest - Optional, vec3 receiving operation result. If not specified result is written to vec
	 *
	 * Returns:
	 * dest if specified, vec otherwise
	 */
	mat4.rotateVec3 = function(mat, vec, dest) {
		if(!dest) { dest = vec }
		
		var x = vec[0], y = vec[1], z = vec[2];
		
		dest[0] = mat[0]*x + mat[4]*y + mat[8]*z;
		dest[1] = mat[1]*x + mat[5]*y + mat[9]*z;
		dest[2] = mat[2]*x + mat[6]*y + mat[10]*z;
		
		return dest;
	};
	
    /**
     * Translates a matrix by the given vector
     *
     * @param {mat4} mat mat4 to translate
     * @param {vec3} vec vec3 specifying the translation
     * @param {mat4} [dest] mat4 receiving operation result. If not specified result is written to mat
     *
     * @returns {mat4} dest if specified, mat otherwise
     */
    mat4.translate = function (mat, vec, dest) {
        var x = vec[0], y = vec[1], z = vec[2],
            a00, a01, a02, a03,
            a10, a11, a12, a13,
            a20, a21, a22, a23;

        if (!dest || mat === dest) {
            mat[12] = mat[0] * x + mat[4] * y + mat[8] * z + mat[12];
            mat[13] = mat[1] * x + mat[5] * y + mat[9] * z + mat[13];
            mat[14] = mat[2] * x + mat[6] * y + mat[10] * z + mat[14];
            mat[15] = mat[3] * x + mat[7] * y + mat[11] * z + mat[15];
            return mat;
        }

        a00 = mat[0]; a01 = mat[1]; a02 = mat[2]; a03 = mat[3];
        a10 = mat[4]; a11 = mat[5]; a12 = mat[6]; a13 = mat[7];
        a20 = mat[8]; a21 = mat[9]; a22 = mat[10]; a23 = mat[11];

        dest[0] = a00; dest[1] = a01; dest[2] = a02; dest[3] = a03;
        dest[4] = a10; dest[5] = a11; dest[6] = a12; dest[7] = a13;
        dest[8] = a20; dest[9] = a21; dest[10] = a22; dest[11] = a23;

        dest[12] = a00 * x + a10 * y + a20 * z + mat[12];
        dest[13] = a01 * x + a11 * y + a21 * z + mat[13];
        dest[14] = a02 * x + a12 * y + a22 * z + mat[14];
        dest[15] = a03 * x + a13 * y + a23 * z + mat[15];
        return dest;
    };

    /**
     * Scales a matrix by the given vector
     *
     * @param {mat4} mat mat4 to scale
     * @param {vec3} vec vec3 specifying the scale for each axis
     * @param {mat4} [dest] mat4 receiving operation result. If not specified result is written to mat
     *
     * @param {mat4} dest if specified, mat otherwise
     */
    mat4.scale = function (mat, vec, dest) {
        var x = vec[0], y = vec[1], z = vec[2];

        if (!dest || mat === dest) {
            mat[0] *= x;
            mat[1] *= x;
            mat[2] *= x;
            mat[3] *= x;
            mat[4] *= y;
            mat[5] *= y;
            mat[6] *= y;
            mat[7] *= y;
            mat[8] *= z;
            mat[9] *= z;
            mat[10] *= z;
            mat[11] *= z;
            return mat;
        }

        dest[0] = mat[0] * x;
        dest[1] = mat[1] * x;
        dest[2] = mat[2] * x;
        dest[3] = mat[3] * x;
        dest[4] = mat[4] * y;
        dest[5] = mat[5] * y;
        dest[6] = mat[6] * y;
        dest[7] = mat[7] * y;
        dest[8] = mat[8] * z;
        dest[9] = mat[9] * z;
        dest[10] = mat[10] * z;
        dest[11] = mat[11] * z;
        dest[12] = mat[12];
        dest[13] = mat[13];
        dest[14] = mat[14];
        dest[15] = mat[15];
        return dest;
    };

    /**
     * Rotates a matrix by the given angle around the specified axis
     * If rotating around a primary axis (X,Y,Z) one of the specialized rotation functions should be used instead for performance
     *
     * @param {mat4} mat mat4 to rotate
     * @param {number} angle Angle (in radians) to rotate
     * @param {vec3} axis vec3 representing the axis to rotate around
     * @param {mat4} [dest] mat4 receiving operation result. If not specified result is written to mat
     *
     * @returns {mat4} dest if specified, mat otherwise
     */
    mat4.rotate = function (mat, angle, axis, dest) {
        var x = axis[0], y = axis[1], z = axis[2],
            len = Math.sqrt(x * x + y * y + z * z),
            s, c, t,
            a00, a01, a02, a03,
            a10, a11, a12, a13,
            a20, a21, a22, a23,
            b00, b01, b02,
            b10, b11, b12,
            b20, b21, b22;

        if (!len) { return null; }
        if (len !== 1) {
            len = 1 / len;
            x *= len;
            y *= len;
            z *= len;
        }

        s = Math.sin(angle);
        c = Math.cos(angle);
        t = 1 - c;

        a00 = mat[0]; a01 = mat[1]; a02 = mat[2]; a03 = mat[3];
        a10 = mat[4]; a11 = mat[5]; a12 = mat[6]; a13 = mat[7];
        a20 = mat[8]; a21 = mat[9]; a22 = mat[10]; a23 = mat[11];

        // Construct the elements of the rotation matrix
        b00 = x * x * t + c; b01 = y * x * t + z * s; b02 = z * x * t - y * s;
        b10 = x * y * t - z * s; b11 = y * y * t + c; b12 = z * y * t + x * s;
        b20 = x * z * t + y * s; b21 = y * z * t - x * s; b22 = z * z * t + c;

        if (!dest) {
            dest = mat;
        } else if (mat !== dest) { // If the source and destination differ, copy the unchanged last row
            dest[12] = mat[12];
            dest[13] = mat[13];
            dest[14] = mat[14];
            dest[15] = mat[15];
        }

        // Perform rotation-specific matrix multiplication
        dest[0] = a00 * b00 + a10 * b01 + a20 * b02;
        dest[1] = a01 * b00 + a11 * b01 + a21 * b02;
        dest[2] = a02 * b00 + a12 * b01 + a22 * b02;
        dest[3] = a03 * b00 + a13 * b01 + a23 * b02;

        dest[4] = a00 * b10 + a10 * b11 + a20 * b12;
        dest[5] = a01 * b10 + a11 * b11 + a21 * b12;
        dest[6] = a02 * b10 + a12 * b11 + a22 * b12;
        dest[7] = a03 * b10 + a13 * b11 + a23 * b12;

        dest[8] = a00 * b20 + a10 * b21 + a20 * b22;
        dest[9] = a01 * b20 + a11 * b21 + a21 * b22;
        dest[10] = a02 * b20 + a12 * b21 + a22 * b22;
        dest[11] = a03 * b20 + a13 * b21 + a23 * b22;
        return dest;
    };

    /**
     * Rotates a matrix by the given angle around the X axis
     *
     * @param {mat4} mat mat4 to rotate
     * @param {number} angle Angle (in radians) to rotate
     * @param {mat4} [dest] mat4 receiving operation result. If not specified result is written to mat
     *
     * @returns {mat4} dest if specified, mat otherwise
     */
    mat4.rotateX = function (mat, angle, dest) {
        var s = Math.sin(angle),
            c = Math.cos(angle),
            a10 = mat[4],
            a11 = mat[5],
            a12 = mat[6],
            a13 = mat[7],
            a20 = mat[8],
            a21 = mat[9],
            a22 = mat[10],
            a23 = mat[11];

        if (!dest) {
            dest = mat;
        } else if (mat !== dest) { // If the source and destination differ, copy the unchanged rows
            dest[0] = mat[0];
            dest[1] = mat[1];
            dest[2] = mat[2];
            dest[3] = mat[3];

            dest[12] = mat[12];
            dest[13] = mat[13];
            dest[14] = mat[14];
            dest[15] = mat[15];
        }

        // Perform axis-specific matrix multiplication
        dest[4] = a10 * c + a20 * s;
        dest[5] = a11 * c + a21 * s;
        dest[6] = a12 * c + a22 * s;
        dest[7] = a13 * c + a23 * s;

        dest[8] = a10 * -s + a20 * c;
        dest[9] = a11 * -s + a21 * c;
        dest[10] = a12 * -s + a22 * c;
        dest[11] = a13 * -s + a23 * c;
        return dest;
    };

    /**
     * Rotates a matrix by the given angle around the Y axis
     *
     * @param {mat4} mat mat4 to rotate
     * @param {number} angle Angle (in radians) to rotate
     * @param {mat4} [dest] mat4 receiving operation result. If not specified result is written to mat
     *
     * @returns {mat4} dest if specified, mat otherwise
     */
    mat4.rotateY = function (mat, angle, dest) {
        var s = Math.sin(angle),
            c = Math.cos(angle),
            a00 = mat[0],
            a01 = mat[1],
            a02 = mat[2],
            a03 = mat[3],
            a20 = mat[8],
            a21 = mat[9],
            a22 = mat[10],
            a23 = mat[11];

        if (!dest) {
            dest = mat;
        } else if (mat !== dest) { // If the source and destination differ, copy the unchanged rows
            dest[4] = mat[4];
            dest[5] = mat[5];
            dest[6] = mat[6];
            dest[7] = mat[7];

            dest[12] = mat[12];
            dest[13] = mat[13];
            dest[14] = mat[14];
            dest[15] = mat[15];
        }

        // Perform axis-specific matrix multiplication
        dest[0] = a00 * c + a20 * -s;
        dest[1] = a01 * c + a21 * -s;
        dest[2] = a02 * c + a22 * -s;
        dest[3] = a03 * c + a23 * -s;

        dest[8] = a00 * s + a20 * c;
        dest[9] = a01 * s + a21 * c;
        dest[10] = a02 * s + a22 * c;
        dest[11] = a03 * s + a23 * c;
        return dest;
    };

    /**
     * Rotates a matrix by the given angle around the Z axis
     *
     * @param {mat4} mat mat4 to rotate
     * @param {number} angle Angle (in radians) to rotate
     * @param {mat4} [dest] mat4 receiving operation result. If not specified result is written to mat
     *
     * @returns {mat4} dest if specified, mat otherwise
     */
    mat4.rotateZ = function (mat, angle, dest) {
        var s = Math.sin(angle),
            c = Math.cos(angle),
            a00 = mat[0],
            a01 = mat[1],
            a02 = mat[2],
            a03 = mat[3],
            a10 = mat[4],
            a11 = mat[5],
            a12 = mat[6],
            a13 = mat[7];

        if (!dest) {
            dest = mat;
        } else if (mat !== dest) { // If the source and destination differ, copy the unchanged last row
            dest[8] = mat[8];
            dest[9] = mat[9];
            dest[10] = mat[10];
            dest[11] = mat[11];

            dest[12] = mat[12];
            dest[13] = mat[13];
            dest[14] = mat[14];
            dest[15] = mat[15];
        }

        // Perform axis-specific matrix multiplication
        dest[0] = a00 * c + a10 * s;
        dest[1] = a01 * c + a11 * s;
        dest[2] = a02 * c + a12 * s;
        dest[3] = a03 * c + a13 * s;

        dest[4] = a00 * -s + a10 * c;
        dest[5] = a01 * -s + a11 * c;
        dest[6] = a02 * -s + a12 * c;
        dest[7] = a03 * -s + a13 * c;

        return dest;
    };

    /**
     * Generates a frustum matrix with the given bounds
     *
     * @param {number} left Left bound of the frustum
     * @param {number} right Right bound of the frustum
     * @param {number} bottom Bottom bound of the frustum
     * @param {number} top Top bound of the frustum
     * @param {number} near Near bound of the frustum
     * @param {number} far Far bound of the frustum
     * @param {mat4} [dest] mat4 frustum matrix will be written into
     *
     * @returns {mat4} dest if specified, a new mat4 otherwise
     */
    mat4.frustum = function (left, right, bottom, top, near, far, dest) {
        if (!dest) { dest = mat4.create(); }
        var rl = (right - left),
            tb = (top - bottom),
            fn = (far - near);
        dest[0] = (near * 2) / rl;
        dest[1] = 0;
        dest[2] = 0;
        dest[3] = 0;
        dest[4] = 0;
        dest[5] = (near * 2) / tb;
        dest[6] = 0;
        dest[7] = 0;
        dest[8] = (right + left) / rl;
        dest[9] = (top + bottom) / tb;
        dest[10] = -(far + near) / fn;
        dest[11] = -1;
        dest[12] = 0;
        dest[13] = 0;
        dest[14] = -(far * near * 2) / fn;
        dest[15] = 0;
        return dest;
    };

    /**
     * Generates a perspective projection matrix with the given bounds
     *
     * @param {number} fovy Vertical field of view
     * @param {number} aspect Aspect ratio. typically viewport width/height
     * @param {number} near Near bound of the frustum
     * @param {number} far Far bound of the frustum
     * @param {mat4} [dest] mat4 frustum matrix will be written into
     *
     * @returns {mat4} dest if specified, a new mat4 otherwise
     */
    mat4.perspective = function (fovy, aspect, near, far, dest) {
        var top = near * Math.tan(fovy * Math.PI / 360.0),
            right = top * aspect;
        return mat4.frustum(-right, right, -top, top, near, far, dest);
    };

    /**
     * Generates a orthogonal projection matrix with the given bounds
     *
     * @param {number} left Left bound of the frustum
     * @param {number} right Right bound of the frustum
     * @param {number} bottom Bottom bound of the frustum
     * @param {number} top Top bound of the frustum
     * @param {number} near Near bound of the frustum
     * @param {number} far Far bound of the frustum
     * @param {mat4} [dest] mat4 frustum matrix will be written into
     *
     * @returns {mat4} dest if specified, a new mat4 otherwise
     */
    mat4.ortho = function (left, right, bottom, top, near, far, dest) {
        if (!dest) { dest = mat4.create(); }
        var rl = (right - left),
            tb = (top - bottom),
            fn = (far - near);
        dest[0] = 2 / rl;
        dest[1] = 0;
        dest[2] = 0;
        dest[3] = 0;
        dest[4] = 0;
        dest[5] = 2 / tb;
        dest[6] = 0;
        dest[7] = 0;
        dest[8] = 0;
        dest[9] = 0;
        dest[10] = -2 / fn;
        dest[11] = 0;
        dest[12] = -(left + right) / rl;
        dest[13] = -(top + bottom) / tb;
        dest[14] = -(far + near) / fn;
        dest[15] = 1;
        return dest;
    };

    /**
     * Generates a look-at matrix with the given eye position, focal point, and up axis
     *
     * @param {vec3} eye Position of the viewer
     * @param {vec3} center Point the viewer is looking at
     * @param {vec3} up vec3 pointing "up"
     * @param {mat4} [dest] mat4 frustum matrix will be written into
     *
     * @returns {mat4} dest if specified, a new mat4 otherwise
     */
    mat4.lookAt = function (eye, center, up, dest) {
        if (!dest) { dest = mat4.create(); }

        var x0, x1, x2, y0, y1, y2, z0, z1, z2, len,
            eyex = eye[0],
            eyey = eye[1],
            eyez = eye[2],
            upx = up[0],
            upy = up[1],
            upz = up[2],
            centerx = center[0],
            centery = center[1],
            centerz = center[2];

        if (eyex === centerx && eyey === centery && eyez === centerz) {
            return mat4.identity(dest);
        }

        //vec3.direction(eye, center, z);
        z0 = eyex - centerx;
        z1 = eyey - centery;
        z2 = eyez - centerz;

        // normalize (no check needed for 0 because of early return)
        len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
        z0 *= len;
        z1 *= len;
        z2 *= len;

        //vec3.normalize(vec3.cross(up, z, x));
        x0 = upy * z2 - upz * z1;
        x1 = upz * z0 - upx * z2;
        x2 = upx * z1 - upy * z0;
        len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
        if (!len) {
            x0 = 0;
            x1 = 0;
            x2 = 0;
        } else {
            len = 1 / len;
            x0 *= len;
            x1 *= len;
            x2 *= len;
        }

        //vec3.normalize(vec3.cross(z, x, y));
        y0 = z1 * x2 - z2 * x1;
        y1 = z2 * x0 - z0 * x2;
        y2 = z0 * x1 - z1 * x0;

        len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);
        if (!len) {
            y0 = 0;
            y1 = 0;
            y2 = 0;
        } else {
            len = 1 / len;
            y0 *= len;
            y1 *= len;
            y2 *= len;
        }

        dest[0] = x0;
        dest[1] = y0;
        dest[2] = z0;
        dest[3] = 0;
        dest[4] = x1;
        dest[5] = y1;
        dest[6] = z1;
        dest[7] = 0;
        dest[8] = x2;
        dest[9] = y2;
        dest[10] = z2;
        dest[11] = 0;
        dest[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
        dest[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
        dest[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
        dest[15] = 1;

        return dest;
    };

    /**
     * Creates a matrix from a quaternion rotation and vector translation
     * This is equivalent to (but much faster than):
     *
     *     mat4.identity(dest);
     *     mat4.translate(dest, vec);
     *     var quatMat = mat4.create();
     *     quat4.toMat4(quat, quatMat);
     *     mat4.multiply(dest, quatMat);
     *
     * @param {quat4} quat Rotation quaternion
     * @param {vec3} vec Translation vector
     * @param {mat4} [dest] mat4 receiving operation result. If not specified result is written to a new mat4
     *
     * @returns {mat4} dest if specified, a new mat4 otherwise
     */
/*    mat4.fromRotationTranslation = function (quat, vec, dest) {
        if (!dest) { dest = mat4.create(); }

        // Quaternion math
        var x = quat[0], y = quat[1], z = quat[2], w = quat[3],
            x2 = x + x,
            y2 = y + y,
            z2 = z + z,

            xx = x * x2,
            xy = x * y2,
            xz = x * z2,
            yy = y * y2,
            yz = y * z2,
            zz = z * z2,
            wx = w * x2,
            wy = w * y2,
            wz = w * z2;

        dest[0] = 1 - (yy + zz);
        dest[1] = xy + wz;
        dest[2] = xz - wy;
        dest[3] = 0;
        dest[4] = xy - wz;
        dest[5] = 1 - (xx + zz);
        dest[6] = yz + wx;
        dest[7] = 0;
        dest[8] = xz + wy;
        dest[9] = yz - wx;
        dest[10] = 1 - (xx + yy);
        dest[11] = 0;
        dest[12] = vec[0];
        dest[13] = vec[1];
        dest[14] = vec[2];
        dest[15] = 1;
        
        return dest;
    };*/

    /**
     * Returns a string representation of a mat4
     *
     * @param {mat4} mat mat4 to represent as a string
     *
     * @returns {string} String representation of mat
     */
    mat4.str = function (mat) {
        return '[' + mat[0] + ', ' + mat[1] + ', ' + mat[2] + ', ' + mat[3] +
            ', ' + mat[4] + ', ' + mat[5] + ', ' + mat[6] + ', ' + mat[7] +
            ', ' + mat[8] + ', ' + mat[9] + ', ' + mat[10] + ', ' + mat[11] +
            ', ' + mat[12] + ', ' + mat[13] + ', ' + mat[14] + ', ' + mat[15] + ']';
    };

    /**
     * @class Quaternion
     * @name quat4
     */
    var quat4 = {};

    /**
     * Creates a new instance of a quat4 using the default array type
     * Any javascript array containing at least 4 numeric elements can serve as a quat4
     *
     * @param {quat4} [quat] quat4 containing values to initialize with
     *
     * @returns {quat4} New quat4
     */
    quat4.create = function (quat) {
        var dest = new MatrixArray(4);

        if (quat) {
            dest[0] = quat[0];
            dest[1] = quat[1];
            dest[2] = quat[2];
            dest[3] = quat[3];
        } else {
            dest[0] = dest[1] = dest[2] = dest[3] = 0;
        }

        return dest;
    };

    /**
     * Creates a new instance of a quat4, initializing it with the given arguments
     *
     * @param {number} x X value
     * @param {number} y Y value
     * @param {number} z Z value
     * @param {number} w W value

     * @returns {quat4} New quat4
     */
    quat4.createFrom = function (x, y, z, w) {
        var dest = new MatrixArray(4);

        dest[0] = x;
        dest[1] = y;
        dest[2] = z;
        dest[3] = w;

        return dest;
    };

    /**
     * Copies the values of one quat4 to another
     *
     * @param {quat4} quat quat4 containing values to copy
     * @param {quat4} dest quat4 receiving copied values
     *
     * @returns {quat4} dest
     */
    quat4.set = function (quat, dest) {
        dest[0] = quat[0];
        dest[1] = quat[1];
        dest[2] = quat[2];
        dest[3] = quat[3];

        return dest;
    };

    /**
     * Compares two quaternions for equality within a certain margin of error
     *
     * @param {quat4} a First vector
     * @param {quat4} b Second vector
     *
     * @returns {Boolean} True if a is equivalent to b
     */
    quat4.equal = function (a, b) {
        return a === b || (
            Math.abs(a[0] - b[0]) < FLOAT_EPSILON &&
            Math.abs(a[1] - b[1]) < FLOAT_EPSILON &&
            Math.abs(a[2] - b[2]) < FLOAT_EPSILON &&
            Math.abs(a[3] - b[3]) < FLOAT_EPSILON
        );
    };

    /**
     * Creates a new identity Quat4
     *
     * @param {quat4} [dest] quat4 receiving copied values
     *
     * @returns {quat4} dest is specified, new quat4 otherwise
     */
    quat4.identity = function (dest) {
        if (!dest) { dest = quat4.create(); }
        dest[0] = 0;
        dest[1] = 0;
        dest[2] = 0;
        dest[3] = 1;
        return dest;
    };

    //var identityQuat4 = quat4.identity();

    /**
     * Calculates the W component of a quat4 from the X, Y, and Z components.
     * Assumes that quaternion is 1 unit in length.
     * Any existing W component will be ignored.
     *
     * @param {quat4} quat quat4 to calculate W component of
     * @param {quat4} [dest] quat4 receiving calculated values. If not specified result is written to quat
     *
     * @returns {quat4} dest if specified, quat otherwise
     */
    quat4.calculateW = function (quat, dest) {
        var x = quat[0], y = quat[1], z = quat[2];

        if (!dest || quat === dest) {
            quat[3] = -Math.sqrt(Math.abs(1.0 - x * x - y * y - z * z));
            return quat;
        }
        dest[0] = x;
        dest[1] = y;
        dest[2] = z;
        dest[3] = -Math.sqrt(Math.abs(1.0 - x * x - y * y - z * z));
        return dest;
    };

    /**
     * Calculates the dot product of two quaternions
     *
     * @param {quat4} quat First operand
     * @param {quat4} quat2 Second operand
     *
     * @return {number} Dot product of quat and quat2
     */
    quat4.dot = function(quat, quat2){
        return quat[0]*quat2[0] + quat[1]*quat2[1] + quat[2]*quat2[2] + quat[3]*quat2[3];
    };

    /**
     * Calculates the inverse of a quat4
     *
     * @param {quat4} quat quat4 to calculate inverse of
     * @param {quat4} [dest] quat4 receiving inverse values. If not specified result is written to quat
     *
     * @returns {quat4} dest if specified, quat otherwise
     */
    quat4.inverse = function(quat, dest) {
        var q0 = quat[0], q1 = quat[1], q2 = quat[2], q3 = quat[3],
            dot = q0*q0 + q1*q1 + q2*q2 + q3*q3,
            invDot = dot ? 1.0/dot : 0;
        
        // TODO: Would be faster to return [0,0,0,0] immediately if dot == 0
        
        if(!dest || quat === dest) {
            quat[0] *= -invDot;
            quat[1] *= -invDot;
            quat[2] *= -invDot;
            quat[3] *= invDot;
            return quat;
        }
        dest[0] = -quat[0]*invDot;
        dest[1] = -quat[1]*invDot;
        dest[2] = -quat[2]*invDot;
        dest[3] = quat[3]*invDot;
        return dest;
    };


    /**
     * Calculates the conjugate of a quat4
     * If the quaternion is normalized, this function is faster than quat4.inverse and produces the same result.
     *
     * @param {quat4} quat quat4 to calculate conjugate of
     * @param {quat4} [dest] quat4 receiving conjugate values. If not specified result is written to quat
     *
     * @returns {quat4} dest if specified, quat otherwise
     */
    quat4.conjugate = function (quat, dest) {
        if (!dest || quat === dest) {
            quat[0] *= -1;
            quat[1] *= -1;
            quat[2] *= -1;
            return quat;
        }
        dest[0] = -quat[0];
        dest[1] = -quat[1];
        dest[2] = -quat[2];
        dest[3] = quat[3];
        return dest;
    };

    /**
     * Calculates the length of a quat4
     *
     * Params:
     * @param {quat4} quat quat4 to calculate length of
     *
     * @returns Length of quat
     */
    quat4.length = function (quat) {
        var x = quat[0], y = quat[1], z = quat[2], w = quat[3];
        return Math.sqrt(x * x + y * y + z * z + w * w);
    };

    /**
     * Generates a unit quaternion of the same direction as the provided quat4
     * If quaternion length is 0, returns [0, 0, 0, 0]
     *
     * @param {quat4} quat quat4 to normalize
     * @param {quat4} [dest] quat4 receiving operation result. If not specified result is written to quat
     *
     * @returns {quat4} dest if specified, quat otherwise
     */
    quat4.normalize = function (quat, dest) {
        if (!dest) { dest = quat; }

        var x = quat[0], y = quat[1], z = quat[2], w = quat[3],
            len = Math.sqrt(x * x + y * y + z * z + w * w);
        if (len === 0) {
            dest[0] = 0;
            dest[1] = 0;
            dest[2] = 0;
            dest[3] = 0;
            return dest;
        }
        len = 1 / len;
        dest[0] = x * len;
        dest[1] = y * len;
        dest[2] = z * len;
        dest[3] = w * len;

        return dest;
    };

    /**
     * Performs quaternion addition
     *
     * @param {quat4} quat First operand
     * @param {quat4} quat2 Second operand
     * @param {quat4} [dest] quat4 receiving operation result. If not specified result is written to quat
     *
     * @returns {quat4} dest if specified, quat otherwise
     */
    quat4.add = function (quat, quat2, dest) {
        if(!dest || quat === dest) {
            quat[0] += quat2[0];
            quat[1] += quat2[1];
            quat[2] += quat2[2];
            quat[3] += quat2[3];
            return quat;
        }
        dest[0] = quat[0]+quat2[0];
        dest[1] = quat[1]+quat2[1];
        dest[2] = quat[2]+quat2[2];
        dest[3] = quat[3]+quat2[3];
        return dest;
    };

    /**
     * Performs a quaternion multiplication
     *
     * @param {quat4} quat First operand
     * @param {quat4} quat2 Second operand
     * @param {quat4} [dest] quat4 receiving operation result. If not specified result is written to quat
     *
     * @returns {quat4} dest if specified, quat otherwise
     */
    quat4.multiply = function (quat, quat2, dest) {
        if (!dest) { dest = quat; }

        var qax = quat[0], qay = quat[1], qaz = quat[2], qaw = quat[3],
            qbx = quat2[0], qby = quat2[1], qbz = quat2[2], qbw = quat2[3];

        dest[0] = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
        dest[1] = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
        dest[2] = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
        dest[3] = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;

        return dest;
    };

    /**
     * Transforms a vec3 with the given quaternion
     *
     * @param {quat4} quat quat4 to transform the vector with
     * @param {vec3} vec vec3 to transform
     * @param {vec3} [dest] vec3 receiving operation result. If not specified result is written to vec
     *
     * @returns dest if specified, vec otherwise
     */
    quat4.multiplyVec3 = function (quat, vec, dest) {
        if (!dest) { dest = vec; }

        var x = vec[0], y = vec[1], z = vec[2],
            qx = quat[0], qy = quat[1], qz = quat[2], qw = quat[3],

            // calculate quat * vec
            ix = qw * x + qy * z - qz * y,
            iy = qw * y + qz * x - qx * z,
            iz = qw * z + qx * y - qy * x,
            iw = -qx * x - qy * y - qz * z;

        // calculate result * inverse quat
        dest[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
        dest[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
        dest[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;

        return dest;
    };

    /**
     * Multiplies the components of a quaternion by a scalar value
     *
     * @param {quat4} quat to scale
     * @param {number} val Value to scale by
     * @param {quat4} [dest] quat4 receiving operation result. If not specified result is written to quat
     *
     * @returns {quat4} dest if specified, quat otherwise
     */
    quat4.scale = function (quat, val, dest) {
        if(!dest || quat === dest) {
            quat[0] *= val;
            quat[1] *= val;
            quat[2] *= val;
            quat[3] *= val;
            return quat;
        }
        dest[0] = quat[0]*val;
        dest[1] = quat[1]*val;
        dest[2] = quat[2]*val;
        dest[3] = quat[3]*val;
        return dest;
    };

    /**
     * Calculates a 4x4 matrix from the given quat4
     *
     * @param {quat4} quat quat4 to create matrix from
     * @param {mat4} [dest] mat4 receiving operation result
     *
     * @returns {mat4} dest if specified, a new mat4 otherwise
     */
    quat4.toMat4 = function (quat, dest) {
        if (!dest) { dest = mat4.create(); }

        var x = quat[0], y = quat[1], z = quat[2], w = quat[3],
            x2 = x + x,
            y2 = y + y,
            z2 = z + z,

            xx = x * x2,
            xy = x * y2,
            xz = x * z2,
            yy = y * y2,
            yz = y * z2,
            zz = z * z2,
            wx = w * x2,
            wy = w * y2,
            wz = w * z2;

        dest[0] = 1 - (yy + zz);
        dest[1] = xy + wz;
        dest[2] = xz - wy;
        dest[3] = 0;

        dest[4] = xy - wz;
        dest[5] = 1 - (xx + zz);
        dest[6] = yz + wx;
        dest[7] = 0;

        dest[8] = xz + wy;
        dest[9] = yz - wx;
        dest[10] = 1 - (xx + yy);
        dest[11] = 0;

        dest[12] = 0;
        dest[13] = 0;
        dest[14] = 0;
        dest[15] = 1;

        return dest;
    };

    /**
     * Performs a spherical linear interpolation between two quat4
     *
     * @param {quat4} quat First quaternion
     * @param {quat4} quat2 Second quaternion
     * @param {number} slerp Interpolation amount between the two inputs
     * @param {quat4} [dest] quat4 receiving operation result. If not specified result is written to quat
     *
     * @returns {quat4} dest if specified, quat otherwise
     */
    quat4.slerp = function (quat, quat2, slerp, dest) {
        if (!dest) { dest = quat; }

        var cosHalfTheta = quat[0] * quat2[0] + quat[1] * quat2[1] + quat[2] * quat2[2] + quat[3] * quat2[3],
            halfTheta,
            sinHalfTheta,
            ratioA,
            ratioB;

        if (Math.abs(cosHalfTheta) >= 1.0) {
            if (dest !== quat) {
                dest[0] = quat[0];
                dest[1] = quat[1];
                dest[2] = quat[2];
                dest[3] = quat[3];
            }
            return dest;
        }

        halfTheta = Math.acos(cosHalfTheta);
        sinHalfTheta = Math.sqrt(1.0 - cosHalfTheta * cosHalfTheta);

        if (Math.abs(sinHalfTheta) < 0.001) {
            dest[0] = (quat[0] * 0.5 + quat2[0] * 0.5);
            dest[1] = (quat[1] * 0.5 + quat2[1] * 0.5);
            dest[2] = (quat[2] * 0.5 + quat2[2] * 0.5);
            dest[3] = (quat[3] * 0.5 + quat2[3] * 0.5);
            return dest;
        }

        ratioA = Math.sin((1 - slerp) * halfTheta) / sinHalfTheta;
        ratioB = Math.sin(slerp * halfTheta) / sinHalfTheta;

        dest[0] = (quat[0] * ratioA + quat2[0] * ratioB);
        dest[1] = (quat[1] * ratioA + quat2[1] * ratioB);
        dest[2] = (quat[2] * ratioA + quat2[2] * ratioB);
        dest[3] = (quat[3] * ratioA + quat2[3] * ratioB);

        return dest;
    };

    /**
     * Creates a quaternion from the given 3x3 rotation matrix.
     * If dest is omitted, a new quaternion will be created.
     *
     * @param {mat3}  mat    the rotation matrix
     * @param {quat4} [dest] an optional receiving quaternion
     *
     * @returns {quat4} the quaternion constructed from the rotation matrix
     *
     */
    quat4.fromRotationMatrix = function(mat, dest) {
        if (!dest) dest = quat4.create();
        
        // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes
        // article "Quaternion Calculus and Fast Animation".

        var fTrace = mat[0] + mat[4] + mat[8];
        var fRoot;

        if ( fTrace > 0.0 ) {
            // |w| > 1/2, may as well choose w > 1/2
            fRoot = Math.sqrt(fTrace + 1.0);  // 2w
            dest[3] = 0.5 * fRoot;
            fRoot = 0.5/fRoot;  // 1/(4w)
            dest[0] = (mat[7]-mat[5])*fRoot;
            dest[1] = (mat[2]-mat[6])*fRoot;
            dest[2] = (mat[3]-mat[1])*fRoot;
        } else {
            // |w| <= 1/2
            var s_iNext = quat4.fromRotationMatrix.s_iNext = quat4.fromRotationMatrix.s_iNext || [1,2,0];
            var i = 0;
            if ( mat[4] > mat[0] )
              i = 1;
            if ( mat[8] > mat[i*3+i] )
              i = 2;
            var j = s_iNext[i];
            var k = s_iNext[j];
            
            fRoot = Math.sqrt(mat[i*3+i]-mat[j*3+j]-mat[k*3+k] + 1.0);
            dest[i] = 0.5 * fRoot;
            fRoot = 0.5 / fRoot;
            dest[3] = (mat[k*3+j] - mat[j*3+k]) * fRoot;
            dest[j] = (mat[j*3+i] + mat[i*3+j]) * fRoot;
            dest[k] = (mat[k*3+i] + mat[i*3+k]) * fRoot;
        }
        
        return dest;
    };

 
    /**
     * Sets a quat4 to the Identity and returns it.
     *
     * @param {quat4} [dest] quat4 to set. If omitted, a
     * new quat4 will be created.
     *
     * @returns {quat4} dest
     */
    quat4.identity = function(dest) {
        if (!dest) dest = quat4.create();
        dest[0] = 0;
        dest[1] = 0;
        dest[2] = 0;
        dest[3] = 1;
        return dest;
    };

    /**
     * Sets a quat4 from the given angle and rotation axis,
     * then returns it. If dest is not given, a new quat4 is created.
     *
     * @param {Number} angle  the angle in radians
     * @param {vec3}   axis   the axis around which to rotate
     * @param {quat4}  [dest] the optional quat4 to store the result
     *
     * @returns {quat4} dest
     **/
    quat4.fromAngleAxis = function(angle, axis, dest) {
        // The quaternion representing the rotation is
        //   q = cos(A/2)+sin(A/2)*(x*i+y*j+z*k)
        if (!dest) dest = quat4.create();
        
        var half = angle * 0.5;
        var s = Math.sin(half);
        dest[3] = Math.cos(half);
        dest[0] = s * axis[0];
        dest[1] = s * axis[1];
        dest[2] = s * axis[2];
        
        return dest;
    };

    /**
     * Stores the angle and axis in a vec4, where the XYZ components represent
     * the axis and the W (4th) component is the angle in radians.
     *
     * If dest is not given, src will be modified in place and returned, after
     * which it should not be considered not a quaternion (just an axis and angle).
     *
     * @param {quat4} quat   the quaternion whose angle and axis to store
     * @param {vec4}  [dest] the optional vec4 to receive the data
     *
     * @returns {vec4} dest
     */
    quat4.toAngleAxis = function(src, dest) {
        if (!dest) dest = src;
        // The quaternion representing the rotation is
        //   q = cos(A/2)+sin(A/2)*(x*i+y*j+z*k)

        var sqrlen = src[0]*src[0]+src[1]*src[1]+src[2]*src[2];
        if (sqrlen > 0)
        {
            dest[3] = 2 * Math.acos(src[3]);
            var invlen = 1.0 / Math.sqrt(sqrlen);
            dest[0] = src[0]*invlen;
            dest[1] = src[1]*invlen;
            dest[2] = src[2]*invlen;
        } else {
            // angle is 0 (mod 2*pi), so any axis will do
            dest[3] = 0;
            dest[0] = 1;
            dest[1] = 0;
            dest[2] = 0;
        }
        
        return dest;
    };

    /**
     * Returns a string representation of a quaternion
     *
     * @param {quat4} quat quat4 to represent as a string
     *
     * @returns {string} String representation of quat
     */
    quat4.str = function (quat) {
        return '[' + quat[0] + ', ' + quat[1] + ', ' + quat[2] + ', ' + quat[3] + ']';
    };
   

    /*
     * Exports
     */

	window.vec3 = vec3;
	window.mat4 = mat4;
	window.quat4 = quat4;
	
	return mat4;

});

/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('gw/EquatorialCoordinateSystem', ['./CoordinateSystem', './Numeric', './AstroCoordTransform', './glMatrix'], function(CoordinateSystem, Numeric, AstroCoordTransform) {

/**************************************************************************************************************/

// Default coordinate system: ("EQ" or "GAL")
CoordinateSystem.type = "EQ";

/**
*	Convert a 3D position to equatorial coordinates
*/
CoordinateSystem.from3DToEquatorial = function(position3d, dest){
	
	if (!dest) { dest = new Array(3); }
	
	var geo = [];

	CoordinateSystem.from3DToGeo(position3d, geo);
	CoordinateSystem.fromGeoToEquatorial(geo, dest);
	
	return dest;
}

/**************************************************************************************************************/

/**
*	Converts an equatorial position to 3D
*/
CoordinateSystem.fromEquatorialTo3D = function(equatorial, dest){
	
	if (!dest) { dest = new Array(3); }

	var geo = [];
	
	CoordinateSystem.fromEquatorialToGeo(equatorial, geo);
	CoordinateSystem.fromGeoTo3D(geo,dest);
	
	return dest;	
}

/**************************************************************************************************************/

/**
*	Convert an equatorial position to geographic
*	@param {String[]} equatorial Array of two strings corresponding to Right Ascension and Declination
*					  specified by: "hours minuts seconds" and "degrees minuts seconds" respectively
*	@param {Float[]} dest Destination array of two floats corresponding to Longitude and Latitude
*/
CoordinateSystem.fromEquatorialToGeo = function(equatorial, dest){
	
	if(!dest) dest = [];
	
	// we use string because : parseFloat("-0") returns 0..
	function sign(stringDegree){
		return ((stringDegree[0] == "-") ? -1 : 1);
	}

	var RA = equatorial[0].split(" ");
	// long
	var deg = parseFloat(RA[0]);
	var min = parseFloat(RA[1]);
	var sec = parseFloat(RA[2]);
	
	dest[0] = (deg + min/60 + sec/3600) * 15.;
	if(dest[0] > 180)
		dest[0] -= 360;
	
	var Decl = equatorial[1].split(" ");
	// lat
	deg = parseFloat(Decl[0]);
	min = parseFloat(Decl[1]);
	sec = parseFloat(Decl[2]);
	
	dest[1] = sign(Decl[0]) * (Math.abs(deg) + min/60 + sec/3600);
	
	return dest;

}

/**************************************************************************************************************/

/**
*	Convert a geographic position to equatorial
*	@param {Float[]} geo Array of two floats corresponding to Longitude and Latitude
*	@param {String[]} dest Destination array of two strings corresponding to Right Ascension and Declination
*					  specified by: 'hours+"h" minuts+"m" seconds+"s"' and 'degrees+"" minuts+"\'" seconds+"""' respectively
* 	@see <CoordinateSystem.fromDegreesToDMS>
* * 	@see <CoordinateSystem.fromDegreesToHMS>
*/
CoordinateSystem.fromGeoToEquatorial = function(geo, dest){
	
	if (!dest) dest = [];
	
	var deg = geo[0];
	// RA
	if(deg < 0){
		deg += 360;
	}

	dest[0] = CoordinateSystem.fromDegreesToHMS( deg );
	dest[1] = CoordinateSystem.fromDegreesToDMS(geo[1]);
	
	return dest;
}

/**************************************************************************************************************/

/**
 *	Function converting degrees to DMS("degrees minuts seconds")
 * 
 *	@param {Float} degree The degree
 */

CoordinateSystem.fromDegreesToDMS = function(degree)
{
	function stringSign(val)
	{
		return (val>=0 ? "+": "-");
	}
	
	var absLat = Math.abs(degree);
	var deg = Math.floor(absLat);
	var decimal = (absLat - deg) * 60;
	var min = Math.floor(decimal);
	var sec = (decimal - min) * 60;
	
	return stringSign(degree) + deg + String.fromCharCode(176) +" "+ min +"' "+ Numeric.roundNumber(sec, 2)+"\"";
	
}

/**************************************************************************************************************/

/**
 *	Function converting degrees to HMS("hours minuts seconds")
 *
 *	@param {Float} degree The degree > 0
 */

CoordinateSystem.fromDegreesToHMS = function(degree)
{
	var degree = degree/15;
	
	var absLon = Math.abs(degree);
	var hours = Math.floor(absLon);
	var decimal = (absLon - hours) * 60;
	var min = Math.floor(decimal);
	var sec = (decimal - min) * 60;
	
	return hours+"h "+min+"m "+ Numeric.roundNumber(sec, 2) +"s";
}

/**************************************************************************************************************/

/**
 *	Conversion between coordinate systems("EQ" or "GAL")
 *
 *	@param {Float[]} geo Geographic coordinates
 *	@param from Type of source coordinate system
 *	@param to Type of destination coordinate system
 */
CoordinateSystem.convert = function(geo, from, to)
{
	switch ( from+"2"+to ) {
		case "GAL2EQ" :
			convertType = AstroCoordTransform.Type.GAL2EQ;
			break;
		case "EQ2GAL" :
			convertType = AstroCoordTransform.Type.EQ2GAL;
			break;
		default:
			console.error("Not implemented");
			return null;
	}
	
	return AstroCoordTransform.transformInDeg( geo, convertType );
}

/**************************************************************************************************************/

/**
 *	Transfrom 3D vector from galactic coordinate system to equatorial
 */
CoordinateSystem.transformVec = function( vec )
{
	var res = [];
	mat4.multiplyVec3( transformMatrix, vec, res );
	return res;
}

/**************************************************************************************************************/

// Compute transformation matrix from GAL to EQ in 3D coordinates
var transformMatrix = [];

var galNorth = CoordinateSystem.convert([0,90], 'GAL', 'EQ');
var gal3DNorth = CoordinateSystem.fromGeoTo3D(galNorth);

var galCenter = CoordinateSystem.convert([0, 0], 'GAL', 'EQ');
var gal3DCenter = CoordinateSystem.fromGeoTo3D(galCenter);

var galEast = CoordinateSystem.convert([90, 0], 'GAL', 'EQ');
var gal3DEast = CoordinateSystem.fromGeoTo3D(galEast);

transformMatrix[0] = gal3DCenter[0];
transformMatrix[1] = gal3DCenter[1];
transformMatrix[2] = gal3DCenter[2];
transformMatrix[3] = 0.;
transformMatrix[4] = gal3DEast[0];
transformMatrix[5] = gal3DEast[1];
transformMatrix[6] = gal3DEast[2];
transformMatrix[7] = 0.;
transformMatrix[8] = gal3DNorth[0];
transformMatrix[9] = gal3DNorth[1];
transformMatrix[10] = gal3DNorth[2];
transformMatrix[11] = 0.;
transformMatrix[12] = 0.;
transformMatrix[13] = 0.;
transformMatrix[14] = 0.;
transformMatrix[15] = 1.;
mat4.create(transformMatrix);
mat4.inverse(transformMatrix);

return CoordinateSystem;

});

/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('gw/Frustum', ['./glMatrix'], function() {

/**************************************************************************************************************/

/** @constructor
	Plane constructor
 */
var Plane = function()
{
	this.normal = vec3.create( [0.0, 0.0, 0.0] );
	this.d = 0.0;
}

/**************************************************************************************************************/

/**
	Plane init from 3 points
 */
Plane.prototype.init = function( v1, v2, v3 )
{
	var vu = [];
	var vv = [];
	vec3.subtract( v2, v1, vu );
	vec3.subtract( v3, v1, vv );
	vec3.cross( vu, vv, this.normal );
	vec3.normalize( this.normal );
	this.d = - vec3.dot( v1, this.normal );
}


/**************************************************************************************************************/

/**
	Transform the plane with the given matrix
 */
Plane.prototype.transform = function(matrix)
{
	var vec = [ this.normal[0], this.normal[1], this.normal[2], this.d ];
	mat4.multiplyVec4(matrix,vec);
	this.normal[0] = vec[0];
	this.normal[1] = vec[1];
	this.normal[2] = vec[2];
	this.d = vec[3];
}

/**************************************************************************************************************/

/**
 Intersection test between plane and bounding sphere.
           return 1 if the bs is completely above plane,
            return 0 if the bs intersects the plane,
            return -1 if the bs is completely below the plane.
*/
Plane.prototype.intersectSphere = function( center, radius )
{
	var dist = vec3.dot( center, this.normal ) + this.d;
	if 	(dist > radius) return 1;
	else if ( dist < - radius ) return -1;
	else return 0;
}

/**************************************************************************************************************/

/**
	Return the distance between a point and the plane
*/
Plane.prototype.distance = function( point )
{
	return point[0] * this.normal[0] + point[1] * this.normal[1] + point[2] * this.normal[2] +  this.d
}


/**************************************************************************************************************/

/**
 Intersection test between plane and bounding box.
           return 1 if the bbox is completely above plane,
            return 0 if the bbox intersects the plane,
            return -1 if the bbox is completely below the plane.
*/
Plane.prototype.intersectBoundingBox = function( bbox )
{
	var upperBBCorner = (this.normal[0]>=0.0?1:0) |
                             (this.normal[1]>=0.0?2:0) |
                             (this.normal[2]>=0.0?4:0);
							 
	var lowerBBCorner = (~upperBBCorner)&7;

	// if lowest point above plane than all above.
	if ( this.distance(bbox.getCorner(lowerBBCorner)) > 0.0) return 1;

	// if highest point is below plane then all below.
	if ( this.distance(bbox.getCorner(upperBBCorner)) < 0.0) return -1;

	// d_lower<=0.0f && d_upper>=0.0f
	// therefore must be crossing plane.
	return 0;
}

/**************************************************************************************************************/

/** @constructor
	Frustum constructor
 */
var Frustum = function()
{
	// The frustum does not contains near and far plane, because near and far are computed during rendering.
	// Some tests have been done with a near plane but are not really useful
	this.planes = [ new Plane(), new Plane(), new Plane(), new Plane(), new Plane() ];
	//this.planes = [ new Plane(), new Plane(), new Plane(), new Plane() ];
}

/**************************************************************************************************************/

/**
	Compute the frustum from the given projection matrix
 */
Frustum.prototype.compute = function(projectionMatrix)
{
	var inverseProjectionMatrix = mat4.create();
	mat4.inverse( projectionMatrix, inverseProjectionMatrix )
	
	var bottomleft = mat4.project( inverseProjectionMatrix, [-1.0,-1.0,-1.0,1.0] );
	var topleft = mat4.project( inverseProjectionMatrix, [-1.0,1.0,-1.0,1.0] );
	var topright = mat4.project( inverseProjectionMatrix, [1.0,1.0,-1.0,1.0] );
	var bottomright = mat4.project( inverseProjectionMatrix, [1.0,-1.0,-1.0,1.0] );
	
	this.planes[0].init( [0.0,0.0,0.0], bottomleft, topleft );
	this.planes[1].init( [0.0,0.0,0.0], topleft, topright );
	this.planes[2].init( [0.0,0.0,0.0], topright, bottomright );
	this.planes[3].init( [0.0,0.0,0.0], bottomright, bottomleft );
	
	// A plane for near plane if needed
	this.planes[4].init( bottomleft, topleft, topright );
}

/**************************************************************************************************************/

/**
	Transform the frustum with the given matrix
 */
Frustum.prototype.transform = function(frustum,matrix)
{
	var mat = mat4.create();
	mat4.inverse(matrix,mat);
	this.inverseTransform(frustum,mat);
}

/**************************************************************************************************************/

/**
	Inverse transform the frustum with the given matrix
 */
Frustum.prototype.inverseTransform = function(frustum,matrix)
{
	// Optimized implementation
	for ( var i = 0; i < frustum.planes.length; i++ )
	{
		var plane = frustum.planes[i];
		
		var x = plane.normal[0];
		var y = plane.normal[1];
		var z = plane.normal[2];
		var w = plane.d;

		plane = this.planes[i];
		
		plane.normal[0] = matrix[0]*x + matrix[1]*y + matrix[2]*z + matrix[3]*w;
		plane.normal[1] = matrix[4]*x + matrix[5]*y + matrix[6]*z + matrix[7]*w;
		plane.normal[2] = matrix[8]*x + matrix[9]*y + matrix[10]*z + matrix[11]*w;
		plane.d = matrix[12]*x + matrix[13]*y + matrix[14]*z + matrix[15]*w;
	}
}

/**************************************************************************************************************/

/**
	Intersection test between frustum and bounding sphere.
	   return 1 if the bs is completely inside the frustum,
		return 0 if the bs intersects the frustum,
		return -1 if the bs is completely outside the frustum.
 */
Frustum.prototype.containsSphere = function( center, radius )
{
	var flag = 1;
	
	for (var i = 0; i < this.planes.length; i++)
	{
		var pn = this.planes[i].normal;
		
		// Compute distance between center and plane (inline to be more efficient)
		var dist = center[0]*pn[0] + center[1]*pn[1] + center[2]*pn[2] + this.planes[i].d;
		
		if 	(dist <= radius)
		{
			if ( dist < - radius ) 
				return -1;
			else 
				flag = 0;
		}	
	}
	
	return flag;
}

/**************************************************************************************************************/

/**
	Test if the frustum contains the given bounding box
 */
Frustum.prototype.containsBoundingBox = function( bbox )
{
	// Optimized implementation
	for (var i = 0; i < this.planes.length; i++)
	{
		var plane = this.planes[i];
		
		// Get the closest point on the bbox
		var bbx = plane.normal[0]>=0.0 ? bbox.max[0] : bbox.min[0];
		var bby = plane.normal[1]>=0.0 ? bbox.max[1] : bbox.min[1];
		var bbz = plane.normal[2]>=0.0 ? bbox.max[2] : bbox.min[2];
		
		// Compute the distance
		var distance = bbx * plane.normal[0] + bby * plane.normal[1] + bbz * plane.normal[2] +  plane.d

		// if highest point is below plane then all below.
		if ( distance < 0.0) return false;
	}
	
/*	for (var i = 0; i < 4; i++)
	{
		if ( this.planes[i].intersectBoundingBox( bbox ) < 0 )
		{
			return false;
		}
	}*/
	
	return true;
}

/**************************************************************************************************************/

// Export plane
Frustum.Plane = Plane;

return Frustum;

});

/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/
 
define('gw/RenderContext',[ './Frustum', './Numeric', './CoordinateSystem', './glMatrix' ], 
	function( Frustum, Numeric, CoordinateSystem ) {

/**************************************************************************************************************/

/** 
	@constructor
	Function constructor for RencerContext
*/
var RenderContext = function(options)
{
	/**
	 * Private properties
	 */
	 
	/**
	 * Private method
	 */

	
	/**
	 * Constructor
	 */
	this.activeAnimations = [];
	this.shadersPath = options['shadersPath'] || "../shaders/";
	this.tileErrorTreshold = options['tileErrorTreshold'] || 4;
	this.lighting = options['lighting'] || false;
	this.continuousRendering = options['continuousRendering'] || false;
	this.stats = null;

	// Init GL
	var canvas = null;
	
	// Check canvas options
	if (!options['canvas'])
		throw "GlobWeb : no canvas in options";
	

	if (typeof options['canvas'] == "string") 
	{
		canvas = document.getElementById(options['canvas']);
	}
	else
	{
		canvas = options['canvas'];
	}
	
	// Check canvas is valid
	if (!canvas instanceof HTMLCanvasElement)
		throw "GlobWeb : invalid canvas";
		
	// Create the webl context
	var names = ["webgl", "experimental-webgl", "webkit-3d", "moz-webgl"];
	var gl = null;
	for (var ii = 0; ii < names.length && gl == null; ++ii) 
	{
		try 
		{
		  gl = canvas.getContext(names[ii], RenderContext.contextAttributes);
		} 
		catch(e) {}
	}
	
	if ( gl == null )
		throw "GlobWeb : WebGL context cannot be initialized";

	
	if ( options['backgroundColor'] )
	{
		var color = options['backgroundColor'];
		gl.clearColor(color[0],color[1],color[2],color[3]);
	}
	else
	{
		gl.clearColor(0.0, 0.0, 0.0, 1.0);
	}
	
	gl.pixelStorei( gl['UNPACK_COLORSPACE_CONVERSION_WEBGL'], gl.NONE );
	gl.enable(gl.DEPTH_TEST);
	gl.enable(gl.CULL_FACE);
		
	// Store local variable into static object
	this.viewMatrix = mat4.create();
	this.modelViewMatrix =  mat4.create();
	this.projectionMatrix = mat4.create();
	this.gl = gl;
	this.canvas = canvas;
	this.frustum = new Frustum();
	this.worldFrustum = new Frustum();
	this.localFrustum = new Frustum();
	this.eyePosition = vec3.create();
	this.eyeDirection = vec3.create();
	this.minNear = 0.001;
	this.near = RenderContext.minNear;
	this.far = 6.0;
	this.numActiveAttribArray = 0;
	this.frameRequested = false;
	this.fov = 45;
	
	
	// Initialize the window requestAnimationFrame
	if ( !window.requestAnimationFrame ) 
	{
		window.requestAnimationFrame = ( function() {
			return window.webkitRequestAnimationFrame ||
				 window.mozRequestAnimationFrame ||
				window.oRequestAnimationFrame ||
				window.msRequestAnimationFrame ||
				function( callback, element ) { window.setTimeout( callback, 1000 / 60 );};
			} )();
	}
	
	var self = this;
	this.frameCallback = function() { self.frame(); };
}

/**************************************************************************************************************/

/** 
	The context attributes used when creating WebGL context, see WebGL specification.
	Can be changed by the renderers if needed, or by an external interface.
*/
RenderContext.contextAttributes = {};

/**************************************************************************************************************/

/** 
	Request a frame
*/
RenderContext.prototype.requestFrame = function()
{	
	if (!this.frameRequested)
	{
		var self = this;
		window.requestAnimationFrame( this.frameCallback );
		this.frameRequested = true;
	}
}


/**************************************************************************************************************/

/** 
	A frame of the application
*/
RenderContext.prototype.frame = function() 
{		
	// Resest frame requested flag first
	this.frameRequested = false;
	
	var stats = this.stats;
	var gl = this.gl;

	if (stats) stats.start("globalRenderTime");
	
	// Update active animations
	if ( this.activeAnimations.length > 0)
	{
		var time = Date.now();
		for (var i = 0; i < this.activeAnimations.length; i++)
		{
			this.activeAnimations[i].update(time);
		}
	}
	
	// Clear the buffer
	if ( RenderContext.contextAttributes.stencil )
	{
		gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT);
	}
	else
	{
		gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
	}
	
	// Check canvas size is valid
	if ( this.canvas.width == 0 || this.canvas.height == 0 )
		return;
		
	gl.viewport(0, 0, this.canvas.width, this.canvas.height);

	// Update view dependent properties to be used during rendering : view matrix, frustum, projection, etc...
	this.updateViewDependentProperties();
			
	// Call renderer
	this.renderer.render();
	
	if (stats) stats.end("globalRenderTime");
	
	// Request next frame
	if ( this.continuousRendering )
	{
		this.requestFrame();
	}
	else if ( this.activeAnimations.length > 0 )
	{
		this.requestFrame();
	}
	
};

/**************************************************************************************************************/

/** 
	Update properies that depends on the view matrix
*/
RenderContext.prototype.updateViewDependentProperties = function()
{
	var inverseViewMatrix = mat4.create();
	mat4.inverse( this.viewMatrix, inverseViewMatrix );
	
	vec3.set( [ 0.0, 0.0, 0.0 ], this.eyePosition );
	mat4.multiplyVec3( inverseViewMatrix, this.eyePosition );
	
	vec3.set( [ 0.0, 0.0, -1.0 ], this.eyeDirection );
	mat4.rotateVec3( inverseViewMatrix, this.eyeDirection );
	
	// Init projection matrix
	mat4.perspective(this.fov, this.canvas.width / this.canvas.height, this.minNear, this.far, this.projectionMatrix);
	
	// Compute the frustum from the projection matrix
	this.frustum.compute(this.projectionMatrix);
	
	// Compute the world frustum
	this.worldFrustum.inverseTransform( this.frustum, this.viewMatrix );
	
	// Compute the pixel size vector from the current view/projection matrix
	this.pixelSizeVector = this.computePixelSizeVector();
}

/**************************************************************************************************************/

/**
	Get mouse coordinates relative to the canvas element
*/
RenderContext.prototype.getXYRelativeToCanvas = function(event)
{
	// cf. http://stackoverflow.com/questions/55677/how-do-i-get-the-coordinates-of-a-mouse-click-on-a-canvas-element
	var pos = [];
	if (event.pageX || event.pageY)
	{
		pos[0] = event.pageX;
		pos[1] = event.pageY;
	}
	else
	{ 
		pos[0] = event.clientX + document.body.scrollLeft + document.documentElement.scrollLeft; 
		pos[1] = event.clientY + document.body.scrollTop + document.documentElement.scrollTop; 
	}
	
	var element = this.canvas; 
	while (element)
	{
		pos[0] -= element.offsetLeft;
		pos[1] -= element.offsetTop;
		element = element.offsetParent;
	}
        
	return pos;
}


/**************************************************************************************************************/

/** 
	Compute the pixel size vector
*/
RenderContext.prototype.computePixelSizeVector = function( mv )
{
	// pre adjust P00,P20,P23,P33 by multiplying them by the viewport window matrix.
	// here we do it in short hand with the knowledge of how the window matrix is formed
	// note P23,P33 are multiplied by an implicit 1 which would come from the window matrix.
	// Robert Osfield, June 2002.
	
	var width = this.canvas.width;
	var height = this.canvas.height;
	var P = this.projectionMatrix;
	var V = mv || this.viewMatrix;
	
	// scaling for horizontal pixels
	var P00 = P[0]*width*0.5;
	var P20_00 = P[8]*width*0.5 + P[11]*width*0.5;
	var scale_00 = [ V[0]*P00 + V[2]*P20_00,
			V[4]*P00 + V[6]*P20_00,
			V[8]*P00 + V[10]*P20_00 ];

	// scaling for vertical pixels
	var P10 = P[5]*height*0.5;
	var P20_10 = P[9]*height*0.5 + P[11]*height*0.5;
	var scale_10 = [ V[1]*P10 + V[2]*P20_10,
			V[5]*P10 + V[6]*P20_10,
			V[9]*P10 + V[10]*P20_10 ];

	var P23 = P[11];
	var P33 = P[15];
	var pixelSizeVector = [V[2]*P23,
				V[6]*P23,
				V[10]*P23,
				V[14]*P23 + V[15]*P33];

	var scaleRatio  = 0.7071067811 / Math.sqrt( vec3.dot(scale_00,scale_00)+ vec3.dot(scale_10,scale_10) );
	pixelSizeVector[0] *= scaleRatio;
	pixelSizeVector[1] *= scaleRatio;
	pixelSizeVector[2] *= scaleRatio;
	pixelSizeVector[3] *= scaleRatio;

	return pixelSizeVector;
}
/**************************************************************************************************************/

/** 
	Get 3D from a pixel
*/
RenderContext.prototype.get3DFromPixel = function(x,y)
{
	// reverse y because (0,0) is top left but opengl's normalized
	// device coordinate (-1,-1) is bottom left
	var nx = ((x / this.canvas.width) * 2.0) - 1.0;
	var ny = -(((y / this.canvas.height) * 2.0) - 1.0);
	
	var tmpMat = mat4.create();
	mat4.multiply(this.projectionMatrix, this.viewMatrix, tmpMat);
	mat4.inverse(tmpMat);
	// Transform pos to world using inverse viewProjection matrix
	var worldPick = mat4.multiplyVec4(tmpMat, [ nx, ny, -1, 1]);
	worldPick[0] /= worldPick[3];
	worldPick[1] /= worldPick[3];
	worldPick[2] /= worldPick[3];
	
	// Shoot a ray from the camera to the picked point
	// Get camera position
	mat4.inverse(this.viewMatrix, tmpMat);
	var worldCam = [tmpMat[12], tmpMat[13], tmpMat[14]];
	var rayDirection = vec3.create();
	vec3.subtract(worldPick, worldCam, rayDirection);
	vec3.normalize(rayDirection);
	
	// Intersect earth sphere
	var t = Numeric.raySphereIntersection(worldCam, rayDirection, [0.0, 0.0, 0.0], CoordinateSystem.radius);
	if (t >= 0)
	{
		var pos3d = Numeric.pointOnRay(worldCam, rayDirection, t);
		return pos3d;
	}
	
	return null;
}

/**************************************************************************************************************/

/** 
	Get pixel from 3D
*/
RenderContext.prototype.getPixelFrom3D = function(x,y,z)
{
	var viewProjectionMatrix = mat4.create();
	mat4.multiply(this.projectionMatrix, this.viewMatrix, viewProjectionMatrix);
	
	// transform world to clipping coordinates
	var point3D = [x,y,z,1];
	mat4.project(viewProjectionMatrix, point3D);
	
	// transform clipping to window coordinates
	var winX = Math.round( ( 1 + point3D[0] ) * 0.5 * this.canvas.width );
	
	// reverse y because (0,0) is top left but opengl's normalized
	// device coordinate (-1,-1) is bottom left
	var winY = Math.round( ( 1 - point3D[1] ) * 0.5 * this.canvas.height );

	return [winX, winY];
}

/**************************************************************************************************************/

/** 
	Create a non power of two texture from an image
*/
RenderContext.prototype.createNonPowerOfTwoTextureFromImage = function(image, invertY)
{	
	var gl = this.gl;
	var tex = gl.createTexture();
	gl.bindTexture(gl.TEXTURE_2D, tex);
	gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, invertY);
	gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
	// Restore to default
	gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
	return tex;
}

/**************************************************************************************************************/

return RenderContext;

});

/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('gw/BoundingBox',[], function() {

/**************************************************************************************************************/

/** @constructor
	BoundingBox constructor
 */
var BoundingBox = function(min,max)
{
	if (min)
	{
		this.min = vec3.create( min );
	}
	if (max)
	{
		this.max = vec3.create( max );
	}
}

/**************************************************************************************************************/

/**
	Extent the bounding box with the given point
 */
BoundingBox.prototype.extend = function( x, y, z)
{
	if (!this.min)
	{
		this.min = vec3.create();
		this.max = vec3.create();
		
		this.min[0] = x;
		this.min[1] = y;
		this.min[2] = z;
		this.max[0] = x;
		this.max[1] = y;
		this.max[2] = z;
	}
	else
	{
		if ( x < this.min[0] )
		{
			this.min[0] = x;
		}
		if ( y < this.min[1] )
		{
			this.min[1] = y;
		}
		if ( z < this.min[2] )
		{
			this.min[2] = z;
		}
		if ( x > this.max[0] )
		{
			this.max[0] = x;
		}
		if ( y > this.max[1] )
		{
			this.max[1] = y;
		}
		if ( z > this.max[2] )
		{
			this.max[2] = z;
		}
	}
}
/**************************************************************************************************************/

/**
	Compute the bounding box from an array of vertices
 */
BoundingBox.prototype.compute = function(vertices,length,stride)
{
	if (!this.min)
	{
		this.min = vec3.create();
		this.max = vec3.create();
	}
	
	this.min[0] = vertices[0];
	this.min[1] = vertices[1];
	this.min[2] = vertices[2];
	this.max[0] = vertices[0];
	this.max[1] = vertices[1];
	this.max[2] = vertices[2];
	
	var st = stride || 3;
	var ll = length || vertices.length;
	
	for (var i=st; i < ll; i += st)
	{
		for (var j=0; j < 3; j++)
		{
			if ( vertices[i+j] < this.min[j] )
			{
				this.min[j] = vertices[i+j];
			}
			if ( vertices[i+j] > this.max[j] )
			{
				this.max[j] = vertices[i+j];
			}
		}
	}
}

/**************************************************************************************************************/

/**
	Get the corner of a bounding box
 */
BoundingBox.prototype.getCorner = function(pos)
{
	return [ pos&1 ? this.max[0] : this.min[0],
			pos&2 ? this.max[1] : this.min[1],
			pos&4 ? this.max[2] : this.min[2]	];
}

/**************************************************************************************************************/

/**
	Get the center of a bounding box
 */
BoundingBox.prototype.getCenter = function()
{
	return [ (this.max[0] + this.min[0]) * 0.5,
			(this.max[1] + this.min[1]) * 0.5,
			(this.max[2] + this.min[2]) * 0.5	];
}

/**************************************************************************************************************/

/**
	Get the radius of a bounding box
 */
BoundingBox.prototype.getRadius = function()
{
	var vec = vec3.create();
	vec3.subtract( this.max, this.min, vec)
	return 0.5 * vec3.length(vec);
}

/**************************************************************************************************************/

return BoundingBox;

});

/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

 define('gw/Tile',['./BoundingBox','./CoordinateSystem','./glMatrix'], 
	function(BoundingBox,CoordinateSystem) {

/**************************************************************************************************************/

/** @constructor
	Tile constructor
 */
var Tile = function()
{
	// Parent/child relationship
	this.parent = null;
	this.parentIndex = -1;
	this.children = null;
	
	// Graphics data to render the tile
	this.vertices = null;
	this.texture = null;
	this.vertexBuffer = null;
	this.texTransform = [1., 1., 0., 0.];
	
	// Tile spatial data
	this.matrix = null;
	this.inverseMatrix = null;
	this.bbox = new BoundingBox();
	
	// For culling
	this.radius = 0.0;	
	this.distance = 0.0;
	this.closestPointToEye = [ 0.0, 0.0, 0.0 ];
	
	// Specific object to store extension from renderers
	this.extension = {};
	
	// For debug
	//this.color = [ Math.random(), Math.random(), Math.random() ];
	
	this.state = Tile.State.NONE;
	
	// Tile configuration given by tile manager : contains if the tile uses skirt, the tesselation, etc...
	this.config = null;
	this.imageSize = 256;
}

/**************************************************************************************************************/

/**
 *	Tile state enumerations
 */
Tile.State = 
{
	ERROR : -10,
	NONE : 0,
	REQUESTED : 1,
	LOADING : 2,
	LOADED : 3
};


/**************************************************************************************************************/

/**
 * Compute position on the tile using normalized coordinate between [0,size-1]
 */
Tile.prototype.computePosition = function(u,v)
{
	var vFloor = Math.floor( v );
	var vFrac = v - vFloor;
	var uFloor = Math.floor( u );
	var uFrac = u - uFloor;
	var size = this.config.tesselation;
	var vertexSize = this.config.vertexSize;
	var vertexOffset = vertexSize*( vFloor*size + uFloor );
	var vec = [ 0.0, 0.0, 0.0 ];
	for ( var i=0; i < 3; i++)
	{
		vec[i] = (1.0 - vFrac) * (1.0 - uFrac) * this.vertices[ vertexOffset + i ]
		+ vFrac * (1.0 - uFrac) * this.vertices[ vertexOffset + vertexSize*size + i ]
		+ vFrac * uFrac * this.vertices[ vertexOffset + vertexSize*size + vertexSize + i ]
		+ (1.0 - vFrac) * uFrac * this.vertices[ vertexOffset + vertexSize + i ];
	}
	
	return vec;
}


/**************************************************************************************************************/

/**
 *	Initialize the tile from its parent
 */
Tile.prototype.initFromParent = function(parent,i,j)
{
	this.parent = parent;
	this.parentIndex = j*2 + i;
	this.matrix  = parent.matrix;
	this.inverseMatrix  = parent.inverseMatrix;
	this.texture = parent.texture;
	this.config = parent.config;
	
	this.vertexBuffer = parent.vertexBuffer;
	
	// Recompute the bounding box
	// Very fast and coarse version but it does not work with HEALPix tiling
	//var w = 0.5 * (parent.bbox.max[0] - parent.bbox.min[0]);
	//var h = -0.5 * (parent.bbox.max[1] - parent.bbox.min[1]);
	//var min = [  parent.bbox.min[0] + i * w, parent.bbox.max[1] + (j+1) * h, parent.bbox.min[2] ];
	//var max = [  parent.bbox.min[0] + (i+1) * w, parent.bbox.max[1] + j * h, parent.bbox.max[2] ];
	
	var size = this.config.tesselation;
	var halfTesselation = (size-1)/2;
	for (var n = 0; n <= halfTesselation; n++)
	{
		var offset = this.config.vertexSize * ( (n+j*halfTesselation)*size + i*halfTesselation );
		for (var k = 0; k <= halfTesselation; k++)
		{
			this.bbox.extend( parent.vertices[offset], parent.vertices[offset+1], parent.vertices[offset+2] );
			offset += this.config.vertexSize;
		}
	}
	
	// Compute the bounding box
	this.radius = this.bbox.getRadius();
	
	// Init extension
	for ( var x in parent.extension ) 
	{
		var e = parent.extension[x];
		if ( e.initChild )
		{
			e.initChild(this,i,j);
		}
	}

}

/**************************************************************************************************************/

/**
 *	Test if the tile needs to be refined
 */
Tile.prototype.needsToBeRefined = function(renderContext)
{
	if ( this.distance < this.radius )
		return true;

	// Approximate the radius of one texel : the radius of the tile divided by the image size
	// The radius is taken as the average of the bbox width and length, rather than the actual radius because at the pole, there is a large difference betwen width and length
	// and the radius (ie maximum width/length) is too pessimistic
	var radius = 0.25 * ( (this.bbox.max[0] - this.bbox.min[0]) + (this.bbox.max[1] - this.bbox.min[1]) )  / this.imageSize; 
	
	// Transform the closest point from the eye in world coordinates
	var mat = this.matrix;
	var c = this.closestPointToEye;
	var px = mat[0]*c[0] + mat[4]*c[1] + mat[8]*c[2] + mat[12];
	var py = mat[1]*c[0] + mat[5]*c[1] + mat[9]*c[2] + mat[13];
	var pz = mat[2]*c[0] + mat[6]*c[1] + mat[10]*c[2] + mat[14];
	
	// Compute the pixel size of the radius texel
	var pixelSizeVector = renderContext.pixelSizeVector;
	var pixelSize = radius / ( px * pixelSizeVector[0] + py * pixelSizeVector[1]
						+ pz * pixelSizeVector[2] + pixelSizeVector[3] );
	
	// Check if pixel radius of a texel is superior to the treshold
	// The pixel size can be negative when the closest point is close to the near plane, so take absolute value
	return Math.abs(pixelSize) > renderContext.tileErrorTreshold;
}

/**************************************************************************************************************/

/**
 *	Test if the tile is culled given the current view parameters
 */
Tile.prototype.isCulled = function(renderContext)
{	
	// Compute the eye in tile local space
	var mat = this.inverseMatrix;
	var c = renderContext.eyePosition;
	var ex = mat[0]*c[0] + mat[4]*c[1] + mat[8]*c[2] + mat[12];
	var ey = mat[1]*c[0] + mat[5]*c[1] + mat[9]*c[2] + mat[13];
	var ez = mat[2]*c[0] + mat[6]*c[1] + mat[10]*c[2] + mat[14];
			
	// If the eye is in the radius of the tile, consider the tile is not culled
	this.distance = Math.sqrt( ex * ex + ey * ey + ez * ez );
	if ( this.distance < this.radius )
	{
		this.distance = 0.0;
		return false;
	}
	else
	{
		var pt = this.closestPointToEye;
		
		// Compute closest point to eye with the bbox of the tile
		pt[0] = Math.min( Math.max( ex, this.bbox.min[0] ), this.bbox.max[0] );
		pt[1] = Math.min( Math.max( ey, this.bbox.min[1] ), this.bbox.max[1] );
		pt[2] = Math.min( Math.max( ez, this.bbox.min[2] ), this.bbox.max[2] );
		
		// Compute horizontal culling only if the eye is "behind" the tile
		if ( ez < 0.0 )
		{
			// Compute vertical at the closest point. The earth center is [0, 0, -radius] in tile local space.
			var vx = pt[0];
			var vy = pt[1];
			var vz = pt[2] + CoordinateSystem.radius;
			var vl = Math.sqrt( vx * vx + vy * vy + vz * vz );
			vx /= vl; vy /= vl; vz /= vl;
			
			// Compute eye direction at the closest point (clampled on earth to avoid problem with mountains)
			// The position clamp to earth is Vertical * Radius + EarthCenter. The EarthCenter being 0,0,-radius a lot of simplification is done.
			var edx = ex - vx * CoordinateSystem.radius;
			var edy = ey - vy * CoordinateSystem.radius;
			var edz = ez - (vz - 1.0) * CoordinateSystem.radius;
			
			// Compute dot product between eye direction and the vertical at the point
			var el = Math.sqrt( edx * edx + edy * edy  + edz * edz );
			var eDv = (edx * vx + edy * vy  + edz * vz) / el;
						
			eDv *= this.config.cullSign;
			
			if ( eDv < -0.05 )
			{
				return true;
			}
		}
		
		// Compute local frustum
		var localFrustum = renderContext.localFrustum;
		localFrustum.inverseTransform( renderContext.worldFrustum, this.matrix );
		
		// Check if the tile is inside the frustum
		return !localFrustum.containsBoundingBox(this.bbox);
	}
}

/**************************************************************************************************************/

/**
 *	Dispose the tile
 */
Tile.prototype.dispose = function(renderContext,tilePool)
{		
	// Dispose extension even if tile isn't loaded because it can be culled
	for ( var x in this.extension )
	{
		if ( this.extension[x].dispose )
			this.extension[x].dispose(renderContext,tilePool);
	}

	if ( this.state == Tile.State.LOADED  )
	{
		tilePool.disposeGLBuffer(this.vertexBuffer);
		if (this.texture) tilePool.disposeGLTexture(this.texture);
		
		this.vertexBuffer = null;
		this.texture = null;
		this.parent = null;
		
		this.state = Tile.State.NONE;
	}
}

/**************************************************************************************************************/

/**
 *	Delete the children
 */
Tile.prototype.deleteChildren = function(renderContext,tilePool)
{
	if ( this.children )
	{
		for (var i = 0; i < 4; i++)
		{
			// Recursively delete its children
			this.children[i].deleteChildren(renderContext,tilePool);
			// Dispose its ressources (WebGL)
			this.children[i].dispose(renderContext,tilePool);
		}
		
		// Cleanup the tile
		this.children = null;
	}
}

/**************************************************************************************************************/

/**
 *	Build skirt vertices
 */
Tile.prototype.buildSkirtVertices = function(center,srcOffset,srcStep,dstOffset)
{
	var vertices = this.vertices;
	var skirtHeight = this.radius * 0.05;
	
	var size = this.config.tesselation;
	for ( var i = 0; i < size; i++)
	{
/*		//Not optimized version of skirt computation
		var srcPos = [ vertices[srcOffset], vertices[srcOffset+1], vertices[srcOffset+2] ];
		var dir = vec3.subtract( srcPos, center, vec3.create() );
		vec3.normalize(dir);
		vec3.scale( dir, skirtHeight );
		vec3.subtract( srcPos, dir );*/
		
		// Optimized version of skirt computation
		var x = vertices[srcOffset] - center[0];
		var y = vertices[srcOffset+1] - center[1];
		var z = vertices[srcOffset+2] - center[2];
		var scale = skirtHeight / Math.sqrt( x*x + y*y + z*z );
		x *= scale;
		y *= scale;
		z *= scale;
		
		vertices[ dstOffset ] = vertices[srcOffset] - x;
		vertices[ dstOffset+1 ] = vertices[srcOffset+1] - y;
		vertices[ dstOffset+2 ] = vertices[srcOffset+2] - z;
		
		for (var n = 3; n < this.config.vertexSize; n++)
		{
			vertices[ dstOffset+n ] = vertices[srcOffset+n];
		}
		
		dstOffset += this.config.vertexSize;
		srcOffset += srcStep;
	}	
}

/**************************************************************************************************************/

/**
 *	Generate normals for a tile
 */
Tile.prototype.generateNormals = function()
{	
	var size = this.config.tesselation;
	var vertexSize = this.config.vertexSize;
	var lineSize = vertexSize*size;
	
	var vo = 0;
	for ( var j=0; j < size; j++ )
	{
		var vp1 = j == size-1 ? 0 : lineSize;
		var vm1 = j == 0 ? 0 : -lineSize;
		for ( var i=0; i < size; i++ )
		{
			var up1 = i == size-1 ? 0 : vertexSize;
			var um1 = i == 0 ? 0 : -vertexSize;
			var u = [
				this.vertices[vo+up1] - this.vertices[vo+um1],
				this.vertices[vo+up1+1] - this.vertices[vo+um1+1],
				this.vertices[vo+up1+2] - this.vertices[vo+um1+2]
			];
			var v = [
				this.vertices[vo+vp1] - this.vertices[vo+vm1],
				this.vertices[vo+vp1+1] - this.vertices[vo+vm1+1],
				this.vertices[vo+vp1+2] - this.vertices[vo+vm1+2]
			];
			
			var normal = vec3.cross( u, v, [] );
			vec3.normalize(normal);
			this.vertices[vo+3] = normal[0];
			this.vertices[vo+4] = normal[1];
			this.vertices[vo+5] = normal[2];
			
			vo += vertexSize;
		}
	}
}

/**************************************************************************************************************/

/**
 *	Generate the tile
 */
Tile.prototype.generate = function(tilePool,image,elevations)
{
	// Generate the vertices
	this.vertices = this.generateVertices(elevations);
		
	// Compute the bounding box
	var size = this.config.tesselation;
	var vertexSize = this.config.vertexSize;
	this.bbox.compute(this.vertices,vertexSize*size*size,vertexSize);
	this.radius = this.bbox.getRadius();
	
	// Compute normals if needed
	if (this.config.normals)
	{
		this.generateNormals();
	}
		
	// Compute skirt from vertices
	if (this.config.skirt)
	{
		// Compute local earth center, used to generate skirts
		var localEarthCenter = [ 0.0, 0.0, 0.0 ];
		mat4.multiplyVec3( this.inverseMatrix, localEarthCenter );
		
		// Skirts
		var dstOffset = vertexSize * (size * size); // TOP
		this.buildSkirtVertices( localEarthCenter, 0, vertexSize, dstOffset );
		dstOffset += vertexSize * size; // BOTTOM
		this.buildSkirtVertices( localEarthCenter, vertexSize * (size * (size-1)), vertexSize, dstOffset );
		dstOffset += vertexSize * size; // LEFT
		this.buildSkirtVertices( localEarthCenter, 0, vertexSize * size, dstOffset );
		dstOffset += vertexSize * size; // RIGHT
		this.buildSkirtVertices( localEarthCenter, vertexSize * (size-1), vertexSize * size, dstOffset );
		
		// These skirts are only used by children tile
		dstOffset += vertexSize * size; // CENTER
		this.buildSkirtVertices( localEarthCenter, vertexSize * ( size * (size-1)/2 ), vertexSize, dstOffset );
		dstOffset += vertexSize * size; // MIDDLE
		this.buildSkirtVertices( localEarthCenter, vertexSize * ( (size-1)/2 ), vertexSize * size, dstOffset );
	}	
	
	// Avoid double creation of vertex buffer for level0Tiles generation
	if (this.vertexBuffer != null && this.parent == null)
	{
		tilePool.disposeGLBuffer(this.vertexBuffer);
	}
	this.vertexBuffer = tilePool.createGLBuffer(this.vertices);

	// Create texture
	if (image)
	{
		this.texture = tilePool.createGLTexture(image);
		this.imageSize = this.config.imageSize;
	}
	
	this.state = Tile.State.LOADED;
}

/**************************************************************************************************************/

return Tile;

});
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

 define('gw/TilePool',[],function() {

/**************************************************************************************************************/

/** 
	@constructor
	TilePool constructor
 */
var TilePool = function(rc)
{
	// Private properties
	var gl = rc.gl;
	var glTexturePools = {};
	var glBuffers = [];
	var self = this;

	// Choose floating point texture filtering depending on extension support
	var float_linear_ext = gl.getExtension("OES_texture_float_linear");
	var float_filtering = float_linear_ext ? gl.LINEAR : gl.NEAREST;
	
	// Public properties
	this.numCreatedTextures = 0;
	this.numReusedTextures = 0;
	
	// Private methods

	/**************************************************************************************************************/

	/**
		Create a new GL texture
	 */
	var createNewGLTexture = function(image,texturePool)
	{
		var glTexture = gl.createTexture();
		gl.bindTexture(gl.TEXTURE_2D, glTexture);
		if ( image.dataType == "byte" )
		{
			gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
			gl.generateMipmap(gl.TEXTURE_2D);
		}
		else
		{
			gl.texImage2D(gl.TEXTURE_2D, 0, gl.LUMINANCE, image.width, image.height, 0, gl.LUMINANCE, gl.FLOAT, image.typedArray);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, float_filtering);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, float_filtering);
		}

		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
		glTexture.pool = texturePool;
		self.numCreatedTextures++;
		
		return glTexture;
	}

	/**************************************************************************************************************/

	/**
		Reuse a GL texture
	 */
	var reuseGLTexture = function(image,texturePool)
	{
		var glTexture = texturePool.pop();
		gl.bindTexture(gl.TEXTURE_2D, glTexture);

		if ( image.dataType == "byte" )
		{
			//gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, gl.RGBA, gl.UNSIGNED_BYTE, image);
			gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
			gl.generateMipmap(gl.TEXTURE_2D);
		}
		else
		{
			gl.texImage2D(gl.TEXTURE_2D, 0, gl.LUMINANCE, image.width, image.height, 0, gl.LUMINANCE, gl.FLOAT, image.typedArray);
		}

		self.numReusedTextures++;
		
		return glTexture;
	};
	
	/**
	 * Get or create a texture pool for the given image
	 */
	var getOrCreateTexturePool = function(image) 
	{
		var key = image.dataType + image.width;
		if (!glTexturePools[key])
		{
			glTexturePools[key] = [];
		}
		return glTexturePools[key];
	};
		
	// Public methods
	
	/**************************************************************************************************************/

	/**
		Create a GL texture to be used by a tile
	 */
	this.createGLTexture = function(image)
	{
		var texturePool = getOrCreateTexturePool(image);

		if ( texturePool.length > 0 )
		{
			return reuseGLTexture(image,texturePool);
		}
		else
		{
			return createNewGLTexture(image,texturePool);
		}
	};

	/**************************************************************************************************************/

	/**
		Create a GL texture to be used by a tile
	 */
	this.createGLBuffer = function(vertices)
	{
		var vb;
		if ( glBuffers.length > 0 )
		{
			vb = glBuffers.pop();
		}
		else
		{
			vb = gl.createBuffer();
		}
		gl.bindBuffer(gl.ARRAY_BUFFER, vb);
		gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
		
		return vb;
	};

	/**************************************************************************************************************/

	/**
		Dispose a texture
	 */
	this.disposeGLTexture = function(texture)
	{
		texture.pool.push(texture);
	}

	/**************************************************************************************************************/

	/**
		Dispose a texture
	 */
	this.disposeGLBuffer = function(buffer)
	{
		glBuffers.push(buffer);
	}

	/**************************************************************************************************************/

	/**
		Dispose all
	 */
	this.disposeAll = function()
	{
		for ( var key in glTexturePools )
		{
			if ( glTexturePools.hasOwnProperty(key) )
			{
				var glTextures = glTexturePools[key];
				for ( var i = 0;  i < glTextures.length; i++ ) 
				{
					gl.deleteTexture( glTextures[i] );
				}
			}
		}
		glTexturePools = {};
		
		for ( var i = 0;  i < glBuffers.length; i++ )
		{
			gl.deleteBuffer( glBuffers[i] );
		}
		glBuffers.length = 0;
	}

	/**************************************************************************************************************/	
};

return TilePool;

});


/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('gw/ImageRequest',[], function(){

/** 
 *	@constructor
 *	ImageRequest constructor
 */
var ImageRequest = function(options)
{
	this.successCallback = options.successCallback;
	this.failCallback = options.failCallback;
	this.abortCallback = options.abortCallback;
	this.image = null;
}

/**************************************************************************************************************/

/**
 *	Send image request
 */
ImageRequest.prototype.send = function(url)
{
	this.image = new Image();
	this.image.crossOrigin = '';
	this.image.dataType = "byte";

	var self = this;
	this.image.onload = function(){
		var isComplete = self.image.naturalWidth != 0 && self.image.complete;
		if ( isComplete )
		{
			self.successCallback.call(self);
		}
	} 
	this.image.onerror = this.failCallback.bind(this);
	this.image.src = url;
}

/**************************************************************************************************************/

/**
 *	Abort image request
 */
ImageRequest.prototype.abort = function()
{
	if ( this.abortCallback )
	{
		this.abortCallback(this);
	}
	this.image.src = '';
}

/**************************************************************************************************************/

return ImageRequest;

});
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

 define('gw/TileRequest',['./Tile', './ImageRequest'], function(Tile, ImageRequest) {
 
/**************************************************************************************************************/

/** @constructor
	TileRequest constructor
 */
var TileRequest = function(tileManager)
{
	// Private variables
	var _imageLoaded = false;
	var _elevationLoaded = true;
	var _xhr = new XMLHttpRequest();
	var _imageRequest;

	// Public variables
	this.tile = null;
	this.elevations = null;
	this.image = null;

	var self = this;
	
	// Setup the XHR callback
	_xhr.onreadystatechange = function(e)
	{
		if ( _xhr.readyState == 4 )
		{
			if ( _xhr.status == 200 )
			{
				_handleLoadedElevation();
			}
			else
			{
				_handleErrorElevation();
			}
		}
	};
	

	/**************************************************************************************************************/

	/**
		Handle when image is loaded
	 */
	var _handleLoadedImage = function() 
	{
		// The method can be called twice when the image is in the cache (see launch())
		if (!_imageLoaded)
		{
			_imageLoaded = true;
			if ( _elevationLoaded )
			{
				// Call post-process function if defined
				if ( tileManager.imageryProvider && tileManager.imageryProvider.handleImage )
					tileManager.imageryProvider.handleImage(_imageRequest);

				tileManager.completedRequests.push(self);
				tileManager.renderContext.requestFrame();
			}
			self.image = _imageRequest.image;
		}
	};

	/**************************************************************************************************************/

	/**
		Handle when loading image failed
	 */
	var _handleErrorImage = function() 
	{
		self.tile.state = Tile.State.ERROR;
		tileManager.availableRequests.push(self);
	}

	/**************************************************************************************************************/

	/**
		Abort request
	 */
	var _handleAbort = function() 
	{
		self.tile.state = Tile.State.NONE;
		tileManager.availableRequests.push(self);
	}

	/**************************************************************************************************************/

	/**
		Handle when elevation is loaded
	 */
	var _handleLoadedElevation = function() 
	{
		self.elevations = tileManager.elevationProvider.parseElevations(_xhr.responseText);	
		_elevationLoaded = true;
		
		if ( _imageLoaded )
		{
			tileManager.completedRequests.push(self);
			tileManager.renderContext.requestFrame();
		}
	}

	/**************************************************************************************************************/

	/**
		Handle when loading elevation failed
	 */
	var _handleErrorElevation = function() 
	{
		self.elevations = null;
		_elevationLoaded = true;
		
		if ( _imageLoaded )
		{
			tileManager.completedRequests.push(self);
			tileManager.renderContext.requestFrame();
		}
	}

	/**************************************************************************************************************/

	/**
		Launch the HTTP request for a tile
	 */
	this.launch = function(tile)
	{
		tile.state = Tile.State.LOADING;
		this.tile = tile;
		
		this.image = null;
		this.elevations = null;
		
		// Request the elevation if needed
		if ( tileManager.elevationProvider )
		{
			_elevationLoaded = false;
			_xhr.open("GET", tileManager.elevationProvider.getUrl(tile) );
			_xhr.send();
		}
		else
		{
			_elevationLoaded = true;
		}
		
		if ( tileManager.imageryProvider )
		{
			if (!_imageRequest)
			{
				_imageRequest = new ImageRequest({
					successCallback: _handleLoadedImage,
					failCallback: _handleErrorImage,
					abortCallback: _handleAbort
				});
			}
			_imageLoaded = false;
			_imageRequest.send( tileManager.imageryProvider.getUrl(tile) );
		}
		
		// Check if there is nothing to load
		if ( !tileManager.imageryProvider && !tileManager.elevationProvider )
		{
			tileManager.completedRequests.push(this);
		}
	};
	
};

/**************************************************************************************************************/

return TileRequest;

});

/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

 define('gw/TileIndexBuffer',[],function() {
 
/**************************************************************************************************************/

/** 
	@constructor TileIndexBuffer
	TileIndexBuffer
 */
var TileIndexBuffer = function( renderContext, config )
{
	this.renderContext = renderContext;
	this.config = config;
	this.solidIndexBuffer = null;
	this.subSolidIndexBuffer = [ null, null, null, null ];
	this.subIndices = [ null, null, null, null ];
}

/**************************************************************************************************************/

/**  
 * Reset the index buffers.
 */
TileIndexBuffer.prototype.reset = function()
{	
	var gl = this.renderContext.gl;
	for ( var i=0; i < 4; i++ )
	{
		if ( this.subSolidIndexBuffer[i] )
		{
			gl.deleteBuffer( this.subSolidIndexBuffer[i] );
			this.subSolidIndexBuffer[i] = null;
		}
	}
	if ( this.solidIndexBuffer )
	{
		gl.deleteBuffer( this.solidIndexBuffer );
		this.solidIndexBuffer = null;
	}
}

/**************************************************************************************************************/

/**
 *	Get index buffer for sub solid
 */
TileIndexBuffer.prototype.getSubSolid = function(ii)
{
	if ( this.subSolidIndexBuffer[ii] == null )
	{
		var i = ii % 2;
		var j = Math.floor( ii / 2 );
		
		var size = this.config.tesselation;
		var halfTesselation = (size-1) / 2;
		
		// Build the sub grid for 'inside' tile
		var indices = [];
		for ( var n=halfTesselation*j; n < halfTesselation*(j+1); n++)
		{
			for ( var k=halfTesselation*i; k < halfTesselation*(i+1); k++)
			{
				indices.push( n * size + k );
				indices.push( (n+1) * size + k );
				indices.push( n * size + k + 1 );
				
				indices.push( n * size + k + 1 );
				indices.push( (n+1) * size + k );
				indices.push( (n+1) * size + k + 1 );
			}
		}
		
		this.subIndices[ii] = indices;

		if (this.config.skirt)
		{
			// Build skirts
			// Top skirt
			var start = (j == 0) ? size * size : size * size + 4 * size;
			var src = (j == 0) ? 0 : halfTesselation * size;
			for ( var n = halfTesselation*i; n < halfTesselation*(i+1); n++)
			{
				indices.push( start + n );
				indices.push( src + n );
				indices.push( start + n + 1 );
				
				indices.push( start + n + 1 );
				indices.push( src + n );
				indices.push( src + n + 1 );
			}
		
			// Bottom skirt
			start = (j == 0) ? size * size + 4 * size : size * size + size;
			src = (j == 0) ? halfTesselation * size : (size-1) * size;
			for ( var n = halfTesselation*i; n < halfTesselation*(i+1); n++)
			{
				indices.push( src + n );
				indices.push( start + n );
				indices.push( src + n + 1 );
				
				indices.push( src + n + 1 );
				indices.push( start + n );
				indices.push( start + n + 1 );
			}
				
			// Left skirt
			start = (i == 0) ? size * size + 2 * size : size * size + 5 * size;
			src = (i == 0) ? 0 : halfTesselation;
			for ( var k=halfTesselation*j; k < halfTesselation*(j+1); k++)
			{
				indices.push( start + k );
				indices.push( start + k + 1 );
				indices.push( src + k * size );
				
				indices.push( src + k * size );
				indices.push( start + k + 1);
				indices.push( src + (k+1) * size );
			}
			
			// Right skirt
			start = (i == 0) ? size * size + 5 * size : size * size + 3 * size;
			src = (i == 0) ? halfTesselation : size - 1;
			for ( var k=halfTesselation*j; k < halfTesselation*(j+1); k++)
			{
				indices.push( k * size + src );
				indices.push( (k+1) * size + src );
				indices.push( start + k );
				
				indices.push( start + k );
				indices.push( (k+1) * size + src );
				indices.push( start + k + 1 );
			}
		}
		
		var gl = this.renderContext.gl;
		var ib = gl.createBuffer();
		gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ib);
		gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);
		ib.numIndices = indices.length;
		this.subSolidIndexBuffer[ii] = ib;
	}
	
	return this.subSolidIndexBuffer[ii];
}

/**************************************************************************************************************/

/*
	Build index buffer
 */
TileIndexBuffer.prototype.getSolid = function()
{
	if ( this.solidIndexBuffer == null )
	{
		var size = this.config.tesselation;
		var indices = [];
		// Build the grid
		for ( var j=0; j < size-1; j++)
		{
			for ( var i=0; i < size-1; i++)
			{
				indices.push( j * size + i );
				indices.push( (j+1) * size + i );
				indices.push( j * size + i + 1 );
				
				indices.push( j * size + i + 1 );
				indices.push( (j+1) * size + i );
				indices.push( (j+1) * size + i + 1 );
			}
		}
		
		if (this.config.skirt)
		{
			// Top skirt
			var start = size * size;
			for ( var i = 0; i < size-1; i++)
			{
				indices.push( start + i );
				indices.push( i );
				indices.push( start + i + 1 );
				
				indices.push( start + i + 1 );
				indices.push( i );
				indices.push( i + 1 );
			}
			
			// Bottom skirt
			start += size;
			for ( var i=0; i < size-1; i++)
			{
				indices.push( (size-1) * size + i );
				indices.push( start + i );
				indices.push( (size-1) * size + i + 1 );
				
				indices.push( (size-1) * size + i + 1 );
				indices.push( start + i );
				indices.push( start + i + 1 );
			}
				
			// Left skirt
			start += size;
			for ( var j=0; j < size-1; j++)
			{
				indices.push( start + j );
				indices.push( start + j + 1 );
				indices.push( j * size );
				
				indices.push( j * size );
				indices.push( start + j + 1);
				indices.push( (j+1) * size );
			}

			// Right skirt
			start += size;
			for ( var j=0; j < size-1; j++)
			{
				indices.push( j * size + size - 1 );
				indices.push( (j+1) * size + size - 1 );
				indices.push( start + j );
				
				indices.push( start + j );
				indices.push( (j+1) * size + size - 1 );
				indices.push( start + j + 1 );
			}
		}
		
		var gl = this.renderContext.gl;
		var ib = gl.createBuffer();
		gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ib);
		gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);
		this.numIndices = indices.length;
		
		this.solidIndexBuffer = ib;
		this.solidIndexBuffer.numIndices = indices.length;
	}
	
	return this.solidIndexBuffer;
}

/**************************************************************************************************************/

return TileIndexBuffer;

});

/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

 define('gw/Program',[],function() {

/**************************************************************************************************************/

/** @constructor
	Program constructor
 */
var Program = function(renderContext)
{
	this.renderContext = renderContext;
    this.glProgram = null;
    this.attributes = {};
    this.uniforms = {};
	this.numActiveAttribArray = 0;
}

/**************************************************************************************************************/

/**
  Creates a shader of the given type from the given source string
*/
Program.prototype.createShader = function(type, source)
{
	var gl = this.renderContext.gl;
    var shader = gl.createShader(type);
    gl.shaderSource(shader, source);
	gl.compileShader(shader);
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS))
    {
		console.log("Shader compilation error: " + gl.getShaderInfoLog(shader));
		console.log(source);
		gl.deleteShader(shader);
        return null;
    }

    return shader;
}

/**************************************************************************************************************/

/**
	Create the program from source shaders
 */
Program.prototype.createFromSource = function(vertexSource, fragmentSource)
{
	var gl = this.renderContext.gl;
	
    //  Create the gl shaders from the source
    var vertexShader = this.createShader(gl.VERTEX_SHADER, vertexSource);
    var fragmentShader = this.createShader(gl.FRAGMENT_SHADER, fragmentSource);
    if (vertexShader == null || fragmentShader == null)
    {
		return false;
    }
	
	// Create the program and attach the shaderss
	this.glProgram = gl.createProgram();
	gl.attachShader(this.glProgram, vertexShader);
	gl.attachShader(this.glProgram, fragmentShader);

	// Link and test the program is ok
	gl.linkProgram(this.glProgram);
    if (!gl.getProgramParameter(this.glProgram, gl.LINK_STATUS)) 
    {
        console.log("Program link error: " + gl.getProgramInfoLog(this.glProgram));
		gl.deleteShader(vertexShader);
		gl.deleteShader(fragmentShader);
		gl.deleteProgram(this.glProgram);
		this.glProgram = null;
        return false;
    }

    // Get vertex attributes used in the program, stored them in an attributes object
    var attributeCount = gl.getProgramParameter(this.glProgram, gl.ACTIVE_ATTRIBUTES);
	this.numActiveAttribArray = 0;
    for (var i = 0; i < attributeCount; ++i)
    {
        var attribute = gl.getActiveAttrib(this.glProgram, i);
		var loc = gl.getAttribLocation(this.glProgram,attribute.name);
        this.attributes[attribute.name] = loc;
		
		if ( loc + 1 > this.numActiveAttribArray )
		{
			this.numActiveAttribArray = loc + 1;
		}
    }

    // Get uniforms used in the program, stored them in an uniforms object
    var uniformCount = gl.getProgramParameter(this.glProgram, gl.ACTIVE_UNIFORMS);
    for (var i = 0; i < uniformCount; ++i)
    {
        var uniform = gl.getActiveUniform(this.glProgram, i);
        this.uniforms[uniform.name] = gl.getUniformLocation(this.glProgram,uniform.name);
    }

    return true;
}

/**************************************************************************************************************/

/*
	Load from file (must be located on the server)
 */
Program.prototype.loadFromFile = function(vertexFile, fragmentFile)
{
    var xhr = new XMLHttpRequest;
	xhr.open("get", this.renderContext.shadersPath + vertexFile, false);
	xhr.send(null);
    var vertexSource = xhr.responseText;
	xhr.open("get", this.renderContext.shadersPath +  fragmentFile, false);
	xhr.send(null);
    var fragmentSource = xhr.responseText;
    
    return this.createFromSource(vertexSource, fragmentSource);
}

/**************************************************************************************************************/

/*
	Apply the programs
 */
Program.prototype.apply = function()
{
	var rc = this.renderContext;
	var gl =  rc.gl;
	
    // Bind program
	gl.useProgram(this.glProgram);
    
	for ( var i = rc.numActiveAttribArray;
		i < this.numActiveAttribArray; i++ )
	{
		gl.enableVertexAttribArray(i);
	}
	for ( var i = this.numActiveAttribArray;
		i < rc.numActiveAttribArray; i++ )
	{
		gl.disableVertexAttribArray(i);
	}
	rc.numActiveAttribArray = this.numActiveAttribArray;
}

/**************************************************************************************************************/

/**
	Dispose the program
 */
Program.prototype.dispose = function()
{
	this.renderContext.gl.deleteProgram(this.glProgram);
}

/**************************************************************************************************************/

/*
	Load shader using Http request
 */
// Program.prototype.loadShader = function (shader, type, callback) 
// {
//     function onreadystatechange() {
//         var xhr = this;
//         if (xhr.readyState == 4) {
//             shader =  gl.createShader(type);
//              gl.shaderSource(shader, xhr.responseText);
//              gl.compileShader(shader);
//             if (! gl.getShaderParameter(shader,  gl.COMPILE_STATUS))
//                 throw  gl.getShaderInfoLog(shader)
//             ;
//             !--length && typeof callback == "function" && callback(shader);
//         }
//     }
	
// 	var asynchronous = !!callback;
// 	xhr = new XMLHttpRequest;
// 	xhr.open("get", shader, asynchronous);
// 	if (asynchronous) 
// 	{
// 		xhr.onreadystatechange = onreadystatechange;
// 	}
// 	xhr.send(null);
// 	onreadystatechange.call(xhr);
		
//     return shader;
// }

/**************************************************************************************************************/


/*
	Get the shader using defined in HTML
 */
// Program.prototype.getShader = function(id)
//  {
// 	var shaderScript = document.getElementById(id);
// 	if (!shaderScript) {
// 		return null;
// 	}

// 	var str = "";
// 	var k = shaderScript.firstChild;
// 	while (k) {
// 		if (k.nodeType == 3) {
// 			str += k.textContent;
// 		}
// 		k = k.nextSibling;
// 	}

// 	var shader;
// 	if (shaderScript.type == "x-shader/x-fragment") {
// 		shader = RenderContext.gl.createShader(RenderContext.gl.FRAGMENT_SHADER);
// 	} else if (shaderScript.type == "x-shader/x-vertex") {
// 		shader = RenderContext.gl.createShader(RenderContext.gl.VERTEX_SHADER);
// 	} else {
// 		return null;
// 	}

// 	RenderContext.gl.shaderSource(shader, str);
// 	RenderContext.gl.compileShader(shader);

// 	if (!RenderContext.gl.getShaderParameter(shader, RenderContext.gl.COMPILE_STATUS)) {
// 		alert(RenderContext.gl.getShaderInfoLog(shader));
// 		return null;
// 	}

// 	return shader;
// }

/**************************************************************************************************************/

return Program;

});

/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('gw/TileManager',['./Tile','./TilePool', './TileRequest', './TileIndexBuffer', './Program', './CoordinateSystem'],
	function (Tile,TilePool,TileRequest,TileIndexBuffer,Program, CoordinateSystem) {

/** @constructor
	TileManager constructor
	
	Take in parameters its parent : can be a globe or a sky
 */
var TileManager = function( parent )
{
	this.parent = parent;
	this.renderContext = this.parent.renderContext;
	// Create a new tile pool or use the one from the parent
	this.tilePool = parent.tilePool || new TilePool(this.renderContext);
	this.tiling = null;
	this.imageryProvider = null;
	this.elevationProvider = null;
	this.tilesToRender = [];
	this.visibleTiles = [];
	this.tilesToRequest = [];
	this.postRenderers = [];
	this.level0Tiles = [];
	
	// Tile requests : limit to 4 at a given time
	this.maxRequests = 4;
	this.availableRequests = [];
	for ( var i=0; i < this.maxRequests; i++ )
	{
		this.availableRequests[i] = new TileRequest(this);
	}
	this.completedRequests = [];
				
	this.level0TilesLoaded = false;
	
	// Configuration for tile
	this.tileConfig = {
		tesselation: 9,
		skirt: true,
		cullSign: 1.0,
		imageSize: 256,
		vertexSize: this.renderContext.lighting ? 6 : 3, 
		normals: this.renderContext.lighting
	};
		
	// Shared index and texture coordinate buffer : all tiles uses the same
	this.tcoordBuffer = null;
	this.tileIndexBuffer = new TileIndexBuffer(this.renderContext,this.tileConfig);

	// For debug
	this.freeze = false;

	// Stats
	this.numTilesGenerated = 0;
	this.frameNumber = 0;

	this.vertexShader = "\
	attribute vec3 vertex;\n\
	attribute vec2 tcoord;\n\
	uniform mat4 modelViewMatrix;\n\
	uniform mat4 projectionMatrix;\n\
	varying vec2 texCoord;\n";
	if ( this.renderContext.lighting )
		this.vertexShader += "attribute vec3 normal;\nvarying vec3 color;\n";
	this.vertexShader += "\
	void main(void) \n\
	{\n\
		gl_Position = projectionMatrix * modelViewMatrix * vec4(vertex, 1.0);\n";
	if ( this.renderContext.lighting )
		this.vertexShader += "vec4 vn = modelViewMatrix * vec4(normal,0);\ncolor = max( vec3(-vn[2],-vn[2],-vn[2]), 0.0 );\n";
	this.vertexShader += "\
		texCoord = tcoord;\n\
	}\n\
	";

	this.fragmentShader = "\
	precision lowp float; \n\
	varying vec2 texCoord;\n";
	if ( this.renderContext.lighting )
		this.fragmentShader += "varying vec3 color;\n";
	this.fragmentShader += "\
	uniform sampler2D colorTexture;\n\
	void main(void)\n\
	{\n\
		gl_FragColor.rgb = texture2D(colorTexture, texCoord).rgb;\n";
	if ( this.renderContext.lighting )
		this.fragmentShader += "gl_FragColor.rgb *= color;\n";
	this.fragmentShader += "\
		gl_FragColor.a = 1.0;\n\
	}\n\
	";
	
	this.program = new Program(this.renderContext);
	this.program.createFromSource( this.vertexShader, this.fragmentShader );
}

/**************************************************************************************************************/

/** 
	Add post renderer
 */
TileManager.prototype.addPostRenderer = function(renderer)
{	
	this.postRenderers.push( renderer );
	
	if ( renderer.generate )
	{
		this.visitTiles( function(tile) {
		
			renderer.generate(tile);
		} );
	}
}

/**************************************************************************************************************/

/** 
	Remove a post renderer
 */
TileManager.prototype.removePostRenderer = function(renderer)
{
	var rendererIndex = this.postRenderers.indexOf(renderer);
	if ( rendererIndex != -1 )
	{
		// Remove the renderer from all the tiles if it has a cleanupTile method
		if ( renderer.cleanupTile )
			this.visitTiles( function(tile) { renderer.cleanupTile(tile); } );
			
		// Remove renderer from the list
		this.postRenderers.splice( rendererIndex, 1 );
	}
}

/**************************************************************************************************************/

/** 
	Set the imagery provider to be used
 */
TileManager.prototype.setImageryProvider = function(ip)
{
	this.reset();
	this.imageryProvider = ip;
	
	if (ip)
	{
		// Clean tile pool
		this.tilePool.disposeAll();
		
		this.tiling = ip.tiling;

		// Rebuild level zero tiles
		this.tileConfig.imageSize = ip.tilePixelSize;
		this.level0Tiles = this.tiling.generateLevelZeroTiles(this.tileConfig,this.tilePool);

		// Update program
		if ( ip.customShader )
		{
			this.program.dispose();
			this.program = new Program(this.renderContext);

			// Memorize current fragment shader
			this.currentFragmentShader = ip.customShader.fragmentCode ? ip.customShader.fragmentCode : this.fragmentShader;
			this.program.createFromSource( ip.customShader.vertexCode ? ip.customShader.vertexCode : this.vertexShader,
											this.currentFragmentShader );
		}
		else
		{	
			// Revert to default if needed
			if ( this.currentFragmentShader != null )
			{
				this.program.dispose();
				this.program = new Program(this.renderContext);
				this.program.createFromSource( this.vertexShader, this.fragmentShader );
				this.currentFragmentShader = null;
			}
		}
	}
}

/**************************************************************************************************************/

/** 
	Get the level zero tiles that overlaps the given geometry
 */
TileManager.prototype.getOverlappedLevelZeroTiles = function( geometry )
{	
	var coords;
	switch ( geometry.type )
	{
	case "Point":
		coords = [];
		coords.push( geometry.coordinates );
		break;
	case "LineString":
		coords = geometry.coordinates;
		break;
	case "Polygon":
		coords = geometry.coordinates[0];
		break;
	case "MultiPolygon":
		coords = [];
		for ( var n = 0; n < geometry.coordinates.length; n++ )
		{
			coords = coords.concat( geometry.coordinates[n][0] );
		}
		break;
	}
	
	if ( !coords )
		console.log("COOORDDS!!");
		
	var indexMap = {};
	var tileIndices = [];
	for ( var i = 0; i < coords.length; i++ )
	{
		var index = this.tiling.lonlat2LevelZeroIndex( coords[i][0], coords[i][1] );
		if ( !indexMap[index] )
		{
			indexMap[ index ] = true;
			tileIndices.push( index );
		}
	}
	
	return tileIndices;
}

/**************************************************************************************************************/

/** 
	Set the elevation provider to be used
 */
TileManager.prototype.setElevationProvider = function(tp)
{	
	this.reset();
	this.elevationProvider = tp;
	
	var newTesselation = tp ? tp.tilePixelSize : 9;
	if ( newTesselation != this.tileConfig.tesselation )
	{
		this.tileConfig.tesselation = newTesselation;
		
		// Reset the shared buffers : texture coordinate and indices
		var gl = this.renderContext.gl;
		this.tileIndexBuffer.reset();
		gl.deleteBuffer( this.tcoordBuffer );
		this.tcoordBuffer = null;
	}
}

/**************************************************************************************************************/

/**
	Reset the tile manager : unload all tiles
 */
TileManager.prototype.reset = function()
{
	// Reset all level zero tiles : destroy render data, and reset state to NONE
	for (var i = 0; i < this.level0Tiles.length; i++)
	{
		this.level0Tiles[i].deleteChildren(this.renderContext,this.tilePool);
		this.level0Tiles[i].dispose(this.renderContext,this.tilePool);
	}
	
	this.level0TilesLoaded = false;
}

/**************************************************************************************************************/

/** 
	Tile visitor
 */
TileManager.prototype.visitTiles = function( callback )
{
	// Store the tiles to process in an array, first copy level0 tiles
	var tilesToProcess = this.level0Tiles.concat([]);
	
	while( tilesToProcess.length > 0 )
	{
		// Retreive the first tile and remove it from the array
		var tile = tilesToProcess.shift();
		
		callback( tile );
		
		// Add tile children to array to be processed later
		if ( tile.children )
		{
			tilesToProcess.push( tile.children[0] );
			tilesToProcess.push( tile.children[1] );
			tilesToProcess.push( tile.children[2] );
			tilesToProcess.push( tile.children[3] );
		}
	}
}

/**************************************************************************************************************/

/**
	Traverse tiless tiles
 */
 TileManager.prototype.traverseTiles = function()
 {		
	this.tilesToRender.length = 0;
	this.visibleTiles.length = 0;
	this.tilesToRequest.length = 0;
	this.numTraversedTiles = 0;
	
	// First load level 0 tiles if needed
	if ( !this.level0TilesLoaded )
	{
		this.level0TilesLoaded = true;
		for ( var i = 0; i < this.level0Tiles.length; i++ )
		{
			var tile = this.level0Tiles[i];
			var tileIsLoaded = tile.state == Tile.State.LOADED;
			
			// Update frame number
			tile.frameNumber = this.frameNumber;
			
			this.level0TilesLoaded = this.level0TilesLoaded && tileIsLoaded;
			if ( !tileIsLoaded )
			{		
				// Request tile if necessary
				if ( tile.state == Tile.State.NONE )
				{
					tile.state = Tile.State.REQUESTED;
					this.tilesToRequest.push(tile);
				}
				else if ( tile.state == Tile.State.ERROR && this.imageryProvider )
				{
					this.parent.publish("baseLayersError", this.imageryProvider);
					this.imageryProvider._ready = false;
				}
			}
		}
		if ( this.level0TilesLoaded && this.imageryProvider  )
		{
			this.parent.publish("baseLayersReady");
		}
	}
	
	// Traverse tiles
	if ( this.level0TilesLoaded )
	{
		// Normal traversal, iterate through level zero tiles and process them recursively
		for ( var i = 0; i < this.level0Tiles.length; i++ )
		{
			var tile = this.level0Tiles[i];
			if ( !tile.isCulled(this.renderContext) )
			{
				this.processTile(tile,0);
			}
			else 
			{
				// Delete its children
				tile.deleteChildren(this.renderContext,this.tilePool);
			}
		}
	}
}

/**************************************************************************************************************/

/**
	Process a tile
 */
TileManager.prototype.processTile = function(tile,level)
{
	this.numTraversedTiles++;
	
	// Update frame number
	tile.frameNumber = this.frameNumber;
	
	var isLeaf = true;

	// Request the tile if needed
	if ( tile.state == Tile.State.NONE )
	{
		tile.state = Tile.State.REQUESTED;
		
		// Add it to the request
		this.tilesToRequest.push(tile);
	}
		
	// Check if the tiles needs to be refined
	// We only refine loaded tile
	if ( tile.state == Tile.State.LOADED  )
	{
		if ( this.imageryProvider )
		{
			isLeaf = level >= this.imageryProvider.numberOfLevels;
		}
		else
		{
			isLeaf = false;
		}
		
		isLeaf |= !tile.needsToBeRefined( this.renderContext );
	}
	
	if ( isLeaf )
	{
		// Push the tiles to render only if the texture is valid
		if ( tile.texture )
		{
			this.tilesToRender.push( tile );
		}
		this.visibleTiles.push( tile );
	}
	else
	{
		// Create the children if needed
		if ( tile.children == null )
		{
			tile.createChildren();
		}
		
		for ( var i = 0; i < 4; i++ )
		{
			if (!tile.children[i].isCulled(this.renderContext))
			{
				this.processTile(tile.children[i],level+1);
			}
			else
			{
				tile.children[i].deleteChildren(this.renderContext,this.tilePool);
			}
		}
	}
	
	// Traverse extension
	for ( var x in tile.extension ) 
	{
		var e = tile.extension[x];
		if ( e.traverse ) e.traverse(tile,isLeaf);
	}
}

/**************************************************************************************************************/

/**
	Generate tiles
 */
 TileManager.prototype.generateReceivedTiles = function()
 {
	while ( this.completedRequests.length > 0 )
	{
		var tileRequest = this.completedRequests.pop();
		var tile = tileRequest.tile;
		if ( tile.frameNumber == this.frameNumber )
		{
			// Generate the tile using data from tileRequest
			tile.generate( this.tilePool, tileRequest.image, tileRequest.elevations );

			// Now post renderers can generate their data on the new tile
			for (var i=0; i < this.postRenderers.length; i++ )
			{
				if ( this.postRenderers[i].generate )
					this.postRenderers[i].generate(tile);
			}
			
			this.numTilesGenerated++;
			this.renderContext.requestFrame();
		}
		else
		{
			tile.state = Tile.State.NONE;			
		}
		this.availableRequests.push(tileRequest);
	}
	
	// All requests have been processed, send endBackgroundLoad event
	if ( this.availableRequests.length == this.maxRequests && this.imageryProvider )
		this.parent.publish("endBackgroundLoad");

}

/**************************************************************************************************************/

/**
	Render tiles
 */
 TileManager.prototype.renderTiles = function()
 {
	var rc = this.renderContext;
	var gl = rc.gl;
	
	// Compute near/far from tiles
	var nr;
	var fr;
	if ( this.tileConfig.cullSign < 0 )
	{
		// When in "Astro" mode, do not compute near/far from tiles not really needed
		// And the code used for "Earth" does not works really well, when the earth is seen from inside...
		nr = 0.2 * CoordinateSystem.radius;
		fr = 1.1 * CoordinateSystem.radius;
	}
	else
	{
		nr = 1e9;
		fr = 0.0;
		for ( var i = 0; i < this.visibleTiles.length; i++ )
		{
			var tile = this.visibleTiles[i];
			// Update near/far to take into account the tile
			nr = Math.min( nr, tile.distance - 1.5 * tile.radius );
			fr = Math.max( fr, tile.distance + 1.5 * tile.radius );
		}
	}
	rc.near = Math.max( rc.minNear, nr );
	rc.far = fr;

	if ( this.tilesToRender.length != 0 )
	{
		// Set state (depends if geo or astro)
		if ( this.tileConfig.cullSign < 0 )
		{
			gl.depthMask(false);
			gl.disable(gl.DEPTH_TEST);
			gl.disable(gl.CULL_FACE);
		}
		else
		{
			gl.enable(gl.POLYGON_OFFSET_FILL);
			gl.polygonOffset(0,4);
		}
		
		// Check if the program of imagery provider changed
		// Only for fragment shader for now
		if ( this.currentFragmentShader && this.currentFragmentShader != this.imageryProvider.customShader.fragmentCode )
		{
			this.program.dispose();
			this.program = new Program(this.renderContext);

			if ( this.imageryProvider.customShader )
			{
				this.currentFragmentShader = this.imageryProvider.customShader.fragmentCode ? this.imageryProvider.customShader.fragmentCode : this.fragmentShader;
				this.program.createFromSource( this.imageryProvider.customShader.vertexShader ? this.imageryProvider.customShader.vertexShader : this.vertexShader,
											   this.currentFragmentShader );
			}
		}

		// Setup program
		this.program.apply();
		
		var attributes = this.program.attributes;
			
		// Update projection matrix with new near and far values
		mat4.perspective(rc.fov, rc.canvas.width / rc.canvas.height, rc.near, rc.far, rc.projectionMatrix);

		// Update uniforms if needed
		if ( this.imageryProvider.customShader )
			this.imageryProvider.customShader.updateUniforms(gl, this.program);

		// Setup state
		gl.activeTexture(gl.TEXTURE0);
		gl.uniformMatrix4fv(this.program.uniforms["projectionMatrix"], false, rc.projectionMatrix);
		gl.uniform1i(this.program.uniforms["colorTexture"], 0);
		
		// Bind the texture coordinate buffer (shared between all tiles
		if ( !this.tcoordBuffer )
			this.buildSharedTexCoordBuffer();
		gl.bindBuffer(gl.ARRAY_BUFFER, this.tcoordBuffer);
		gl.vertexAttribPointer(attributes['tcoord'], 2, gl.FLOAT, false, 0, 0);
		
		var currentIB = null;
		
		for ( var i = 0; i < this.tilesToRender.length; i++ )
		{
			var tile = this.tilesToRender[i];
			
			var isLoaded = ( tile.state == Tile.State.LOADED );
			var isLevelZero = ( tile.parentIndex == -1 );
			
			// Bind tile texture
			gl.bindTexture(gl.TEXTURE_2D, tile.texture);

			// Update uniforms for modelview matrix
			mat4.multiply( rc.viewMatrix, tile.matrix, rc.modelViewMatrix );
			gl.uniformMatrix4fv(this.program.uniforms["modelViewMatrix"], false, rc.modelViewMatrix);
		
			// Bind the vertex buffer
			gl.bindBuffer(gl.ARRAY_BUFFER, tile.vertexBuffer);
			gl.vertexAttribPointer(attributes['vertex'], 3, gl.FLOAT, false, 4*this.tileConfig.vertexSize, 0);
			if (this.tileConfig.normals)
				gl.vertexAttribPointer(attributes['normal'], 3, gl.FLOAT, false, 4*this.tileConfig.vertexSize, 12);
					
			var indexBuffer = ( isLoaded || isLevelZero ) ? this.tileIndexBuffer.getSolid() : this.tileIndexBuffer.getSubSolid(tile.parentIndex);
			// Bind the index buffer only if different (index buffer is shared between tiles)
			if ( currentIB != indexBuffer )
			{	
				gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
				currentIB = indexBuffer;
			}
			
			// Finally draw the tiles
			gl.drawElements(gl.TRIANGLES, currentIB.numIndices, gl.UNSIGNED_SHORT, 0);
		}
		
		if ( this.tileConfig.cullSign < 0 )
		{
			gl.depthMask(true);
			gl.enable(gl.DEPTH_TEST);
		}
		else		
		{
			gl.disable(gl.POLYGON_OFFSET_FILL);
		}
	}
	
	for (var i=0; i < this.postRenderers.length; i++ )
	{
		this.postRenderers[i].render( this.visibleTiles );
	}
}

// Internal function to sort tiles
var _sortTilesByDistance = function(t1,t2)
{
	return t1.distance - t2.distance;
};

/**************************************************************************************************************/

/**
	Request tiles
 */
 TileManager.prototype.launchRequests = function()
 {
	// Process request
	this.tilesToRequest.sort( _sortTilesByDistance );
	
	var trl = this.tilesToRequest.length; 
	for ( var i = 0; i < trl; i++ )
	{
		var tile = this.tilesToRequest[i];
		if ( this.availableRequests.length > 0 ) // Check to limit the number of requests done per frame
		{
			// First launch request, send an event
			if ( this.availableRequests.length == this.maxRequests && this.imageryProvider )
				this.parent.publish("startBackgroundLoad");
			
			var tileRequest = this.availableRequests.pop();
			tileRequest.launch( tile );
		}
		else
		{
			tile.state = Tile.State.NONE;
		}
	}
}

/**************************************************************************************************************/

/**
	Render the tiles
 */
TileManager.prototype.render = function()
{
	if ( this.imageryProvider && !this.imageryProvider._ready )
	{
		return;
	}
	
	// Specific case when the image provider has a level zero image : generate the texture for each level zero tile
	if ( !this.level0TilesLoaded && this.imageryProvider && this.imageryProvider.levelZeroImage )
	{
		this.imageryProvider.generateLevel0Textures( this.level0Tiles, this.tilePool );
		
		for (var n = 0; n < this.level0Tiles.length; n++ )
		{
			var tile = this.level0Tiles[n];
			// Generate the tile
			tile.generate( this.tilePool );

			// Now post renderers can generate their data on the new tile
			for (var i = 0; i < this.postRenderers.length; i++ )
			{
				if ( this.postRenderers[i].generate )
					this.postRenderers[i].generate(tile);
			}
		}

		this.level0TilesLoaded = true;
		this.parent.publish("baseLayersReady");
	}

	var stats = this.renderContext.stats;
	
	if (!this.freeze)
	{
		if (stats) stats.start("traverseTime");
		this.traverseTiles();
		if (stats) stats.end("traverseTime");
	}

	if ( this.level0TilesLoaded )
	{
		if (stats) stats.start("renderTime");
		this.renderTiles();
		if (stats) stats.end("renderTime");
	}
	
	if (stats) stats.start("generateTime");
	this.generateReceivedTiles();
	if (stats) stats.end("generateTime");
	
	if (stats) stats.start("requestTime");
	this.launchRequests();
	if (stats) stats.end("requestTime");
		
	this.frameNumber++;
}

/**************************************************************************************************************/

/**
	Returns visible tile for given longitude/latitude, null otherwise
 */
TileManager.prototype.getVisibleTile = function(lon, lat)
{
	return this.tiling.findInsideTile(lon, lat, this.visibleTiles);
}

/**************************************************************************************************************/

/**
	Build shared texture coordinate buffer
 */
TileManager.prototype.buildSharedTexCoordBuffer = function()
{
	var size = this.tileConfig.tesselation;
	var skirt = this.tileConfig.skirt;
	var bufferSize = 2*size*size;
	if (skirt)
		bufferSize += 2*size*6;

	var tcoords = new Float32Array( bufferSize );

	var step = 1.0 / (size-1);
	
	var offset = 0;
	var v = 0.0;
	for ( var j=0; j < size; j++)
	{
		var u = 0.0;
		for ( var i=0; i < size; i++)
		{
			tcoords[offset] = u;
			tcoords[offset+1] = v;

			offset += 2;
			u += step;
		}
		
		v += step;
	}
	
	if ( skirt )
	{
		// Top skirt
		u = 0.0;
		v = 0.0;
		for ( var i=0; i < size; i++)
		{
			tcoords[offset] = u;
			tcoords[offset+1] = v;
			u += step;
			offset += 2;
		}
		// Bottom skirt
		u = 0.0;
		v = 1.0;
		for ( var i=0; i < size; i++)
		{
			tcoords[offset] = u;
			tcoords[offset+1] = v;
			u += step;
			offset += 2;
		}
		// Left skirt
		u = 0.0;
		v = 0.0;
		for ( var i=0; i < size; i++)
		{
			tcoords[offset] = u;
			tcoords[offset+1] = v;
			v += step;
			offset += 2;
		}
		// Right skirt
		u = 1.0;
		v = 0.0;
		for ( var i=0; i < size; i++)
		{
			tcoords[offset] = u;
			tcoords[offset+1] = v;
			v += step;
			offset += 2;
		}
		
		// Center skirt
		u = 0.0;
		v = 0.5;
		for ( var i=0; i < size; i++)
		{
			tcoords[offset] = u;
			tcoords[offset+1] = v;
			u += step;
			offset += 2;
		}
		
		// Middle skirt
		u = 0.5;
		v = 0.0;
		for ( var i=0; i < size; i++)
		{
			tcoords[offset] = u;
			tcoords[offset+1] = v;
			v += step;
			offset += 2;
		}
	}
	
	var gl = this.renderContext.gl;
	var tcb = gl.createBuffer();
	gl.bindBuffer(gl.ARRAY_BUFFER, tcb);
	gl.bufferData(gl.ARRAY_BUFFER, tcoords, gl.STATIC_DRAW);
	
	this.tcoordBuffer = tcb;
}

/**************************************************************************************************************/

return TileManager;

});
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('gw/VectorRendererManager',[], function() {

/**************************************************************************************************************/

/** @constructor
	VectorRenderererManager constructor
 */
var VectorRendererManager = function(globe)
{
	// Create the registered renderers
	this.renderers = [];
	for ( var i = 0; i < VectorRendererManager.factory.length; i++ )
	{
		this.renderers.push( VectorRendererManager.factory[i](globe) );
	}
	
	// The array of renderables used during rendering
	this.renderables = [];
	
	// To uniquely identify buckets created by the renderers
	this.bucketId = 0;
}

/**************************************************************************************************************/

/**
	The factory for renderers
 */
VectorRendererManager.factory = [];

/**************************************************************************************************************/

/**
	Get a renderer
 */
VectorRendererManager.prototype.getRenderer = function(geometry,style)
{
	for ( var i = 0; i < this.renderers.length; i++ )
	{
		if ( this.renderers[i].canApply(geometry.type,style) )
		{
			return this.renderers[i];
		}
	}
	
	return null;
}

/**************************************************************************************************************/

/**
 *	Generate the tile data
 */
VectorRendererManager.prototype.generate = function(tile)
{
	if ( !tile.parent )
	{
		for ( var i=0; i < this.renderers.length; i++ )
		{
			this.renderers[i].generateLevelZero(tile);
		}
	}
	else
	{
		var tileData = tile.parent.extension.renderer;
		if ( tileData )
		{
			// delete renderer created at init time
			delete tile.extension.renderer;
			
			// Now generate renderables
			for ( var i = 0; i < tileData.renderables.length; i++ )
			{
				var renderable = tileData.renderables[i];
				if ( renderable.generateChild )
				{
					renderable.generateChild( tile );
				}
			}
		}
	}
}

/**************************************************************************************************************/

/**
 	Add a geometry to the renderer
 */
VectorRendererManager.prototype.addGeometry = function(layer, geometry, style)
{
	var renderer = this.getRenderer(geometry,style);
	renderer.addGeometry(layer, geometry, style);
}

/**************************************************************************************************************/

/**
 	Remove a geometry from the renderer
 */
VectorRendererManager.prototype.removeGeometry = function(geometry)
{
	var bucket = geometry._bucket;
	if ( bucket )
	{
		bucket.renderer.removeGeometry(geometry);
	}
}

/**************************************************************************************************************/

/**
	Add a geometry to a tile
 */
VectorRendererManager.prototype.addGeometryToTile = function(layer, geometry, style, tile)
{
	var renderer = this.getRenderer(geometry,style);
	renderer.addGeometryToTile(layer, geometry, style, tile);
}
	

/**************************************************************************************************************/

/**
	Remove a geometry from a tile
 */
VectorRendererManager.prototype.removeGeometryFromTile = function(geometry,tile)
{
	var bucket = geometry._bucket;
	bucket.renderer.removeGeometryFromTile(geometry,tile);
}


/**************************************************************************************************************/

/**
	Function to sort with zIndex, then bucket
 */
var renderableSort = function(r1,r2)
{
	var zdiff = r1.bucket.style.zIndex - r2.bucket.style.zIndex;
	if ( zdiff == 0 )
		return r1.bucket.id - r2.bucket.id;
	else
		return zdiff;
};

/**************************************************************************************************************/

/**
	Render all
 */
VectorRendererManager.prototype.render = function()
{
	// Add main renderables
	for ( var j = 0; j < this.renderers.length; j++ )
	{
		var buckets = this.renderers[j].buckets;
		for ( var i = 0; i < buckets.length; i++ )
		{
			if ( buckets[i].layer._visible && buckets[i].mainRenderable )
			{
				this.renderables.push( buckets[i].mainRenderable );
			}
		}
	}
	
	// Renderable sort
	this.renderables.sort( renderableSort );
	
	//var renderCall = 0;
	
	var i = 0;
	while ( i < this.renderables.length )
	{
		var j = i + 1;
		
		var currentRenderer = this.renderables[i].bucket.renderer;
		while ( j < this.renderables.length && this.renderables[j].bucket.renderer == currentRenderer )
		{
			j++;
		}
		currentRenderer.render( this.renderables, i, j );
		//renderCall++;
		
		i = j;
	}
	
	//console.log( "# of render calls "  + renderCall );
	
	this.renderables.length = 0;
}

/**************************************************************************************************************/

return VectorRendererManager;

});
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

 define('gw/GeoBound',[], function() {
 
/**************************************************************************************************************/

/** @constructor
	@export
	GeoBound constructor
 */
var GeoBound = function( w, s, e, n )
{
	this.south = s;
	this.west = w;
	this.north = n;
	this.east = e;
}

/**************************************************************************************************************/

/**
	Get geo center
 */
GeoBound.prototype.getCenter = function()
{
	return [ (this.east+this.west)*0.5, (this.south+this.north)*0.5, 0.0 ];
}

/**************************************************************************************************************/

/**	@export
	Get north
 */
GeoBound.prototype.getNorth = function()
{
	return this.north;
}

/**************************************************************************************************************/

/**	@export
	Get south
 */
GeoBound.prototype.getSouth = function()
{
	return this.south;
}

/**************************************************************************************************************/

/**	@export
	Get west
 */
GeoBound.prototype.getWest = function()
{
	return this.west;
}

/**************************************************************************************************************/

/**	@export
	Get east
 */
GeoBound.prototype.getEast = function()
{
	return this.east;
}

/**************************************************************************************************************/

/**
	Compute the geo bound from coordinates
 */
GeoBound.prototype.computeFromCoordinates = function( coordinates )
{
	this.west = coordinates[0][0];
	this.east = coordinates[0][0];
	this.south = coordinates[0][1];
	this.north = coordinates[0][1];
	
	for ( var i = 1; i < coordinates.length; i++ )
	{
		this.west = Math.min( this.west, coordinates[i][0] );
		this.east = Math.max( this.east, coordinates[i][0] );
		this.south = Math.min( this.south, coordinates[i][1] );
		this.north = Math.max( this.north, coordinates[i][1] );
	}
}

/**************************************************************************************************************/

/**
	Intersects this geo bound with another one
 */
GeoBound.prototype.intersects = function( geoBound )
{
	if ( this.west >= geoBound.east || this.east <= geoBound.west )
		return false;
		
	if ( this.south >= geoBound.north || this.north <= geoBound.south )
		return false;
		
	return true;
}

/**************************************************************************************************************/

return GeoBound;

});

/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

 define('gw/Event',[], function() {

/**************************************************************************************************************/

/** 
	@name Event
	@class
	A light-weight event object.
 */
var Event = function()
{	
	// Event callbacks
	this.callbacks = {};
}

/**************************************************************************************************************/

/** 
	Subscribe to an event
	
	@param name Event name
		<ul>
			<li>startNavigation : called when navigation is started (by the user or through animation)</li>
			<li>endNavigation : called when navigation is ended (by the user or through animation)t</li>
			<li>baseLayersReady : called when the base layers are ready to be displayed</li>
			<li>baseLayersError : called when the base layers are not valid, or not accessible, in that case nothing is displayed so this event is useful to provide an error message to the user</li>
			<li>startBackgroundLoad : called when background layers (imagery and/or elevation) start to be loaded</li>
			<li>endBackgroundLoad : called when background layers (imagery and/or elevation) end loading</li>
			<li>startLoad : called when a layer start to be loaded</li>
			<li>endLoad : called whena layer end loading</li>
		</ul>
	@param callback Callback function
*/
Event.prototype.subscribe = function(name,callback)
{
	if ( !this.callbacks[name] ) {
		this.callbacks[name] = [ callback ];
	} else {
		this.callbacks[name].push( callback );
	}
}

/**************************************************************************************************************/

/** 
	Unsubscribe to an event 
	
	@param name Event name {@link Globe#subscribe}
	@param callback Callback function
*/
Event.prototype.unsubscribe = function(name,callback)
{
	if( this.callbacks[name] ) {
		var i = this.callbacks[name].indexOf( callback );
		if ( i != -1 ) {
			this.callbacks[name].splice(i,1);
		}
	}
}

/**************************************************************************************************************/

/**
	Publish an event
	
	@param name Event name
	@param context Context
	
	@private
*/
Event.prototype.publish = function(name,context)
{
	if ( this.callbacks[name] ) {
		var cbs = this.callbacks[name];
		for ( var i = 0; i < cbs.length; i++ ) {
			cbs[i](context);
		}
	}
}

/**************************************************************************************************************/

return Event;

});

/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/
 
 define ('gw/Utils',[], function() {
 
 var Utils = {};
 
 /** 
  * Inherits from an object
  */
Utils.inherits = function(base, sub) 
{
	function tempCtor() {}
	tempCtor.prototype = base.prototype;
	sub.prototype = new tempCtor();
	sub.prototype.constructor = sub;
}

return Utils;

});

/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

 define('gw/Sky',['./CoordinateSystem', './RenderContext', './TileManager', './TilePool', './Tile', './VectorRendererManager', './Numeric', './GeoBound', './Event', './Utils' ], 
	function(CoordinateSystem, RenderContext, TileManager, TilePool, Tile, VectorRendererManager, Numeric, GeoBound, Event, Utils) {

/**************************************************************************************************************/

/** 
	@name Sky
	@class
	Create a virtual sky in a HTML canvas element, passed in options parameter.
	The virtual sky data is set using setBaseImage/addLayer methods.
	
	@param options Configuration properties for the Sky :
		<ul>
			<li>canvas : the canvas for WebGL, can be string (id) or a canvas element</li>
			<li>backgroundColor : the background color of the canvas (an array of 4 floats)</li>
			<li>shadersPath : the path to shaders file</li>
			<li>continuousRendering: if true rendering is done continuously, otherwise it is done only if needed</li>
		</ul>
	
 */
var Sky = function(options)
{
	Event.prototype.constructor.call( this );

	this.renderContext = new RenderContext(options);
	this.tilePool =  new TilePool(this.renderContext);
	this.tileManagers = {
		'EQ': new TileManager( this ),
		'GAL': new TileManager( this )
	};
	// Default tile manager is in equatorial coord sys
	this.tileManager = this.tileManagers['EQ'];
	this.vectorRendererManager = new VectorRendererManager( this );
	this.attributionHandler = null;
	this.baseImagery = null;
	this.nbCreatedLayers = 0;
	
	this.tileManager.addPostRenderer( this.vectorRendererManager );
	
	this.renderContext.renderer = this;
	this.renderContext.requestFrame();
}

/**************************************************************************************************************/

Utils.inherits( Event, Sky );


/**************************************************************************************************************/

/** 
  Refresh rendering, must be called when canvas size is modified
 */
Sky.prototype.refresh = function()
{
	this.renderContext.requestFrame();
}

/**************************************************************************************************************/

/** 
  Set the base imagery layer for the sky
  
  @param {RasterLayer} layer the layer to use, must be an imagery RasterLayer
*/
Sky.prototype.setBaseImagery = function(layer)
{
	if ( this.baseImagery == layer )
		return;
		
	if ( this.baseImagery ) 
	{
		this.removeLayer( this.baseImagery );	
		this.tileManagers[ this.baseImagery.coordSystem ].setImageryProvider(null);
		this.baseImagery = null;		
	}
	
	// Attach the layer to the globe 
	if ( layer )
	{
		layer._overlay = false;
		this.addLayer(layer);
		
		// Modify the tile manager after the layer has been attached
		this.tileManagers[ layer.coordSystem ].setImageryProvider( layer );
		this.baseImagery = layer;
	}
	
}

/**************************************************************************************************************/

/** 
  Add a layer to the globe.
  A layer must be added to be visualized on the globe.
  
  @param layer the layer to add
*/
Sky.prototype.addLayer = function(layer)
{
	layer.id = this.nbCreatedLayers;
	layer._attach(this);
	this.renderContext.requestFrame();
	this.nbCreatedLayers++;
}

/**************************************************************************************************************/

/** 
  Remove a layer
  
  @param layer the layer to remove
*/
Sky.prototype.removeLayer = function(layer)
{
	layer._detach();
	this.renderContext.requestFrame();
}

/**************************************************************************************************************/

/** 
  Add an animation
  
  @param anim the animation to add
*/
Sky.prototype.addAnimation = function(anim)
{
	anim.renderContext = this.renderContext;
}

/**************************************************************************************************************/

/** 
  Remove an animation
  
  @param anim the animation to remove
*/
Sky.prototype.removeAnimation = function(anim)
{
	anim.renderContext = null;
}

/**************************************************************************************************************/

/** 
	Get the viewport geo bound

	@param transformCallback
		Callback transforming the frustum/globe intersection coordinates if needed

    @return the geo bound of the viewport
*/
Sky.prototype.getViewportGeoBound = function(transformCallback)
{
	var rc = this.renderContext;
	var tmpMat = mat4.create();
	
	// Compute eye in world space
	mat4.inverse(rc.viewMatrix, tmpMat);
	var eye = [tmpMat[12], tmpMat[13], tmpMat[14]];
	
	// Compute the inverse of view/proj matrix
	mat4.multiply(rc.projectionMatrix, rc.viewMatrix, tmpMat);
	mat4.inverse(tmpMat);
	
	// Transform the four corners of the frustum into world space
	// and then for each corner compute the intersection of ray starting from the eye with the earth
	var points = [ [ -1, -1, 1, 1 ], [ 1, -1, 1, 1 ], [ -1, 1, 1, 1 ], [ 1, 1, 1, 1 ] ];
	var tmpPt = vec3.create();
	var earthCenter = [ 0, 0, 0 ];
	for ( var i = 0; i < 4; i++ )
	{
		mat4.multiplyVec4( tmpMat, points[i] );
		vec3.scale( points[i], 1.0 / points[i][3] );
		vec3.subtract(points[i], eye, points[i]);
		vec3.normalize( points[i] );
		
		var t = Numeric.raySphereIntersection( eye, points[i], earthCenter, CoordinateSystem.radius);
		if ( t < 0.0 )
			return null;
			
		points[i] = CoordinateSystem.from3DToGeo( Numeric.pointOnRay(eye, points[i], t, tmpPt) );
		if (transformCallback) 
		{
			points[i] = transformCallback(points[i]);
		}
	}

	var geoBound = new GeoBound();
	geoBound.computeFromCoordinates( points );

	return geoBound;
}

/**************************************************************************************************************/

/** 
	Get the lon-lat from a pixel.
	The pixel is expressed in the canvas frame, i.e. (0,0) corresponds to the lower-left corner of the pixel
	
	@param 	x the pixel x coordinate
	@param 	y the pixel y coordinate
	@return	an array of two numbers [lon,lat] or null if the pixel is not on the globe
 */
Sky.prototype.getLonLatFromPixel = function(x,y)
{	
	var pos3d = this.renderContext.get3DFromPixel(x,y);
	if ( pos3d )
	{
		return CoordinateSystem.from3DToGeo(pos3d);
	}
	else
	{
		return null;
	}
}

/**************************************************************************************************************/

/** 
	Get pixel from lon-lat
	The pixel is expressed in the canvas frame, i.e. (0,0) corresponds to the lower-left corner of the pixel
	
	@param lon	the longitude
	@param lat	the latitude
	@return	an array of two numbers [x,y] or null if the pixel is not on the globe
 */
Sky.prototype.getPixelFromLonLat = function(lon,lat)
{	
	var pos3d = vec3.create();
	CoordinateSystem.fromGeoTo3D([lon,lat], pos3d);
	var pixel = this.renderContext.getPixelFrom3D(pos3d[0],pos3d[1],pos3d[2]);
	return pixel
}

/**************************************************************************************************************/

/**
	Render the globe
	TODO : private for now because it is automatically called in requestAnimationFrame.
	@private
 */
Sky.prototype.render = function()
{		
	// Render tiles manager
	this.tileManagers['GAL'].render();
	this.tileManagers['EQ'].render();
}

/**************************************************************************************************************/

/**
	Display some render statistics
	@private
 */
Sky.prototype.getRenderStats = function()
{
	return "# rendered tiles : " + this.tileManager.tilesToRender.length;
}

/**************************************************************************************************************/

return Sky;

});

/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

 define('gw/Stats',[], function() {
 
/**************************************************************************************************************/

/** 
	@name Stats
	@class
	Display some rendering statistics in a HTML element
	@param options Configuration properties for Stats.
		<ul>
			<li>element : the HTML element to receivce statistcs, can be a string (the ID) or the DOM element itself</li>
			<li>verbose : the verbosity of the stats, default is false</li>
		</ul>
 */
var Stats = function(renderContext,options)
{
	renderContext.stats = this;
	this.renderContext = renderContext;
	
	var elt = options ? options['element'] : undefined;
	if ( elt )
	{	
		if (typeof elt == "string") 
		{
			this.element = document.getElementById(elt);
		}
		else
		{
			this.element = elt;
		}
	}
	
	this.showFPS = this.renderContext.continuousRendering;
	this.verbose = options && options['verbose'] ? options['verbose'] : false;
	this.numFrames = 0;
	
	var self = this;
	window.setInterval( function() { self.print(); }, 1000 );
}

/**************************************************************************************************************/

/** 
	Start measuring time
 */
Stats.prototype.start = function(name)
{
	this[name] = Date.now();
}

/**************************************************************************************************************/

/** 
	End measuring time
 */
Stats.prototype.end = function(name)
{
	var time = Date.now() - this[name];
	
	var max = this["max_"+name] || -1; 
	if (max < time) max = time;
	
	var sum = this["sum_"+name] || 0; 
	sum += time;
	
	this[name] = time;
	this["max_"+name] = max;
	this["sum_"+name] = sum;
	
	if ( name == "globalRenderTime" )
	{
		this.numFrames++;
	}
}

/**************************************************************************************************************/

/** 
	Print stats in an HTML element
 */
Stats.prototype.print = function()
{
	if ( this.numFrames > 0 )
	{
		var content = "";
		
		if ( this.showFPS )
		{
			content += "FPS : " + this.numFrames + "<br>";
		}
		
		content += "Average render time : " + (this["sum_globalRenderTime"] / this.numFrames).toFixed(2) + " ms";
		if ( this.renderContext.renderer.getRenderStats )
			content += "<br>" + this.renderContext.renderer.getRenderStats();
		
		if ( this.verbose )
		{
			content += "<br>Average traverse tiles time : " + (this["sum_traverseTime"] / this.numFrames).toFixed(2) + " ms";
			content += "<br>Average render tiles time : " + (this["sum_renderTime"] / this.numFrames).toFixed(2) + " ms";
			content += "<br>Average generate tiles time : " + (this["sum_generateTime"] / this.numFrames).toFixed(2) + " ms";
			content += "<br>Average request tiles time : " + (this["sum_requestTime"] / this.numFrames).toFixed(2) + " ms";
			content += "<br>Max render time : " + this["max_globalRenderTime"] + " ms";
			content += "<br>Max traverse tiles time : " + this["max_traverseTime"] + " ms";
			content += "<br>Max render tiles time : " + this["max_renderTime"] + " ms";
			content += "<br>Max generate tiles time : " + this["max_generateTime"]  + " ms";
			content += "<br>Max request tiles time : " + this["max_requestTime"] + " ms";
		}
		
		this.element.innerHTML = content;
		
		this["sum_globalRenderTime"] = 0;
		this["sum_traverseTime"] = 0;
		this["sum_renderTime"] = 0;
		this["sum_generateTime"] = 0;
		this["sum_requestTime"] = 0;
		this["max_globalRenderTime"] = 0;
		this["max_traverseTime"] = 0;
		this["max_renderTime"] = 0;
		this["max_generateTime"] = 0;
		this["max_requestTime"] = 0;
		this.numFrames = 0;
	}
}

/**************************************************************************************************************/

return Stats;

});

/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('gw/MouseNavigationHandler',[], function() {

/**************************************************************************************************************/

/** @export
	@constructor
	Mouse_navigationHandler constructor
	@param options Configuration properties for the Mouse_navigationHandler :
			<ul>
				<li>zoomOnDblClick : if true defines animation on double click</li>
			</ul>
 */
var MouseNavigationHandler = function(options){
	
	/**************************************************************************************************************/
	
	/**
 	 * Private variables
	 */
	 
	var _navigation = null;
	var _pressedButton = -1;
	var _lastMouseX = -1;
	var _lastMouseY = -1;
	var _dx = 0;
	var _dy = 0;
	var _panButton = (options && options.panButton) || 0;
	var _rotateButton = (options && options.rotateButton) || 1;

	/**************************************************************************************************************/
	
	/**
 	 * Private methods
	 */

	/**
		Event handler for mouse wheel
	 */
	var _handleMouseWheel = function(event)
	{	
		var factor;

		// Check differences between firefox and the rest of the world
		if ( event.wheelDelta === undefined)
		{
			factor = event.detail;
		}
		else
		{
			factor = -event.wheelDelta / 120.0;	
		}
		_navigation.zoom(factor);
		
		// Stop all animations when an event is received
		_navigation.stopAnimations();
		
		// Launch inertia if needed
		if ( _navigation.inertia )
		{
			_navigation.inertia.launch("zoom", factor < 0 ? -1 : 1 );
		}

		// Stop mouse wheel to be propagated, because default is to scroll the page
		// This is need when using Firefox event listener on DOMMouseScroll
		if ( event.preventDefault )
		{
			event.preventDefault();
		}
		event.returnValue = false;
					
		// Return false to stop mouse wheel to be propagated when using onmousewheel
		return false;
	};

	/**
	 * Event handler for mouse down
	 */
	var _handleMouseDown = function(event)
	{
		document.addEventListener("mouseup", _handleMouseUp);
		_pressedButton = event.button;
		
		// Stop all animations when an event is received
		_navigation.stopAnimations();

		if ( event.button == _panButton || event.button == _rotateButton )
		{		
			_lastMouseX = event.clientX;
			_lastMouseY = event.clientY;
			_dx = 0;
			_dy = 0;
						
			// Return false to stop mouse down to be propagated when using onmousedown
			return false;
		}
		
		return true;
	};

	/**
	 * Event handler for mouse up
	 */
	var _handleMouseUp = function(event)
	{
		// No button pressed anymore
		_pressedButton = -1;
		document.removeEventListener("mouseup", _handleMouseUp);

		if ( _navigation.inertia && (_dx != 0 || _dy != 0)  )
		{	
			if ( event.button == _panButton )
			{
				_navigation.inertia.launch("pan", _dx, _dy );
			
			}
			if ( event.button == _rotateButton )
			{
				_navigation.inertia.launch("rotate", _dx, _dy );
			}
		}

		if ( event.button == _panButton || event.button == _rotateButton )
		{
			event.preventDefault();
			
			// Stop mouse up event
			return false;
		}

		return true;
	};

	/**
		Event handler for mouse move
	*/
	var _handleMouseMove = function(event)
	{
		// No button pressed
		if (_pressedButton < 0)
			return;
		
		_dx = (event.clientX - _lastMouseX);
		_dy = (event.clientY - _lastMouseY);
		
		if ( _dx == 0 && _dy == 0 )
			return;
		
		var ret = false;
		// Pan
		if ( _pressedButton == _panButton )
		{
			_navigation.pan( _dx, _dy );
			ret = true;
		}
		// Rotate
		else if ( _pressedButton == _rotateButton )
		{
			_navigation.rotate(_dx,_dy);
			ret = true;
		}
		
		_lastMouseX = event.clientX;
		_lastMouseY = event.clientY;
		
		return ret;
	};

	/**
		Event handler for mouse double click
	 */
	var _handleMouseDblClick = function(event)
	{
		if (event.button == 0)
		{
			var pos = _navigation.globe.renderContext.getXYRelativeToCanvas(event);
			var geo = _navigation.globe.getLonLatFromPixel( pos[0], pos[1] );
		
			if (geo)
			{
				_navigation.zoomTo(geo);
			}
		}
	};

	/**************************************************************************************************************/
	
	 /**
	  * Public methods
	  */
			
	/** 
	 *	Setup the default event handlers for the _navigation
	 */
	this.install = function(nav)
	{
		_navigation = nav;
		
		var canvas = _navigation.renderContext.canvas;
		
		// Setup the mouse event handlers
		canvas.addEventListener("mousedown", _handleMouseDown);
		canvas.addEventListener("mousemove", _handleMouseMove);
		
		if ( options && options.zoomOnDblClick )
			canvas.addEventListener("dblclick", _handleMouseDblClick);
			
		// For Firefox
		canvas.addEventListener("DOMMouseScroll", _handleMouseWheel);
		canvas.addEventListener("mousewheel", _handleMouseWheel);
		
		// Fix for Google Chrome : avoid dragging
		// TODO : a hack, should be more robust (restore on uninstall?)
		canvas.addEventListener("dragstart", function(event){event.preventDefault(); return false;});

		if ( _rotateButton == 2 ) 
		{
			canvas.addEventListener("contextmenu", function(e) { e.preventDefault(); return false; }, false);
		}
	};

	/** 
	 *	Remove the default event handlers for the _navigation
	 */
	this.uninstall = function()
	{
		// Setup the mouse event handlers
		var canvas = _navigation.renderContext.canvas;

		canvas.removeEventListener("mousedown", _handleMouseDown);
		canvas.removeEventListener("mousemove", _handleMouseMove);
		
		if ( options && options.zoomOnDblClick )
			canvas.removeEventListener("dblclick", _handleMouseDblClick);
			
		// For Firefox
		canvas.removeEventListener("DOMMouseScroll", _handleMouseWheel);
		canvas.removeEventListener("mousewheel", _handleMouseWheel);
	};
};

return MouseNavigationHandler;

});

/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('gw/KeyboardNavigationHandler',[], function() {

/**************************************************************************************************************/

/** @export
	@constructor
	KeyboardNavigationHandler constructor
	@param options Configuration properties for the KeyboardNavigationHandler :
			<ul>
				<li>panFactor  : Factor for panning within the scene</li>
				<li>zoomFactor : Factor for zooming into the scene</li>
				<li>installOnDocument : True to install the event listener on the document and not on the canvas</li>
			</ul>
 */
var KeyboardNavigationHandler = function(options){
	
	/**************************************************************************************************************/
	
	/**
 	 * Private variables
	 */
	var _navigation = null;
	var self = this;
	
	/**
	 * Public variables
	 */
	this.panFactor = 10.;
	this.zoomFactor = 1.;
	
	// Setup options
	if ( options )
	{
		if ( options['panFactor'] && typeof options['panFactor'] == 'number' )
			this.panFactor = options['panFactor'];
		if ( options['zoomFactor'] && typeof options['zoomFactor'] == 'number' )
			this.zoomFactor = options['zoomFactor'];
	}
	
	/**************************************************************************************************************/
	
	/**
 	 * Private methods
	 */

	/**
	 * Set focus
	 */
	var _setFocus = function(event)
	{
		this.focus();
		return false;
	};
	  
	/**
	 *	Event handler for key down
	 */
	var _handleKeyDown = function(event)
	{
		switch( event.keyCode ){
			case 32 :
				// space bar
				// Stop all animations when an event is received
				_navigation.stopAnimations();
				break;
			case 187 :
				// + on Safari
			case 61 :
				// +(=) on Firefox and Opera
			case 107 :
				// + on other
				_navigation.zoom(-self.zoomFactor);
				break;
			case 189 :
				// - on Safari
			case 54 :
				// -(6) on Firefox and Opera
			case 109 :
				// - on other
				_navigation.zoom(self.zoomFactor);
				break;
			case 81 :
				// q
			case 37 :
				// Left arrow
				if ( event.shiftKey )
				{
					_navigation.rotate( self.panFactor, 0 );
				}
				else
				{
					_navigation.pan( self.panFactor, 0 );
				}
				break;
			case 90 :
				// z
			case 38 :
				// Up arrow
				if ( event.shiftKey )
				{
					_navigation.rotate( 0, self.panFactor );
				}
				else
				{

					_navigation.pan( 0, self.panFactor );
				}
				break;
			case 68 :
				// d
			case 39 :
				// Right arrow
				if ( event.shiftKey )
				{
					_navigation.rotate( -self.panFactor, 0 );
				}
				else
				{
					_navigation.pan( -self.panFactor, 0 );
				}
				break;
			case 83 :
				// s
			case 40 :
				// Down arrow
				if ( event.shiftKey )
				{
					_navigation.rotate( 0, -self.panFactor );
				}
				else
				{

					_navigation.pan( 0, -self.panFactor );
				}
				break;
		}
	};

	/**************************************************************************************************************/
	
	 /**
	  * Public methods
	  */

	/** 
		Setup the default event handlers for the navigation
	 */
	this.install = function(navigation)
	{
		// Setup the keyboard event handlers
		_navigation = navigation;
		
		if ( options && options.installOnDocument )
		{
			document.addEventListener("keydown", _handleKeyDown);
		}
		else
		{
			var canvas = _navigation.renderContext.canvas;
			canvas.addEventListener("keydown", _handleKeyDown);
			// Setup focus handling to receive keyboard event on canvas
			canvas.tabIndex = "0";
			canvas.addEventListener("mousedown", _setFocus);
		}
	};

	/** 
		Remove the default event handlers for the navigation
	 */
	this.uninstall = function()
	{	
		if ( options && options.installOnDocument )
		{
			document.removeEventListener("keydown", _handleKeyDown);
		}
		else
		{
			var canvas = _navigation.renderContext.canvas;
			canvas.removeEventListener("keydown", _handleKeyDown);
			canvas.removeEventListener("mousedown", _setFocus);
		}
	};
	
};

return KeyboardNavigationHandler;

});


/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

 define('gw/Animation',[], function() {
 
/**************************************************************************************************************/

/**	@constructor
	Base animation class
	Defines animation states (STOPPED, STARTED), animation base members
	and start() stop() functions.
*/
var Animation = function()
{
    this.startTime = -1;
	this.pauseTime = -1;
	this.renderContext = null;
}

/**************************************************************************************************************/

/**
  Unregister as active animation
*/
Animation.prototype._unregisterActive = function()
{
	var index = this.renderContext.activeAnimations.indexOf(this);
	this.renderContext.activeAnimations.splice(index,1);
}

/**************************************************************************************************************/

/**
  Get animation status
*/
Animation.prototype.getStatus = function()
{
	if ( this.startTime == -1 )
		return "STOPPED";
	else 
		return this.pauseTime == -1 ? "RUNNING" : "PAUSED";
}

/**************************************************************************************************************/

/** @export
	Start function, record the start time in startTime member
	and register the animation in the GlobWeb object.
*/
Animation.prototype.start = function()
{
	if ( !this.renderContext )
		return;
	
	if ( this.startTime == -1 || this.pauseTime != - 1 )
	{
 		var now = Date.now();
		if ( this.startTime == -1 )
		{
			this.startTime = now;
		}
		else
		{
			// resume after pause
			this.startTime += now - this.pauseTime;
			this.pauseTime = -1;
		}
		
		// Register animation as active
		this.renderContext.activeAnimations.push(this);
		this.renderContext.requestFrame();
	}
}

/**************************************************************************************************************/

/** @export
	Pause function
*/
Animation.prototype.pause = function()
{	
	if ( !this.renderContext )
		return;
		
	if ( this.startTime != -1 && this.pauseTime == -1 )
	{
		this.pauseTime = Date.now();
		this._unregisterActive(this);
	}
}

/**************************************************************************************************************/

/** @export
	Stop function, removes the animation from the GlobWeb object
*/
Animation.prototype.stop = function()
{
	this.startTime = -1;
	this.pauseTime = -1;
		
	if ( this.onstop )
		this.onstop();

    // Unregister animation
    this._unregisterActive(this);
}

/**************************************************************************************************************/

return Animation;

});
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

 define('gw/InertiaAnimation',['./Utils','./Animation'], function(Utils,Animation) {
 
/**************************************************************************************************************/

var epsilon = 0.1;

/**	@constructor
 *	Animation simulating inertia for camera navigation
 *
 *	@param nav Navigation
 *	@param options Configuration of navigation
 *			<ul>
 *				<li>panFactor : Pan factor</li>
 *				<li>rotateFactor : Rotate factor</li>
 *				<li>zoomFactor : Zoom factor</li>
 *			</ul>
 */
var InertiaAnimation = function(nav, options)
{
    Animation.prototype.constructor.call(this);

    if ( options )
    {
		this.panFactor = options.hasOwnProperty('panFactor') ? options['panFactor'] : 0.95;
		this.rotateFactor = options.hasOwnProperty('rotateFactor') ? options['rotateFactor'] : 0.95;
		this.zoomFactor = options.hasOwnProperty('zoomFactor') ? options['zoomFactor'] : 0.95;
	}

	this.type = null;
	this.dx = 0;
	this.dy = 0;
	this.navigation = nav;
	this.renderContext = nav.renderContext;
}

/**************************************************************************************************************/

Utils.inherits(Animation,InertiaAnimation);

/**************************************************************************************************************/

/**
 * Update inertia
 */
InertiaAnimation.prototype.update = function(now)
{
	var hasToStop = false;
	
	switch(this.type)
	{
		case "pan":
			this.navigation.pan(this.dx,this.dy);
			this.dx *= this.panFactor;
			this.dy *= this.panFactor;
			hasToStop = (Math.abs(this.dx) < epsilon && Math.abs(this.dy) < epsilon);
			break;
		case "rotate":
			this.navigation.rotate(this.dx,this.dy);
			this.dx *= this.rotateFactor;
			this.dy *= this.rotateFactor;
			hasToStop = (Math.abs(this.dx) < epsilon && Math.abs(this.dy) < epsilon);
			break;
		case "zoom":
			this.navigation.zoom(this.dx);
			this.dx *= this.zoomFactor;
			hasToStop = (Math.abs(this.dx) < epsilon);
			break;
		default:
	}
	this.navigation.renderContext.requestFrame();

	if ( hasToStop )
		this.stop();
}

/**************************************************************************************************************/

/**
 *	@param type Type of inertia
 *				<ul>
 *					<li>pan</li>
 *					<li>rotate</li>
 *					<li>zoom</li>
 *				</ul>
 *	@param speed Starting speed
 *	@param {Int[]} inertiaVector Vector of mouvement in window coordinates(for pan and rotate inertias)
 */
InertiaAnimation.prototype.launch = function(type, dx, dy)
{
	// Set first value
 	this.type = type;
	this.dx = dx;
	this.dy = dy;

	this.start();
}

/**************************************************************************************************************/

return InertiaAnimation;

});

/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('gw/BaseNavigation', ['./Utils', './Event', './MouseNavigationHandler', './KeyboardNavigationHandler', './InertiaAnimation' ], 
	function(Utils,Event,MouseNavigationHandler,KeyboardNavigationHandler,InertiaAnimation) {

/**************************************************************************************************************/

/** @name BaseNavigation
	@constructor
	Base class for navigation object

	@param renderContext Render context
	@param options Configuration options
		<ul>
			<li>handlers : Array of objects defining navigation events for different supports(mouse, keyboard..)</li>
			<li>inertia : Boolean for inertia effect</li>
			<li>panFactor : Pan factor</li>
			<li>rotateFactor : Rotate factor</li>
			<li>zoomFactor : Zoom factor</li>
		</ul>

 */
var BaseNavigation = function(renderContext, options)
{
	Event.prototype.constructor.call( this );
	
	this.renderContext = renderContext;

	// Create default handlers if none are created in options
	if ( options && options.handlers ) 
	{
		this.handlers = options.handlers;
	}
	else
	{
		this.handlers = [ new MouseNavigationHandler(options ? options.mouse : null), new KeyboardNavigationHandler(options ? options.keyboard : null) ];
	}
	
	// Inertia effect
	if( options && options.inertia )
	{
		this.inertia = new InertiaAnimation(this, options);
	}
	// ZoomTo animation
	this.zoomToAnimation = null;

	// Automatically start
	this.start();
}

/**************************************************************************************************************/

Utils.inherits( Event, BaseNavigation );

/**************************************************************************************************************/

/** @export
	Start the navigation
*/
BaseNavigation.prototype.start = function()
{
	// Install handlers
	for (var i=0; i<this.handlers.length; i++)
	{
		this.handlers[i].install(this);
	}
}

/**************************************************************************************************************/

/** @export
	Stop the navigation
*/
BaseNavigation.prototype.stop = function()
{
	// Uninstall handlers
	for (var i=0; i<this.handlers.length; i++)
	{
		this.handlers[i].uninstall();
	}
}

/**************************************************************************************************************/

/** @export
	Stop the animations running on the navigation
*/
BaseNavigation.prototype.stopAnimations = function()
{
	if ( this.inertia )
	{
		this.inertia.stop();
	}
	if( this.zoomToAnimation )
	{
		this.zoomToAnimation.stop();
		this.zoomToAnimation = null;
	}
}

/**************************************************************************************************************/

/** @export
	Get the field of view used by the navigation
	
	@return {Float[]} Fovx and fovy in degrees
*/
BaseNavigation.prototype.getFov = function()
{
	var aspect = this.renderContext.canvas.width / this.renderContext.canvas.height;
	return [ aspect * this.renderContext.fov, this.renderContext.fov ];
}

/**************************************************************************************************************/

return BaseNavigation;

});

/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

 define('gw/SegmentedAnimation',['./Utils','./Animation','./Numeric'], function(Utils,Animation,Numeric) {

/**************************************************************************************************************/

/** @constructor
  SegmentedAnimation is an animation defined with segments.
  Each segment has a [start,end] pair of 't' value and a [start,end] pair of
  values that will be interpolated with the interpolator set on the segment.
  When the animation runs, a t parameter is mapped to [0,1] according to
  current time and animation duration.
  The current segment is then looked up with that 't' value and used to interpolate
  the animation's current value.
 */
var SegmentedAnimation = function(duration, valueSetter)
{
    // Call ancestor constructor
    Animation.prototype.constructor.call(this);

    this.segments = [];
    this.duration = duration;
    this.valueSetter = valueSetter;
}

/**************************************************************************************************************/

Utils.inherits(Animation,SegmentedAnimation);

/**************************************************************************************************************/

/** @constructor
  Segment struct
*/
var Segment = function(start, startValue, end, endValue, interpolator)
{
    this.start = start;
    this.startValue = startValue;
    this.end = end;
    this.endValue = endValue;
    this.interpolator = interpolator;
}

/**************************************************************************************************************/

/*
	Adds a new segment to the animation.
	start, end are 't' values at which the segment will be the current segment
	startValue, endValue are animation values at 't'=start and 't'=end
	interpolator is the function that will be called to interpolate bewteen startValue and endValue.
*/
SegmentedAnimation.prototype.addSegment = function(start, startValue, end, endValue, interpolator)
{
    var count = this.segments.length;
    var index = 0;
    while (index < count && this.segments[index].end <= start) index++;
    // Insert new segment at position 'index'
    this.segments.splice(index, 0, new Segment(start, startValue, end, endValue, interpolator));
}

/**************************************************************************************************************/

/*
	Animation update method
*/
SegmentedAnimation.prototype.update = function(now)
{
    var t = Numeric.map01(now, this.startTime, this.startTime + this.duration);
    if (t >= 1)
    {
		 // Set last value
		var lastIndex = this.segments.length - 1;
		this.valueSetter(this.segments[lastIndex].endValue);
		this.stop();
    }
	else
	{
		// Find current segment
		var count = this.segments.length;
		var index = 0;
		while (index < count && this.segments[index].end < t) index++;
		index = Math.min(index, count-1);
		
		// Remap t between segment bounds
		t = Numeric.map01(t, this.segments[index].start, this.segments[index].end);
		// Interpolate value
		var value = this.segments[index].interpolator(t, this.segments[index].startValue, this.segments[index].endValue);
		// Use value
		this.valueSetter(value);
	}
}

/**************************************************************************************************************/

return SegmentedAnimation;

});

/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('gw/AstroNavigation',['./Utils', './CoordinateSystem', './BaseNavigation', './SegmentedAnimation', './Numeric', './glMatrix'], function(Utils,CoordinateSystem,BaseNavigation,SegmentedAnimation,Numeric) {

/**************************************************************************************************************/

/** @export
	@constructor
	Astronavigation constructor
	@param globe Globe
	@param options Configuration properties for the AstroNavigation :
		<ul>
			<li>minFov : The minimum field of view in degrees</li>
			<li>maxFov : The maximum field of view in degrees</li>
		</ul>
 */
var AstroNavigation = function(globe, options)
{
	BaseNavigation.prototype.constructor.call( this, globe.renderContext, options );
	
	this.globe = globe;
	
	// Default values for fov (in degrees)
	this.minFov = (options && options.minFov) || 0.001;
	this.maxFov = (options && options.maxFov) || 100;

	// Initialize the navigation
	this.center3d = [1.0, 0.0, 0.0];
	this.up = [0., 0., 1.];

	if ( options )
	{
		if ( options.initTarget ) {
			CoordinateSystem.fromGeoTo3D(options.initTarget, this.center3d );
		}

		if ( options.initFov ) {
			this.renderContext.fov = options.initFov;
			this._clampFov();
		}

		if ( options.up )
		{
			this.up = options.up;
		}
	}
		
	// Update the view matrix now
	this.computeViewMatrix();
}

/**************************************************************************************************************/

Utils.inherits( BaseNavigation, AstroNavigation );

/**************************************************************************************************************/

/** @export
	Zoom to a 3d position
	@param {Float[]} geoPos Array of two floats corresponding to final Longitude and Latitude(in this order) to zoom
	@param {Int} fov Final zooming fov in degrees
	@param {Int} duration Duration of animation in milliseconds
	@param {Function} callback Callback on the end of animation
 */
AstroNavigation.prototype.zoomTo = function(geoPos, fov, duration, callback)
{
	var navigation = this;
	
	// default values
	var destFov = fov || 2.0;
	duration = duration || 2000;
	
	// Create a single animation to animate center3d and fov
	var geoStart = [];
	var middleFov = 25.0;	// arbitrary middle fov value which determines if the animation needs two segments
	
	CoordinateSystem.from3DToGeo(this.center3d, geoStart);
	var startValue = [geoStart[0], geoStart[1], this.renderContext.fov];
	var endValue = [geoPos[0], geoPos[1], destFov];
	
	// Compute the shortest path if needed
	if (Math.abs(geoPos[0] - geoStart[0]) > 180. )
	{
		if (geoStart[0] < geoPos[0])
			startValue[0] += 360;
		else
			endValue[0] +=360;
	}
	var animation = new SegmentedAnimation(
		duration,
		// Value setter
		function(value) {
			var position3d = CoordinateSystem.fromGeoTo3D( [ value[0], value[1] ] );
			navigation.center3d[0] = position3d[0];
			navigation.center3d[1] = position3d[1];
			navigation.center3d[2] = position3d[2];
			navigation.globe.renderContext.fov = value[2];
			navigation.computeViewMatrix();
		});
	
	// TODO : maybe improve it ?
	// End point which is out of frustum invokes two steps animation, one step otherwise
	var end3DValue = CoordinateSystem.fromGeoTo3D( geoPos );
	if (middleFov > this.renderContext.fov && this.renderContext.worldFrustum.containsSphere( end3DValue, 0.005 ) < 0 )
	{
		// Two steps animation, 'rising' & 'falling'
		
		// Compute the middle value
		var midValue = [startValue[0]*0.5 + endValue[0]*0.5,
			startValue[1]*0.5 + endValue[1]*0.5,
			middleFov];

		// Add two segments
		animation.addSegment(
			0.0, startValue,
			0.5, midValue,
			function(t, a, b) {
				var pt = Numeric.easeInQuad(t);
				var dt = Numeric.easeOutQuad(t);
				return [Numeric.lerp(pt, a[0], b[0]), // geoPos.long
					Numeric.lerp(pt, a[1], b[1]), // geoPos.lat
					Numeric.lerp(dt, a[2], b[2])]; // fov
			});

		animation.addSegment(
			0.5, midValue,
			1.0, endValue,
			function(t, a, b) {
				var pt = Numeric.easeOutQuad(t);
				var dt = Numeric.easeInQuad(t);
				return [Numeric.lerp(pt, a[0], b[0]), // geoPos.long
					Numeric.lerp(pt, a[1], b[1]), // geoPos.lat
					Numeric.lerp(dt, a[2], b[2])]; // fov
		});
	}
	else
	{
		// One step animation, 'falling' only
		
		// Add only one segment
		animation.addSegment(
			0.0, startValue,
			1.0, endValue,
			function(t, a, b) {
				var pt = Numeric.easeOutQuad(t);
				var dt = Numeric.easeInQuad(t);
				return [Numeric.lerp(pt, a[0], b[0]),  // geoPos.long
					Numeric.lerp(pt, a[1], b[1]),  // geoPos.lat
					Numeric.lerp(dt, a[2], b[2])];  // fov
		});
	}

	animation.onstop = function() {
		if ( callback )
		{
			callback();
		}
		navigation.zoomToAnimation = null;
	}
	
	this.globe.addAnimation(animation);
	animation.start();
	this.zoomToAnimation = animation;
}

/**************************************************************************************************************/

/** @export
	Move to a 3d position
	@param {Float[]} geoPos Array of two floats corresponding to final Longitude and Latitude(in this order) to zoom
	@param {Int} duration Duration of animation in milliseconds
	@param {Function} callback Callback on the end of animation
 */
AstroNavigation.prototype.moveTo = function(geoPos, duration, callback)
{
	var navigation = this;
	
	duration = duration || 5000;
	
	// Create a single animation to animate center3d
	var geoStart = [];
	CoordinateSystem.from3DToGeo(this.center3d, geoStart);
	
	var startValue = [geoStart[0], geoStart[1]];
	var endValue = [geoPos[0], geoPos[1]];
	
	// Compute the shortest path if needed
	if (Math.abs(geoPos[0] - geoStart[0]) > 180. )
	{
		if (geoStart[0] < geoPos[0])
			startValue[0] += 360;
		else
			endValue[0] +=360;
	}
	
	var animation = new SegmentedAnimation(
		duration,
		// Value setter
		function(value) {
			var position3d = CoordinateSystem.fromGeoTo3D( [ value[0], value[1] ] );
			navigation.center3d[0] = position3d[0];
			navigation.center3d[1] = position3d[1];
			navigation.center3d[2] = position3d[2];
			navigation.computeViewMatrix();
		}
	);
	
	animation.addSegment(
		0.0, startValue,
		1.0, endValue,
		function(t, a, b) {
			var pt = Numeric.easeOutQuad(t);
			return [Numeric.lerp(pt, a[0], b[0]),  // geoPos.long
				Numeric.lerp(pt, a[1], b[1])];  // geoPos.lat
		}
	);

	animation.onstop = function() {
		if ( callback )
		{
			callback();
		}
	}
	
	this.globe.addAnimation(animation);
	animation.start();
}

/**************************************************************************************************************/

/**
 *	Move up vector
 */
 AstroNavigation.prototype.moveUpTo = function(vec, duration)
 {
	// Create a single animation to animate up
	var startValue = [];
	var endValue = [];
	CoordinateSystem.from3DToGeo(this.up, startValue);
	CoordinateSystem.from3DToGeo(vec, endValue);
	var duration = duration || 1000;

	var navigation = this;
	var animation = new SegmentedAnimation(
		duration,
		// Value setter
		function(value) {
			var position3d = CoordinateSystem.fromGeoTo3D( [ value[0], value[1] ] );
			navigation.up[0] = position3d[0];
			navigation.up[1] = position3d[1];
			navigation.up[2] = position3d[2];
			navigation.computeViewMatrix();
		}
	);
	
	animation.addSegment(
		0.0, startValue,
		1.0, endValue,
		function(t, a, b) {
			var pt = Numeric.easeOutQuad(t);
			return [Numeric.lerp(pt, a[0], b[0]),  // geoPos.long
				Numeric.lerp(pt, a[1], b[1])];  // geoPos.lat
		}
	);
	
	this.globe.addAnimation(animation);
	animation.start();
}

/**************************************************************************************************************/

/**
	Compute the view matrix
 */
AstroNavigation.prototype.computeViewMatrix = function()
{
	var eye = [];
	vec3.normalize(this.center3d);
	
	var vm = this.renderContext.viewMatrix;

	mat4.lookAt([0., 0., 0.], this.center3d, this.up, vm);
	// mat4.inverse( vm );
	// mat4.rotate(vm, this.heading * Math.PI/180., [1., 0., 0.])
	// mat4.inverse( vm );

	this.up = [ vm[1], vm[5], vm[9] ];
	this.publish("modified");
	this.renderContext.requestFrame();
}

/**************************************************************************************************************/

/**
	Event handler for mouse wheel
	@param delta Delta zoom
 */
AstroNavigation.prototype.zoom = function(delta, scale)
{
	
	// TODO : improve zoom, using scale or delta ? We should use scale always
	if ( scale )
	{
		this.renderContext.fov *= 1/scale;
	}
	else
	{
		// Arbitrary value for smooth zooming
		this.renderContext.fov *= (1 + delta * 0.1);
	}
	
	this._clampFov();
	this.computeViewMatrix();
}

/**************************************************************************************************************/

/**
	Pan the navigation by computing the difference between 3D centers
	@param dx Window delta x
	@param dy Window delta y
 */
AstroNavigation.prototype.pan = function(dx, dy)
{
	var x = this.renderContext.canvas.width / 2.;
	var y = this.renderContext.canvas.height / 2.;
	this.center3d = this.renderContext.get3DFromPixel(x - dx, y - dy);
		
	this.computeViewMatrix();
}

/**************************************************************************************************************/

/**
	Rotate the navigation
	@param dx Window delta x
	@param dy Window delta y
 */
AstroNavigation.prototype.rotate = function(dx,dy)
{
	// constant tiny angle 
	var angle = dx * 0.1 * Math.PI/180.;
	
	var rot = quat4.fromAngleAxis(angle,this.center3d);
	quat4.multiplyVec3( rot, this.up );

	this.computeViewMatrix();
}

/**
 *	Clamping of fov
 */
AstroNavigation.prototype._clampFov = function() {
	if ( this.renderContext.fov > this['maxFov'] )
	{
		this.renderContext.fov = this['maxFov'];
	}
	if ( this.renderContext.fov < this['minFov'] )
	{
		this.renderContext.fov = this['minFov'];
	}
}

/**************************************************************************************************************/

return AstroNavigation;

});
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

 define('gw/AttributionHandler',[], function() {

/**************************************************************************************************************/

/** 
 * 	@class Manage the attributions
	@constructor
	Function constructor for AttributionHandler
	
	@param globe
	@param options Configuration properties
		<ul>
			<li>element : the HTML element to show attributions, can be a string (the ID) or the DOM element itself</li>
		</ul>
*/

var AttributionHandler = function(globe, options)
{
	globe.attributionHandler = this;

	var elt = options ? options['element'] : undefined;
	if ( elt )
	{	
		if (typeof elt == "string") 
		{
			this.element = document.getElementById(elt);
		}
		else
		{
			this.element = elt;
		}
	}
}

/**************************************************************************************************************/

/**
* 	Remove attribution from HTML
* 	@param layer Selected layer
*/
AttributionHandler.prototype.removeAttribution = function( layer )
{
	var div = document.getElementById( "attribution_"+layer.id );
	if ( div )
		this.element.removeChild( div );
}

/**************************************************************************************************************/

/**
* 	Add attribution in HTML
* 	@param layer Selected layer
*/
AttributionHandler.prototype.addAttribution = function(layer)
{ 
	var div = document.createElement('div');
	div.innerHTML = layer.attribution;
	div.id = "attribution_"+layer.id;
	
	if(layer.id == 0)
	{
		// Background layer
		this.element.insertBefore( div, this.element.firstChild );
	}
	else
	{
		this.element.appendChild( div );
	}
}

/**************************************************************************************************************/

/**
*	Toggle attribution
* 	@param layer Selected layer
*/
AttributionHandler.prototype.toggleAttribution = function(layer)
{
	var div = document.getElementById("attribution_"+layer.id);
	if ( div )
	{
		this.removeAttribution(layer);
	}
	else
	{
		this.addAttribution(layer);
	}
}

/**************************************************************************************************************/

return AttributionHandler;

});

/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

 define('gw/BaseLayer',[], function() {
 
/**************************************************************************************************************/


/** @name BaseLayer
	@class
	Base class for layer.
	@param options Configuration properties for a BaseLayer:
		<ul>
			<li>name : the layer name</li>
			<li>description :  its description</li>
			<li>attribution : its attribution</li>
			<li>icon : an icon to represent the layer</li>
			<li>visible : a boolean flag to set the layer visible, default is true </li>
			<li>opacity : an opacity value, default is 1.0</li>
		</ul>
 */
var BaseLayer = function(options)
{
	this.globe = null;
	this.name = options && options.hasOwnProperty('name') ? options['name'] : "";
	this.attribution = options && options.hasOwnProperty('attribution') ? options['attribution'] : "";
	this.icon = options && options.hasOwnProperty('icon') ? options['icon'] : "";
	this.description = options && options.hasOwnProperty('description') ? options['description'] : "";
	this._visible = options && options.hasOwnProperty('visible') ? options['visible'] : true;
	this._opacity = options && options.hasOwnProperty('opacity') ? options['opacity'] : 1.0;
}

/**************************************************************************************************************/

/** 
  Attach the raster layer to the globe
 */
BaseLayer.prototype._attach = function( g )
{
	this.globe = g;
	if ( this.attribution && this.globe.attributionHandler && this._visible )
	{
		this.globe.attributionHandler.addAttribution(this);
	}
}

/**************************************************************************************************************/

/** 
  Detach the vector layer from the globe
 */
BaseLayer.prototype._detach = function()
{
	if ( this.attribution && this.globe.attributionHandler )
	{
		this.globe.attributionHandler.removeAttribution(this);
	}
	
	this.globe = null;
}

/**************************************************************************************************************/

/**
  Get/Set the layer visible
 */
BaseLayer.prototype.visible = function( arg )
{
	if ( typeof arg == "boolean" )
	{
		if (  this._visible != arg && this.attribution && this.globe.attributionHandler )
		{
			this.globe.attributionHandler.toggleAttribution(this);
		}

		this._visible = arg;
		if ( this.globe ) this.globe.renderContext.requestFrame();
	}
	return this._visible;
}

/**************************************************************************************************************/

/**
  Get/Set the opacity of the layer
 */
BaseLayer.prototype.opacity = function( arg )
{
	if ( typeof arg == "number" )
	{
		this._opacity = arg;
		if ( this.globe ) this.globe.renderContext.requestFrame();
	}
	return this._opacity;
}

return BaseLayer;

});

/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

 define('gw/FeatureStyle',[], function() {
 
 
// Simple colors
var simple_colors = {
   aliceblue: 'f0f8ff',
   antiquewhite: 'faebd7',
   aqua: '00ffff',
   aquamarine: '7fffd4',
   azure: 'f0ffff',
   beige: 'f5f5dc',
   bisque: 'ffe4c4',
   black: '000000',
   blanchedalmond: 'ffebcd',
   blue: '0000ff',
   blueviolet: '8a2be2',
   brown: 'a52a2a',
   burlywood: 'deb887',
   cadetblue: '5f9ea0',
   chartreuse: '7fff00',
   chocolate: 'd2691e',
   coral: 'ff7f50',
   cornflowerblue: '6495ed',
   cornsilk: 'fff8dc',
   crimson: 'dc143c',
   cyan: '00ffff',
   darkblue: '00008b',
   darkcyan: '008b8b',
   darkgoldenrod: 'b8860b',
   darkgray: 'a9a9a9',
   darkgreen: '006400',
   darkkhaki: 'bdb76b',
   darkmagenta: '8b008b',
   darkolivegreen: '556b2f',
   darkorange: 'ff8c00',
   darkorchid: '9932cc',
   darkred: '8b0000',
   darksalmon: 'e9967a',
   darkseagreen: '8fbc8f',
   darkslateblue: '483d8b',
   darkslategray: '2f4f4f',
   darkturquoise: '00ced1',
   darkviolet: '9400d3',
   deeppink: 'ff1493',
   deepskyblue: '00bfff',
   dimgray: '696969',
   dodgerblue: '1e90ff',
   feldspar: 'd19275',
   firebrick: 'b22222',
   floralwhite: 'fffaf0',
   forestgreen: '228b22',
   fuchsia: 'ff00ff',
   gainsboro: 'dcdcdc',
   ghostwhite: 'f8f8ff',
   gold: 'ffd700',
   goldenrod: 'daa520',
   gray: '808080',
   green: '008000',
   greenyellow: 'adff2f',
   honeydew: 'f0fff0',
   hotpink: 'ff69b4',
   indianred : 'cd5c5c',
   indigo : '4b0082',
   ivory: 'fffff0',
   khaki: 'f0e68c',
   lavender: 'e6e6fa',
   lavenderblush: 'fff0f5',
   lawngreen: '7cfc00',
   lemonchiffon: 'fffacd',
   lightblue: 'add8e6',
   lightcoral: 'f08080',
   lightcyan: 'e0ffff',
   lightgoldenrodyellow: 'fafad2',
   lightgrey: 'd3d3d3',
   lightgreen: '90ee90',
   lightpink: 'ffb6c1',
   lightsalmon: 'ffa07a',
   lightseagreen: '20b2aa',
   lightskyblue: '87cefa',
   lightslateblue: '8470ff',
   lightslategray: '778899',
   lightsteelblue: 'b0c4de',
   lightyellow: 'ffffe0',
   lime: '00ff00',
   limegreen: '32cd32',
   linen: 'faf0e6',
   magenta: 'ff00ff',
   maroon: '800000',
   mediumaquamarine: '66cdaa',
   mediumblue: '0000cd',
   mediumorchid: 'ba55d3',
   mediumpurple: '9370d8',
   mediumseagreen: '3cb371',
   mediumslateblue: '7b68ee',
   mediumspringgreen: '00fa9a',
   mediumturquoise: '48d1cc',
   mediumvioletred: 'c71585',
   midnightblue: '191970',
   mintcream: 'f5fffa',
   mistyrose: 'ffe4e1',
   moccasin: 'ffe4b5',
   navajowhite: 'ffdead',
   navy: '000080',
   oldlace: 'fdf5e6',
   olive: '808000',
   olivedrab: '6b8e23',
   orange: 'ffa500',
   orangered: 'ff4500',
   orchid: 'da70d6',
   palegoldenrod: 'eee8aa',
   palegreen: '98fb98',
   paleturquoise: 'afeeee',
   palevioletred: 'd87093',
   papayawhip: 'ffefd5',
   peachpuff: 'ffdab9',
   peru: 'cd853f',
   pink: 'ffc0cb',
   plum: 'dda0dd',
   powderblue: 'b0e0e6',
   purple: '800080',
   red: 'ff0000',
   rosybrown: 'bc8f8f',
   royalblue: '4169e1',
   saddlebrown: '8b4513',
   salmon: 'fa8072',
   sandybrown: 'f4a460',
   seagreen: '2e8b57',
   seashell: 'fff5ee',
   sienna: 'a0522d',
   silver: 'c0c0c0',
   skyblue: '87ceeb',
   slateblue: '6a5acd',
   slategray: '708090',
   snow: 'fffafa',
   springgreen: '00ff7f',
   steelblue: '4682b4',
   tan: 'd2b48c',
   teal: '008080',
   thistle: 'd8bfd8',
   tomato: 'ff6347',
   turquoise: '40e0d0',
   violet: 'ee82ee',
   violetred: 'd02090',
   wheat: 'f5deb3',
   white: 'ffffff',
   whitesmoke: 'f5f5f5',
   yellow: 'ffff00',
   yellowgreen: '9acd32'
};

var parseHex = /^(\w{2})(\w{2})(\w{2})$/;
var parseRgb = /^rgb\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/;
var parseRgba = /^rgba\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3},\s*(\d{1,3}))\)$/;


/**************************************************************************************************************/

/** @name FeatureStyle
	@class
	The style to display a Feature
	@param style an object containing the following style properties
		<ul>
			<li>strokeColor : the color for line, or polygon outline</li>
			<li>strokeWidth : the width of a line</li>
			<li>fillColor : the color for solid polygon or point</li>
			<li>fillTextureUrl : the texture for solid polygon</li>
			<li>iconUrl : the icon to be used for point</li>
			<li>pointMaxSize : maximum size (in meter) for a point</li>
		</ul>
 */
var FeatureStyle = function(style)
{
	// Color used for lines or polygon outline
	this.strokeColor = [1.0, 0.0, 0.0, 1.0];
	// Color used to full polygon
	this.fillColor = [1.0, 0.0, 0.0, 1.0];
	this.fillTextureUrl = null;
    this.fillTexture = null;
    this.fillShader = null;
	this.strokeWidth = 1;
	this.iconUrl = null;
	this.icon = null;
	this.label = null;
	this.textColor = [1.0, 1.0, 1.0, 1.0];
	this.fill = false;
	this.pointMaxSize = 40;
	this.opacity = 1.;
	this.zIndex = 0;
	
	if ( style )
	{
		for ( var s in style )
		{
			this[s] = style[s];
		}
	}
}


/**************************************************************************************************************/

/**
 * Convert a color from a string to RGB
 */
FeatureStyle.fromStringToColor = function(color_string)
{
	var r = 0, g = 0, b = 0, a = 255;
	var match;
	
	color_string = color_string.trim();
	color_string = color_string.toLowerCase();
	// strip any leading #
	if (color_string.charAt(0) == '#') { // remove # if any
	   color_string = color_string.substr(1,6);
	}
	
	// Convert a litteral color to rgb string
	if ( simple_colors.hasOwnProperty(color_string) )
	{
		color_string = simple_colors[color_string];
	}
	
	match = parseHex.exec(color_string);
	if ( match )
	{
		r = parseInt(match[1],16);
		g = parseInt(match[2],16);
		b = parseInt(match[3],16);
	}
	
	match = parseRgb.exec(color_string);
	if ( match )
	{
		r = parseInt(match[1]);
		g = parseInt(match[2]);
		b = parseInt(match[3]);
	}
	
	match = parseRgba.exec(color_string);
	if ( match )
	{
		r = parseInt(match[1]);
		g = parseInt(match[2]);
		b = parseInt(match[3]);
		a = parseInt(match[4]);
	}

	// validate/cleanup values
	r = (r < 0) ? 0 : ((r > 255) ? 255 : r);
	g = (g < 0) ? 0 : ((g > 255) ? 255 : g);
	b = (b < 0) ? 0 : ((b > 255) ? 255 : b);
	a = (a < 0) ? 0 : ((a > 255) ? 255 : a);

	return [r / 255.0, g / 255.0, b / 255.0, a / 255.0];
}

/**************************************************************************************************************/

/** 
 * Convert an internal color to a string based color representation
 */
FeatureStyle.fromColorToString = function(color)
{		
   var hashColor = '#';
   for ( var i=0; i<3; i++ )
   {
      var component = parseInt( color[i] * 255.0 ).toString(16)
      hashColor += (component < 10) ? '0'+component : component;
   }

	return hashColor;
}

/**************************************************************************************************************/

return FeatureStyle;

});


/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/
 
define('gw/VectorLayer',['./Utils', './BaseLayer', './FeatureStyle'], 
	function(Utils, BaseLayer, FeatureStyle) {

/**************************************************************************************************************/

/** @name VectorLayer
	@class
	Create a layer to display vector data in GeoJSON format.
	@augments BaseLayer
	@param options Configuration properties for VectorLayer. See {@link BaseLayer} for base properties :
		<ul>
			<li>style : the style to use. See {@link FeatureStyle}</li>
		</ul>
 */
var VectorLayer = function( options )
{
	BaseLayer.prototype.constructor.call( this, options );
	
	// Set style
	if ( options && options['style'] )
		this.style = options['style'];
	else
		this.style = new FeatureStyle();
	
	this.features = [];
}

/**************************************************************************************************************/

Utils.inherits( BaseLayer,VectorLayer );

/**************************************************************************************************************/

/** 
  Attach the vector layer to the globe
 */
VectorLayer.prototype._attach = function( g )
{
	BaseLayer.prototype._attach.call( this, g );
	
	// Add the feature to renderers
	for ( var i=0; i < this.features.length; i++ )
	{
		this._addFeatureToRenderers( this.features[i] );
	}
}

/**************************************************************************************************************/

/** 
  Detach the vector layer from the globe
 */
VectorLayer.prototype._detach = function()
{
	// Remove feature from renderers
	for ( var i=0; i < this.features.length; i++ )
	{
		this._removeFeatureFromRenderers( this.features[i] );
	}
	
	BaseLayer.prototype._detach.call(this);
}

/**************************************************************************************************************/

/** @export
  Adds a feature collection, in GeoJSON format
 */
VectorLayer.prototype.addFeatureCollection = function( featureCollection )
{
	// Note : use property defined as ['']  to avoid renaming when compiled in advanced mode with the closure compiler
	var features = featureCollection['features'];
	if ( features )
	{
		for ( var i = 0; i < features.length; i++)
		{
			this.addFeature( features[i] );
		}
	}
}

/**************************************************************************************************************/

/** @export
  Removes a feature collection, in GeoJSON format
*/
VectorLayer.prototype.removeFeatureCollection = function( featureCollection )
{
	// Note : use property defined as ['']  to avoid renaming when compiled in advanced mode with the closure compiler
	var features = featureCollection['features'];
	if ( features )
	{
		for ( var i = 0; i < features.length; i++)
		{
			this.removeFeature( features[i] );
		}
	}
}

/**************************************************************************************************************/

/** 
  Add a feature to renderers
*/
VectorLayer.prototype._addFeatureToRenderers = function( feature )
{
	var geometry = feature['geometry']
	
	// Manage style, if undefined try with properties, otherwise use defaultStyle
	var style = this.style;
	var props = feature['properties'];
	if ( props && props['style'] )
	{
		style = props['style'];
	}

	// Manage geometry collection
	if ( geometry.type == "GeometryCollection" )
	{
		var geoms = geometry["geometries"];
		for ( var i = 0; i < geoms.length; i++ )
		{
			this.globe.vectorRendererManager.addGeometry( this, geoms[i], style );
		}
	}
	else
	{
		// Add geometry to renderers
		this.globe.vectorRendererManager.addGeometry( this, geometry, style );
	}
}

/**************************************************************************************************************/

/** 
  Remove a feature from renderers
*/
VectorLayer.prototype._removeFeatureFromRenderers = function( feature )
{
	var geometry = feature['geometry']
	
	// Manage geometry collection
	if ( geometry.type == "GeometryCollection" )
	{
		var geoms = geometry["geometries"];
		for ( var i = 0; i < geoms.length; i++ )
		{
			this.globe.vectorRendererManager.removeGeometry( geoms[i], this );
		}
	}
	else
	{
		this.globe.vectorRendererManager.removeGeometry( geometry, this );
	}
}

/**************************************************************************************************************/

/** @export
  Add a feature to the layer
*/
VectorLayer.prototype.addFeature = function( feature )
{
	// Check feature geometry : only add valid feature
	var geometry = feature['geometry'];
	if ( !geometry || !geometry.type )
		return;
	this.features.push( feature );
	
	// Add features to renderer if layer is attached to globe
	if ( this.globe )
	{			
		this._addFeatureToRenderers(feature);
		if (this._visible) this.globe.renderContext.requestFrame();
	}
}

/**************************************************************************************************************/

/** @export
  Remove a feature from the layer
*/
VectorLayer.prototype.removeFeature = function( feature )
{
	var index = this.features.indexOf( feature );
	this.features.splice( index, 1 );
	if ( this.globe )
	{
		this._removeFeatureFromRenderers( feature );
		if (this._visible) this.globe.renderContext.requestFrame();
	}
}

/**************************************************************************************************************/

/** @export
  Remove all feature from the layer
*/
VectorLayer.prototype.removeAllFeatures = function()
{
	// Remove feature from renderers
	if ( this.globe )
	{
		for ( var i = 0; i < this.features.length; i++ )
		{
			this._removeFeatureFromRenderers( this.features[i] );
		}
	}
	this.features.length = 0;
	
	// Refresh rendering if needed
	if ( this.globe && this._visible )
	{
		this.globe.renderContext.requestFrame();
	}
}

/**************************************************************************************************************/

/** @export
  Modify feature style
*/
VectorLayer.prototype.modifyFeatureStyle = function( feature, style )
{
	this._removeFeatureFromRenderers( feature );
	feature['properties']['style'] = style;
	this._addFeatureToRenderers( feature );
}

/**************************************************************************************************************/

/** @export
  Modify the vector layer style
*/
VectorLayer.prototype.modifyStyle = function(style)
{
	for ( var i=0; i<this.features.length; i++ )
	{
		this._removeFeatureFromRenderers( this.features[i] );
	}
	
	this.style = style;
	
	for ( var i=0; i<this.features.length; i++ )
	{
		this._addFeatureToRenderers( this.features[i] );
	}
}

/**************************************************************************************************************/

return VectorLayer;

});


/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('gw/TouchNavigationHandler',[], function() {

/**************************************************************************************************************/

/**
 *	Types of actions for inertia execution
 */
var Type = {
	PAN : 0,
	ROTATE : 1,
	TILT : 2,
	ZOOM : 3
};

/** @export
	@constructor
	TouchNavigationHandler constructor
	@param options Configuration properties for the TouchNavigationHandler :
			<ul>
				<li>inversed : if true inverse the sens of touching events</li>
				<li>zoomOnDblClick : if true defines animation on double click</li>
			</ul>
 */
var TouchNavigationHandler = function(options){

	/**************************************************************************************************************/
	
	/**
 	 * Private variables
	 */
	 
	var _navigation = null;
	var _lastFingerDistance;

	var _startTouches = [];
	var _lastTouches;
	var _lastAngle;

	var _dx, _dy;
	var _type;

	// Parameters for intertia management
	var _actionHits = [0, 0, 0, 0];
	var _lastTapDate;
	var _rotation;


	// Double tap
	var _doubletap_interval = 300;
	var _inversed = (options && options.hasOwnProperty('inversed')) ? options.inversed : false;

	/**************************************************************************************************************/
	
	/**
 	 * Private methods
	 */

	/**
	 * Calculate the angle between two coordinates
	 */
	var _getAngle = function(touch1, touch2) {
		var y = touch2.clientY - touch1.clientY,
			x = touch2.clientX - touch1.clientX;
		return Math.atan2(y, x) * 180 / Math.PI;
	};

	/**************************************************************************************************************/

	/**
	 * Calculate the rotation degrees between two touchLists (fingers)
	 */
	var _getRotation = function(start, end) {
		// Need two fingers
		if(start.length >= 2 && end.length >= 2) {
			return _getAngle(end[1], end[0]) - _getAngle(start[1], start[0]);
		}
		return 0;
    };

    /**************************************************************************************************************/

	/** 
	  Handle touch start event
	 */
	var _handleTouchStart = function(event)
	{
		//console.log("# events : " + event.touches.length );
		_lastTouches = event.touches;
		_startTouches = event.touches;
		
		_actionHits = [0, 0, 0, 0];

		// Stop all animations when an event is received
		_navigation.stopAnimations();
		_dx = 0;
		_dy = 0;
		if ( event.touches.length == 2 )
		{
			var dx = event.touches[0].clientX - event.touches[1].clientX;
			var dy = event.touches[0].clientY - event.touches[1].clientY;
			_lastFingerDistance = Math.sqrt( dx * dx + dy * dy );
			console.log("Finger distance : " + _lastFingerDistance );
			
			_lastAngle = _getRotation( _startTouches, event.touches );
		}
				
		if ( event.preventDefault )
		{
			event.preventDefault();
		}
		event.returnValue = false;

		// Return false to stop event to be propagated
		return false;
	};

	/**************************************************************************************************************/

	/** 
	  Handle touch move event
	 */
	var _handleTouchMove = function(event)
	{
		_dx = event.touches[0].clientX - _lastTouches[0].clientX;
		_dy = event.touches[0].clientY - _lastTouches[0].clientY;
		if ( event.touches.length == 1 )
		{	
			// Pan
	       	_navigation.pan(_dx, _dy);
	        _actionHits[Type.PAN]++;
		}
		else
		{
			// Depending on direction of two fingers, decide if tilt OR rotation
			var sameDirection = ( (event.touches[0].clientY - _lastTouches[0].clientY) * (event.touches[1].clientY - _lastTouches[1].clientY) > 0 );
			if ( sameDirection )
			{
				// Tilt
				_navigation.rotate(0., -_dy);
				_actionHits[Type.TILT]++;
			}
			else
			{
				// Rotation
				var rotation = _getRotation( _startTouches, event.touches );
				var dx = rotation - _lastAngle;
				_lastAngle = rotation;

				if ( _inversed )
				{
					dx *= -1;
				}
				
				_rotation = dx * 10;
				_navigation.rotate(_rotation, 0);
				_actionHits[Type.ROTATE]++;
			}

			// Zoom
			var dx = event.touches[0].clientX - event.touches[1].clientX;
			var dy = event.touches[0].clientY - event.touches[1].clientY;
			var fingerDistance = Math.sqrt( dx * dx + dy * dy );
			var deltaDistance = (fingerDistance - _lastFingerDistance);

			var scale;
			if ( _inversed )
			{
				scale = fingerDistance/_lastFingerDistance;
			}
			else
			{
				scale = _lastFingerDistance/fingerDistance;
			}

			if (_lastFingerDistance != 0)
			{
				_navigation.zoom( deltaDistance * 0.025, scale);
				_actionHits[Type.ZOOM]++;
			}
			_navigation.renderContext.requestFrame();
			_lastFingerDistance = fingerDistance;
		}

		// Update _lastTouches
		_lastTouches = event.touches;
		
		if ( event.preventDefault )
		{
			event.preventDefault();
		}
		event.returnValue = false;
		
		return false;
	};

	/**************************************************************************************************************/

	/** 
	  Handle touch end event
	 */
	var _handleTouchEnd = function(event)
	{	
		if ( options && options.zoomOnDblClick && event.touches.length == 0 && _dx == 0 && _dy == 0 )
		{
			// Handle double tap
			// TODO : take into account the distance
			var now = Date.now();
			if ( now - _lastTapDate < _doubletap_interval )
			{
				var geo = _navigation.globe.getLonLatFromPixel( _lastTouches[0].clientX, _lastTouches[0].clientY );
		
				if (geo)
				{
					_navigation.zoomTo(geo);
				}
			}
			_lastTapDate = now;
		}

		// Update last touches
		_lastTouches = event.touches;

		if ( _navigation.inertia && (_dx != 0 || _dy != 0) )
		{
			// Launch inertia depending on action hits while "moving" phase
			var hitIndex = _actionHits.indexOf( Math.max.apply(this,_actionHits) );
			if ( hitIndex == Type.PAN )
			{
				// Pan
				_navigation.inertia.launch("pan", _dx, _dy);
			}
			else if ( hitIndex == Type.ROTATE )
			{
				// Rotate
				//_navigation.inertia.launch("rotate", _rotation, 0);
			}
			else if ( hitIndex == Type.TILT )
			{
				// No inertia for tilt
			}
		}

		if ( event.preventDefault )
		{
			event.preventDefault();
		}
		event.returnValue = false;
		
		return false;
	};

	/**************************************************************************************************************/
	
	/**
	 * Public methods
	 */
			
	/** 
	 *	Setup the default event handlers for the _navigation
	 */
	this.install = function(nav)
	{
		_navigation = nav;
		
		// Setup the touch event handlers
		var canvas = _navigation.renderContext.canvas;
		
		canvas.addEventListener("touchstart", _handleTouchStart,false);
		canvas.addEventListener("touchend", _handleTouchEnd,false);
		canvas.addEventListener("touchmove", _handleTouchMove,false);
	};

	/** 
	 *	Remove the default event handlers for the _navigation
	 */
	this.uninstall = function()
	{
		// Setup the mouse event handlers
		var canvas = _navigation.renderContext.canvas;

		canvas.removeEventListener("touchstart", _handleTouchStart,false);
		canvas.removeEventListener("touchend", _handleTouchEnd,false);
		canvas.removeEventListener("touchmove", _handleTouchMove,false);
	};
};

return TouchNavigationHandler;

});
/**
 * @license RequireJS text 2.0.3 Copyright (c) 2010-2012, The Dojo Foundation All Rights Reserved.
 * Available via the MIT or new BSD license.
 * see: http://github.com/requirejs/text for details
 */
/*jslint regexp: true */
/*global require: false, XMLHttpRequest: false, ActiveXObject: false,
  define: false, window: false, process: false, Packages: false,
  java: false, location: false */

define('text',['module'], function (module) {
    

    var text, fs,
        progIds = ['Msxml2.XMLHTTP', 'Microsoft.XMLHTTP', 'Msxml2.XMLHTTP.4.0'],
        xmlRegExp = /^\s*<\?xml(\s)+version=[\'\"](\d)*.(\d)*[\'\"](\s)*\?>/im,
        bodyRegExp = /<body[^>]*>\s*([\s\S]+)\s*<\/body>/im,
        hasLocation = typeof location !== 'undefined' && location.href,
        defaultProtocol = hasLocation && location.protocol && location.protocol.replace(/\:/, ''),
        defaultHostName = hasLocation && location.hostname,
        defaultPort = hasLocation && (location.port || undefined),
        buildMap = [],
        masterConfig = (module.config && module.config()) || {};

    text = {
        version: '2.0.3',

        strip: function (content) {
            //Strips <?xml ...?> declarations so that external SVG and XML
            //documents can be added to a document without worry. Also, if the string
            //is an HTML document, only the part inside the body tag is returned.
            if (content) {
                content = content.replace(xmlRegExp, "");
                var matches = content.match(bodyRegExp);
                if (matches) {
                    content = matches[1];
                }
            } else {
                content = "";
            }
            return content;
        },

        jsEscape: function (content) {
            return content.replace(/(['\\])/g, '\\$1')
                .replace(/[\f]/g, "\\f")
                .replace(/[\b]/g, "\\b")
                .replace(/[\n]/g, "\\n")
                .replace(/[\t]/g, "\\t")
                .replace(/[\r]/g, "\\r")
                .replace(/[\u2028]/g, "\\u2028")
                .replace(/[\u2029]/g, "\\u2029");
        },

        createXhr: masterConfig.createXhr || function () {
            //Would love to dump the ActiveX crap in here. Need IE 6 to die first.
            var xhr, i, progId;
            if (typeof XMLHttpRequest !== "undefined") {
                return new XMLHttpRequest();
            } else if (typeof ActiveXObject !== "undefined") {
                for (i = 0; i < 3; i += 1) {
                    progId = progIds[i];
                    try {
                        xhr = new ActiveXObject(progId);
                    } catch (e) {}

                    if (xhr) {
                        progIds = [progId];  // so faster next time
                        break;
                    }
                }
            }

            return xhr;
        },

        /**
         * Parses a resource name into its component parts. Resource names
         * look like: module/name.ext!strip, where the !strip part is
         * optional.
         * @param {String} name the resource name
         * @returns {Object} with properties "moduleName", "ext" and "strip"
         * where strip is a boolean.
         */
        parseName: function (name) {
            var strip = false, index = name.indexOf("."),
                modName = name.substring(0, index),
                ext = name.substring(index + 1, name.length);

            index = ext.indexOf("!");
            if (index !== -1) {
                //Pull off the strip arg.
                strip = ext.substring(index + 1, ext.length);
                strip = strip === "strip";
                ext = ext.substring(0, index);
            }

            return {
                moduleName: modName,
                ext: ext,
                strip: strip
            };
        },

        xdRegExp: /^((\w+)\:)?\/\/([^\/\\]+)/,

        /**
         * Is an URL on another domain. Only works for browser use, returns
         * false in non-browser environments. Only used to know if an
         * optimized .js version of a text resource should be loaded
         * instead.
         * @param {String} url
         * @returns Boolean
         */
        useXhr: function (url, protocol, hostname, port) {
            var uProtocol, uHostName, uPort,
                match = text.xdRegExp.exec(url);
            if (!match) {
                return true;
            }
            uProtocol = match[2];
            uHostName = match[3];

            uHostName = uHostName.split(':');
            uPort = uHostName[1];
            uHostName = uHostName[0];

            return (!uProtocol || uProtocol === protocol) &&
                   (!uHostName || uHostName.toLowerCase() === hostname.toLowerCase()) &&
                   ((!uPort && !uHostName) || uPort === port);
        },

        finishLoad: function (name, strip, content, onLoad) {
            content = strip ? text.strip(content) : content;
            if (masterConfig.isBuild) {
                buildMap[name] = content;
            }
            onLoad(content);
        },

        load: function (name, req, onLoad, config) {
            //Name has format: some.module.filext!strip
            //The strip part is optional.
            //if strip is present, then that means only get the string contents
            //inside a body tag in an HTML string. For XML/SVG content it means
            //removing the <?xml ...?> declarations so the content can be inserted
            //into the current doc without problems.

            // Do not bother with the work if a build and text will
            // not be inlined.
            if (config.isBuild && !config.inlineText) {
                onLoad();
                return;
            }

            masterConfig.isBuild = config.isBuild;

            var parsed = text.parseName(name),
                nonStripName = parsed.moduleName + '.' + parsed.ext,
                url = req.toUrl(nonStripName),
                useXhr = (masterConfig.useXhr) ||
                         text.useXhr;

            //Load the text. Use XHR if possible and in a browser.
            if (!hasLocation || useXhr(url, defaultProtocol, defaultHostName, defaultPort)) {
                text.get(url, function (content) {
                    text.finishLoad(name, parsed.strip, content, onLoad);
                }, function (err) {
                    if (onLoad.error) {
                        onLoad.error(err);
                    }
                });
            } else {
                //Need to fetch the resource across domains. Assume
                //the resource has been optimized into a JS module. Fetch
                //by the module name + extension, but do not include the
                //!strip part to avoid file system issues.
                req([nonStripName], function (content) {
                    text.finishLoad(parsed.moduleName + '.' + parsed.ext,
                                    parsed.strip, content, onLoad);
                });
            }
        },

        write: function (pluginName, moduleName, write, config) {
            if (buildMap.hasOwnProperty(moduleName)) {
                var content = text.jsEscape(buildMap[moduleName]);
                write.asModule(pluginName + "!" + moduleName,
                               "define(function () { return '" +
                                   content +
                               "';});\n");
            }
        },

        writeFile: function (pluginName, moduleName, req, write, config) {
            var parsed = text.parseName(moduleName),
                nonStripName = parsed.moduleName + '.' + parsed.ext,
                //Use a '.js' file name so that it indicates it is a
                //script that can be loaded across domains.
                fileName = req.toUrl(parsed.moduleName + '.' +
                                     parsed.ext) + '.js';

            //Leverage own load() method to load plugin value, but only
            //write out values that do not have the strip argument,
            //to avoid any potential issues with ! in file names.
            text.load(nonStripName, req, function (value) {
                //Use own write() method to construct full module value.
                //But need to create shell that translates writeFile's
                //write() to the right interface.
                var textWrite = function (contents) {
                    return write(fileName, contents);
                };
                textWrite.asModule = function (moduleName, contents) {
                    return write.asModule(moduleName, fileName, contents);
                };

                text.write(pluginName, nonStripName, textWrite, config);
            }, config);
        }
    };

    if (masterConfig.env === 'node' || (!masterConfig.env &&
            typeof process !== "undefined" &&
            process.versions &&
            !!process.versions.node)) {
        //Using special require.nodeRequire, something added by r.js.
        fs = require.nodeRequire('fs');

        text.get = function (url, callback) {
            var file = fs.readFileSync(url, 'utf8');
            //Remove BOM (Byte Mark Order) from utf8 files if it is there.
            if (file.indexOf('\uFEFF') === 0) {
                file = file.substring(1);
            }
            callback(file);
        };
    } else if (masterConfig.env === 'xhr' || (!masterConfig.env &&
            text.createXhr())) {
        text.get = function (url, callback, errback) {
            var xhr = text.createXhr();
            xhr.open('GET', url, true);

            //Allow overrides specified in config
            if (masterConfig.onXhr) {
                masterConfig.onXhr(xhr, url);
            }

            xhr.onreadystatechange = function (evt) {
                var status, err;
                //Do not explicitly handle errors, those should be
                //visible via console output in the browser.
                if (xhr.readyState === 4) {
                    status = xhr.status;
                    if (status > 399 && status < 600) {
                        //An http 4xx or 5xx error. Signal an error.
                        err = new Error(url + ' HTTP status: ' + status);
                        err.xhr = xhr;
                        errback(err);
                    } else {
                        callback(xhr.responseText);
                    }
                }
            };
            xhr.send(null);
        };
    } else if (masterConfig.env === 'rhino' || (!masterConfig.env &&
            typeof Packages !== 'undefined' && typeof java !== 'undefined')) {
        //Why Java, why is this so awkward?
        text.get = function (url, callback) {
            var stringBuffer, line,
                encoding = "utf-8",
                file = new java.io.File(url),
                lineSeparator = java.lang.System.getProperty("line.separator"),
                input = new java.io.BufferedReader(new java.io.InputStreamReader(new java.io.FileInputStream(file), encoding)),
                content = '';
            try {
                stringBuffer = new java.lang.StringBuffer();
                line = input.readLine();

                // Byte Order Mark (BOM) - The Unicode Standard, version 3.0, page 324
                // http://www.unicode.org/faq/utf_bom.html

                // Note that when we use utf-8, the BOM should appear as "EF BB BF", but it doesn't due to this bug in the JDK:
                // http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4508058
                if (line && line.length() && line.charAt(0) === 0xfeff) {
                    // Eat the BOM, since we've already found the encoding on this file,
                    // and we plan to concatenating this buffer with others; the BOM should
                    // only appear at the top of a file.
                    line = line.substring(1);
                }

                stringBuffer.append(line);

                while ((line = input.readLine()) !== null) {
                    stringBuffer.append(lineSeparator);
                    stringBuffer.append(line);
                }
                //Make sure we return a JavaScript string and not a Java string.
                content = String(stringBuffer.toString()); //String
            } finally {
                input.close();
            }
            callback(content);
        };
    }

    return text;
});
define('text!../templates/mizarCore.html',[],function () { return '<div id="webGLNotAvailable">\n\tIf you see this message, WebGL is not supported in your browser.<br/>\n\tPlease install a recent version of <a href="http://www.mozilla.com">Firefox</a> or <a href="http://www.google.com/chrome">Google Chrome</a>.<br/>\n\tIf you already have a recent version of Firefox or Google Chrome, your graphics driver are too old, please update it.<br/>\n\tOn Google Chrome, you can check why it is not working by entering "about:gpu" in the url bar.\n</div>\n\n<div id="webGLContextLost">\n\tIf you see this message, WebGL context was lost.<br/>\n\tPlease re-launch your browser. We are working on restoring without relaunching.\n</div>\n\n<div id="loading"></div>\n\n<div class="canvas">\n\n\t<!-- Side bar will contain available layers -->\n\t<div class="sidebar">\n\t</div>\n\t\n\t<div class="noSelect" id="navigationDiv">\n\t\t<div id="searchDiv">\n\t\t</div>\n\n\t\t<div id="compassDiv">\n\t\t</div>\n\n\t\t<div id="imageViewerDiv">\n\t\t</div>\n\t</div>\n\t\n\t<!-- Left-Bottom-section -->\n\t<div class="noSelect" id="leftBottomDiv">\n\t\t<!-- Div for relative position 164 = define height of mollweideContent-->\n\t\t<div id="2dMapContainer" style="display: none; position: relative; height: 164px; margin-bottom: 5px;">\n\t\t\t<div id="mollweideDiv">\n\t\t\t\t<span id="mollweideContent">\n\t\t\t\t\t<canvas id="mollweideCanvas" class="noSelect" width="232px" height="116px"></canvas>\n\t\t\t\t\t<div id="fov" class="ui-widget">Fov : 45 x 45</div>\n\t\t\t\t</span>\n\t\t\t\t\n\t\t\t\t<span id="slideArrow"></span>\n\t\t\t</div>\n\t\t</div>\n\t\t<div id="shareContainer" style="display: none;" class="leftBottomButton">\n\t\t\t<input type="button" id="share" />\n\t\t\t<div id="shareResult" style="pointer-events : auto;">\n\t\t\t\t<input type="text" id="shareInput" />\n\t\t\t\t<input type="button" id="shareClear" />\n\t\t\t</div>\n\t\t</div>\n\t\t<div id="sampContainer" style="display: none;" class="leftBottomButton">\n\t\t\t<input type="button" id="sampInvoker" />\n\t\t</div>\n\t\t<div id="measureContainer" style="display: none;" class="leftBottomButton">\n\t\t\t<input type="button" id="measureInvoker" />\n\t\t</div>\n\t\t<div style="display: none;" id="fps" class="statBox ui-widget">FPS : 0</div>\t\n\t</div>\n\t\n\t<div class="noSelect" id="attributions"></div>\t\n\t<div id="posTracker" class="noSelect"></div>\n\n\t<canvas class="noSelect" id="GlobWebCanvas" style="border: none; margin: 0; padding: 0;" width="0" height="0">\n\t</canvas>\n\n</div>';});

define('text!../data/backgroundSurveys.json',[],function () { return '[\n\t/**\n\t *\tBuilt-in star/constellation catalogs\n\t */\n\t{\n\t\t"category": "Other",\n\t\t"type": "GeoJSON",\n\t\t"name": "Constellations",\n\t\t"icon": "css/images/constellation_icon.png",\n\t\t"attribution": "Constellation coming from <a href=\\"http://cdsweb.u-strasbg.fr/index-fr.gml\\" target=\\"_blank\\"><object width=\'24\' height=\'16\' data=\\"http://demonstrator.telespazio.com/mizar/css/images/cds.svg\\" type=\\"image/svg+xml\\"></object></a>",\n\t\t"description": "Constellation shapes from VizieR Catalogue",\n\t\t"data": {\n\t\t\t"type": "constellation",\n\t\t\t"nameUrl": "http://demonstrator.telespazio.com/mizar/data/ConstellationNames.tsv",\n\t\t\t"catalogueUrl": "http://demonstrator.telespazio.com/mizar/data/bound_20.dat"\n\t\t},\n\t\t"visible": false,\n\t\t"pickable" : false,\n\t\t"color": "rgb(8, 59, 167)"\n\t},\n\t{\n\t\t"category": "Other",\n\t\t"type": "GeoJSON",\n\t\t"name": "Brighten stars",\n\t\t"icon": "http://demonstrator.telespazio.com/mizar/css/images/star_icon.png",\n\t\t"attribution": "The most brighten stars coming from <a href=\\"http://cdsweb.u-strasbg.fr/index-fr.gml\\" target=\\"_blank\\"><object width=\'24\' height=\'16\' data=\\"http://demonstrator.telespazio.com/mizar/css/images/cds.svg\\" type=\\"image/svg+xml\\"></object></a>",\n\t\t"description": "The most brighten stars from VizieR Catalogue",\n\t\t"data": {\n\t\t\t"type": "star",\n\t\t\t"nameUrl": "http://demonstrator.telespazio.com/mizar/data/Names.tsv",\n\t\t\t"catalogueUrl": "http://demonstrator.telespazio.com/mizar/data/Catalogue.tsv"\n\t\t},\n\t\t"visible": true,\n\t\t"opacity": 100,\n\t\t"pickable" : false,\n\t\t"color": "white"\n\t},\n\t/**\n     * Coordinate grids\n\t */\n\t{\n\t\t"category": "Coordinate systems",\n\t\t"type": "coordinateGrid",\n\t\t"name": "Equatorial grid",\n\t\t"visible": false,\n\t\t"coordSystem": "EQ",\n\t\t"color": "white",\n\t\t"latFormat": "DMS",\n\t\t"longFormat": "HMS"\n\t},\n\t{\n\t\t"category": "Coordinate systems",\n\t\t"type": "coordinateGrid",\n\t\t"name": "Galactic grid",\n\t\t"visible": false,\n\t\t"coordSystem": "GAL",\n\t\t"color": "red",\n\t\t"latFormat": "Deg",\n\t\t"longFormat": "Deg"\n\t},\n\t/**\n\t *\tAlasky healpix sources\n\t *\n\t *\tPlugin: Proxy Healpix Image cache\n\t *\turlClient: http://alasky.u-strasbg.fr or http://healpix.ias.u-psud.fr/\n\t */\n\t{\n\t\t"type": "healpix",\n\t\t"name": "WISE RGB",\n\t\t"baseUrl": "http://demonstrator.telespazio.com/sitools/Alasky/WISE/RGB/",\n\t\t"description": "WISE color",\t\t\t\n\t\t"visible": false,\n\t\t"background": true,\t\n        "coordSystem": "GAL",\n        "attribution":"<a href=\\"http://irsa.ipac.caltech.edu/Missions/wise.html\\" target=\\"_blank\\"><img src=\\"http://demonstrator.telespazio.com/sitools/upload/wise.svg\\" width=\'24\' height=\'16\'/></a> color background provided by <a href=\\"http://cdsweb.u-strasbg.fr/index-fr.gml\\" target=\\"_blank\\"><object width=\'24\' height=\'16\' data=\\"http://demonstrator.telespazio.com/mizar/css/images/cds.svg\\" type=\\"image/svg+xml\\"></object></a>",\n\t\t"numberOfLevels": 5\n\t},\n\t{\n\t\t"type": "healpix",\n\t\t"name": "SpitzerI1I2I4color",\n\t\t"baseUrl": "http://demonstrator.telespazio.com/Alasky/SpitzerI1I2I4color",\n\t\t"description": "Spitzer color",\t\t\t\n\t\t"visible": false,\n\t\t"background": true,\t\n        "coordSystem": "GAL",\n        "attribution":"<object width=\'24\' height=\'16\' data=\\"http://demonstrator.telespazio.com/upload/spitzer.svg\\" type=\\"image/svg+xml\\"></object> color background provided by <a href=\\"http://cdsweb.u-strasbg.fr/index-fr.gml\\" target=\\"_blank\\"><object width=\'24\' height=\'16\' data=\\"http://demonstrator.telespazio.com/mizar/css/images/cds.svg\\" type=\\"image/svg+xml\\"></object></a>",\n\t\t"numberOfLevels": 9\n\t},\n\t{\n\t\t"type": "healpix",\n\t\t"name": "IRIS",\n\t\t"baseUrl": "http://demonstrator.telespazio.com/Alasky/IRISColor",\n\t\t"description": "IRIS color",\n\t\t"icon": "http://demonstrator.telespazio.com/mizar/css/images/star_icon.png",\n\t\t"visible": false,\n\t\t"background": true,\n\t\t"coordSystem": "GAL",\n        "attribution": "IRIS background from <img width=\'24\' height=\'16\' src=\\"http://demonstrator.telespazio.com/mizar/css/images/cds.svg\\" />",\n\t\t"numberOfLevels": 1\n\t},\n\t{ \n\t\t"type": "healpix",\n\t\t"name": "Deep CFHTLS",\n\t\t"baseUrl": "http://demonstrator.telespazio.com/sitools/Alasky/CFHTLS-T0007b/Deep/RGB-UGIm",\n\t\t"description": "Deep CFHTLS from CDS",\n\t\t"attribution": "Deep CFHTLS background from <a href=\\"http://cdsweb.u-strasbg.fr/index-fr.gml\\" target=\\"_blank\\"><img width=\'24\' height=\'16\' src=\\"http://demonstrator.telespazio.com/mizar/css/images/cds.svg\\" /></a>",\n\t\t"visible": false,\n\t\t"background": true,\n\t\t"numberOfLevels": 11\n\t},\n\t{ \n\t\t"type": "healpix",\n\t\t"name": "CFHTLS Wide",\n\t\t"baseUrl": "http://demonstrator.telespazio.com/sitools/Alasky/CFHTLS-T0007b/Wide/RGB-UGIm",\n\t\t"description": "CFHTLS-W-Colored (UGI)",\n        "attribution": "TERAPIX - Healpixed by <a href=\\"http://cdsweb.u-strasbg.fr/index-fr.gml\\" target=\\"_blank\\"><img width=\'24\' height=\'16\' src=\\"http://demonstrator.telespazio.com/mizar/css/images/cds.svg\\" /></a>",\n\t\t"visible": false,\n\t\t"background": true,\n\t\t"numberOfLevels": 10\n\t},\n\t{ \n\t\t"type": "healpix",\n\t\t"name": "2MASS",\n\t\t"baseUrl": "http://demonstrator.telespazio.com/sitools/Alasky/2MASS/Color",\n\t\t"description": "Infrared 2MASS colored survey from NASA, healpixed by CDS",\n\t\t"attribution": "2MASS background from <a href=\\"http://cdsweb.u-strasbg.fr/index-fr.gml\\" target=\\"_blank\\"><img width=\'24\' height=\'16\' src=\\"http://demonstrator.telespazio.com/mizar/css/images/cds.svg\\" /></a>",\n\t\t"visible": false,\n\t\t"background": true,\n\t\t"numberOfLevels": 8\n\t},\n\t{ \n\t\t"type": "healpix",\n\t\t"name": "RASS",\n\t\t"baseUrl": "http://demonstrator.telespazio.com/sitools/Alasky/RASS",\n\t\t"description": "RASS-ROSAT X-Ray All-Sky Survey",\n\t\t"attribution": "Distributed by MPE - Healpixed by <a href=\\"http://cdsweb.u-strasbg.fr/index-fr.gml\\" target=\\"_blank\\"><img width=\'24\' height=\'16\' src=\\"http://demonstrator.telespazio.com/mizar/css/images/cds.svg\\" /></a>",\n\t\t"visible": false,\n\t\t"background": true,\n\t\t"numberOfLevels": 3\n\t},\n\t{ \n\t\t"type": "healpix",\n\t\t"name": "NVSS",\n\t\t"baseUrl": "http://demonstrator.telespazio.com/sitools/Alasky/NVSS/intensity",\n\t\t"description": "NVSS intensity maps (1.4GHz)",\n\t\t"visible": false,\n\t\t"background": true,\n\t\t"numberOfLevels": 4\n\t},\n\t{ \n\t\t"type": "healpix",\n\t\t"name": "DSS",\n\t\t"baseUrl": "http://demonstrator.telespazio.com/Alasky/DssColor",\n\t\t"description": "Digital Sky Survey from CDS",\n\t\t"attribution": "DSS background from <a href=\\"http://cdsweb.u-strasbg.fr/index-fr.gml\\" target=\\"_blank\\"><img width=\'24\' height=\'16\' src=\\"http://demonstrator.telespazio.com/mizar/css/images/cds.svg\\" /></a>",\n\t\t"visible": true,\n\t\t"background": true,\n\t\t"numberOfLevels": 8\n\t},\n\t{\t\t\t\n\t\t"type": "healpix",\n\t\t"name": "SDSS",\n\t\t"baseUrl": "http://demonstrator.telespazio.com/sitools/Alasky/SDSS/DR7/Color",\n\t\t"description": "Sloan Digital Sky Survey from CDS",\n\t\t"attribution": "SDSS background from <a href=\\"http://cdsweb.u-strasbg.fr/index-fr.gml\\" target=\\"_blank\\"><img width=\'24\' height=\'16\' src=\\"http://demonstrator.telespazio.com/mizar/css/images/cds.svg\\" /></a>",\n\t\t"icon": "http://demonstrator.telespazio.com/mizar/css/images/star_icon.png",\n\t\t"visible": false,\n\t\t"background": true\n\t},\n\t/**\n\t *\tPlack FITS supported surveys\n\t */\n\t// Background\n\t{\n\t\t"type": "healpix",\n\t\t"name": "PlanckCMB",\n\t\t"baseUrl" : "http://demonstrator.telespazio.com/Alasky/PLANCK/CMB",\n\t\t"description": "Planck survey from CDS",\n\t\t"visible": false,\n\t\t"background": true,\n\t\t"dataType": "jpg",\n\t\t"fitsSupported": true,\n\t\t"coordSystem": "GAL",\n\t\t//"availableServices": [ { "name": "HEALPixCut", "fileName": "HFI_SkyMap_857_2048_R1.10_nominal.fits"\t} ],\n\t\t"numberOfLevels": 2,\n        "attribution":"<a href=\\"http://irsa.ipac.caltech.edu/data/Planck/release_1/all-sky-maps/\\" target=\\"_blank\\"><img src=\\"http://demonstrator.telespazio.com/sitools/upload/planck.svg\\" width=\'20\' height=\'20\'/></a> data provided by <a href=\\"http://cdsweb.u-strasbg.fr/index-fr.gml\\" target=\\"_blank\\"><img width=\'24\' height=\'16\' src=\\"http://demonstrator.telespazio.com/mizar/css/images/cds.svg\\" /></a>"\n\t},\n    {\n\t\t"type": "healpix",\n\t\t"name": "Planck-HFI-857",\n\t\t"baseUrl": "http://demonstrator.telespazio.com/sitools/Alasky/PLANCK/HFI857",\n\t\t"description": "PLANCK HFI 857 from CDS",\n\t\t"visible": false,\n\t\t"background": true,\n\t\t"coordSystem": "GAL",\n\t\t"fitsSupported": true,\n\t\t"dataType": "jpg",\n\t\t//"availableServices": [ { "name": "HEALPixCut", "fileName": "HFI_SkyMap_857_2048_R1.10_nominal.fits"\t} ],\n\t\t"numberOfLevels": 2,\n        "attribution":"<a href=\\"http://irsa.ipac.caltech.edu/data/Planck/release_1/all-sky-maps/\\" target=\\"_blank\\"><img src=\\"http://demonstrator.telespazio.com/sitools/upload/planck.svg\\" width=\'20\' height=\'20\'/></a> data provided by <a href=\\"http://cdsweb.u-strasbg.fr/index-fr.gml\\" target=\\"_blank\\"><img width=\'24\' height=\'16\' src=\\"http://demonstrator.telespazio.com/mizar/css/images/cds.svg\\" /></a>"\n    },\n    {\n\t\t"type": "healpix",\n\t\t"name": "Planck-HFI-545",\n\t\t"baseUrl": "http://demonstrator.telespazio.com/sitools/Alasky/PLANCK/HFI545",\n\t\t"description": "PLANCK HFI 545 from CDS",\n\t\t"visible": false,\n\t\t"background": true,\n\t\t"coordSystem": "GAL",\n\t\t"fitsSupported": true,\n\t\t"dataType": "jpg",\n\t\t//"availableServices": [ { "name": "HEALPixCut", "fileName": "HFI_SkyMap_545_2048_R1.10_nominal.fits"\t} ],\n\t\t"numberOfLevels": 2,\n        "attribution":"<a href=\\"http://irsa.ipac.caltech.edu/data/Planck/release_1/all-sky-maps/\\" target=\\"_blank\\"><img src=\\"http://demonstrator.telespazio.com/sitools/upload/planck.svg\\" width=\'20\' height=\'20\'/></a> data provided by <a href=\\"http://cdsweb.u-strasbg.fr/index-fr.gml\\" target=\\"_blank\\"><img width=\'24\' height=\'16\' src=\\"http://demonstrator.telespazio.com/mizar/css/images/cds.svg\\" /></a>"\n    },\n    {\n\t\t"type": "healpix",\n\t\t"name": "Planck-HFI-353",\n\t\t"baseUrl": "http://demonstrator.telespazio.com/sitools/Alasky/PLANCK/HFI353",\n\t\t"description": "PLANCK HFI 353 from CDS",\n\t\t"visible": false,\n\t\t"background": true,\n\t\t"coordSystem": "GAL",\n\t\t"fitsSupported": true,\n\t\t"dataType": "jpg",\n\t\t//"availableServices": [ { "name": "HEALPixCut", "fileName": "HFI_SkyMap_353_2048_R1.10_nominal.fits"\t} ],\n\t\t"numberOfLevels": 2,\n        "attribution":"<a href=\\"http://irsa.ipac.caltech.edu/data/Planck/release_1/all-sky-maps/\\" target=\\"_blank\\"><img src=\\"http://demonstrator.telespazio.com/sitools/upload/planck.svg\\" width=\'20\' height=\'20\'/></a> data provided by <a href=\\"http://cdsweb.u-strasbg.fr/index-fr.gml\\" target=\\"_blank\\"><img width=\'24\' height=\'16\' src=\\"http://demonstrator.telespazio.com/mizar/css/images/cds.svg\\" /></a>"\n    },\n    {\n\t\t"type": "healpix",\n\t\t"name": "Planck-HFI-217",\n\t\t"baseUrl": "http://demonstrator.telespazio.com/sitools/Alasky/PLANCK/HFI217",\n\t\t"description": "PLANCK HFI 217 from CDS",\n\t\t"visible": false,\n\t\t"background": true,\n\t\t"coordSystem": "GAL",\n\t\t"fitsSupported": true,\n\t\t"dataType": "jpg",\n\t\t//"availableServices": [ { "name": "HEALPixCut", "fileName": "HFI_SkyMap_217_2048_R1.10_nominal.fits"\t} ],\n\t\t"numberOfLevels": 2,\n        "attribution":"<a href=\\"http://irsa.ipac.caltech.edu/data/Planck/release_1/all-sky-maps/\\" target=\\"_blank\\"><img src=\\"http://demonstrator.telespazio.com/sitools/upload/planck.svg\\" width=\'20\' height=\'20\'/></a> data provided by <a href=\\"http://cdsweb.u-strasbg.fr/index-fr.gml\\" target=\\"_blank\\"><img width=\'24\' height=\'16\' src=\\"http://demonstrator.telespazio.com/mizar/css/images/cds.svg\\" /></a>"\n    },\n    {\n\t\t"type": "healpix",\n\t\t"name": "Planck-HFI-143",\n\t\t"baseUrl": "http://demonstrator.telespazio.com/sitools/Alasky/PLANCK/HFI143",\n\t\t"description": "PLANCK HFI 143 from CDS",\n\t\t"visible": false,\n\t\t"background": true,\n\t\t"coordSystem": "GAL",\n\t\t"fitsSupported": true,\n\t\t"dataType": "jpg",\n\t\t//"availableServices": [ { "name": "HEALPixCut", "fileName": "HFI_SkyMap_143_2048_R1.10_nominal.fits"\t} ],\n\t\t"numberOfLevels": 2,\n        "attribution":"<a href=\\"http://irsa.ipac.caltech.edu/data/Planck/release_1/all-sky-maps/\\" target=\\"_blank\\"><img src=\\"http://demonstrator.telespazio.com/sitools/upload/planck.svg\\" width=\'20\' height=\'20\'/></a> data provided by <a href=\\"http://cdsweb.u-strasbg.fr/index-fr.gml\\" target=\\"_blank\\"><img width=\'24\' height=\'16\' src=\\"http://demonstrator.telespazio.com/mizar/css/images/cds.svg\\" /></a>"\n    },\n    {\n\t\t"type": "healpix",\n\t\t"name": "Planck-HFI-100",\n\t\t"baseUrl": "http://demonstrator.telespazio.com/sitools/Alasky/PLANCK/HFI100",\n\t\t"description": "PLANCK HFI 100 from CDS",\n\t\t"visible": false,\n\t\t"background": true,\n\t\t"coordSystem": "GAL",\n\t\t"fitsSupported": true,\n\t\t"dataType": "jpg",\n\t\t//"availableServices": [ { "name": "HEALPixCut", "fileName": "HFI_SkyMap_100_2048_R1.10_nominal.fits"\t} ],\n\t\t"numberOfLevels": 2,\n        "attribution":"<a href=\\"http://irsa.ipac.caltech.edu/data/Planck/release_1/all-sky-maps/\\" target=\\"_blank\\"><img src=\\"http://demonstrator.telespazio.com/sitools/upload/planck.svg\\" width=\'20\' height=\'20\'/></a> data provided by <a href=\\"http://cdsweb.u-strasbg.fr/index-fr.gml\\" target=\\"_blank\\"><img width=\'24\' height=\'16\' src=\\"http://demonstrator.telespazio.com/mizar/css/images/cds.svg\\" /></a>"\n    },\n\n\t// Overlay\n\t{\n\t\t"category": "Image",\n\t\t"type": "healpix",\n\t\t"name": "PlanckCMB",\n\t\t"baseUrl" : "http://demonstrator.telespazio.com/sitools/Alasky/PLANCK/CMB",\n\t\t"description": "Planck survey from CDS",\n\t\t"visible": false,\n\t\t"background": false,\n\t\t"dataType": "jpg",\n\t\t"fitsSupported": true,\n\t\t"coordSystem": "GAL",\n        "attribution":"<a href=\\"http://irsa.ipac.caltech.edu/data/Planck/release_1/all-sky-maps/\\" target=\\"_blank\\"><img src=\\"http://demonstrator.telespazio.com/sitools/upload/planck.svg\\" width=\'20\' height=\'20\'/></a> data provided by <a href=\\"http://cdsweb.u-strasbg.fr/index-fr.gml\\" target=\\"_blank\\"><img width=\'24\' height=\'16\' src=\\"http://demonstrator.telespazio.com/mizar/css/images/cds.svg\\" /></a>"\n\t},\n\t/**\n\t *\tHealpix grid\n\t */\n\t{\n\t\t"category": "Other",\n\t\t"type": "healpixGrid",\n\t\t"name": "Healpix grid",\n\t\t"outline": true\n\t},\n\t/**\n\t *\tIAS PLWSAG Healpix imagery\n\t *\n\t *\tPlugin: Proxy Healpix Image cache\n\t *\turlClient: http://healpix.ias.u-psud.fr/PLWSAG-4ALLSKY\n\t */\n\t{\n\t\t"category": "Herschel-SAG4",\n\t\t"type": "healpix",\n\t\t"name": "PLWSAG-4ALL",\n\t\t"baseUrl": "http://demonstrator.telespazio.com/sitools/ias-Alasky/PLWSAG-4ALLSKY/",\n\t\t"description": "PLWSAG-4ALL",\n\t\t"attribution": "PLWSAG-4ALLSKY provided by <a href=\\"http://idoc-herschel.ias.u-psud.fr/\\" target=\\"_blank\\"><img width=\'28\' height=\'16\' src=\\"http://demonstrator.telespazio.com/sitools/upload/idoc.svg\\" /></a>",\n\t\t"visible": false,\n\t\t"background": false,\n\t\t"dataType": "jpg",\n        "numberOfLevels": 5,\n        "fitsSupported": true\n\t},\n\t/**\n\t *\tIAS PMWSAG Healpix imagery\n\t *\n\t *\tPlugin: Proxy Healpix Image cache\n\t *\turlClient: http://healpix.ias.u-psud.fr/PMWSAG-4ALLSKY/\n\t */\n\t{\n\t\t"category": "Herschel-SAG4",\n\t\t"type": "healpix",\n\t\t"name": "PMWSAG-4ALLSKY",\n\t\t"baseUrl": "http://demonstrator.telespazio.com/sitools/ias-Alasky/PMWSAG-4ALLSKY/",\n\t\t"description": "PLWSAG-4ALL",\n\t\t"attribution": "PLWSAG-4ALL provided by <a href=\\"http://idoc-herschel.ias.u-psud.fr/\\" target=\\"_blank\\"><img width=\'28\' height=\'16\' src=\\"http://demonstrator.telespazio.com/sitools/upload/idoc.svg\\" /></a>",\n\t\t"visible": false,\n\t\t"background": false,\n\t\t"dataType": "jpg",\n        "numberOfLevels": 5,\n        "fitsSupported": true\n\t},\n\t/**\n\t *\tIAS PSWSAG Healpix imagery\n\t *\n\t *\tPlugin: Proxy Healpix Image cache\n\t *\turlClient: http://healpix.ias.u-psud.fr/PSWSAG-4ALLSKY/\n\t */\n\t{\n\t\t"category": "Herschel-SAG4",\n\t\t"type": "healpix",\n\t\t"name": "PSWSAG-4ALLSKY",\n\t\t"baseUrl": "http://demonstrator.telespazio.com/sitools/ias-Alasky/PSWSAG-4ALLSKY/",\n\t\t"description": "PSWSAG-4ALLSKY",\n\t\t"attribution": "PSWSAG-4ALLSKY provided by <a href=\\"http://idoc-herschel.ias.u-psud.fr/\\" target=\\"_blank\\"><img width=\'28\' height=\'16\' src=\\"http://demonstrator.telespazio.com/sitools/upload/idoc.svg\\" /></a>",\n\t\t"visible": false,\n\t\t"background": false,\n\t\t"dataType": "jpg",\n        "numberOfLevels": 5,\n        "fitsSupported": true\n\t},\n\t/**\n\t *\tIAS RGBSAG-4ALLSKYfromPNG Healpix imagery\n\t *\n\t *\tPlugin: Proxy Healpix Image cache\n\t *\turlClient: http://healpix.ias.u-psud.fr/SAG-4_RGB/\n\t */\n\t{\n\t\t"category": "Herschel-SAG4",\n\t\t"type": "healpix",\n\t\t"name": "SAG4-Herschel-RGB",\n\t\t"baseUrl": "http://demonstrator.telespazio.com/sitools/ias-Alasky/SAG-4_RGB",\n\t\t"description": "combined bands (PSW, PMW, PLW)",\n\t\t"attribution": "SAG4-Herschel-RGB provided by <a href=\\"http://idoc-herschel.ias.u-psud.fr/\\" target=\\"_blank\\"><img width=\'28\' height=\'16\' src=\\"http://demonstrator.telespazio.com/sitools/upload/idoc.svg\\" /></a>",\n\t\t"visible": false,\n\t\t"background": false,\n\t\t"dataType": "png",\n        "numberOfLevels": 5,\n        "fitsSupported": true\n\t},\n\t/**\n\t *\tOpenSearch SOLR Herschel layer\n\t *\n\t *\tPlugin: OpenSearch Application\n\t *\tqueryShape: healpix\n\t *\thealpixScheme: NESTED\n\t *\tsolrCore: herschel\n\t */\n\t{\n        "category": "Herschel-SAG4",\n\t\t"type": "DynamicOpenSearch",\n\t\t"dataType": "line",\n\t\t"name": "Pacs-SAG4-Herschel",\n\t\t"serviceUrl": "http://demonstrator.telespazio.com/sitools/oherschel",\n\t\t"visible": false,\n        "description": "SAG-4 : Evolution of interstellar dust (Herschel Guaranteed Time Key Project prepared by the ISM Specialist Astronomy Group of the SPIRE consortium) ",\n\t\t"attribution": "SAG4 provided by <a href=\\"http://idoc-herschel.ias.u-psud.fr/\\" target=\\"_blank\\"><img width=\'28\' height=\'16\' src=\\"http://demonstrator.telespazio.com/sitools/upload/idoc.svg\\" /></a>",\n\t\t"minOrder": 4,\n\t\t"availableServices": [ "OpenSearch", "Moc", "XMatch" ]\n\t},\n\t/**\n\t *\tOpenSearch SOLR Herschel layer\n\t *\n\t *\tPlugin: OpenSearch Application\n\t *\tqueryShape: healpix\n\t *\thealpixScheme: NESTED\n\t *\tsolrCore: spire-herschel\n\t */\n\t{\n        "category": "Herschel-SAG4",\n\t\t"type": "DynamicOpenSearch",\n\t\t"dataType": "line",\n\t\t"name": "Spire-SAG4-Herschel",\n\t\t"serviceUrl": "http://demonstrator.telespazio.com/sitools/spireherschel",\n\t\t"visible": false,\n\t\t"minOrder": 4,\n        "description": "SAG-4 : Evolution of interstellar dust (Herschel Guaranteed Time Key Project prepared by the ISM Specialist Astronomy Group of the SPIRE consortium) ",\n\t\t"attribution": "SAG4 provided by <a href=\\"http://idoc-herschel.ias.u-psud.fr/\\" target=\\"_blank\\"><img width=\'28\' height=\'16\' src=\\"http://demonstrator.telespazio.com/sitools/upload/idoc.svg\\" /></a>",\n\t\t"availableServices": [ "OpenSearch", "Moc", "XMatch" ]\n\t},\n\t/**\n\t *\tOpenSearch SIA ESO layer\n\t *\n\t *\tPlugin: VO OpenSearchApplication for Sia\n\t *\tsiaSearchUrl: http://archive.eso.org/apps/siaserver/EsoProxySiap?\n\t */\n\t{\n\t\t"category": "Image",\n\t\t"type": "DynamicOpenSearch",\n\t\t"dataType": "line",\n\t\t"name": "ESO",\n\t\t"serviceUrl": "http://demonstrator.telespazio.com/sitools/eso/siap",\n        "displayProperties": [ "identifier","Instrument","Telescope name","quicklook"],\n\t\t"visible": false,\n        "attribution":"<a href=\\"http://archive.eso.org/cms.html\\" target=\\"_blank\\"><img width=\'28\' height=\'28\' src=\\"http://demonstrator.telespazio.com/sitools/upload/eso.svg\\"></a>Science Archive Facility",\n\t\t"minOrder": 4,\n\t\t"invertY": true\n\t},\n\t/**\n\t *\tOpenSearch Sia HST layer\n\t *\n\t *\tPlugin: VO OpenSearch Application for Sia\n\t *\tsiaSearchUrl: http://archives.esac.esa.int/hst/hst-vo/hla_sia?REQUEST=queryData&\n\t */\n\t{\n\t\t"category": "Image",\n\t\t"type": "DynamicOpenSearch",\n\t\t"dataType": "line",\n\t\t"name": "HST",\n\t\t"serviceUrl": "http://demonstrator.telespazio.com/sitools/hst",\n        "description":"Hubble Space Telescope (HST) is an orbiting astronomical observatory operating from the near-infrared into the ultraviolet. Launched in 1990 and scheduled to operate through 2010, HST carries and has carried a wide variety of instruments producing imaging, spectrographic, astrometric, and photometric data through both pointed and parallel observing programs. MAST is the primary archive and distribution center for HST data, distributing science, calibration, and engineering data to HST users and the astronomical community at large. Over 100 000 observations of more than 20 000 targets are available for retrieval from the Archive.",\n\t\t"visible": false,\n\t\t"minOrder": 4,\n        "attribution":"HST data provided by <a href=\\"http://hst.esac.esa.int\\" target=\\"_blank\\"><img src=\\"http://demonstrator.telespazio.com/sitools/upload/esa.svg\\" width=\'28\' height=\'16\'/></a>"\n\t},\n\t/**\n\t *\tOpenSearch Sia ISO layer\n\t *\n\t *\tPlugin: VO OpenSearch Application for Sia\n\t *\tsiaSearchUrl: http://archives.esac.esa.int/ida/aio/jsp/siap.jsp?imageType=image&\n\t */\n\t{\n\t\t"category": "Image",\n\t\t"type": "DynamicOpenSearch",\n\t\t"dataType": "line",\n\t\t"name": "Iso",\n\t\t"serviceUrl": "http://demonstrator.telespazio.com/sitools/iso",\n\t\t"visible": false,\n\t\t"minOrder": 4,\n\t\t"availableServices": [ "Moc", "XMatch" ]\n\t},\n\t/**\n\t *\tOpenSearch ConeSearch I320 layer\n\t *\n\t *\tPlugin: VO OpenSearch Application for Cone Search\n\t *\tmocUrl: http://alasky.u-strasbg.fr/footprints/tables/vizier/I_320_spm4/MOC\n\t *\tconeSearchUrl: http://vizier.u-strasbg.fr/viz-bin/votable/-A?-source=I/320/spm4&\n\t */\n\t{\n\t\t"category": "Catalog",\n\t\t"type": "DynamicOpenSearch",\n\t\t"dataType": "point",\n\t\t"name": "SPM4",\n\t\t"description":"The SPM4 Catalog contains absolute proper motions, celestial coordinates, and B,V photometry for 103,319,647 stars and galaxies between the south celestial pole and -20 degrees declination. The  catalog is roughly complete to V=17.5. It is based on photographic  and CCD observations taken with the Yale Southern Observatory\'s  double-astrograph at Cesco Observatory in El Leoncito, Argentina. The first-epoch survey, taken from 1965 to 1979, was entirely photographic. The second-epoch survey is approximately 1/3 photographic (taken from 1988 to 1998) and 2/3 CCD-based (taken  from 2004 through 2008). Full details about the creation of the SPM4.0 catalog can be found in the paper, and also in  the document \\"spm4_doc.txt\\" file which describes the original files, accessible from tttp://www.astro.yale.edu/astrom/spm4cat/",\n\t\t"serviceUrl": "http://demonstrator.telespazio.com/sitools/i320",\n\t\t"visible": false,\n\t\t"minOrder": 9,\n\t\t"availableServices": [ "Moc", "XMatch" ]\n\t},\n\t/**\n\t *\tOpenSearch ConeSearch USNOB1 layer\n\t *\n\t *\tPlugin: VO OpenSearch Application for Cone Search\n\t *\tmocUrl: http://alasky.u-strasbg.fr/footprints/tables/vizier/I_284_out/MOC\n\t *\tconeSearchUrl: http://vizier.u-strasbg.fr/viz-bin/votable/-A?-source=I/284&\n\t */\n\t{\n\t\t"category": "Catalog",\n\t\t"type": "DynamicOpenSearch",\n\t\t"dataType": "point",\n\t\t"name": "USNO-B1.0",\n\t\t"description":" The USNO-B1.0 is a catalog that presents positions, proper motions, magnitudes in various optical passbands, and star/galaxy estimators for 1,045,913,669 objects derived from 3,648,832,040 separate observations. The data were taken from scans of 7,435 Schmidt plates taken from various sky surveys during the last 50 years. The catalog is expected to be complete down to V=21; the estimated accuracies are 0.2arcsec for the positions at J2000, 0.3mag in up to 5 colors, and 85% accuracy for distinguishing stars from non-stellar objects.",\n\t\t"attribution": "USNOB1 coming from <a href=\\"http://cdsweb.u-strasbg.fr/index-fr.gml\\" target=\\"_blank\\"><img width=\'24\' height=\'16\' src=\\"http://demonstrator.telespazio.com/mizar/css/images/cds.svg\\" /></a>",\n\t\t"serviceUrl": "http://demonstrator.telespazio.com/sitools/usnob1",\n\t\t"visible": false,\n\t\t"minOrder": 9,\n\t\t"availableServices": [ "Moc", "XMatch" ]\n\t},\n\t/**\n\t *\tOpenSearch ConeSearch Hipparcos layer\n\t *\n\t *\tPlugin: VO OpenSearch Application for Cone Search\n\t *\tmocUrl: http://alasky.u-strasbg.fr/footprints/tables/vizier/I_239_tyc_main/MOC\n\t *\tconeSearchUrl: http://vizier.u-strasbg.fr/viz-bin/votable/-A?-source=I/239&\n\t */\n\t//{\n\t//\t"category": "Catalog",\n\t//\t"type": "DynamicOpenSearch",\n\t//\t"dataType": "point",\n\t//\t"name": "Hipparcos",\n\t//\t"description":" The Hipparcos and Tycho Catalogues are the primary products of the  European Space Agency\'s astrometric mission, Hipparcos. The satellite, which operated for four years, returned high quality scientific data from November 1989 to March 1993.",\n\t//\t"attribution": "Hipparcos coming from <a href=\\"http://cdsweb.u-strasbg.fr/index-fr.gml\\" target=\\"_blank\\"><img width=\'24\' height=\'16\' src=\\"http://demonstrator.telespazio.com/mizar/css/images/cds.svg\\" /></a>",\n\t//\t"serviceUrl": "/sitools/hipparcos",\n\t//\t"visible": false,\n\t//\t"minOrder": 5,\n\t//\t"availableServices": [ "Moc", "XMatch" ]\n\t//},\n    /**\n     *      Built-in planets provider\n     */\n    {\n        "category": "Solar system",\n        "type": "GeoJSON",\n        "name": "Planets",\n        "icon": "http://demonstrator.telespazio.com/mizar/css/images/star_icon.png",\n        "description": "Planets",\n        "data": {\n                "type": "planets"\n        },\n        "visible": true,\n        "opacity": 100,\n        "pickable" : false\n    },\n\n\t/**\n\t *\tOpenSearch ConeSearch IMCCE layer\n\t *\n\t *\tPlugin: VO OpenSearch Application for Cone Search\n\t *\tmocUrl: http://alasky.u-strasbg.fr/footprints/tables/vizier/II_306_sdss8/MOC\n\t *\tconeSearchUrl: http://vo.imcce.fr/webservices/skybot/skybotconesearch_query.php?from=SITools2&EPOCH=now&\n\t */\n\t{\n\t\t"category": "Solar system",\n\t\t"type": "DynamicOpenSearch",\n\t\t"dataType": "point",\n\t\t"name": "IMCCE",\n\t\t"serviceUrl": "http://demonstrator.telespazio.com/sitools/solar",\n\t\t"minOrder": 7\n\t},\n\t/**\n\t *\tOpenSearch ConeSearch exoplanet layer\n\t *\n\t *\tPlugin: VO OpenSearch Application\n\t *\tconeSearchUrl: http://exoplanet.eu/catalog/conesearch?\n\t */\n\t{\n\t\t"category": "Solar system",\n\t\t"type": "DynamicOpenSearch",\n\t\t"dataType": "point",\n\t\t"name": "Exoplanets",\n\t\t"description":"The Extrasolar Planets Encyclopaedia (http://exoplanet.eu)",\n\t\t"serviceUrl": "http://demonstrator.telespazio.com/sitools/exoplanet",\n\t\t"visible": false,\n\t\t"minOrder": 3\n\t},\n\t/**\n\t *\tOpenSearch ConeSearch COROT exo\n\t *\n\t *\tPlugin: VO OpenSearch Application\n\t *\tconeSearchUrl: http://vizier.u-strasbg.fr/viz-bin/votable/-A?-source=B/corot/exo&\n\t */\n\t{\n\t\t"category": "Corot",\n\t\t"type": "DynamicOpenSearch",\n\t\t"dataType": "point",\n\t\t"name": "Corot exo",\n\t\t"description":"CoRoT observation log Release 13 (CoRoT, 2009-2013). Stars observed in the exoplanet detection program",\n\t\t"serviceUrl": "http://demonstrator.telespazio.com/sitools/corot/exo",\n\t\t"visible": false,\n\t\t"minOrder": 5,\n\t\t"availableServices" : [ "Moc", "XMatch" ],\n        "attribution":"<img width=\'28\' height=\'16\' src=\\"http://demonstrator.telespazio.com/sitools/upload/corot.svg\\"> data provided by <a href=\\"http://cdsweb.u-strasbg.fr/index-fr.gml\\" target=\\"_blank\\"><img width=\'24\' height=\'16\' src=\\"http://demonstrator.telespazio.com/mizar/css/images/cds.svg\\" /></a>"\n\t},\n\t/**\n\t *\tOpenSearch ConeSearch COROT exo\n\t *\n\t *\tPlugin: VO OpenSearch Application\n\t *\tconeSearchUrl: http://vizier.u-strasbg.fr/viz-bin/votable/-A?-source=B/corot/astero&\n\t */\n\t{\n\t\t"category": "Corot",\n\t\t"type": "DynamicOpenSearch",\n\t\t"dataType": "point",\n\t\t"name": "Corot astero",\n\t\t"description":"CoRoT observation log Release 13 (CoRoT, 2009-2013). Stars observed in the asterosismology program",\n\t\t"serviceUrl": "http://demonstrator.telespazio.com/sitools/corot/astero",\n\t\t"visible": false,\n\t\t"minOrder": 5,\n\t\t"availableServices" : [ "Moc", "XMatch" ],\n        "attribution":"<img width=\'28\' height=\'16\' src=\\"http://demonstrator.telespazio.com/sitools/upload/corot.svg\\"> data provided by <a href=\\"http://cdsweb.u-strasbg.fr/index-fr.gml\\" target=\\"_blank\\"><img width=\'24\' height=\'16\' src=\\"http://demonstrator.telespazio.com/mizar/css/images/cds.svg\\" /></a>"\n\t}\n]';});

/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

/** 
 *	Module with constants
 */
define('gw/HEALPixTables',[],function() {

/**************************************************************************************************************/

var HealPixTables = {
	ctab : [
	  0,1,256,257,2,3,258,259,512,513,768,769,514,515,770,771,4,5,260,261,6,7,262,
	  263,516,517,772,773,518,519,774,775,1024,1025,1280,1281,1026,1027,1282,1283,
	  1536,1537,1792,1793,1538,1539,1794,1795,1028,1029,1284,1285,1030,1031,1286,
	  1287,1540,1541,1796,1797,1542,1543,1798,1799,8,9,264,265,10,11,266,267,520,
	  521,776,777,522,523,778,779,12,13,268,269,14,15,270,271,524,525,780,781,526,
	  527,782,783,1032,1033,1288,1289,1034,1035,1290,1291,1544,1545,1800,1801,1546,
	  1547,1802,1803,1036,1037,1292,1293,1038,1039,1294,1295,1548,1549,1804,1805,
	  1550,1551,1806,1807,2048,2049,2304,2305,2050,2051,2306,2307,2560,2561,2816,
	  2817,2562,2563,2818,2819,2052,2053,2308,2309,2054,2055,2310,2311,2564,2565,
	  2820,2821,2566,2567,2822,2823,3072,3073,3328,3329,3074,3075,3330,3331,3584,
	  3585,3840,3841,3586,3587,3842,3843,3076,3077,3332,3333,3078,3079,3334,3335,
	  3588,3589,3844,3845,3590,3591,3846,3847,2056,2057,2312,2313,2058,2059,2314,
	  2315,2568,2569,2824,2825,2570,2571,2826,2827,2060,2061,2316,2317,2062,2063,
	  2318,2319,2572,2573,2828,2829,2574,2575,2830,2831,3080,3081,3336,3337,3082,
	  3083,3338,3339,3592,3593,3848,3849,3594,3595,3850,3851,3084,3085,3340,3341,
	  3086,3087,3342,3343,3596,3597,3852,3853,3598,3599,3854,3855 ],
	utab : [
	  0,1,4,5,16,17,20,21,64,65,68,69,80,81,84,85,256,257,260,261,272,273,276,277,
	  320,321,324,325,336,337,340,341,1024,1025,1028,1029,1040,1041,1044,1045,1088,
	  1089,1092,1093,1104,1105,1108,1109,1280,1281,1284,1285,1296,1297,1300,1301,
	  1344,1345,1348,1349,1360,1361,1364,1365,4096,4097,4100,4101,4112,4113,4116,
	  4117,4160,4161,4164,4165,4176,4177,4180,4181,4352,4353,4356,4357,4368,4369,
	  4372,4373,4416,4417,4420,4421,4432,4433,4436,4437,5120,5121,5124,5125,5136,
	  5137,5140,5141,5184,5185,5188,5189,5200,5201,5204,5205,5376,5377,5380,5381,
	  5392,5393,5396,5397,5440,5441,5444,5445,5456,5457,5460,5461,16384,16385,16388,
	  16389,16400,16401,16404,16405,16448,16449,16452,16453,16464,16465,16468,16469,
	  16640,16641,16644,16645,16656,16657,16660,16661,16704,16705,16708,16709,16720,
	  16721,16724,16725,17408,17409,17412,17413,17424,17425,17428,17429,17472,17473,
	  17476,17477,17488,17489,17492,17493,17664,17665,17668,17669,17680,17681,17684,
	  17685,17728,17729,17732,17733,17744,17745,17748,17749,20480,20481,20484,20485,
	  20496,20497,20500,20501,20544,20545,20548,20549,20560,20561,20564,20565,20736,
	  20737,20740,20741,20752,20753,20756,20757,20800,20801,20804,20805,20816,20817,
	  20820,20821,21504,21505,21508,21509,21520,21521,21524,21525,21568,21569,21572,
	  21573,21584,21585,21588,21589,21760,21761,21764,21765,21776,21777,21780,21781,
	  21824,21825,21828,21829,21840,21841,21844,21845 ],

	  // coordinate of the lowest corner of each face
	  jrll : [ 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4 ],
	  jpll : [ 1, 3, 5, 7, 0, 2, 4, 6, 1, 3, 5, 7 ],

	  xoffset : [ -1,-1, 0, 1, 1, 1, 0,-1 ],
	  yoffset : [  0, 1, 1, 1, 0,-1,-1,-1 ],
	  facearray :
			[ [  8, 9,10,11,-1,-1,-1,-1,10,11, 8, 9 ],   // S
			  [  5, 6, 7, 4, 8, 9,10,11, 9,10,11, 8 ],   // SE
			  [ -1,-1,-1,-1, 5, 6, 7, 4,-1,-1,-1,-1 ],   // E
			  [  4, 5, 6, 7,11, 8, 9,10,11, 8, 9,10 ],   // SW
			  [  0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10,11 ],   // center
			  [  1, 2, 3, 0, 0, 1, 2, 3, 5, 6, 7, 4 ],   // NE
			  [ -1,-1,-1,-1, 7, 4, 5, 6,-1,-1,-1,-1 ],   // W
			  [  3, 0, 1, 2, 3, 0, 1, 2, 4, 5, 6, 7 ],   // NW
			  [  2, 3, 0, 1,-1,-1,-1,-1, 0, 1, 2, 3 ] ], // N
	  swaparray :
			[ [ 0,0,3 ],   // S
			  [ 0,0,6 ],   // SE
			  [ 0,0,0 ],   // E
			  [ 0,0,5 ],   // SW
			  [ 0,0,0 ],   // center
			  [ 5,0,0 ],   // NE
			  [ 0,0,0 ],   // W
			  [ 6,0,0 ],   // NW
			  [ 3,0,0 ] ], // N

	  swap_cycle : [
		[],
		[0,1,8,12,16,21,40],
		[0,1,2,40,114],
		[0,4,160,263],
		[0,4,30,49,51,87,526,1027,1105,1387,1807,2637],
		[0,8,10,18,39,74,146,307,452,4737],
		[0,1,2,7,9,17,80,410,1526,1921,32859,33566,38931],
		[0,5,6,10,12,24,27,95,372,494,924,1409,3492,4248,9137,66043,103369,156899],
		[0,1,2,3,4,45,125,351,697,24337,102940,266194,341855,419857],
		[0,1,2,3,9,16,1705,2082,2126,8177,12753,15410,52642,80493,83235,88387,99444,
		 1675361,2495125],
		[0,2,6,8,9,11,20,50,93,152,183,2137,13671,44794,486954,741908,4803258,
		  5692573],
		[0,1,5,6,44,53,470,2847,3433,4906,13654,14710,400447,1797382,2744492,
		  18775974,23541521],
		[0,4,9,10,16,33,83,117,318,451,5759,10015,128975,171834,211256,347608,
		  1278690,2154097,2590798,3427694,5581717,21012301,27023976,72522811,
		  95032729,139166747,171822389],
		[0,5,10,267,344,363,2968,3159,9083,18437,76602,147614,1246902,1593138,
		  2035574,6529391,9511830,11340287,29565945,281666026,677946848] ]
};

return HealPixTables;

});
/***************************************
 * Copyright 2009 The Closure Library Authors. All Rights Reserved. (Apache License, Version 2.0)
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('gw/Long',[],function() {


/**************************************************************************************************************/

/**
*	@constructor Long
*	Long class for only unsigned integers
*/

/**
 * Constructs a 64-bit two's-complement integer, given its low and high 32-bit
 * values as *signed* integers.  See the from* functions below for more
 * convenient ways of constructing Longs.
 *
 * The internal representation of a long is the two given signed, 32-bit values.
 * We use 32-bit pieces because these are the size of integers on which
 * Javascript performs bit-operations.  For operations like addition and
 * multiplication, we split each number into 16-bit pieces, which can easily be
 * multiplied within Javascript's floating-point representation without overflow
 * or change in sign.
 *
 * In the algorithms below, we frequently reduce the negative case to the
 * positive case by negating the input(s) and then post-processing the result.
 * Note that we must ALWAYS check specially whether those values are MIN_VALUE
 * (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as
 * a positive number, it overflows back into a negative).  Not handling this
 * case would often result in infinite recursion.
 *
 * @param {number} low  The low (signed) 32 bits of the long.
 * @param {number} high  The high (signed) 32 bits of the long.
 * @constructor
 */
var Long = function(low, high) {
  /**
   * @type {number}
   * @private
   */
  this.low_ = low | 0;  // force into 32 signed bits.

  /**
   * @type {number}
   * @private
   */
  this.high_ = high | 0;  // force into 32 signed bits.
};

/**
 * A cache of the Long representations of small integer values.
 * @type {!Object}
 * @private
 */
Long.IntCache_ = {};

/**
 * Returns a Long representing the given (32-bit) integer value.
 * @param {number} value The 32-bit integer in question.
 * @return {!Long} The corresponding Long value.
 */
Long.fromInt = function(value) {
  if (-128 <= value && value < 128) {
    var cachedObj = Long.IntCache_[value];
    if (cachedObj) {
      return cachedObj;
    }
  }

  var obj = new Long(value | 0, value < 0 ? -1 : 0);
  if (-128 <= value && value < 128) {
    Long.IntCache_[value] = obj;
  }
  return obj;
};

/**
 * Returns a Long representing the given value, provided that it is a finite
 * number.  Otherwise, zero is returned.
 * @param {number} value The number in question.
 * @return {!Long} The corresponding Long value.
 */
Long.fromNumber = function(value) {
  if (isNaN(value) || !isFinite(value)) {
    return Long.ZERO;
  } else if (value <= -Long.TWO_PWR_63_DBL_) {
    return Long.MIN_VALUE;
  } else if (value + 1 >= Long.TWO_PWR_63_DBL_) {
    return Long.MAX_VALUE;
  } else if (value < 0) {
    return Long.fromNumber(-value).negate();
  } else {
    return new Long(
        (value % Long.TWO_PWR_32_DBL_) | 0,
        (value / Long.TWO_PWR_32_DBL_) | 0);
  }
};

/**
 * Returns a Long representing the 64-bit integer that comes by concatenating
 * the given high and low bits.  Each is assumed to use 32 bits.
 * @param {number} lowBits The low 32-bits.
 * @param {number} highBits The high 32-bits.
 * @return {!Long} The corresponding Long value.
 */
Long.fromBits = function(lowBits, highBits) {
  return new Long(lowBits, highBits);
};

/**
 * Number used repeated below in calculations.  This must appear before the
 * first call to any from* function below.
 * @type {number}
 * @private
 */
Long.TWO_PWR_16_DBL_ = 1 << 16;


/**
 * @type {number}
 * @private
 */
Long.TWO_PWR_24_DBL_ = 1 << 24;


/**
 * @type {number}
 * @private
 */
Long.TWO_PWR_32_DBL_ =
    Long.TWO_PWR_16_DBL_ * Long.TWO_PWR_16_DBL_;


/**
 * @type {number}
 * @private
 */
Long.TWO_PWR_64_DBL_ =
    Long.TWO_PWR_32_DBL_ * Long.TWO_PWR_32_DBL_;


/**
 * @type {number}
 * @private
 */
Long.TWO_PWR_63_DBL_ =
    Long.TWO_PWR_64_DBL_ / 2;


/** @type {!Long} */
Long.ZERO = Long.fromInt(0);


/** @type {!Long} */
Long.ONE = Long.fromInt(1);

/** @type {!Long} */
Long.MAX_VALUE =
    Long.fromBits(0xFFFFFFFF | 0, 0x7FFFFFFF | 0);


/** @type {!Long} */
Long.MIN_VALUE = Long.fromBits(0, 0x80000000 | 0);

/**
 * @type {!Long}
 * @private
 */
Long.TWO_PWR_24_ = Long.fromInt(1 << 24);


/** @return {number} The value, assuming it is a 32-bit integer. */
Long.prototype.toInt = function() {
  return this.low_;
};

/** @return {number} The closest floating-point representation to this value. */
Long.prototype.toNumber = function() {
  return this.high_ * Long.TWO_PWR_32_DBL_ +
         this.getLowBitsUnsigned();
};

/** @return {number} The low 32-bits as an unsigned value. */
Long.prototype.getLowBitsUnsigned = function() {
  return (this.low_ >= 0) ?
      this.low_ : Long.TWO_PWR_32_DBL_ + this.low_;
};

/** @return {boolean} Whether this value is zero. */
Long.prototype.isZero = function() {
  return this.high_ == 0 && this.low_ == 0;
};


/** @return {boolean} Whether this value is negative. */
Long.prototype.isNegative = function() {
  return this.high_ < 0;
};


/** @return {boolean} Whether this value is odd. */
Long.prototype.isOdd = function() {
  return (this.low_ & 1) == 1;
};


/**
 * @param {Long} other Long to compare against.
 * @return {boolean} Whether this Long equals the other.
 */
Long.prototype.equals = function(other) {
  return (this.high_ == other.high_) && (this.low_ == other.low_);
};

/**
 * @param {Long} other Long to compare against.
 * @return {boolean} Whether this Long is less than the other.
 */
Long.prototype.lessThan = function(other) {
  return this.compare(other) < 0;
};

/**
 * @param {Long} other Long to compare against.
 * @return {boolean} Whether this Long is greater than or equal to the other.
 */
Long.prototype.greaterThanOrEqual = function(other) {
  return this.compare(other) >= 0;
};


/**
 * Compares this Long with the given one.
 * @param {Long} other Long to compare against.
 * @return {number} 0 if they are the same, 1 if the this is greater, and -1
 *     if the given one is greater.
 */
Long.prototype.compare = function(other) {
  if (this.equals(other)) {
    return 0;
  }

  var thisNeg = this.isNegative();
  var otherNeg = other.isNegative();
  if (thisNeg && !otherNeg) {
    return -1;
  }
  if (!thisNeg && otherNeg) {
    return 1;
  }

  // at this point, the signs are the same, so subtraction will not overflow
  if (this.subtract(other).isNegative()) {
    return -1;
  } else {
    return 1;
  }
};

/** @return {!Long} The negation of this value. */
Long.prototype.negate = function() {
  if (this.equals(Long.MIN_VALUE)) {
    return Long.MIN_VALUE;
  } else {
    return this.not().add(Long.ONE);
  }
};


/**
 * Returns the sum of this and the given Long.
 * @param {Long} other Long to add to this one.
 * @return {!Long} The sum of this and the given Long.
 */
Long.prototype.add = function(other) {
  // Divide each number into 4 chunks of 16 bits, and then sum the chunks.

  var a48 = this.high_ >>> 16;
  var a32 = this.high_ & 0xFFFF;
  var a16 = this.low_ >>> 16;
  var a00 = this.low_ & 0xFFFF;

  var b48 = other.high_ >>> 16;
  var b32 = other.high_ & 0xFFFF;
  var b16 = other.low_ >>> 16;
  var b00 = other.low_ & 0xFFFF;

  var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
  c00 += a00 + b00;
  c16 += c00 >>> 16;
  c00 &= 0xFFFF;
  c16 += a16 + b16;
  c32 += c16 >>> 16;
  c16 &= 0xFFFF;
  c32 += a32 + b32;
  c48 += c32 >>> 16;
  c32 &= 0xFFFF;
  c48 += a48 + b48;
  c48 &= 0xFFFF;
  return Long.fromBits((c16 << 16) | c00, (c48 << 16) | c32);
};


/**
 * Returns the difference of this and the given Long.
 * @param {Long} other Long to subtract from this.
 * @return {!Long} The difference of this and the given Long.
 */
Long.prototype.subtract = function(other) {
  return this.add(other.negate());
};


/**
 * Returns the product of this and the given long.
 * @param {Long} other Long to multiply with this.
 * @return {!Long} The product of this and the other.
 */
Long.prototype.multiply = function(other) {
  if (this.isZero()) {
    return Long.ZERO;
  } else if (other.isZero()) {
    return Long.ZERO;
  }

  if (this.equals(Long.MIN_VALUE)) {
    return other.isOdd() ? Long.MIN_VALUE : Long.ZERO;
  } else if (other.equals(Long.MIN_VALUE)) {
    return this.isOdd() ? Long.MIN_VALUE : Long.ZERO;
  }

  if (this.isNegative()) {
    if (other.isNegative()) {
      return this.negate().multiply(other.negate());
    } else {
      return this.negate().multiply(other).negate();
    }
  } else if (other.isNegative()) {
    return this.multiply(other.negate()).negate();
  }

  // If both longs are small, use float multiplication
  if (this.lessThan(Long.TWO_PWR_24_) &&
      other.lessThan(Long.TWO_PWR_24_)) {
    return Long.fromNumber(this.toNumber() * other.toNumber());
  }

  // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.
  // We can skip products that would overflow.

  var a48 = this.high_ >>> 16;
  var a32 = this.high_ & 0xFFFF;
  var a16 = this.low_ >>> 16;
  var a00 = this.low_ & 0xFFFF;

  var b48 = other.high_ >>> 16;
  var b32 = other.high_ & 0xFFFF;
  var b16 = other.low_ >>> 16;
  var b00 = other.low_ & 0xFFFF;

  var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
  c00 += a00 * b00;
  c16 += c00 >>> 16;
  c00 &= 0xFFFF;
  c16 += a16 * b00;
  c32 += c16 >>> 16;
  c16 &= 0xFFFF;
  c16 += a00 * b16;
  c32 += c16 >>> 16;
  c16 &= 0xFFFF;
  c32 += a32 * b00;
  c48 += c32 >>> 16;
  c32 &= 0xFFFF;
  c32 += a16 * b16;
  c48 += c32 >>> 16;
  c32 &= 0xFFFF;
  c32 += a00 * b32;
  c48 += c32 >>> 16;
  c32 &= 0xFFFF;
  c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
  c48 &= 0xFFFF;
  return Long.fromBits((c16 << 16) | c00, (c48 << 16) | c32);
};

/** @return {!Long} The bitwise-NOT of this value. */
Long.prototype.not = function() {
  return Long.fromBits(~this.low_, ~this.high_);
};


/**
 * Returns the bitwise-AND of this Long and the given one.
 * @param {Long} other The Long with which to AND.
 * @return {!Long} The bitwise-AND of this and the other.
 */
Long.prototype.and = function(other) {
  return Long.fromBits(this.low_ & other.low_,
                                 this.high_ & other.high_);
};


/**
 * Returns the bitwise-OR of this Long and the given one.
 * @param {Long} other The Long with which to OR.
 * @return {!Long} The bitwise-OR of this and the other.
 */
Long.prototype.or = function(other) {
  return Long.fromBits(this.low_ | other.low_,
                                 this.high_ | other.high_);
};

/**
 * Returns this Long with bits shifted to the right by the given amount, with
 * the new top bits matching the current sign bit.
 * @param {number} numBits The number of bits by which to shift.
 * @return {!Long} This shifted to the right by the given amount, with
 *     zeros placed into the new leading bits.
 */
Long.prototype.shiftRightUnsigned = function(numBits) {
  numBits &= 63;
  if (numBits == 0) {
    return this;
  } else {
    var high = this.high_;
    if (numBits < 32) {
      var low = this.low_;
      return Long.fromBits(
          (low >>> numBits) | (high << (32 - numBits)),
          high >>> numBits);
    } else if (numBits == 32) {
      return Long.fromBits(high, 0);
    } else {
      return Long.fromBits(high >>> (numBits - 32), 0);
    }
  }
};

/**************************************************************************************************************/

return Long;

});

/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

/** 
 *	Module which contains all the maths stuff
 */
define('gw/HEALPixBase',['./HEALPixTables','./Long'], function(HealPixTables,Long) {

/**************************************************************************************************************/

var HALF_PI = 3.14159265/2;

var lonLat2ang = function(lon, lat)
{
	if ( lon < 0 )
		lon += 360;

	var phi = lon * Math.PI / 180.;
	
	var theta = ( -lat + 90. ) * Math.PI / 180.;
	return [phi, theta];
}

/**************************************************************************************************************/

/** Returns the remainder of the division {@code v1/v2}.
  The result is non-negative.
  @param v1 dividend; can be positive or negative
  @param v2 divisor; must be positive
  @return Remainder of the division; positive and smaller than {@code v2} */
var fmodulo = function(v1, v2)
{
	if (v1>=0.)
		return (v1<v2) ? v1 : v1%v2;
	var tmp=v1%v2+v2;
	return (tmp==v2) ? 0. : tmp;
}

/**************************************************************************************************************/

var spread_bits = function(v)
{
	return (HealPixTables.utab[ v      &0xff])      | ((HealPixTables.utab[(v>>> 8)&0xff])<<16)
		| ((HealPixTables.utab[(v>>>16)&0xff])<<32) | ((HealPixTables.utab[(v>>>24)&0xff])<<48);
}

/**************************************************************************************************************/

var xyf2nest = function(ix, iy, face_num, order)
{
    return ((face_num)<<(2*order)) +
     		 spread_bits(ix) + (spread_bits(iy)<<1);
}

/**************************************************************************************************************/

var loc2pix = function(order, phi, theta)
{
	var nside = Math.pow(2, order);
	var z = Math.cos(theta);
	var phi = phi;

	var loc = {
		phi: phi,
		theta: theta,
		z: z
	}
	if (Math.abs(z)>(9./10.))
	{
	  loc.sth = Math.sin(theta);
	  loc.have_sth=true;
	}

	var inv_halfpi = 2./Math.PI;
	var tt = fmodulo((phi*inv_halfpi),4.0);// in [0,4)

	var za = Math.abs(z);
	if (za<=2./3.) // Equatorial region
	{
		var temp1 = nside*(0.5+tt);
        var temp2 = nside*(z*0.75);

        var jp = Long.fromNumber(temp1 - temp2);
        var jm = Long.fromNumber(temp1 + temp2);
        var ifp = jp.shiftRightUnsigned(order);
        var ifm = jm.shiftRightUnsigned(order);
        var face_num;
        if ( ifp.equals(ifm) )
        {
        	face_num = ifp.or(Long.fromInt(4));
        }
        else
        {
        	if ( ifp.lessThan(ifm) )
        	{
        		face_num = ifp;
        	}
        	else
        	{
        		face_num = ifm.add(Long.fromInt(8));
        	}
        }

        var nSideMinusOne = Long.fromNumber(nside-1);
        var ix = jm.and( nSideMinusOne );
        var iy = nSideMinusOne.subtract( jp.and(nSideMinusOne) );

        return xyf2nest(ix.toInt(),iy.toInt(),face_num.toInt(), order);

	}
		else // polar region, za > 2/3
	{
		var ntt = parseInt( Math.min( 3, parseInt(tt) ) );
		var tp = tt-ntt;
		var tmp = ( (za < (9./10.)) || (!loc.have_sth) ) ?
						nside*Math.sqrt(3*(1-za)) :
						nside*loc.sth/Math.sqrt((1.+za)/3.);

		var jp = Long.fromNumber(tp*tmp);
		var jm = Long.fromNumber((1.0-tp)*tmp);
		var lNside = Long.fromNumber(nside);
		var nSideMinusOne = Long.fromNumber(nside-1.);
		var lOne = Long.fromInt(1);
		if ( jp.greaterThanOrEqual(lNside) )
			jp = nSideMinusOne;
		if ( jm.greaterThanOrEqual(lNside) )
			jm = nSideMinusOne;

		if (z>=0)
		{
			return xyf2nest( lNside.subtract(jm).subtract(lOne).toInt(), lNside.subtract(jp).subtract(lOne).toInt(), ntt, order );
		}
		else
		{
			return xyf2nest( jp.toInt(), jm.toInt(), ntt+8, order );
		}
	}
}

/**************************************************************************************************************/

var HEALPixBase = {
	compress_bits: function(v){
		//  raw  = v & 0x5555555555555 in place of raw = v & 0x5555555555555555
		//		--> still not resolved, dunno why
		//
		
		// in Java implementation mask == 0x5555555555555555
		// var raw = v & 0x5555555555555; // v & 101010101010101010101010101010101010101010101010101010101010101
										  // // raw>>>15 = 0101010101010101010101010101010101010101010101010
		// var dec = raw>>>15;
		// raw |= dec;				  // 101010101010101111111111111111111111111111111111111111111111111
		// var raw1 = (raw&0xffff);
		// var dec2 = raw>>>31;
		// var raw2 = (dec2&0xffff);
		
		var longV = Long.fromNumber(v);
		var longMask = Long.fromNumber(0x5555555555555);
		var raw = longV.and(longMask);
		var dec = raw.shiftRightUnsigned(15);
		raw = raw.or(dec);
		var raw1 = (raw.and(Long.fromNumber(0xffff))).toInt();
		var dec2 = raw.shiftRightUnsigned(32);
		var raw2 = (dec2.and(Long.fromNumber(0xffff))).toInt();
		
		return HealPixTables.ctab[raw1&0xff] | (HealPixTables.ctab[raw1>>>8]<< 4)
			| (HealPixTables.ctab[raw2&0xff]<<16) | (HealPixTables.ctab[raw2>>>8]<<20);
	},

	/**
	 *	Function describing a location on the sphere
	 */
	fxyf: function(_fx,_fy,_face){	
		var jr = HealPixTables.jrll[_face] - _fx - _fy;
		var z = 0;
		var phi = 0;
		var sth = 0;
		var have_sth = false;

		var nr;
		if (jr<1){
			nr = jr;
			var tmp = nr*nr/3.;
			z = 1 - tmp;
			if (z>0.99) { sth=Math.sqrt(tmp*(2.-tmp)); have_sth=true; }
		} else if (jr>3){
			nr = 4-jr;
			var tmp = nr*nr/3.;
			z = tmp - 1;
			if (z<-0.99) {
				sth=Math.sqrt(tmp*(2.-tmp)); 
				have_sth=true;
			}
		} else {
			nr = 1;
			z = (2-jr)*2./3.;
		}

		var tmp=HealPixTables.jpll[_face]*nr+_fx-_fy;
		if (tmp<0) tmp+=8;
		if (tmp>=8) tmp-=8;
		
		phi = (nr<1e-15) ? 0 : (0.5*HALF_PI*tmp)/nr;
		
		var st = (have_sth) ? sth : Math.sqrt((1.0-z)*(1.0+z));
		return [st*Math.cos(phi), st*Math.sin(phi), z];
	},

	/**
	 *	Static function
	 *	Convert nside to order
	 *	(ilog2(nside))
	 */
	nside2order: function(arg){
		var res=0;
		while (arg > 0x0000FFFF) { res+=16; arg>>>=16; }
		if (arg > 0x000000FF) { res|=8; arg>>>=8; }
		if (arg > 0x0000000F) { res|=4; arg>>>=4; }
		if (arg > 0x00000003) { res|=2; arg>>>=2; }
		if (arg > 0x00000001) { res|=1; }
		return res;
	},

	/**
	 *	Returns pixel index of point on sphere
	 *
	 *	@param order Tile order
	 *	@param lon Longitude
	 *	@param lat Latitude
	 */
	lonLat2pix: function(order, lon, lat){
		var loc = lonLat2ang( lon, lat );
		return loc2pix( order, loc[0], loc[1] );
	}
};

/**************************************************************************************************************/

return HEALPixBase;

});
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('gw/HEALPixTiling',['./Tile', './HEALPixBase', './GeoBound', './EquatorialCoordinateSystem', './Numeric', './AstroCoordTransform'], 
	function(Tile, HEALPixBase, GeoBound, CoordinateSystem, Numeric, AstroCoordTransform) {

/**************************************************************************************************************/
 
/** @constructor
 *	HEALPixTiling constructor
 *	
 *	@param order Starting tiling order
 *	@param options Options
 *		<ul>
 *			<li>coordSystem: Coordinate system of the given tiling</li>
 *		</ul>
 *	
 */
var HEALPixTiling = function(order, options)
{
	this.order = order;
	this.nside = Math.pow(2,this.order);
	this.coordSystem = options.coordSystem || "EQ";
}

/**************************************************************************************************************/

/** 
	Generate the tiles for level zero
 */
HEALPixTiling.prototype.generateLevelZeroTiles = function( config, tilePool )
{	
	config.skirt = false;
	config.cullSign = -1;
	config.tesselation = 5;
	config.coordSystem = this.coordSystem;

	var level0Tiles = [];
	
	var qpf = Math.pow(this.nside,2); // quad per face
	var nFaces = 12;
	var nQuads = nFaces * qpf;
	
	for (var i = 0; i < nQuads; i++){
		var face = Math.floor(i/qpf);
		var tile = new HEALPixTile(this.order, i, face);
		tile.config = config;
		level0Tiles.push( tile );
	}

	return level0Tiles;
}

/**************************************************************************************************************/

/** 
	Locate a level zero tile
 */
HEALPixTiling.prototype.lonlat2LevelZeroIndex = function(lon,lat)
{	
	if ( this.coordSystem != "EQ" )
	{
		var geo = CoordinateSystem.convert( [lon, lat], 'EQ', this.coordSystem );
		lon = geo[0];
		lat = geo[1];
	}

	return HEALPixBase.lonLat2pix( this.order, lon, lat );
}

/**************************************************************************************************************/

/**
 	Return tile of given longitude/latitude from tiles array if exists, null otherwise
 */
HEALPixTiling.prototype.findInsideTile = function(lon, lat, tiles)
{
	if ( this.coordSystem != "EQ" )
	{
		var geo = CoordinateSystem.convert( [lon, lat], 'EQ', this.coordSystem );
		lon = geo[0];
		lat = geo[1];
	}

	for ( var i=0; i<tiles.length; i++ )
	{
		var tile = tiles[i];
		var index = HEALPixBase.lonLat2pix( tile.order, lon, lat );
		if ( index == tile.pixelIndex )
			return tile;
	}
	return null;
}

/**************************************************************************************************************/

/** @constructor
	Tile constructor
	
		Quadrilateral which composes one tile of HEALPix sphere
		
		nside : 2^order
		order : log2(nside);
		pix : pixel index number
		face : face number = [0..11]
 */
var HEALPixTile = function( order, pix, face )
{
    // Call ancestor constructor
    Tile.prototype.constructor.call(this);
	
	this.order = order;
	this.nside = Math.pow(2, this.order);
	this.pixelIndex = pix;
	this.face = face;

	// Compute texture transform
/*	var width = 1728/64;
	var height = 1856/64;
	this.texTransform = [64/1728, 64/1856, ((this.pixelIndex % width))/width, ((Math.floor(this.pixelIndex/width))/height)];*/

	this.geoBound = null;
}

/**************************************************************************************************************/

/** inherits from Tile */
HEALPixTile.prototype = new Tile;

/**************************************************************************************************************/

/**
	Create the children
 */
HEALPixTile.prototype.createChildren = function()
{
	// Create the children
	
	var child00 = new HEALPixTile(this.order + 1, this.pixelIndex*4, this.face);
	var child10 = new HEALPixTile(this.order + 1, this.pixelIndex*4+2, this.face);
	var child01 = new HEALPixTile(this.order + 1, this.pixelIndex*4+1, this.face);
	var child11 = new HEALPixTile(this.order + 1, this.pixelIndex*4+3, this.face);
	
	child00.initFromParent( this, 0, 0 );
	child10.initFromParent( this, 1, 0 );
	child01.initFromParent( this, 0, 1 );
	child11.initFromParent( this, 1, 1 );
	
	this.children = [ child00, child10, child01, child11 ];

}

/**************************************************************************************************************/

/**
	Compute the local matrix for the tile
 */
HEALPixTile.prototype.computeLocalMatrix = function(vertices){
	var matrix = mat4.create();
	
	var east = vec3.create();
	var north = vec3.create();
	var up = vec3.create();
	
	var mx = 0;
	var my = 0;
	var mz = 0;
	for(var i=0; i<vertices.length; i++){
		mx+=vertices[i][0];
		my+=vertices[i][1];
		mz+=vertices[i][2];
	}
	var barycenter = vec3.create([mx/vertices.length,my/vertices.length,mz/vertices.length]);
	
	vec3.set(barycenter,up);
	vec3.normalize(up);
	
	vec3.subtract(vertices[0],vertices[3],north);
	
	vec3.cross(up, north, east);
	vec3.normalize(east);
	vec3.cross(up, east, north);
	vec3.normalize(north);
		
	matrix[0] = east[0];
	matrix[1] = east[1];
	matrix[2] = east[2];
	matrix[3] = 0.0;
	
	matrix[4] = north[0];
	matrix[5] = north[1];
	matrix[6] = north[2];
	matrix[7] = 0.0;
	
	matrix[8] = up[0];
	matrix[9] = up[1];
	matrix[10] = up[2];
	matrix[11] = 0.0;
	
	matrix[12] = barycenter[0];
	matrix[13] = barycenter[1];
	matrix[14] = barycenter[2];
	matrix[15] = 1.0;
	
	return matrix;
}

/**************************************************************************************************************/

/**
	Generate vertices for tile
 */
HEALPixTile.prototype.generateVertices = function()
{
	// Build the vertices
	var size = this.config.tesselation;
	var worldSpaceVertices = new Array();
	var step = 1./(size - 1);
	
	// xyf calculation
	var pix=this.pixelIndex&(this.nside*this.nside-1);
	var ix = HEALPixBase.compress_bits(pix);
	var iy = HEALPixBase.compress_bits(pix>>>1);
	
	// Compute array of worldspace coordinates
	for(var u = 0; u < size; u++){
		for(var v = 0; v < size; v++){


			if ( this.config.coordSystem != 'EQ' )
			{
				var vertice = HEALPixBase.fxyf((ix+u*step)/this.nside, (iy+v*step)/this.nside, this.face);
				var geo = CoordinateSystem.from3DToGeo( vertice );
				var eq = CoordinateSystem.convert(geo, this.config.coordSystem, 'EQ');
				worldSpaceVertices[u*size + v] = CoordinateSystem.fromGeoTo3D( eq );
			}
			else
			{
				worldSpaceVertices[u*size + v] = HEALPixBase.fxyf((ix+u*step)/this.nside, (iy+v*step)/this.nside, this.face);
			}
		}
	}
	
	// Compute geoBound using corners of tile
	this.geoBound = new GeoBound();

	var corners = [];
	corners.push( CoordinateSystem.from3DToGeo( worldSpaceVertices[0] ) );
	corners.push( CoordinateSystem.from3DToGeo( worldSpaceVertices[size-1] ) );
	corners.push( CoordinateSystem.from3DToGeo( worldSpaceVertices[size*(size-1)] ) );
	corners.push( CoordinateSystem.from3DToGeo( worldSpaceVertices[size*size-1] ) );

	this.geoBound.computeFromCoordinates( corners );

	// Compute tile matrix
	this.matrix = this.computeLocalMatrix(worldSpaceVertices);	
	var invMatrix = mat4.create();
	mat4.inverse( this.matrix, invMatrix );
	this.inverseMatrix = invMatrix;
	
	// Compute tile matrix
	/*var center = HEALPixBase.fxyf((ix+0.5)/this.nside, (iy+0.5)/this.nside, face);
	var geoCenter = CoordinateSystem.from3DToGeo(center);
	this.matrix = CoordinateSystem.getLHVTransform( geoCenter );
	var invMatrix = mat4.create();
	mat4.inverse( this.matrix, invMatrix );
	this.inverseMatrix = invMatrix;*/
	
	// Build the vertices
	var vertices = new Float32Array( 3*size*size );
	
	// Vertex coordinates in local space
	var vertexOffset = 0;
	for(var i=0;i<worldSpaceVertices.length;i++){
		vertices[vertexOffset] = invMatrix[0]*worldSpaceVertices[i][0] + invMatrix[4]*worldSpaceVertices[i][1] + invMatrix[8]*worldSpaceVertices[i][2] + invMatrix[12];
		vertices[vertexOffset+1] = invMatrix[1]*worldSpaceVertices[i][0] + invMatrix[5]*worldSpaceVertices[i][1] + invMatrix[9]*worldSpaceVertices[i][2] + invMatrix[13];
		vertices[vertexOffset+2] = invMatrix[2]*worldSpaceVertices[i][0] + invMatrix[6]*worldSpaceVertices[i][1] + invMatrix[10]*worldSpaceVertices[i][2] + invMatrix[14];
		vertexOffset += 3;
	}
	
	return vertices;
}

/**************************************************************************************************************/

return HEALPixTiling;

});
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('gw/RendererTileData',[], function() {

/**************************************************************************************************************/

/** @constructor
	RendererTileData constructor
	Contains a list of renderables for the tiles
	
	A renderable contains the following attributes/methods :
		Attributes :
			bucket : the renderable bucket
			initChild (opt) : create a child at "init" time (children are created but not yet loaded)
			generateChild (opt) : generate a child at "generate" time (children are loaded)
			dispose : discard any gl data
			add : add a geometry to the renderable
			remove: remove a geometry from the renderable
 */
var RendererTileData = function(manager)
{
	this.manager = manager;
	this.renderables = [];
}

/**************************************************************************************************************/

/**
 * Initialize a child tile
 */
RendererTileData.prototype.initChild = function(childTile,i,j)
{
	var childData;
	for ( var n = 0; n < this.renderables.length; n++ ) 
	{
		if ( this.renderables[n].initChild )
		{		
			var r = this.renderables[n].initChild(i,j,childTile);
			if (r)
			{
				if (!childData)
					childData = childTile.extension.renderer = new RendererTileData(this.manager);
				childData.renderables.push( r );
			}
		}
	}
}

/**************************************************************************************************************/

/**
 * Traverse the renderer data
 */
RendererTileData.prototype.traverse = function(tile,isLeaf)
{
	for ( var i = 0; i < this.renderables.length; i++ ) 
	{
		var renderable = this.renderables[i];
		var bucket = renderable.bucket;
		if ( bucket.layer._visible && bucket.layer._opacity > 0 )
		{
			if ( renderable.traverse )
			{
				renderable.traverse( this.manager, tile, isLeaf  );
			}
			else
			{
				if ( renderable.hasChildren 
					&& !isLeaf )
					continue;
				
				this.manager.renderables.push( renderable );
			}
		}
	}
}

/**************************************************************************************************************/

/**
	Get a renderable from the tile, given the bucket
 */
RendererTileData.prototype.getRenderable = function(bucket)
{
	for ( var i=0; i < this.renderables.length; i++ )
	{
		if ( bucket == this.renderables[i].bucket )
		{
			return this.renderables[i];
		}
	}
	return null;
}

/**************************************************************************************************************/

/**
	Dispose renderable data from tile
 */
RendererTileData.prototype.dispose = function(renderContext,tilePool)
{
	for ( var i=0; i < this.renderables.length; i++ )
	{
		this.renderables[i].dispose(renderContext,tilePool);
	}
	this.renderables.length = 0;
}

/**************************************************************************************************************/

return RendererTileData;

});
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('gw/RasterOverlayRenderer', ['./Program','./Tile','./ImageRequest','./RendererTileData'], function(Program, Tile, ImageRequest, RendererTileData) {

/**************************************************************************************************************/

/** 
	@constructor
	RasterOverlayRenderer constructor
 */
var RasterOverlayRenderer = function(globe)
{
	this.vertexShader = "\
	attribute vec3 vertex;\n\
	attribute vec2 tcoord;\n\
	uniform mat4 modelViewMatrix;\n\
	uniform mat4 projectionMatrix;\n\
	uniform vec4 textureTransform; \n\
	varying vec2 texCoord;\n\
	void main(void) \n\
	{\n\
		gl_Position = projectionMatrix * modelViewMatrix * vec4(vertex, 1.0);\n\
		texCoord = tcoord * textureTransform.xy + textureTransform.zw;\n\
	}\n\
	";

	this.fragmentShader = "\
	precision lowp float;\n\
	varying vec2 texCoord;\n\
	uniform sampler2D overlayTexture;\n\
	uniform float opacity; \n\
	void main(void)\n\
	{\n\
		gl_FragColor.rgba = texture2D(overlayTexture, texCoord.xy); \n\
		gl_FragColor.a *= opacity; \n\
	}\n\
	";
	
	this.rendererManager = globe.vectorRendererManager;
	this.tileManager = globe.tileManager;
	this.programs = [];
	this.program = this.createProgram( {
		vertexCode: this.vertexShader,
		fragmentCode: this.fragmentShader,
		updateUniforms: null
	});
	
	this.buckets = [];
	this.imageRequests = [];
	this.frameNumber = 0;
	
	
	var self = this;
	for ( var i = 0; i < 4; i++ ) {
		var imageRequest = new ImageRequest({
			successCallback: function(){
				if ( this.renderable )
				{
					if ( this.renderable.bucket.layer.handleImage )
						this.renderable.bucket.layer.handleImage(this);

					this.renderable.ownTexture = self.tileManager.tilePool.createGLTexture(this.image);
					this.renderable.texture = this.renderable.ownTexture;
					this.renderable.uvScale = 1.0;
					this.renderable.uTrans = 0.0;
					this.renderable.vTrans = 0.0;
					this.renderable.updateChildrenTexture();
					this.renderable.onRequestFinished(true);
					this.renderable = null;
					self.tileManager.renderContext.requestFrame();
				}
			},
			failCallback: function(){
				if ( this.renderable )
				{
					this.renderable.onRequestFinished(true);
					this.renderable = null;
				}
			},
			abortCallback: function(){
				//console.log("Raster overlay request abort.");
				if ( this.renderable )
				{
					this.renderable.onRequestFinished(false);
					this.renderable = null;
				}
			}
		});

		this.imageRequests.push( imageRequest );
	}
}

/**************************************************************************************************************/

/** 
	@constructor
	Create a renderable for the overlay.
	There is one renderable per overlay and per tile.
 */
var RasterOverlayRenderable = function( bucket )
{
	this.bucket = bucket;
	this.ownTexture = null;
	this.texture = null;
	this.request = null;
	this.requestFinished = false;
	this.tile = null;
	this.uvScale = 1.0;
	this.uTrans = 0.0;
	this.vTrans = 0.0;
}

/**************************************************************************************************************/

/** 
	Called when a request is started
 */
RasterOverlayRenderable.prototype.onRequestStarted = function(request)
{
	this.request = request;
	this.requestFinished = false;
	var layer = this.bucket.layer;
	if ( layer._numRequests == 0 )
	{
		layer.globe.publish('startLoad',layer);
	}
	layer._numRequests++;
}

/**************************************************************************************************************/

/** 
	Called when a request is finished
 */
RasterOverlayRenderable.prototype.onRequestFinished = function(completed)
{
	this.request = null;
	this.requestFinished = completed;
	var layer = this.bucket.layer;
	layer._numRequests--;
	if ( layer.globe && layer._numRequests == 0 )
	{
		layer.globe.publish('endLoad',layer);
	}
}

/**************************************************************************************************************/

/**
 * Initialize a child renderable
 */
RasterOverlayRenderable.prototype.initChild = function(i,j,childTile)
{				
	// Request finished and no texture  : no init needed for children
/*	// TODO : does not work because sometimes level 0 cannot be loaded
	if (this.requestFinished && !this.ownTexture)
		return null;*/
		
	var renderable = this.bucket.createRenderable();
	renderable.tile = childTile;	
	if ( this.texture )
	{
		renderable.texture = this.texture;
		renderable.uvScale = this.uvScale;
		renderable.uTrans = this.uTrans;
		renderable.vTrans = this.vTrans;
	}
	
	return renderable;
}

/**************************************************************************************************************/

/** 
	Generate child renderable
 */
RasterOverlayRenderable.prototype.generateChild = function( tile )
{
	// Request finished and no texture  : no generate needed for children
/*	// TODO : does not work because sometimes level 0 cannot be loaded
	if (this.requestFinished && !this.ownTexture)
		return;*/

	var r = this.bucket.renderer;
	r.addOverlayToTile( tile, this.bucket, this );
}

/**************************************************************************************************************/

/** 
	Update the children texture
 */
 RasterOverlayRenderable.prototype.updateChildrenTexture = function()
{
	if ( this.tile.children )
	{
		for ( var i = 0; i < 4; i++ )
		{
			var rd = this.tile.children[i].extension.renderer;
			if ( rd )
			{
				var cr = rd.getRenderable(this.bucket);
				if ( cr && !cr.ownTexture )
				{
					cr.updateTextureFromParent( this );
					cr.updateChildrenTexture();
				}
			}
		}
	}
}

/**************************************************************************************************************/

/** 
	Update texture from its parent
 */
RasterOverlayRenderable.prototype.updateTextureFromParent = function( parent )
{
	if ( this.tile.state == Tile.State.LOADED )
	{
		this.texture = parent.texture;
		this.uvScale = parent.uvScale * 0.5;
		this.uTrans = parent.uTrans;
		this.vTrans = parent.vTrans;
		
		this.uTrans += (this.tile.parentIndex & 1) ? this.uvScale : 0;
		this.vTrans += (this.tile.parentIndex & 2) ? this.uvScale : 0;
	}
	else
	{
		this.texture = parent.texture;
		this.uvScale = parent.uvScale;
		this.uTrans = parent.uTrans;
		this.vTrans = parent.vTrans;
	}
}

/**************************************************************************************************************/

/** 
	Traverse renderable : add it to renderables list if there is a texture
	Request the texture
 */
 RasterOverlayRenderable.prototype.traverse = function( manager, tile, isLeaf  )
{
	if ( isLeaf && this.texture )
	{
		manager.renderables.push( this );
	}
	
	if (!this.requestFinished && this.tile.state == Tile.State.LOADED)
	{
		this.bucket.renderer.requestOverlayTextureForTile( this);
	}
}

/**************************************************************************************************************/

/** 
	Dispose the renderable
 */
RasterOverlayRenderable.prototype.dispose = function(renderContext,tilePool)
{
	if ( this.ownTexture ) 
	{
		tilePool.disposeGLTexture(this.ownTexture);
		this.ownTexture = null;
	}
}


/**************************************************************************************************************/

/**
	Bucket constructor for RasterOverlay
 */
var Bucket = function(layer)
{
	this.layer = layer;
	this.renderer = null;
	// TODO : hack
	this.style = layer;
}

/**************************************************************************************************************/

/**
	Create a renderable for this bucket
 */
Bucket.prototype.createRenderable = function()
{
	return new RasterOverlayRenderable(this);
}

/**************************************************************************************************************/

/**
	Add an overlay into the renderer.
	The overlay is added to all loaded tiles.
 */
RasterOverlayRenderer.prototype.addOverlay = function( overlay )
{
	// Initialize num requests to 0
	overlay._numRequests = 0;

	var bucket = new Bucket(overlay);
	bucket.renderer = this;
	bucket.id = this.rendererManager.bucketId++;
	this.buckets.push( bucket );
	
	overlay._bucket = bucket;
	
	for ( var i = 0; i < this.tileManager.level0Tiles.length; i++ )
	{
		var tile = this.tileManager.level0Tiles[i];
		if ( tile.state == Tile.State.LOADED )
		{
			this.addOverlayToTile( tile, bucket );
		}
	}
}

/**************************************************************************************************************/

/**
	Remove an overlay
	The overlay is removed from all loaded tiles.
 */
RasterOverlayRenderer.prototype.removeOverlay = function( overlay )
{
	var index = this.buckets.indexOf( overlay._bucket );
	this.buckets.splice(index,1);
	
	var rc = this.tileManager.renderContext;
	var tp = this.tileManager.tilePool;
	this.tileManager.visitTiles( function(tile) 
			{
				var rs = tile.extension.renderer;
				var renderable = rs ?  rs.getRenderable( overlay._bucket ) : null;
				if ( renderable ) 
				{
					// Remove the renderable
					var index = rs.renderables.indexOf(renderable);
					rs.renderables.splice(index,1);
					
					// Dispose its data
					renderable.dispose(rc,tp);
					
					// Remove tile data if not needed anymore
					if ( rs.renderables.length == 0 )
						delete tile.extension.renderer;
				}
			}
	);
}

/**************************************************************************************************************/

/**
	Add an overlay into a tile.
	Create tile data if needed, and create the renderable for the overlay.
 */
RasterOverlayRenderer.prototype.addOverlayToTile = function( tile, bucket, parentRenderable )
{
	if (!this.overlayIntersects( tile.geoBound, bucket.layer ))
		return;
		
	if ( !tile.extension.renderer )
		tile.extension.renderer = new RendererTileData(this.rendererManager);
	
	var renderable = bucket.createRenderable();
	renderable.tile = tile;
	tile.extension.renderer.renderables.push( renderable );
	
	if ( parentRenderable && parentRenderable.texture )
	{
		renderable.updateTextureFromParent( parentRenderable );
	}
	
	if ( tile.children )
	{
		// Add the overlay to loaded children
		for ( var i = 0; i < 4; i++ )
		{
			if ( tile.children[i].state == Tile.State.LOADED )
			{
				this.addOverlayToTile( tile.children[i], bucket, renderable );
			}
		}
	}

}

/**************************************************************************************************************/

/**
	Create an interpolated for polygon clipping
 */	
var _createInterpolatedVertex = function( t, p1, p2 )
{
	return [ p1[0] + t * (p2[0] - p1[0]), p1[1] + t * (p2[1] - p1[1]) ];
}

/**************************************************************************************************************/

/**
	Clip polygon to a side (used by bound-overlay intersection)
 */	
RasterOverlayRenderer.prototype.clipPolygonToSide = function( coord, sign, value, polygon )
{
	var clippedPolygon = [];

	// iterate through vertices
	for ( var i = 0; i < polygon.length; i++ )
	{
		var p1 = polygon[i];
		var p2 = polygon[ (i+1) % polygon.length ];
		var val1 = p1[coord];
		var val2 = p2[coord];

		// test containement
		var firstInside = (val1 - value) * sign >= 0.0;
		var secondInside = (val2 - value) * sign >= 0.0;
	
		// output vertices for inside polygon
		if ( !firstInside && secondInside )
		{
			var t = (value - val1) / (val2- val1);
			var newPoint = _createInterpolatedVertex( t, p1, p2 );
			clippedPolygon.push( newPoint );
			clippedPolygon.push( p2 );
		}
		else if ( firstInside && secondInside )
		{
			clippedPolygon.push( p2 );
		}
		else if ( firstInside && !secondInside )
		{
			var t = (value - val1) / (val2- val1);
			var newPoint = _createInterpolatedVertex( t, p1, p2 );
			clippedPolygon.push( newPoint );
		}
	}
	
	return clippedPolygon;
}

/**************************************************************************************************************/

/**
	Check the intersection between a geo bound and an overlay
 */	
RasterOverlayRenderer.prototype.overlayIntersects = function( bound, overlay )
{
	if ( overlay.coordinates )
	{
		var c;
		c = this.clipPolygonToSide( 0, 1, bound.west, overlay.coordinates );
		c = this.clipPolygonToSide( 0, -1, bound.east, c );
		c = this.clipPolygonToSide( 1, 1, bound.south, c );
		c = this.clipPolygonToSide( 1, -1, bound.north, c );
		return c.length > 0;
	}
	else if ( overlay.geoBound )
	{
		return overlay.geoBound.intersects( bound );
	}
	
	// No geobound or coordinates : always return true
	return true;
}

/**************************************************************************************************************/

/**
	Generate Raster overlay data on the tile.
	The method is called by TileManager when a new tile has been generated.
 */
RasterOverlayRenderer.prototype.generateLevelZero = function( tile )
{
	// Traverse all overlays
	for ( var i = 0; i < this.buckets.length; i++ )
	{
		this.addOverlayToTile(tile,this.buckets[i]);
	}
}

/**************************************************************************************************************/

/**
	Request the overlay texture for a tile
 */
RasterOverlayRenderer.prototype.requestOverlayTextureForTile = function( renderable )
{	
	if ( !renderable.request )
	{
		var imageRequest;
		for ( var i = 0; i < this.imageRequests.length; i++ )
		{
			if ( !this.imageRequests[i].renderable  ) 
			{
				imageRequest = this.imageRequests[i];
				break;
			}
		}
		
		if ( imageRequest )
		{
			renderable.onRequestStarted(imageRequest);
			imageRequest.renderable = renderable;
			imageRequest.frameNumber = this.frameNumber;
			imageRequest.send(renderable.bucket.layer.getUrl(renderable.tile));
		}
	}
	else
	{
		renderable.request.frameNumber = this.frameNumber;
	}
}

/**************************************************************************************************************/

/**
 	Create program from customShader object
 */
RasterOverlayRenderer.prototype.createProgram = function(customShader)
{
	var program = new Program(this.tileManager.renderContext);
	program.createFromSource(this.vertexShader, customShader.fragmentCode);
	
    // Add program
    program.id = this.programs.length;
    this.programs.push({ 
    	fragmentCode: customShader.fragmentCode,
    	program: program
	});
	return program;
}

/**************************************************************************************************************/

/**
 	Get program if known by renderer, create otherwise
 */
RasterOverlayRenderer.prototype.getProgram = function(customShader) {

	var program;

    for(var id=0; id<this.programs.length; id++)
    {
        if( this.programs[id].fragmentCode == customShader.fragmentCode )
        {
        	program = this.programs[id].program;
        }
    }

    if ( !program )
    {
    	program = this.createProgram(customShader);
    }
    return program;
}

/**************************************************************************************************************/

/**
 *	Render the raster overlays for the given tiles
 */
RasterOverlayRenderer.prototype.render = function( renderables, start, end )
{
	var rc = this.tileManager.renderContext;
 	var gl = rc.gl;

	// Update gl states
	gl.enable(gl.BLEND);
	gl.blendFunc( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA );
	gl.depthFunc( gl.LEQUAL );
	
	var modelViewMatrix = mat4.create();
	
	var currentTile = null;
	var currentIB = null;
	var currentProgram = null;

	for ( var n = start; n < end; n++ )
	{
		var renderable = renderables[n];
		var bucket = renderable.bucket;
		var layer = bucket.layer;
		
		var updateUniforms;
		var program;
		if ( layer.customShader )
		{
			program = this.getProgram(layer.customShader);
			updateUniforms = layer.customShader.updateUniforms;
		}
		else
		{
			program = this.getProgram({
				vertexCode: this.vertexShader,
				fragmentCode: this.fragmentShader,
				updateUniforms: null
			});
		}
		
		// Apply program if changed
		if ( program != currentProgram )
		{
			currentProgram = program;
			program.apply();
							
			gl.uniformMatrix4fv(program.uniforms["projectionMatrix"], false, rc.projectionMatrix);
			gl.uniform1i(program.uniforms["overlayTexture"], 0);
			
			// Bind tcoord buffer
			gl.bindBuffer(gl.ARRAY_BUFFER, this.tileManager.tcoordBuffer);
			gl.vertexAttribPointer(program.attributes['tcoord'], 2, gl.FLOAT, false, 0, 0);
		}	
		
		if (updateUniforms)
			updateUniforms(gl, program);
		
		// Bind the vertex buffer
		gl.bindBuffer(gl.ARRAY_BUFFER, renderable.tile.vertexBuffer);
		gl.vertexAttribPointer(program.attributes['vertex'], 3, gl.FLOAT, false, 0, 0);
		
		// Bind the index buffer only if different (index buffer is shared between tiles)
		var indexBuffer = ( renderable.tile.state == Tile.State.LOADED ) ? this.tileManager.tileIndexBuffer.getSolid() : this.tileManager.tileIndexBuffer.getSubSolid(renderable.tile.parentIndex);
		if ( currentIB != indexBuffer )
		{	
			gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer );
			currentIB = indexBuffer;
		}

		// Bind the tile tile matrix
		mat4.multiply( rc.viewMatrix, renderable.tile.matrix, modelViewMatrix );
		gl.uniformMatrix4fv(program.uniforms["modelViewMatrix"], false, modelViewMatrix);
					
		gl.uniform1f(program.uniforms["opacity"], layer._opacity );
		gl.uniform4f(program.uniforms["textureTransform"], renderable.uvScale, renderable.uvScale, renderable.uTrans, renderable.vTrans );
		
		gl.activeTexture(gl.TEXTURE0);
		gl.bindTexture(gl.TEXTURE_2D, renderable.texture );
		
		// Finally draw the tiles
		gl.drawElements(gl.TRIANGLES, currentIB.numIndices, gl.UNSIGNED_SHORT, 0);
	}
	
	// reset gl states
	gl.disable(gl.BLEND);
	//gl.disable(gl.POLYGON_OFFSET_FILL);
	gl.depthFunc( gl.LESS );
}

/**************************************************************************************************************/

/**
 * Check if renderer is applicable
 */
RasterOverlayRenderer.prototype.canApply = function(type,style)
{
	return false;
}

/**************************************************************************************************************/
									
return RasterOverlayRenderer;

});

/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

 define('gw/RasterLayer',['./Utils', './BaseLayer', './RasterOverlayRenderer' ], 
	function(Utils, BaseLayer, RasterOverlayRenderer) {

/**************************************************************************************************************/


/** @name RasterLayer
	@class
	Base class for raster layer
	@augments BaseLayer
	@param options Configuration properties for the RasterLayer. See {@link BaseLayer} for base properties :
		<ul>
			<li>tilePixelSize : the image size for a tile, default is 256.</li>
			<li>numberOfLevels : the maximum number of levels</li> 
			<li>geoBound : the extent of the layer</li> 
		</ul>
*/
var RasterLayer = function( options )
{
	BaseLayer.prototype.constructor.call( this, options );
	
	// Base properties
	this.tilePixelSize = -1;
	this.tiling = null;
	this.numberOfLevels = -1;
	this.geoBound = options.geoBound || null;
	this.coordinates = options.coordinates || null;
	this.zIndex = options.zIndex || 0;
	
	// Internal
	this._overlay = true; 
	this._ready = true; // Ready is use by TileManager
}

/**************************************************************************************************************/

Utils.inherits( BaseLayer,RasterLayer );

/**************************************************************************************************************/

/** 
  Attach the raster layer to the globe
 */
RasterLayer.prototype._attach = function( g )
{
	if ( !this._overlay )
	{
		// Override id of background layer because of unicity of background not overlayed layer
		this.id = 0;
	}

	BaseLayer.prototype._attach.call( this, g );
		
	if ( this._overlay )
	{
		// Create the renderer if needed
		if ( !g.rasterOverlayRenderer )
		{
			var renderer = new RasterOverlayRenderer(g);
			g.vectorRendererManager.renderers.push( renderer );
			g.rasterOverlayRenderer = renderer;
		}
		g.rasterOverlayRenderer.addOverlay(this);
	}
}

/**************************************************************************************************************/

/** 
  Detach the raster layer from the globe
 */
RasterLayer.prototype._detach = function()
{
	// Remove raster from overlay renderer if needed
	if ( this._overlay && this.globe.rasterOverlayRenderer )
	{
		this.globe.rasterOverlayRenderer.removeOverlay(this);
	}
	
	BaseLayer.prototype._detach.call(this);
}

/**************************************************************************************************************/

return RasterLayer;

});

/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('gw/HEALPixLayer',['./Utils', './HEALPixTiling', './RasterLayer'], 
	function(Utils, HEALPixTiling, RasterLayer) {

/**************************************************************************************************************/

/** @export
	@constructor
	HEALPixLayer constructor
*/

var HEALPixLayer = function(options)
{
	RasterLayer.prototype.constructor.call( this, options );
	
	this.tilePixelSize = options.tilePixelSize || 512;
	this.tiling = new HEALPixTiling( options.baseLevel || 2, options );
	this.numberOfLevels = options.numberOfLevels || 10;
	this.type = "ImageryRaster";
	this.baseUrl = options['baseUrl'];
	this.dataType = options.dataType || "jpg";
	this.coordSystem = options.coordSystem || "EQ";
	
	// allsky
	this.levelZeroImage = new Image();
	var self = this;
	this.levelZeroImage.crossOrigin = '';
	this.levelZeroImage.onload = function () 
	{
		self._ready = true;
		
		// Call callback if set
		if (options.onready && options.onready instanceof Function)
		{
			options.onready(self);
		}
		
		// Request a frame
		if ( self.globe )
		{
			self.globe.renderContext.requestFrame();
		}
	}
	this.levelZeroImage.onerror = function(event) {
		self.globe.publish("baseLayersError", self);
		self._ready = false;
		
		console.log("Cannot load " + self.levelZeroImage.src );
	}
	
	this._ready = false;
}

/**************************************************************************************************************/

Utils.inherits(RasterLayer, HEALPixLayer);

/**************************************************************************************************************/

/** 
  Attach the raster layer to the globe
 */
HEALPixLayer.prototype._attach = function( g )
{
	RasterLayer.prototype._attach.call( this, g );

	// Load level zero image now, only for background
	if ( !this._overlay )
	{
		this.levelZeroImage.src = this.baseUrl + "/Norder3/Allsky."+this.dataType;
	}
}

/**************************************************************************************************************/

/**
 *	Get url from a given tile
 */
HEALPixLayer.prototype.getUrl = function(tile)
{
	var url = this.baseUrl;
	
	url += "/Norder";
	url += tile.order;
	
	url += "/Dir";
	var indexDirectory = Math.floor(tile.pixelIndex/10000) * 10000;
	url += indexDirectory;
	
	url += "/Npix";
	url += tile.pixelIndex;
	url += "."+this.dataType;
	
	return url;
}


/**************************************************************************************************************/

/**
 *	Generate the level0 texture for the tiles
 */
HEALPixLayer.prototype.generateLevel0Textures = function(tiles,tilePool)
{
	// Create a canvas to build the texture
	var canvas = document.createElement("canvas");
	canvas.width = 128;
	canvas.height = 128;
	
	var context = canvas.getContext("2d");
	
	for ( var i = 0; i < tiles.length; i++ )
	{
		var tile = tiles[i];
		
		// Top left
		var pi = tile.pixelIndex * 4;
		var sx = ( pi % 27) * 64;
		var sy = ( Math.floor(pi /27) ) * 64;
		context.drawImage(this.levelZeroImage,sx,sy,64,64,0,0,64,64);
		
		// Top right
		pi = tile.pixelIndex * 4 + 2;
		var sx = ( pi % 27) * 64;
		var sy = ( Math.floor(pi /27) ) * 64;
		context.drawImage(this.levelZeroImage,sx,sy,64,64,64,0,64,64);
		
		// Bottom left
		pi = tile.pixelIndex * 4 + 1;
		var sx = ( pi % 27) * 64;
		var sy = ( Math.floor(pi /27) ) * 64;
		context.drawImage(this.levelZeroImage,sx,sy,64,64,0,64,64,64);
		
		// Bottom right
		pi = tile.pixelIndex * 4 + 3;
		var sx = ( pi % 27) * 64;
		var sy = ( Math.floor(pi /27) ) * 64;
		context.drawImage(this.levelZeroImage,sx,sy,64,64,64,64,64,64);

		var imgData = context.getImageData(0, 0, 128, 128);
		imgData.dataType = 'byte';
		
		tile.texture = tilePool.createGLTexture( imgData );
		tile.imageSize = 128;
	}
}

/**************************************************************************************************************/

return HEALPixLayer;

});
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('gw/Mesh',[],function() {

/**************************************************************************************************************/

/** @constructor
	Mesh constructor
 */
var Mesh = function(renderContext)
{
	this.renderContext = renderContext;
	this.vertexBuffer = null;
	this.tcoordBuffer = null;
	this.indexBuffer = null;
	this.colorBuffer = null;
	this.numVertices = 0;
	this.mode = renderContext.gl.TRIANGLES;
}

/**************************************************************************************************************/

/*
	Mesh setVertices method
 */
Mesh.prototype.setVertices = function(vertices)
{
	var gl = this.renderContext.gl;
	if ( this.vertexBuffer == null )
	{
		this.vertexBuffer = gl.createBuffer();
	}
	gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
	gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
	this.numVertices = vertices.length;
}

/**************************************************************************************************************/

/*
	Mesh setTexCoords method
 */
Mesh.prototype.setTexCoords = function(tcoords)
{
	var gl = this.renderContext.gl;
	if ( this.tcoordBuffer == null )
	{
		this.tcoordBuffer = gl.createBuffer();
	}
	gl.bindBuffer(gl.ARRAY_BUFFER, this.tcoordBuffer);
	gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(tcoords), gl.STATIC_DRAW);
}

/**************************************************************************************************************/

/*
	Mesh setColors method
 */
Mesh.prototype.setColors = function(colors)
{
	var gl = this.renderContext.gl;
	if ( this.colorBuffer == null )
	{
		this.colorBuffer = gl.createBuffer();
	}
	gl.bindBuffer(gl.ARRAY_BUFFER, this.colorBuffer);
	gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STATIC_DRAW);
}

/**************************************************************************************************************/

/*
	Mesh setIndices method
 */
Mesh.prototype.setIndices = function(indices)
{
	var gl = this.renderContext.gl;
	if ( this.indexBuffer == null )
	{
		this.indexBuffer = gl.createBuffer();
	}
	gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
	gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);
	this.numIndices = indices.length;
}

/**************************************************************************************************************/

/*
	Convert to wireframe (for debug purposes)
 */
Mesh.prototype.setIndicesToWireframe = function(indices)
{
	this.mode = this.renderContext.gl.LINES;
	
	// Convert indices
	var wireframeIndices = [];
	wireframeIndices.length = 2 * indices.length;
	
	for ( var i =0;  i < indices.length; i += 3 )
	{
		wireframeIndices[2*i] = indices[i];
		wireframeIndices[2*i+1] = indices[i+1];
		
		wireframeIndices[2*i+2] = indices[i+1];
		wireframeIndices[2*i+3] = indices[i+2];
		
		wireframeIndices[2*i+4] = indices[i+2];
		wireframeIndices[2*i+5] = indices[i];
	}
	
	this.setIndices( wireframeIndices );
}

/**************************************************************************************************************/

/*
	Mesh render method
 */
Mesh.prototype.render = function(attributes)
{
	var gl = this.renderContext.gl;
	
	// Warning : use quoted strings to access properties of the attributes, to work correclty in advanced mode with closure compiler
	gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
	gl.vertexAttribPointer(attributes['vertex'], 3, gl.FLOAT, false, 0, 0);
	if ( attributes.hasOwnProperty('tcoord') )
	{
		gl.bindBuffer(gl.ARRAY_BUFFER, this.tcoordBuffer);
		gl.vertexAttribPointer(attributes['tcoord'], 2, gl.FLOAT, false, 0, 0);
	}
	if ( attributes.hasOwnProperty('color') )
	{
		gl.bindBuffer(gl.ARRAY_BUFFER, this.colorBuffer);
		gl.vertexAttribPointer(attributes['color'], 4, gl.FLOAT, false, 0, 0);
	}
	if ( this.indexBuffer ) 
	{
		gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
		gl.drawElements(this.mode, this.numIndices, gl.UNSIGNED_SHORT, 0);
	}
	else
	{
		gl.drawArrays(this.mode, 0, this.numVertices / 3);
	}
}

/**************************************************************************************************************/

/*
	Mesh dispose method
 */
Mesh.prototype.dispose = function()
{
	var gl = this.renderContext.gl;
	if ( this.indexBuffer )
		gl.deleteBuffer(this.indexBuffer);
	if ( this.vertexBuffer )
		gl.deleteBuffer(this.vertexBuffer);
	if ( this.tcoordBuffer )
		gl.deleteBuffer(this.tcoordBuffer);
	if ( this.colorBuffer )
		gl.deleteBuffer(this.colorBuffer);
	
	this.indexBuffer = null;
	this.vertexBuffer = null;
	this.tcoordBuffer = null;
	this.colorBuffer = null;
}

/**************************************************************************************************************/

return Mesh;

});


/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('gw/CoordinateGridLayer', ['./BaseLayer', './Utils', './Program', './Mesh', './CoordinateSystem', './AstroCoordTransform', './FeatureStyle'],
		function(BaseLayer, Utils, Program, Mesh, CoordinateSystem, AstroCoordTransform, FeatureStyle) {
 
/**************************************************************************************************************/

/** 
	@constructor
	Function constructor for CoordinateGridLayer

	@param options Options of coordinate grid layer :
		<ul>
			<li>longitudeSample : Longitude sampling</li>
			<li>latitudeSample : Latitude sampling</li>
			<li>color : Stroke color of grid</li>
			<li>coordSystem: The coordinate system which is represented by grid("EQ" or "GAL" for now)</li>
			<li>longFormat: Representation of longitude axe(HMS, DMS, Deg)</li>
			<li>latFormat: Representation of latitude axe(HMS, DMS, Deg)</li>
			<li>tesselation: Tesselation order (only for latitude bands currently)</li>
		</ul>
 */
var CoordinateGridLayer = function( options )
{
	BaseLayer.prototype.constructor.call( this, options );
	this.globe = null;

	// Equatorial coordinates label renderables
	this.labels = {};

	// WebGL textures
	this.texturePool = null;
	
	this.longitudeSample = options.longitudeSample || 15; // *24 = 360
	this.latitudeSample = options.latitudeSample || 10; // *18 = 180

	// Canvas for generation of equatorial coordinate labels
	this.canvas2d = document.createElement("canvas");
	this.canvas2d.width = 100;
	this.canvas2d.height = 20;

	// Grid buffers
	this.vertexBuffer = null;
	this.indexBuffer = null;

	this.color = options.color || [1., 1., 1.];
	this.coordSystem = options.coordSystem ? options.coordSystem : "EQ";
	this.longFormat = options.longFormat ? options.longFormat : "Deg";
	this.latFormat = options.latFormat ? options.latFormat : "Deg";
	
	// Keep trace on geoBound
	this.geoBound = {};
	this.tesselation = options.tesselation || 2;
}

/**************************************************************************************************************/

Utils.inherits( BaseLayer, CoordinateGridLayer );

/**************************************************************************************************************/

/**
 *	Generate image data from text
 *
 *	@param {String} text Text generated in canvas
 */
CoordinateGridLayer.prototype.generateImageData = function(text)
{
	var ctx = this.canvas2d.getContext("2d");
	ctx.clearRect(0,0, this.canvas2d.width, this.canvas2d.height);
	ctx.fillStyle = FeatureStyle.fromColorToString(this.color);
	ctx.font = '18px sans-serif';
	ctx.textBaseline = 'top';
	ctx.textAlign = 'center';
	var x = this.canvas2d.width / 2;

	ctx.fillText(text, x, 0);

	return ctx.getImageData(0,0, this.canvas2d.width,this.canvas2d.height);
}

/**************************************************************************************************************/

/** 
	Attach the layer to the globe
 */
CoordinateGridLayer.prototype._attach = function( g )
{
	BaseLayer.prototype._attach.call( this, g );
	
	if ( this._visible )
	{
		this.globe.tileManager.addPostRenderer(this);
	}

	if (!this.gridProgram)
	{
		var vertexShader = "\
		attribute vec3 vertex;\n\
		uniform mat4 viewProjectionMatrix;\n\
		void main(void) \n\
		{\n\
			gl_Position = viewProjectionMatrix * vec4(vertex, 1.0);\n\
		}\n\
		";

		var fragmentShader = "\
		precision highp float; \n\
		uniform float alpha; \n\
		uniform vec3 color; \n\
		void main(void)\n\
		{\n\
			gl_FragColor = vec4(color,alpha);\n\
		}\n\
		";
		
		var vertexLabelShader = "\
		attribute vec3 vertex; // vertex have z = 0, spans in x,y from -0.5 to 0.5 \n\
		uniform mat4 viewProjectionMatrix; \n\
		uniform vec3 poiPosition; // world position \n\
		uniform vec2 poiScale; // x,y scale \n\
		\n\
		varying vec2 texCoord; \n\
		\n\
		void main(void)  \n\
		{ \n\
			// Generate texture coordinates, input vertex goes from -0.5 to 0.5 (on x,y) \n\
			texCoord = vertex.xy + vec2(0.5); \n\
			// Invert y \n\
			texCoord.y = 1.0 - texCoord.y; \n\
			\n\
			// Compute poi position in clip coordinate \n\
			gl_Position = viewProjectionMatrix * vec4(poiPosition, 1.0); \n\
			gl_Position.xy += vertex.xy * gl_Position.w * poiScale; \n\
		} \n\
		";
	
		var fragmentLabelShader = "\
		#ifdef GL_ES \n\
		precision highp float; \n\
		#endif \n\
		\n\
		varying vec2 texCoord; \n\
		uniform sampler2D texture; \n\
		uniform float alpha; \n\
		\n\
		void main(void) \n\
		{ \n\
			vec4 textureColor = texture2D(texture, texCoord); \n\
			gl_FragColor = vec4(textureColor.rgb, textureColor.a * alpha); \n\
		} \n\
		";
		
		this.gridProgram = new Program(this.globe.renderContext);
		this.labelProgram = new Program(this.globe.renderContext);
		this.gridProgram.createFromSource( vertexShader, fragmentShader );
		this.labelProgram.createFromSource( vertexLabelShader, fragmentLabelShader );
	}
	
	// Texture used to show the equatorial coordinates
	this.labelMesh = new Mesh(this.globe.renderContext);
	var vertices = [-0.5, -0.5, 0.0,
			-0.5,  0.5, 0.0,
			0.5,  0.5, 0.0,
			0.5, -0.5, 0.0];
	var indices = [0, 3, 1, 1, 3, 2];
	this.labelMesh.setVertices(vertices);
	this.labelMesh.setIndices(indices);

	// Init grid buffers	
	var gl = this.globe.renderContext.gl;
	this.vertexBuffer = gl.createBuffer();
	this.indexBuffer = gl.createBuffer();

	// Init texture pool
	if ( !this.texturePool )
		this.texturePool = new TexturePool(gl);
}

/**************************************************************************************************************/

/** 
	Detach the layer from the globe
 */
CoordinateGridLayer.prototype._detach = function()
{
	var gl = this.globe.renderContext.gl;
	gl.deleteBuffer( this.vertexBuffer );
	gl.deleteBuffer( this.indexBuffer );

	this.texturePool.disposeAll();
	for ( var i in this.labels )
	{
		delete this.labels[i];
	}

	this.globe.tileManager.removePostRenderer(this);
	BaseLayer.prototype._detach.call(this);

}

/**************************************************************************************************************/

/**
 *	Clamp geoBound to longitude/latitude samples
 */
CoordinateGridLayer.prototype.clampGeoBound = function( geoBound )
{
	geoBound.west = Math.floor(geoBound.west / this.longitudeSample)*this.longitudeSample;
	geoBound.east = Math.ceil(geoBound.east / this.longitudeSample)*this.longitudeSample;
	geoBound.north = Math.ceil(geoBound.north / this.latitudeSample)*this.latitudeSample;
	geoBound.south = Math.floor(geoBound.south / this.latitudeSample)*this.latitudeSample;
	return geoBound;
}

/**
	Render the grid
 */
CoordinateGridLayer.prototype.render = function( tiles )
{
	var renderContext = this.globe.renderContext;
	var gl = renderContext.gl;
	
	gl.disable(gl.DEPTH_TEST);
	gl.enable(gl.BLEND);
	gl.blendEquation(gl.FUNC_ADD);
	gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

	// Compute current geoBound
	var geoBound;
	if ( this.coordSystem != 'EQ' )
	{
		// Transform geoBound computed in default coordinate system to coordinate system of current grid if different
		var self = this;
		geoBound = this.globe.getViewportGeoBound(function(coordinate) {
			return CoordinateSystem.convert(coordinate, 'EQ', self.coordSystem);
		});
	}
	else
	{
		geoBound = this.globe.getViewportGeoBound();
	}

	// Clamp geoBound angles to longitude/latitude samples
	geoBound = this.clampGeoBound(geoBound);

	// Regenerate grid & labels only if geoBound has changed
	if (this.geoBound.west != geoBound.west || this.geoBound.east != geoBound.east || this.geoBound.north != geoBound.north || this.geoBound.south != geoBound.south )
	{
		this.geoBound = geoBound;
		this.computeSamples()
		this.generateGridBuffers();
		this.generateLabels();
	}
	else
	{
		this.updateLabels();	
	}
	
	/*** Render grid ***/
	this.gridProgram.apply();
	mat4.multiply(renderContext.projectionMatrix, renderContext.viewMatrix, renderContext.modelViewMatrix)
	gl.uniformMatrix4fv(this.gridProgram.uniforms["viewProjectionMatrix"], false, renderContext.modelViewMatrix);
	gl.uniform1f(this.gridProgram.uniforms["alpha"], this._opacity );
	gl.uniform3f(this.gridProgram.uniforms["color"], this.color[0], this.color[1], this.color[2] );
	
	gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
	gl.vertexAttribPointer(this.gridProgram.attributes['vertex'], this.vertexBuffer.itemSize, gl.FLOAT, false, 0, 0);
	
	gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
	gl.drawElements( gl.LINES, this.indexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
	
	/*** Render labels ***/
	this.labelProgram.apply();
	
	mat4.multiply(renderContext.projectionMatrix, renderContext.viewMatrix, renderContext.modelViewMatrix)
	gl.uniformMatrix4fv(this.labelProgram.uniforms["viewProjectionMatrix"], false, renderContext.modelViewMatrix);
	gl.uniform1i(this.labelProgram.uniforms["texture"], 0);
	
	var pixelSizeVector = renderContext.computePixelSizeVector();
	for ( var n in this.labels )
	{
		var label = this.labels[n];
		// Bind point texture
		gl.activeTexture(gl.TEXTURE0);
		gl.bindTexture(gl.TEXTURE_2D, label.texture);

		// 2.0 * because normalized device coordinates goes from -1 to 1
		var scale = [2.0 * label.textureWidth / renderContext.canvas.width,
					 2.0 * label.textureHeight / renderContext.canvas.height];
					 
		gl.uniform2fv(this.labelProgram.uniforms["poiScale"], scale);
		// gl.uniform2fv(this.labelProgram.uniforms["tst"], [ 0.5 / (label.textureWidth), 0.5 / (label.textureHeight)  ]);
		
		// Poi culling
		var worldPoi = label.pos3d;
		var poiVec = label.vertical;
		scale = label.textureHeight * ( pixelSizeVector[0] * worldPoi[0] + pixelSizeVector[1] * worldPoi[1] + pixelSizeVector[2] * worldPoi[2] + pixelSizeVector[3] );

		var x = poiVec[0] * scale + worldPoi[0];
		var y = poiVec[1] * scale + worldPoi[1];
		var z = poiVec[2] * scale + worldPoi[2];
			
		gl.uniform3f(this.labelProgram.uniforms["poiPosition"], x, y, z);
		gl.uniform1f(this.labelProgram.uniforms["alpha"], 1.);
			
		this.labelMesh.render(this.labelProgram.attributes);
		label.needed = false;	
	}
	gl.enable(gl.DEPTH_TEST);
	gl.disable(gl.BLEND);
}

/**************************************************************************************************************/

/**
 * 	Set visibility of the layer
 */
CoordinateGridLayer.prototype.visible = function( arg )
{
	if ( typeof arg == "boolean" && this._visible != arg )
	{
		this._visible = arg;
		
		if ( arg )
		{
			this.globe.tileManager.addPostRenderer(this);
		}
		else
		{
			this.globe.tileManager.removePostRenderer(this);
		}
	}
	
	return this._visible;
}

/**************************************************************************************************************/

/**
 * 	Set opacity of the layer
 */
CoordinateGridLayer.prototype.opacity = function( arg )
{
	return BaseLayer.prototype.opacity.call( this, arg );
}

/**************************************************************************************************************/

/**
 * 	Compute samples depending on geoBound
 */
CoordinateGridLayer.prototype.computeSamples = function()
{
	var dlong = this.geoBound.east - this.geoBound.west;
	var dlat = this.geoBound.north - this.geoBound.south;
	
	// if under-sampled and not divergent
	while ( dlong / this.longitudeSample < 3. && this.longitudeSample > 1. )
	{
		this.longitudeSample /= 2;
		this.latitudeSample /= 2;
	}
	
	// if over-sampled and not exceed the initial value
	while ( dlong / this.longitudeSample > 7. && this.longitudeSample < 15. )
	{
		this.longitudeSample *= 2;
		this.latitudeSample *= 2;
	}
}

/**************************************************************************************************************/

/**
 * 	Generate buffers object of the grid
 */
CoordinateGridLayer.prototype.generateGridBuffers = function()
{
	var phiStart, phiStop;
	// Difference is larger than hemisphere
	if ( (this.geoBound.east - this.geoBound.west) > 180. )
	{
		// pole in the viewport
		phiStart = 0;
		phiStop = 360;
	}
	else
	{
		phiStart = this.geoBound.west;
		phiStop = this.geoBound.east;
	}

	// TODO adaptative generation of theta value
	// for (var theta = geoBound.south; theta <= geoBound.north; theta+=latStep) {

	var vertexPositionData = [];
	var latitudeBands = 180. / this.latitudeSample;

	for ( var latNumber = 0; latNumber <= latitudeBands; latNumber++ )
	{
		var theta = latNumber * Math.PI / latitudeBands;
		var sinTheta = Math.sin(theta);
		var cosTheta = Math.cos(theta);
		
		for ( var phi = phiStart; phi <= phiStop ; phi+=this.longitudeSample )
		{
			// Tesselation
			var step = this.longitudeSample/this.tesselation;
			for ( var i=0; i<this.tesselation; i++ ) {
				var radPhi = (phi + i*step) * Math.PI / 180;
			
				var sinPhi = Math.sin(radPhi);
				var cosPhi = Math.cos(radPhi);
				
				// z is the up vector
				var x = cosPhi * sinTheta;
				var y = sinPhi * sinTheta;
				var z = cosTheta;

				if ( this.coordSystem != "EQ" ) {
					var geo = CoordinateSystem.from3DToGeo( [x, y, z] );
					geo = CoordinateSystem.convert(geo, this.coordSystem, "EQ");
					var eq = CoordinateSystem.fromGeoTo3D( geo );
					vertexPositionData.push(eq[0], eq[1], eq[2]);				
				} else {
					vertexPositionData.push(x, y, z);
				}
			}
			
		}
	}

	var gl = this.globe.renderContext.gl;
	gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
	gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertexPositionData), gl.STATIC_DRAW);
	this.vertexBuffer.itemSize = 3;
	this.vertexBuffer.numItems = vertexPositionData.length/3;

	
	var indexData = [];
	var longitudeBands = (phiStop - phiStart)/this.longitudeSample + 1;

	// Tesselation
	longitudeBands *= this.tesselation;

	for ( var latNumber = 0; latNumber < latitudeBands; latNumber++ )
	{
		for ( var phi = phiStart, longNumber = 0; phi < phiStop ; phi+=this.longitudeSample, longNumber+=this.tesselation )
		{
			var first = (latNumber * (longitudeBands)) + longNumber % (longitudeBands - 1);
			var second = first + longitudeBands;

			// Horizontal lines
			for ( var i=0; i<this.tesselation; i++ ) 
			{
				indexData.push(first + i);
				indexData.push(first + i + 1);
			}
			
			// Vertical lines
			indexData.push(first + this.tesselation);
			indexData.push(second + this.tesselation);
			
			indexData.push(second);
			indexData.push(first);
		}
	}

	gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
	gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indexData), gl.STATIC_DRAW);
	this.indexBuffer.itemSize = 1;
	this.indexBuffer.numItems = indexData.length;
}

/**************************************************************************************************************/

/**
 *	Build angle representation
 *
 *	@param {String} format The building format("HMS", "DMS" or "Deg")
 *	@param angle The angle to build
 */
 function _buildAngle( format, angle ) {
 	var label;
	switch ( format ) {
		case "Deg":
			label = angle+"";
			break;
		case "HMS":
			label = CoordinateSystem.fromDegreesToHMS( angle );
			break;
		case "DMS":
			label = CoordinateSystem.fromDegreesToDMS( angle );
			break;
		default:
			console.error(format + " : format not supported");
			return null;
	}
	return label;
 }

/**************************************************************************************************************/

/**
 *	Compute geographic center of canvas in grid's coordinate system
 */
CoordinateGridLayer.prototype.computeGeoCenter = function() {
	var center3d = this.globe.renderContext.get3DFromPixel( this.globe.renderContext.canvas.width / 2. , this.globe.renderContext.canvas.height / 2. );
	var geoCenter = [];
	CoordinateSystem.from3DToGeo( center3d, geoCenter );

	// Convert geoCenter into grid's coordinate system
	if ( this.coordSystem != "EQ" ) {
		geoCenter = CoordinateSystem.convert( geoCenter, "EQ", this.coordSystem );
	}
	return geoCenter;
}

/**************************************************************************************************************/

/**
 *	Update 3D position of given label
 *
 *	@param {String} label The label id in labels object
 *	@param {Float[]} posGeo Updated geographic position of label
 */
CoordinateGridLayer.prototype.updateLabel = function(label, posGeo) {
	if ( this.coordSystem != "EQ" ) {
		posGeo = CoordinateSystem.convert( posGeo, this.coordSystem, "EQ" );
	}

	var pos3d = CoordinateSystem.fromGeoTo3D( posGeo );
	var vertical = vec3.create();
	vec3.normalize(pos3d, vertical);
	
	this.labels[label].pos3d = pos3d;
	this.labels[label].vertical = vertical;
	this.labels[label].needed = true;
}

/**************************************************************************************************************/

/**
 *	Update position of all labels
 */
CoordinateGridLayer.prototype.updateLabels = function() {

	var geoCenter = this.computeGeoCenter();
	for ( var x in this.labels ) {
		// Compute position of label
		var posGeo;
		if ( this.labels[x].type == "lat" ) 
		{
			posGeo = [ this.labels[x].angle, geoCenter[1] ];
		}
		else if ( this.labels[x].type == "long" )
		{
			posGeo = [ geoCenter[0], this.labels[x].angle ];
		}
		this.updateLabel(x, posGeo);
	}
}

/**************************************************************************************************************/

/**
 * 	Generate labels of the grid
 */
CoordinateGridLayer.prototype.generateLabels = function()
{
	var phiStop, phiStart;
	// Difference is larger than hemisphere
	if ( (this.geoBound.east - this.geoBound.west) > 180. )
	{
		// pole in the viewport => generate all longitude bands
		phiStart = 0;
		phiStop = 360;
	}
	else
	{
		phiStart = this.geoBound.west;
		phiStop = this.geoBound.east;
	}

	var geoCenter = this.computeGeoCenter();
	var label;
	for ( var phi = phiStart; phi < phiStop; phi+=this.longitudeSample )
	{
		// convert to positive [0..360[
		var angle = (phi < 0) ? phi+360 : phi;

		label = _buildAngle(this.longFormat, angle);

		if ( !this.labels["lat_"+label] )
		{
			this.labels["lat_"+label] = {
				angle: phi,
				type: "lat"
			};
			var imageData = this.generateImageData( label );
			this._buildTextureFromImage(this.labels["lat_"+label],imageData);
		}
		
		// Compute position of label
		var posGeo = [ phi, geoCenter[1] ];
		this.updateLabel("lat_"+label, posGeo);
	}
	
	// TODO <!> Adaptative rendering isn't totally implemented for theta due to difficulty to compute extrem latitude using geoBound <!>
	thetaStart = Math.min( this.geoBound.north, this.geoBound.south );
	thetaStop = Math.max( this.geoBound.north, this.geoBound.south );
	
	for ( var theta = thetaStart; theta <= thetaStop; theta+=this.latitudeSample )
	{
// 	for (var theta = -90; theta < 90; theta+=this.latitudeSample) {

		label = _buildAngle(this.latFormat, theta);

		if ( !this.labels["long_"+label] )
		{
			this.labels["long_"+label] = {
				angle: theta,
				type: "long"
			};
			var imageData = this.generateImageData( label );
			this._buildTextureFromImage(this.labels["long_"+label], imageData);
		}
		
		// Compute position of label
		var posGeo = [ geoCenter[0], theta ];
		this.updateLabel("long_"+label, posGeo);
	}

	// Dispose texture if not needed
	for ( var x in this.labels )
	{
		if( !this.labels[x].needed )
		{
			this.texturePool.disposeGLTexture(this.labels[x].texture);
			delete this.labels[x];
		}
	}
	
}

/**************************************************************************************************************/

/*
	Build a texture from an image and store in a renderable
 */
CoordinateGridLayer.prototype._buildTextureFromImage = function(renderable,image)
{  	
	renderable.texture = this.texturePool.createGLTexture(image);
	renderable.textureWidth = image.width;
	renderable.textureHeight = image.height;
}

/**************************************************************************************************************/

/**
 *	@constructor
 *	GL Textures pool
 */
var TexturePool = function(gl)
{
	var gl = gl;
	var glTextures = [];

	/**
		Create a GL texture
	 */
	this.createGLTexture = function(image)
	{
		if ( glTextures.length > 0 )
		{
			return reuseGLTexture(image);
		}
		else
		{
			return createNewGLTexture(image);
		}
	};


	/**
	 	Dispose a GL texture
	 */
	this.disposeGLTexture = function( texture )
	{
		glTextures.push(texture);
	}

	this.disposeAll = function()
	{
		for ( var i=0; i<glTextures.length; i++ )
		{
			gl.deleteTexture(glTextures[i]);
		}
		glTextures.length = 0;
	}

	/** 
		Create a non power of two texture from an image
	*/
	var createNewGLTexture = function(image)
	{	
		var tex = gl.createTexture();
		gl.bindTexture(gl.TEXTURE_2D, tex);
		gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
		return tex;
	}


	/**
		Reuse a GL texture
	 */
	var reuseGLTexture = function(image)
	{
		var glTexture = glTextures.pop();
		gl.bindTexture(gl.TEXTURE_2D, glTexture);
		gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);	
		return glTexture;
	}
}

/**************************************************************************************************************/

return CoordinateGridLayer;

});
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/
 
define('gw/TileWireframeLayer',['./Utils', './BaseLayer','./Program','./Tile'], 
	function(Utils, BaseLayer, Program, Tile) {

/**************************************************************************************************************/

/** 
	@constructor
	Function constructor for TileWireframeLayer
 */
var TileWireframeLayer = function( options )
{
	BaseLayer.prototype.constructor.call( this, options );
	this.outline = (options && options['outline']) ? options['outline'] : false;
	this.globe = null;
	this.program = null;
	this.indexBuffer = null;
	this.subIndexBuffer = [ null, null, null, null ];
}

/**************************************************************************************************************/

Utils.inherits( BaseLayer,TileWireframeLayer );

/**************************************************************************************************************/

/** 
  Build the index buffer
 */
TileWireframeLayer.prototype.buildIndexBuffer = function()
{
	var gl = this.globe.renderContext.gl;
	var size = this.globe.tileManager.tileConfig.tesselation;
	var indices = [];
	
	var step = this.outline ? size-1 : 1;
	
	// Build horizontal lines
	for ( var j=0; j < size; j += step)
	{
		for ( var i=0; i < size-1; i++)
		{
			indices.push( j * size + i );
			indices.push( j * size + i + 1 );
		}
	}

	// Build vertical lines
	for ( var j=0; j < size; j += step)
	{
		for ( var i=0; i < size-1; i++)
		{
			indices.push( i * size + j );
			indices.push( (i+1) * size + j );
		}
	}

	
	var ib = gl.createBuffer();
	gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ib);
	gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);
	
	ib.numIndices = indices.length;
	this.indexBuffer = ib;
	
	var halfTesselation = (size-1) / 2;
	step = this.outline ? halfTesselation : 1;
	for ( var ii = 0; ii < 4; ii++ )
	{
		var i = ii % 2;
		var j = Math.floor( ii / 2 );
		
		// Build the sub grid for 'inside' tile
		var indices = [];
		for ( var n=halfTesselation*j; n < halfTesselation*(j+1)+1; n+= step)
		{
			for ( var k=halfTesselation*i; k < halfTesselation*(i+1); k++)
			{
				indices.push( n * size + k );
				indices.push( n * size + k + 1 );
			}
		}
		for ( var n=halfTesselation*i; n < halfTesselation*(i+1)+1; n+= step)
		{
			for ( var k=halfTesselation*j; k < halfTesselation*(j+1); k++)
			{
				indices.push( k * size + n );
				indices.push( (k+1) * size + n );
			}
		}
	
		var ib = gl.createBuffer();
		gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ib);
		gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);
		ib.numIndices = indices.length;
		this.subIndexBuffer[ii] = ib;
	}
}

/**************************************************************************************************************/

/** 
  Attach the layer to the globe
 */
TileWireframeLayer.prototype._attach = function( g )
{
	BaseLayer.prototype._attach.call( this, g );
	
	if ( this._visible )
	{
		this.globe.tileManager.addPostRenderer(this);
	}
	
	if (!this.program)
	{
		var vertexShader = "\
		attribute vec3 vertex;\n\
		uniform mat4 modelViewMatrix;\n\
		uniform mat4 projectionMatrix;\n\
		void main(void) \n\
		{\n\
			gl_Position = projectionMatrix * modelViewMatrix * vec4(vertex, 1.0);\n\
		}\n\
		";

		var fragmentShader = "\
		precision highp float; \n\
		uniform float alpha; \n\
		void main(void)\n\
		{\n\
				gl_FragColor = vec4(1.0,1.0,1.0,alpha);\n\
		}\n\
		";
		
		this.program = new Program(this.globe.renderContext);
		this.program.createFromSource( vertexShader, fragmentShader );
		
		this.buildIndexBuffer();
	}
}

/**************************************************************************************************************/

/** 
  Detach the layer from the globe
 */
TileWireframeLayer.prototype._detach = function()
{
	this.globe.tileManager.removePostRenderer(this);
	BaseLayer.prototype._detach.call(this);
}

/**************************************************************************************************************/

/**
	Render the tiles outline
 */
TileWireframeLayer.prototype.render = function( tiles )
{
	var rc = this.globe.renderContext;
	var gl = rc.gl;
	
	gl.enable(gl.BLEND);
	
	// Setup program
	this.program.apply();
	gl.uniformMatrix4fv(this.program.uniforms["projectionMatrix"], false, rc.projectionMatrix);
	
	var vertexAttribute = this.program.attributes['vertex'];
	var currentIB = null;	
	
	for ( var i = 0; i < tiles.length; i++ )
	{
		var tile = tiles[i];
		
		var isLoaded = ( tile.state == Tile.State.LOADED );
		var isLevelZero = ( tile.parentIndex == -1 );
	
		// Update uniforms for modelview matrix
		mat4.multiply( rc.viewMatrix, tile.matrix, rc.modelViewMatrix );
		gl.uniformMatrix4fv(this.program.uniforms["modelViewMatrix"], false, rc.modelViewMatrix);
		gl.uniform1f(this.program.uniforms["alpha"], this.opacity() );
			
		// Bind the vertex buffer
		gl.bindBuffer(gl.ARRAY_BUFFER, tile.vertexBuffer);
		gl.vertexAttribPointer(vertexAttribute, 3, gl.FLOAT, false, 4*tile.config.vertexSize, 0);
		
		var indexBuffer = ( isLoaded || isLevelZero ) ? this.indexBuffer : this.subIndexBuffer[tile.parentIndex];
		// Bind the index buffer only if different (index buffer is shared between tiles)
		if ( currentIB != indexBuffer )
		{
			gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
			currentIB = indexBuffer;
		}
		
		// Draw the tiles in wireframe mode
		var numIndices = currentIB.numIndices;
		gl.drawElements(gl.LINES, currentIB.numIndices, gl.UNSIGNED_SHORT, 0);
	}
	
	gl.disable(gl.BLEND);
}

/**************************************************************************************************************/

/**
 * 	Set visibility of the layer
 */
TileWireframeLayer.prototype.visible = function( arg )
{
	if ( typeof arg == "boolean" && this._visible != arg )
	{
		this._visible = arg;
		
		if ( arg ){
			this.globe.tileManager.addPostRenderer(this);
		}
		else
		{
			this.globe.tileManager.removePostRenderer(this);
		}
	}
	
	return this._visible;
}

return TileWireframeLayer;

});

/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

 define('gw/OpenSearchLayer',['./FeatureStyle','./VectorRendererManager','./Utils','./BaseLayer','./RendererTileData', './CoordinateSystem', './Tile'],
	function(FeatureStyle,VectorRendererManager,Utils,BaseLayer,RendererTileData, CoordinateSystem, Tile) {

/**************************************************************************************************************/

/**	@constructor
 * 	@class
 * 	OpenSearch dynamic layer
 * 	
 * 	@param options Configuration options
 * 		<ul>
			<li>serviceUrl : Url of OpenSearch description XML file(necessary option)</li>
			<li>minOrder : Starting order for OpenSearch requests</li>
			<li>displayProperties : Properties which will be shown in priority</li>
			<li>invertY : a boolean, if set all the image data of current layer is flipped along the vertical axis</li>
		</ul>
*/
var OpenSearchLayer = function(options){
	BaseLayer.prototype.constructor.call( this, options );
	
	this.serviceUrl = options.serviceUrl;
	this.minOrder = options.minOrder || 5;
	this.maxRequests = options.maxRequests || 2;
	this.requestProperties = "";
	this.invertY = options.invertY || false;
	this.coordSystemRequired = options.hasOwnProperty('coordSystemRequired') ? options.coordSystemRequired : true;

	// Set style
	if ( options && options['style'] )
	{
		this.style = options['style'];
	}
	else
	{
		this.style = new FeatureStyle();
	}
	
	this.extId = "os";

	// Used for picking management
	this.features = [];
	// Counter set, indicates how many times the feature has been requested
	this.featuresSet = {};

	// Maximum two requests for now
	this.freeRequests = [];
	this.tilesToLoad = [];
	
	// Build the request objects
	for ( var i =0; i < this.maxRequests; i++ )
	{
		var xhr = new XMLHttpRequest();
		this.freeRequests.push( xhr );
	}
}

/**************************************************************************************************************/

Utils.inherits( BaseLayer, OpenSearchLayer );

/**************************************************************************************************************/

/**
 * 	Attach the layer to the globe
 * 
 * 	@param g The globe
 */
OpenSearchLayer.prototype._attach = function( g )
{
	BaseLayer.prototype._attach.call( this, g );
	this.extId += this.id;
	g.tileManager.addPostRenderer(this);
}

/**************************************************************************************************************/

/** 
  Detach the layer from the globe
 */
OpenSearchLayer.prototype._detach = function()
{
	this.globe.tileManager.removePostRenderer(this);	
	BaseLayer.prototype._detach.call(this);
}

/**************************************************************************************************************/

/**
 * 	Launch request to the OpenSearch service
 */
OpenSearchLayer.prototype.launchRequest = function(tile, url)
{
	var tileData = tile.extension[this.extId];
	var index = null;
	
	if ( this.freeRequests.length == 0 )
	{
		return;
	}
	
	// Set that the tile is loading its data for OpenSearch
	tileData.state = OpenSearchLayer.TileState.LOADING;

	// Add request properties to length
	if ( this.requestProperties != "" )
	{
		url += '&' + this.requestProperties;
	}
		
	// Pusblish the start load event, only if there is no pending requests
	if ( this.maxRequests == this.freeRequests.length )
	{
		this.globe.publish("startLoad",this);
	}
	
	var xhr = this.freeRequests.pop();
	var self = this;
	xhr.onreadystatechange = function(e)
	{
		if ( xhr.readyState == 4 ) 
		{
			if ( xhr.status == 200 )
			{

				var response = JSON.parse(xhr.response);

				tileData.complete = (response.totalResults == response.features.length);
					
				self.updateFeatures(response.features);
				
				for ( var i=0; i < response.features.length; i++ )
				{
					self.addFeature( response.features[i], tile );
				}
			}
			else if ( xhr.status >= 400 )
			{
				tileData.complete = true;
				console.error( xhr.responseText );
			}
			
			tileData.state = OpenSearchLayer.TileState.LOADED;
			self.freeRequests.push( xhr );
			
			// Publish the end load event, only if there is no pending requests
			if ( self.maxRequests == self.freeRequests.length )
			{
				self.globe.publish("endLoad",self);
			}
		}
	};
	xhr.open("GET", url );
	xhr.send();
}

/**************************************************************************************************************/

/**
 * 	Set new request properties
 */
OpenSearchLayer.prototype.setRequestProperties = function(properties)
{
	// clean renderers
	for ( var x in this.featuresSet )
	{
		var featureData = this.featuresSet[x];
		for ( var i=0; i<featureData.tiles.length; i++ )
		{
			var tile = featureData.tiles[i];
			var feature = this.features[featureData.index];
			this.globe.vectorRendererManager.removeGeometryFromTile(this,feature.geometry,tile);
		}
	}

	// Clean old results
	var self = this;
	this.globe.tileManager.visitTiles( function(tile) {
		if( tile.extension[self.extId] )
		{
			tile.extension[self.extId].dispose();
			tile.extension[self.extId].featureIds = []; // exclusive parameter to remove from layer
			tile.extension[self.extId].state = OpenSearchLayer.TileState.NOT_LOADED;
			tile.extension[self.extId].complete = false;
		}
	});
	this.featuresSet = {};
	this.features = [];

	// Set request properties
	this.requestProperties = "";
	for (var key in properties)
	{
		if ( this.requestProperties != "" )
			this.requestProperties += '&'
		this.requestProperties += key+'='+properties[key];
	}
	
}

/**************************************************************************************************************/

/**
 *	Add feature to the layer and to the tile extension
 */
OpenSearchLayer.prototype.addFeature = function( feature, tile )
{
	var tileData = tile.extension[this.extId];
	var featureData;
	
	// Add feature if it doesn't exist
	if ( !this.featuresSet.hasOwnProperty(feature.properties.identifier) )
	{
		this.features.push( feature );
		featureData = {
			index: this.features.length-1, 
			tiles: [tile]
		};
		this.featuresSet[feature.properties.identifier] = featureData;
	}
	else
	{
		featureData = this.featuresSet[feature.properties.identifier];
		
		// Store the tile
		featureData.tiles.push(tile);

		// Always use the base feature to manage geometry indices
		feature = this.features[ featureData.index ];
	}
	
	// Add feature id
	tileData.featureIds.push( feature.properties.identifier );
	
	// Set the identifier on the geometry
	feature.geometry.gid = feature.properties.identifier;

	// Add to renderer
	//this.addFeatureToRenderer(feature, tile);
	
	// MS: Feature could be added from ClusterOpenSearch which have features with different styles
	var style = feature.properties.style ? feature.properties.style : this.style;

	this.globe.vectorRendererManager.addGeometryToTile(this, feature.geometry, style, tile);
}


/**************************************************************************************************************/

/**
 *	Remove feature from Dynamic OpenSearch layer
 */
OpenSearchLayer.prototype.removeFeature = function( identifier, tile )
{
	var featureIt = this.featuresSet[identifier];
	
	if (!featureIt) {
		return;
	}
	
	// Remove tile from array
	var tileIndex = featureIt.tiles.indexOf(tile);
	if ( tileIndex >= 0 )
	{
		featureIt.tiles.splice(tileIndex,1);
	}
	else
	{
		console.log('OpenSearchLayer internal error : tile not found when removing feature');
	}
	
	if ( featureIt.tiles.length == 0 )
	{
		// Remove it from the set		
		delete this.featuresSet[identifier];

		// Remove it from the array by swapping it with the last feature to optimize removal.
		var lastFeature = this.features.pop();
		if ( featureIt.index < this.features.length ) 
		{
			// Set the last feature at the position of the removed feature
			this.features[ featureIt.index ] = lastFeature;
			// Update its index in the Set.
			this.featuresSet[ lastFeature.properties.identifier ].index = featureIt.index;
		}
	}
}

/**************************************************************************************************************/

/**
 *	Modify feature style
 */
OpenSearchLayer.prototype.modifyFeatureStyle = function( feature, style )
{
	feature.properties.style = style;
	var featureData = this.featuresSet[feature.properties.identifier];
	if ( featureData )
	{
		for ( var i = 0; i < featureData.tiles.length; i++ )
		{
			var tile = featureData.tiles[i];
			this.globe.vectorRendererManager.removeGeometryFromTile(feature.geometry,tile);
			this.globe.vectorRendererManager.addGeometryToTile(this,feature.geometry,style,tile);
		}
		
	}
}

OpenSearchLayer.TileState = {
	LOADING: 0,
	LOADED: 1,
	NOT_LOADED: 2,
	INHERIT_PARENT: 3
};


/**************************************************************************************************************/

/**
 *	Generate the tile data
 */
OpenSearchLayer.prototype.generate = function(tile) 
{
	if ( tile.order == this.minOrder )
	{
		tile.extension[this.extId] = new OSData(this,tile,null);
	}
	
};

/**************************************************************************************************************/

/**
 *	OpenSearch renderable
 */

var OSData = function(layer,tile,p)
{
	this.layer = layer;
	this.parent = p;
	this.tile = tile;
	this.featureIds = []; // exclusive parameter to remove from layer
	this.state = OpenSearchLayer.TileState.NOT_LOADED;
	this.complete = false;
	this.childrenCreated = false;
}

/**************************************************************************************************************/

/**
 * Traverse 
 */
OSData.prototype.traverse = function( tile )
{
	if (!this.layer._visible)
		return;
		
	if (tile.state != Tile.State.LOADED)
		return;

	// Check if the tile need to be loaded
	if ( this.state == OpenSearchLayer.TileState.NOT_LOADED )
	{
		this.layer.tilesToLoad.push( this );
	}
	
	// Create children if needed
	if ( this.state == OpenSearchLayer.TileState.LOADED && !this.complete
			&&  tile.state == Tile.State.LOADED && tile.children && !this.childrenCreated )
	{
		for ( var i = 0; i < 4; i++ )
		{
			if (!tile.children[i].extension[this.layer.extId])
				tile.children[i].extension[this.layer.extId] = new OSData(this.layer,tile.children[i],this);
		}
		this.childrenCreated = true;
	
		
		// HACK : set renderable to have children
		var renderables = tile.extension.renderer ? tile.extension.renderer.renderables : [];
		for ( var i=0; i<renderables.length; i++ )
		{
			if ( renderables[i].bucket.layer == this.layer )
				renderables[i].hasChildren = true;
		}
	}
}

/**************************************************************************************************************/

/**
 * 	Dispose renderable data from tile
 */
OSData.prototype.dispose = function( renderContext, tilePool )
{
	if (this.parent && this.parent.childrenCreated)
	{
		this.parent.childrenCreated = false;
		// HACK : set renderable to not have children!
		var renderables = this.parent.tile.extension.renderer ? this.parent.tile.extension.renderer.renderables : [];
		for ( var i=0; i<renderables.length; i++ )
		{
			if ( renderables[i].bucket.layer == this.layer )
				renderables[i].hasChildren = false;
		}
	}
	
	for( var i = 0; i < this.featureIds.length; i++ )
	{
		this.layer.removeFeature( this.featureIds[i], this.tile );
	}
	this.tile = null;
	this.parent = null;
}

/**************************************************************************************************************/

/**
 *	Build request url
 */
OpenSearchLayer.prototype.buildUrl = function( tile )
{
	var url = this.serviceUrl + "/search?order=" + tile.order + "&healpix=" + tile.pixelIndex;
	if ( this.coordSystemRequired )
	{
		// OpenSearchLayer always works in equatorial
		url += "&coordSystem=EQUATORIAL";
	}
	url += "&media=json";
	return url;
}

/**************************************************************************************************************/

// Internal function to sort tiles
function _sortTilesByDistance(t1,t2)
{
	return t1.tile.distance - t2.tile.distance;
};

/**
	Render function
	
	@param tiles The array of tiles to render
 */
OpenSearchLayer.prototype.render = function( tiles )
{
	if (!this._visible)
		return;
	
	// Sort tiles
	this.tilesToLoad.sort( _sortTilesByDistance );

	// Load data for the tiles if needed
	for ( var i = 0; i < this.tilesToLoad.length && this.freeRequests.length > 0; i++ )
	{
		var tile = this.tilesToLoad[i].tile;
		var url = this.buildUrl(tile);
		if ( url )
		{
			this.launchRequest(tile, url);
		}
	}
	
	this.tilesToLoad.length = 0;
}

/**************************************************************************************************************/

/**
 * 	Update features
 */
OpenSearchLayer.prototype.updateFeatures = function( features )
{
	for ( var i=0; i<features.length; i++ )
	{
		var currentFeature = features[i];
		
		switch ( currentFeature.geometry.type )
		{
			case "Point":

				// Convert to default coordinate system if needed
				/*if ( "EQ" != this.globe.tileManager.imageryProvider.tiling.coordSystem )
				{
					currentFeature.geometry.coordinates = CoordinateSystem.convert(currentFeature.geometry.coordinates, this.globe.tileManager.imageryProvider.tiling.coordSystem, "EQ");
				}*/

				// Convert to geographic to simplify picking
				if ( currentFeature.geometry.coordinates[0] > 180 )
					currentFeature.geometry.coordinates[0] -= 360;
				break;
			case "Polygon":
				var ring = currentFeature.geometry.coordinates[0];
				for ( var j = 0; j < ring.length; j++ )
				{
					// Convert to default coordinate system if needed
					/*if ( "EQ" != this.globe.tileManager.imageryProvider.tiling.coordSystem )
					{
						ring[j] = CoordinateSystem.convert(ring[j], this.globe.tileManager.imageryProvider.tiling.coordSystem, "EQ");
					}*/

					// Convert to geographic to simplify picking
					if ( ring[j][0] > 180 )
						ring[j][0] -= 360;
				}
				break;
			default:
				break;
		}
	}
}

/*************************************************************************************************************/

return OpenSearchLayer;

});

/******************************************************************************* 
* Copyright 2012, 2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES 
* 
* This file is part of SITools2. 
* 
* SITools2 is free software: you can redistribute it and/or modify 
* it under the terms of the GNU General Public License as published by 
* the Free Software Foundation, either version 3 of the License, or 
* (at your option) any later version. 
* 
* SITools2 is distributed in the hope that it will be useful, 
* but WITHOUT ANY WARRANTY; without even the implied warranty of 
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
* GNU General Public License for more details. 
* 
* You should have received a copy of the GNU General Public License 
* along with SITools2. If not, see <http://www.gnu.org/licenses/>. 
******************************************************************************/ 

define('ClusterOpenSearchLayer', [ "gw/FeatureStyle", "gw/Utils", "gw/OpenSearchLayer", "gw/HEALPixBase", "gw/CoordinateSystem", "gw/RendererTileData" ],
		function(FeatureStyle, Utils, OpenSearchLayer, HEALPixBase, CoordinateSystem, RendererTileData) {

/**************************************************************************************************************/

/**	@constructor
 * 	@class
 * 	Cluster OpenSearch layer
 * 	
 * 	@param options Configuration options
 * 		<ul>
			<li>serviceUrl : Url of OpenSearch description XML file(necessary option)</li>
			<li>minOrder : Starting order for OpenSearch requests</li>
			<li>displayProperties : Properties which will be shown in priority</li>
			<li>treshold : Visibility treshold</li>
			<li>maxClusterOrder: Maximal cluster refinement order</li>
			<li>accuracyOrder : Accuracy order</li>
		</ul>
*/
var ClusterOpenSearchLayer = function(options){

	OpenSearchLayer.prototype.constructor.call( this, options );

	// Configure cluster service options
	this.treshold = options.treshold || 5;
	this.maxClusterOrder = options.maxClusterOrder || 8;
	this.accuracyOrder = options.accuracyOrder || 10;
	this.coordSystemRequired = options.hasOwnProperty('coordSystemRequired') ? options.coordSystemRequired : true;

	// Handle distributions
	this.distributions = null;
	this.clusterServiceUrl = null;

	this.handleClusterService();

	this.clusterStyle = new FeatureStyle(this.style);
	this.clusterStyle.iconUrl = options.clusterIconUrl || "css/images/cluster.png";
	this.clusterBucket = null;
}

/**************************************************************************************************************/

Utils.inherits( OpenSearchLayer, ClusterOpenSearchLayer );

/**************************************************************************************************************/

/** 
 *	Detach the layer from the globe
 */
ClusterOpenSearchLayer.prototype._detach = function()
{
	OpenSearchLayer.prototype._detach.call( this );
	this.clusterBucket = null;
}

/**************************************************************************************************************/

/**
 *	Get cluster service url from OpenSearch description XML file
 */
ClusterOpenSearchLayer.prototype.handleClusterService = function()
{
	var xhr = new XMLHttpRequest();
	var self = this;
	xhr.onreadystatechange = function(e)
	{
		if ( xhr.readyState == 4 ) 
		{
			if ( xhr.status == 200 )
			{
				var urls = xhr.responseXML.getElementsByTagName("Url");
				// Find rel=clusterdesc url
				for ( var i=0; i<urls.length; i++ )
				{
					if ( urls[i].attributes.getNamedItem("rel") && urls[i].attributes.getNamedItem("rel").nodeValue == "clusterdesc" )
					{
						// Get clusterdesc template
						var describeUrl = urls[i].attributes.getNamedItem("template").nodeValue;
						
						if ( describeUrl )
						{
							// Cut unused data
							var splitIndex = describeUrl.indexOf( "q=" );
							if ( splitIndex != -1 )
							{
								self.clusterServiceUrl = describeUrl.substring( 0, splitIndex );
							}
							else
							{
								self.clusterServiceUrl =  describeUrl;
							}
							self.updateDistributions(self);
						}
						break;
					}
				}
				if ( i == urls.length )
				{
					// Cluster description doesn't exist, use open search without clusters
					self.prototype = OpenSearchLayer.prototype;
				}
			}
			else
			{
				// Cluster description doesn't exist, use open search without clusters
				self.prototype = OpenSearchLayer.prototype;
			}
		}
	};
	xhr.open("GET", this.serviceUrl );
	xhr.send();
}

/**************************************************************************************************************/

/**
 *	Update cluster distribution
 */
ClusterOpenSearchLayer.prototype.updateDistributions = function(layer)
{
	var xhr = new XMLHttpRequest();
	var url = layer.clusterServiceUrl + layer.requestProperties;
	xhr.onreadystatechange = function(e)
	{
		if ( xhr.readyState == 4 ) 
		{
			if ( xhr.status == 200 )
			{
				var response = JSON.parse(xhr.response);
				layer.handleDistribution(response);
			}
		}
	};
	xhr.open("GET", url );
	xhr.send();
}

/**************************************************************************************************************/

/**
 *	Handle SOLR distribution response
 *
 *	@param response SOLR response
 *	@param distributions Distributions ClusterManager variable
 */
ClusterOpenSearchLayer.prototype.handleDistribution = function(response)
{
	var distributions = {};
	var facet_fields = response.facet_counts.facet_fields;
	var order = 3;
	for (var key in facet_fields)
	{
		distributions[order] = {};
		for (var i=0; i<facet_fields[key].length; i+=2)
		{
			distributions[order][facet_fields[key][i]] = facet_fields[key][i+1];
		}
		order++;
	}
	this.distributions = distributions;
}

/**************************************************************************************************************/

/**
 *	Adding cluster geometry to renderer
 *
 *	@param pixelIndex Pixel index
 *	@param order Pixel order
 *	@param face Face of pixel
 *	@param pixelDistribution Number of features in cluster
 */
ClusterOpenSearchLayer.prototype.addCluster = function(pixelIndex, order, face, pixelDistribution, tile)
{
	
	// Create geometry
	var nside = Math.pow(2, order);
	var pix=pixelIndex&(nside*nside-1);
	var ix = HEALPixBase.compress_bits(pix);
	var iy = HEALPixBase.compress_bits(pix>>>1);
	var center = HEALPixBase.fxyf((ix+0.5)/nside, (iy+0.5)/nside, face);

	var geo = CoordinateSystem.from3DToGeo( center );
	var pos3d = center;
	var vertical = vec3.create();
	vec3.normalize(pos3d, vertical);
	
	var geometry = {
		coordinates: geo,
		type: "Point"
	};

	// Create renderable
	var identifier = order+"_"+pixelIndex;
	var feature = {
		geometry: geometry,
		properties: {
			featureNum: pixelDistribution,
			identifier: identifier,
			title: "Cluster("+pixelDistribution+")",
			order: order,
			pixelIndex: pixelIndex,
			style: new FeatureStyle(this.clusterStyle)
		},
		cluster : true
	};
	tile.extension[this.extId].containsCluster = true;
	this.addFeature( feature, tile );
}

/**************************************************************************************************************/

/**
 * 	Launch request to the OpenSearch service
 */
ClusterOpenSearchLayer.prototype.launchRequest = function(tile, url)
{
	var tileData = tile.extension[this.extId];
	var index = null;
	
	if ( this.freeRequests.length == 0 )
	{
		return;
	}
	
	// Set that the tile is loading its data for OpenSearch
	tileData.state = OpenSearchLayer.TileState.LOADING;

	// Add request properties to length
	if ( this.requestProperties != "" )
	{
		url += '&' + this.requestProperties;
	}
		
	// Publish the start load event, only if there is no pending requests
	if ( this.maxRequests == this.freeRequests.length )
	{
		this.globe.publish("startLoad",this);
	}

	var xhr = this.freeRequests.pop();

	var self = this;
	xhr.onreadystatechange = function(e)
	{
		if ( xhr.readyState == 4 ) 
		{
			if ( xhr.status == 200 )
			{
				var response = JSON.parse(xhr.response);

				if ( !tileData.containsCluster )
				{
					tileData.complete = (response.totalResults == response.features.length);
				}

				self.updateFeatures(response.features);
				
				if ( response.features.length > 0 )
				{
					for ( var i=0; i < response.features.length; i++ )
					{
						self.addFeature( response.features[i], tile );
					}
				}
			}
			else if ( xhr.status >= 400 )
			{
				console.error( xhr.responseText );
			}
			
			tileData.state = OpenSearchLayer.TileState.LOADED;
			self.freeRequests.push( xhr );
			
			// Publish the end load event, only if there is no pending requests
			if ( self.maxRequests == self.freeRequests.length )
			{
				self.globe.publish("endLoad",self);
			}
		}
	};
	xhr.open("GET", url );
	xhr.send();
}

/**************************************************************************************************************/

ClusterOpenSearchLayer.prototype.buildUrl = function( tile )
{
	if ( this.distributions && tile.order < this.maxClusterOrder  )
	{
		var pixelIndicesToRequest = [];
		var orderDepth = this.accuracyOrder - tile.order;
		var childOrder = this.accuracyOrder;

		if(  this.distributions[childOrder] )
		{
			// Distribution exists
			var numSubTiles = Math.pow(4,orderDepth); // Number of subtiles depending on order
			var firstSubTileIndex = tile.pixelIndex * numSubTiles;

			for ( var j=firstSubTileIndex; j<firstSubTileIndex+numSubTiles; j++ )
			{
				var pixelDistribution = this.distributions[childOrder][j];
				if ( pixelDistribution > this.treshold )
				{
					// Cluster child
					this.addCluster(j, this.accuracyOrder, tile.face, pixelDistribution, tile);
				}
				else if ( pixelDistribution > 0 )
				{
					// Feature containing child
					pixelIndicesToRequest.push(j);
				}
			}
		}
		
		if ( pixelIndicesToRequest.length > 0 )
		{
			var indices = "";
			for ( var i=0; i<pixelIndicesToRequest.length-1; i++ )
			{
				indices+=pixelIndicesToRequest[i]+",";
			}
			indices+=pixelIndicesToRequest[i];

			var url = this.serviceUrl + "/search?order=" + childOrder + "&healpix=" + indices;

			return url;
		}
		else 
		{
			if ( !tile.extension[this.extId].containsCluster )
			{
				// Empty tile
				tile.extension[this.extId].complete = true;
			}
			tile.extension[this.extId].state = OpenSearchLayer.TileState.LOADED;
			return null;
		}
	}
	else
	{
		return OpenSearchLayer.prototype.buildUrl.call( this, tile );
	}
}

/**************************************************************************************************************/

/**
 * 	Set new request properties
 */
ClusterOpenSearchLayer.prototype.setRequestProperties = function(properties)
{
	OpenSearchLayer.prototype.setRequestProperties.call( this, properties );
	// Reset distributions
	this.distributions = null;
	this.updateDistributions(this);
}

return ClusterOpenSearchLayer;

});
/******************************************************************************* 
* Copyright 2012, 2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES 
* 
* This file is part of SITools2. 
* 
* SITools2 is free software: you can redistribute it and/or modify 
* it under the terms of the GNU General Public License as published by 
* the Free Software Foundation, either version 3 of the License, or 
* (at your option) any later version. 
* 
* SITools2 is distributed in the hope that it will be useful, 
* but WITHOUT ANY WARRANTY; without even the implied warranty of 
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
* GNU General Public License for more details. 
* 
* You should have received a copy of the GNU General Public License 
* along with SITools2. If not, see <http://www.gnu.org/licenses/>. 
******************************************************************************/ 

/**
 * Moc renderer/layer module
 */
define('MocLayer', [ "jquery", "gw/BaseLayer", 'gw/FeatureStyle', "gw/Utils", "gw/HEALPixBase", "gw/CoordinateSystem" ],
		function($, BaseLayer, FeatureStyle, Utils, HEALPixBase, CoordinateSystem) {

/**
 * 	@constructor
 * 	@class
 * 	MocLayer
 *
 * 	@param options Configuration options
 * 		<ul>
 *			<li>serviceUrl : Url of the service providing the MOC data(necessary option)</li>
 *			<li>startOrder : Starting order of HEALPix tiling
 *		</ul>
 */
var MocLayer = function(options)
{

	BaseLayer.prototype.constructor.call( this, options );

	this.serviceUrl = options.serviceUrl;
	this.startOrder = options.startOrder || 2;

	// Set style
	if ( options && options['style'] )
	{
		this.style = new FeatureStyle(options['style']);
	}
	else
	{
		this.style = new FeatureStyle();
	}

	this.featuresSet = null;
}

/**************************************************************************************************************/

Utils.inherits( BaseLayer, MocLayer );

/**************************************************************************************************************/

/**
 * 	Attach the layer to the globe
 * 
 * 	@param g The globe
 */
MocLayer.prototype._attach = function( g )
{
	BaseLayer.prototype._attach.call( this, g );

	var self = this;
	$.ajax({
		type: "GET",
		url: self.serviceUrl,
		dataType: 'json',
		success: function(response){
				self.handleDistribution(response);
		},
		error: function (xhr, ajaxOptions, thrownError) {
			$('#addLayer_'+self.id).find('label').css("color","red");
			console.error( xhr.responseText );
		}
	});
	
	// As post renderer, moc layer will regenerate data on tiles in case of base imagery change
	g.tileManager.addPostRenderer(this);
}

/**************************************************************************************************************/

/**
 *	Generates moc data on tiles
 */
MocLayer.prototype.generate = function(tile)
{
	if ( this.featuresSet && tile.order == this.startOrder )
	{
		var geometries = this.featuresSet[tile.pixelIndex];
		if ( geometries )
		{
			for ( var i=0; i<geometries.length; i++ )
			{
				this.globe.vectorRendererManager.addGeometryToTile( this, geometries[i], this.style, tile );
			}
		}
	}
}

/**************************************************************************************************************/

/**
 *	Render
 */
MocLayer.prototype.render = function()
{
	// No rendering
}

/**************************************************************************************************************/

/** 
  Detach the layer from the globe
 */
MocLayer.prototype._detach = function()
{
	for ( var tileIndex in this.featuresSet )
	{
		var tile = this.globe.tileManager.level0Tiles[tileIndex];
		for ( var i=0; i<this.featuresSet[tileIndex].length; i++ )
		{
			this.globe.vectorRendererManager.removeGeometryFromTile(this.featuresSet[tileIndex][i], tile);
		}
	}
	this.featuresSet = null;
	this.globe.tileManager.removePostRenderer(this);

	BaseLayer.prototype._detach.call(this);
}

/**************************************************************************************************************/

/**
 *	Return children indices of starting tiling order
 *	@param index Parent index
 *	@param order Parent order
 */
MocLayer.prototype.findChildIndices = function(index, order)
{
	var childOrder = this.startOrder;
	var orderDepth = childOrder - order;
	var numSubTiles = Math.pow(4,orderDepth); // Number of subtiles depending on order
	var firstSubTileIndex = index * numSubTiles;
	var indices = [];
	for ( var i=firstSubTileIndex; i<firstSubTileIndex + numSubTiles; i++ )
	{
		indices.push(i);
	}

	return indices;
}

/**************************************************************************************************************/

/**
 *	Return index of parent of starting tiling order
 *	@param index Child index
 *	@param order Child order
 */
MocLayer.prototype.findParentIndex = function(index, order)
{
	var parentOrder = this.startOrder;
	var orderDepth = order - parentOrder;
	var parentIndex = Math.floor( index / (Math.pow(4,orderDepth)) );
	return parentIndex;
}

/**************************************************************************************************************/

/**
 *	Handle MOC response
 *
 *	@param response MOC response
 */
MocLayer.prototype.handleDistribution = function(response)
{	
	var gl = this.globe.tileManager.renderContext.gl;
	this.featuresSet = {};
	// For each order, compute rectangles geometry depending on the pixel index
	for (var key in response)
	{
		var order = parseInt(key);
		for(var i=0; i<response[key].length; i++)
		{
			var pixelIndex = response[key][i];

			if ( order > this.startOrder )
			{
				var parentIndex = this.findParentIndex(pixelIndex, order);
			}
			else if ( order == this.startOrder )
			{
				var parentIndex = pixelIndex;
			}
			else
			{
				// Handle low orders(< 3) by creating children polygons of order 3
				var indices = this.findChildIndices( pixelIndex, order );
				response[this.startOrder.toString()] = response[this.startOrder.toString()].concat( indices );
				continue;
			}

			var geometry = {
				type: "Polygon",
				gid: "moc"+this.id+"_"+order+"_"+pixelIndex,
				coordinates: [[]]
			};

			// Build the vertices
			var size = 2; // TODO
			var step = 1;

			// Tesselate only low-order tiles
			if ( order < 5 )
			{
				size = 5;
				step = 1./(size - 1);
			}
			
			var nside = Math.pow(2, order);
			var pix=pixelIndex&(nside*nside-1);
			var ix = HEALPixBase.compress_bits(pix);
			var iy = HEALPixBase.compress_bits(pix>>>1);
			var face = (pixelIndex>>>(2*order));

			var vertice, geo;

			// Horizontal boudaries
			for(var u = 0; u < 2; u++ ) {
				for(var v = 0; v < size; v++){
					vertice = HEALPixBase.fxyf((ix+u*(size-1)*step)/nside, (iy+v*step)/nside, face);
					geo = CoordinateSystem.from3DToGeo( vertice );
					if ( u == 0 )
					{
						// Invert to clockwise sense
						geometry.coordinates[0][2*u*size +(size-1)-v] = [ geo[0], geo[1] ];
					}
					else
					{
						geometry.coordinates[0][2*u*size +v] = [ geo[0], geo[1] ];
					}
				}
			}

			// Vertical boundaries
			for(var v = 0; v < 2; v++ ) {
				for(var u = 0; u < size; u++ ){
					vertice = HEALPixBase.fxyf((ix+u*step)/nside, (iy+v*(size-1)*step)/nside, face);
					geo = CoordinateSystem.from3DToGeo( vertice );
					if ( v==1 )
					{
						// Invert to clockwise sense
						geometry.coordinates[0][size + 2*v*size +(size-1)-u] = [ geo[0], geo[1] ];
					}
					else
					{
						geometry.coordinates[0][size + 2*v*size +u] = [ geo[0], geo[1] ];
					}	
				}
			}
				
			var parentTile = this.globe.tileManager.level0Tiles[parentIndex];

			if ( !this.featuresSet[ parentIndex ] )
			{
				this.featuresSet[parentIndex] = [];
			}

			this.featuresSet[parentIndex].push(geometry);
			this.globe.vectorRendererManager.addGeometryToTile( this, geometry, this.style, parentTile );
		}
	}
}

return MocLayer;

});

/***************************************
 * Copyright 2010, Aladin by the Centre de Donnes astronomiques de Strasbourg (CDS).
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('gw/ColorMap',[], function() {

/**************************************************************************************************************/
var transferFonctions = {
	"linear": [],
	"asin": [],
	"sqrt": [],
	"sqr": [],
	"log": []
};

var computeTransferFunctions = function() 
{

	for ( var x in transferFonctions)
	{
	    var min=Number.MAX_VALUE;
	    var max=Number.MIN_VALUE;
	    var v;
	    var val = [];
	    for( var i=0; i<256; i++ ) {
	      	v = i;
	      	switch( x ) {
	      		case "linear":
	      			val[i] = v;
	      			break;
	      		case "asin":
	      			val[i] = Math.log(v + Math.sqrt(Math.pow(v,2)+1.));
	      			break;
	      		case "log":
	      			val[i] = Math.log(v/10.+1);
	      			break;
	      		case "sqrt":
	      			val[i] = Math.sqrt(v/10.);
	      			break;
	      		case "sqr":
	      			val[i] = v*v;
	      			break;
	      		default:
	      			break;
	      	}
	      	 
	        if( val[i]<min ) min=val[i];
	        if( val[i]>max ) max=val[i];
	    }

	    // Normalize between [0..256]
	    for( i=0; i<256; i++ )
	    {
	    	v = 256 * ((val[i] - min)/(max-min));

	    	// Clamp
	        if( v>256. )
	        	v=256.;
	        else if( v<0. )
	        	v=0.;

	        transferFonctions[x][i] = Math.floor(v);
	    }
	}
}

computeTransferFunctions();

// Contstant colormaps
var colormaps = {
		// composantes de la table 'Fire' (ImageJ)
		"fire" : {
		    red: [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,4,7,
			   10,13,16,19,22,25,28,31,34,37,40,43,46,49,52,55,58,61,64,67,70,73,76,79,
			   82,85,88,91,94,98,101,104,107,110,113,116,119,122,125,128,131,134,137,
			   140,143,146,148,150,152,154,156,158,160,162,163,164,166,167,168,170,171,
			   173,174,175,177,178,179,181,182,184,185,186,188,189,190,192,193,195,196,
			   198,199,201,202,204,205,207,208,209,210,212,213,214,215,217,218,220,221,
			   223,224,226,227,229,230,231,233,234,235,237,238,240,241,243,244,246,247,
			   249,250,252,252,252,253,253,253,254,254,255,255,255,255,255,255,255,255,
			   255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
			   255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
			   255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
			   255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
			   255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
			   255,255,255,255,255,255,255,255,255,255,255,255,255,255],

		    green: [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
			   0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
			   0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
			   0,0,0,0,0,0,1,3,5,7,8,10,12,14,16,19,21,24,27,29,32,35,37,40,43,46,48,
			   51,54,57,59,62,65,68,70,73,76,79,81,84,87,90,92,95,98,101,103,105,107,
			   109,111,113,115,117,119,121,123,125,127,129,131,133,134,136,138,140,141,
			   143,145,147,148,150,152,154,155,157,159,161,162,164,166,168,169,171,173,
			   175,176,178,180,182,184,186,188,190,191,193,195,197,199,201,203,205,206,
			   208,210,212,213,215,217,219,220,222,224,226,228,230,232,234,235,237,239,
			   241,242,244,246,248,248,249,250,251,252,253,254,255,255,255,255,255,255,
			   255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
			   255,255,255,255,255,255,255,255],

		    blue: [0,7,15,22,30,38,45,53,61,65,69,74,78,
			   82,87,91,96,100,104,108,113,117,121,125,130,134,138,143,147,151,156,160,
			   165,168,171,175,178,181,185,188,192,195,199,202,206,209,213,216,220,220,
			   221,222,223,224,225,226,227,224,222,220,218,216,214,212,210,206,202,199,
			   195,191,188,184,181,177,173,169,166,162,158,154,151,147,143,140,136,132,
			   129,125,122,118,114,111,107,103,100,96,93,89,85,82,78,74,71,67,64,60,56,
			   53,49,45,42,38,35,31,27,23,20,16,12,8,5,4,3,3,2,1,1,0,0,0,0,0,0,0,0,0,0,
			   0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
			   0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
			   4,8,13,17,21,26,30,35,42,50,58,66,74,82,90,98,105,113,121,129,136,144,
			   152,160,167,175,183,191,199,207,215,223,227,231,235,239,243,247,251,255,
			   255,255,255,255,255,255,255]
		},

		// composantes de la table EOSB (IDL color table 27)
		"eosb" : {
			red: [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
			   0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
			   0,0,0,0,0,0,0,0,0,0,0,0,0,9,18,27,36,45,49,57,72,81,91,100,109,118,127,
			   136,131,139,163,173,182,191,200,209,218,227,213,221,255,255,255,255,255,
			   255,255,255,229,229,255,255,255,255,255,255,255,255,229,229,255,255,255,
			   255,255,255,255,255,229,229,255,255,255,255,255,255,255,255,229,229,255,
			   255,255,255,255,255,255,255,229,229,255,255,255,255,255,255,255,255,229,
			   229,255,255,255,255,255,255,255,255,229,229,255,255,255,255,255,255,255,
			   255,229,229,255,255,255,255,255,255,255,255,229,229,255,253,251,249,247,
			   245,243,241,215,214,235,234,232,230,228,226,224,222,198,196,216,215,213,
			   211,209,207,205,203,181,179,197,196,194,192,190,188,186,184,164,162,178,
			   176,175,173,171,169,167,165,147,145,159,157,156,154,152,150,148,146,130,
			   128,140,138,137,135,133,131,129,127,113,111,121,119,117,117],

		   green: [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
			   0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,15,23,31,39,47,55,57,64,79,87,95,
			   103,111,119,127,135,129,136,159,167,175,183,191,199,207,215,200,207,239,
			   247,255,255,255,255,255,255,229,229,255,255,255,255,255,255,255,255,229,
			   229,255,255,255,255,255,255,255,255,229,229,255,250,246,242,238,233,229,
			   225,198,195,212,208,204,199,195,191,187,182,160,156,169,165,161,157,153,
			   148,144,140,122,118,127,125,123,121,119,116,114,112,99,97,106,104,102,
			   99,97,95,93,91,80,78,84,82,80,78,76,74,72,70,61,59,63,61,59,57,55,53,50,
			   48,42,40,42,40,38,36,33,31,29,27,22,21,21,19,16,14,12,13,8,6,3,1,0,0,0,
			   0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
			   0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],

		   blue: [116,121,127,131,136,140,144,148,153,
			   157,145,149,170,174,178,182,187,191,195,199,183,187,212,216,221,225,229,
			   233,238,242,221,225,255,247,239,231,223,215,207,199,172,164,175,167,159,
			   151,143,135,127,119,100,93,95,87,79,71,63,55,47,39,28,21,15,7,0,0,0,0,0,
			   0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
			   0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
			   0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
			   0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
			   0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
			   0,0,0,0,0,0,0]
		},

		// tableau des composantes pour Stern
		"stern" : {
	   	red: [0,18,36,54,72,90,108,127,145,163,199,217,235,
	         254,249,244,239,234,229,223,218,213,208,203,197,192,187,182,177,172,
	         161,156,151,146,140,135,130,125,120,115,109,104,99,94,89,83,78,73,68,
	         63,52,47,42,37,32,26,21,16,11,6,64,65,66,67,68,69,70,71,72,73,75,76,
	         77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,96,97,98,99,100,
	         101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,117,118,
	         119,120,121,122,123,124,125,126,128,129,130,131,132,133,134,135,136,
	         137,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,
	         155,156,157,158,160,161,162,163,164,165,166,167,168,169,170,171,172,
	         173,174,175,176,177,178,179,181,182,183,184,185,186,187,188,189,190,
	         192,193,194,195,196,197,198,199,200,201,203,204,205,206,207,208,209,
	         210,211,212,213,214,215,216,217,218,219,220,221,222,224,225,226,227,
	         228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,245,
	         246,247,248,249,250,251,252,253,254],

   		green: [0,1,2,3,4,5,6,7,8,9,11,12,13,14,15,16,17,18,
	         19,20,21,22,23,24,25,26,27,28,29,30,32,33,34,35,36,37,38,39,40,41,42,
	         43,44,45,46,47,48,49,50,51,53,54,55,56,57,58,59,60,61,62,64,65,66,67,
	         68,69,70,71,72,73,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,
	         92,93,94,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,
	         112,113,114,115,117,118,119,120,121,122,123,124,125,126,128,129,130,
	         131,132,133,134,135,136,137,139,140,141,142,143,144,145,146,147,148,
	         149,150,151,152,153,154,155,156,157,158,160,161,162,163,164,165,166,
	         167,168,169,170,171,172,173,174,175,176,177,178,179,181,182,183,184,
	         185,186,187,188,189,190,192,193,194,195,196,197,198,199,200,201,203,
	         204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,
	         221,222,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,
	         239,240,241,242,243,245,246,247,248,249,250,251,252,253,254],

   		blue : [0,1,3,5,7,9,11,13,15,17,21,23,25,27,29,31,33,
	         35,37,39,41,43,45,47,49,51,53,55,57,59,63,65,67,69,71,73,75,77,79,81,
	         83,85,87,89,91,93,95,97,99,101,105,107,109,111,113,115,117,119,121,
	         123,127,129,131,133,135,137,139,141,143,145,149,151,153,155,157,159,
	         161,163,165,167,169,171,173,175,177,179,181,183,185,187,191,193,195,
	         197,199,201,203,205,207,209,211,213,215,217,219,221,223,225,227,229,
	         233,235,237,239,241,243,245,247,249,251,255,251,247,243,238,234,230,
	         226,221,217,209,204,200,196,192,187,183,179,175,170,166,162,158,153,
	         149,145,141,136,132,128,119,115,111,107,102,98,94,90,85,81,77,73,68,
	         64,60,56,51,47,43,39,30,26,22,17,13,9,5,0,3,7,15,19,22,26,30,34,38,41,
	         45,49,57,60,64,68,72,76,79,83,87,91,95,98,102,106,110,114,117,121,125,
	         129,137,140,144,148,152,156,159,163,167,171,175,178,182,186,190,194,
	         197,201,205,209,216,220,224,228,232,235,239,243,247,251]
		},

		// composantes de la table rainbow (IDL color table 13)
		"rainbow": {
			red : [0,4,9,13,18,22,27,31,36,40,45,50,54,
			   58,61,64,68,69,72,74,77,79,80,82,83,85,84,86,87,88,86,87,87,87,85,84,84,
			   84,83,79,78,77,76,71,70,68,66,60,58,55,53,46,43,40,36,33,25,21,16,12,4,0,
			   0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
			   0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
			   0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,8,12,21,25,29,33,42,
			   46,51,55,63,67,72,76,80,89,93,97,101,110,114,119,123,131,135,140,144,153,
			   157,161,165,169,178,182,187,191,199,203,208,212,221,225,229,233,242,246,
			   250,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
			   255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
			   255,255,255,255,255,255,255,255,255,255,255,255,255,255],
   		green : [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
			   0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
			   0,0,0,0,0,0,0,0,4,8,16,21,25,29,38,42,46,51,55,63,67,72,76,84,89,93,97,
			   106,110,114,119,127,131,135,140,144,152,157,161,165,174,178,182,187,195,
			   199,203,208,216,220,225,229,233,242,246,250,255,255,255,255,255,255,255,
			   255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
			   255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
			   255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
			   255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
			   255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
			   255,250,242,238,233,229,221,216,212,208,199,195,191,187,178,174,170,165,
			   161,153,148,144,140,131,127,123,119,110,106,102,97,89,85,80,76,72,63,59,
			   55,51,42,38,34,29,21,17,12,8,0],
   		blue : [0,3,7,10,14,19,23,28,32,38,43,48,53,
			   59,63,68,72,77,81,86,91,95,100,104,109,113,118,122,127,132,136,141,145,
			   150,154,159,163,168,173,177,182,186,191,195,200,204,209,214,218,223,227,
			   232,236,241,245,250,255,255,255,255,255,255,255,255,255,255,255,255,255,
			   255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
			   255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
			   255,255,255,255,255,255,246,242,238,233,225,220,216,212,203,199,195,191,
			   187,178,174,170,165,157,152,148,144,135,131,127,123,114,110,106,102,97,
			   89,84,80,76,67,63,59,55,46,42,38,34,25,21,16,12,8,0,0,0,0,0,0,0,0,0,0,0,
			   0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
			   0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
			   0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
		},

		// Simple grey levels
		"grey": {
			red : [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,
		     19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,
		     43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,
		     68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,
		     92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,
		     112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,
		     131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,
		     149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,
		     167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,
		     185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,
		     204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,
		     221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,
		     239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255],
     	green: [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,
		     19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,
		     43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,
		     68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,
		     92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,
		     112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,
		     131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,
		     149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,
		     167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,
		     185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,
		     204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,
		     221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,
		     239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255],
     	blue: [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,
		     19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,
		     43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,
		     68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,
		     92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,
		     112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,
		     131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,
		     149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,
		     167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,
		     185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,
		     204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,
		     221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,
		     239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255]
	}
}

/**
 *	Create texture from array
 *	TODO : maybe move this function to renderContext ?
 *
 *	@param gl Context
 *	@param dataArray Array creating the texture
 *	@param format Content format(gl.LUMINANCE, gl.RGB...)
 *	@param dataType Type of data(gl.UNSIGNED_BYTE or gl.FLOAT)
 *	@param width Width of texture
 *	@param height Height of texture
 *
 *	@return GLTexture, or null caused by not supported format
 */
function _textureFromPixelArray(gl, dataArray, format, dataType, width, height) {
	var dataTypedArray;
	if ( dataType == gl.UNSIGNED_BYTE )
    	dataTypedArray = new Uint8Array(dataArray);
    else if ( dataType == gl.FLOAT )
    	dataTypedArray = new Float32Array(dataArray);
    else
    	return null;

    var texture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.texImage2D(gl.TEXTURE_2D, 0, format, width, height, 0, format, dataType, dataTypedArray);

    // NPOT properties
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);

    return texture;
}

return {

	/**
	 * Generate colormap
	 */
	generateColormap : function(gl, transferFonction, colormap, inverse)
	{
		// var pas1 = 128./(tr1-tr0);
	  	// var pas2 = 128./(tr2-tr1);
		
		// Get transfer function
		var fctGap = transferFonctions[transferFonction];

		var cm = [];

		var Sr, Sg, Sb;
		Sr = colormaps[colormap].red;
		Sg = colormaps[colormap].green;
		Sb = colormaps[colormap].blue;
		var max = Sr.length-1;
	  	for( var i=0; i<256; i++ ) {
	     	// int j= i<tr0 ? 0 :
	      //       i<tr1 ? (int)Math.round((i-tr0)*pas1) :
	      //       i<tr2 ? 128+(int)Math.round((i-tr1)*pas2) :
	      //               max;

	     	var j = fctGap[i];

	     	// Clamp
	     	if( j>max ) j=max;
	     		else if( j<0 ) j=0;
	     	if( inverse ) j=max-j;

	     	// Normalize between [0..1]
	     	cm[i*3] = Sr[j] / 256.;
	     	cm[i*3+1] = Sg[j] / 256.;
	     	cm[i*3+2] = Sb[j] / 256.;
	  }

	    // Create new texture
		return _textureFromPixelArray(gl, cm, gl.RGB, gl.FLOAT, cm.length/3, 1);
	}

}

});
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('gw/DynamicImage',['./ColorMap'], function(ColorMap) {
 
/**************************************************************************************************************/

// TODO : Unify shader programs between TileManager, ConvexPolygonRenderer and ImageRenderer
//		* inverse Y coordinates(if needed)
//		* vTextureCoord name refactor
var defaultFragmentCode = "\
		precision highp float; \n\
		varying vec2 vTextureCoord;\n\
		uniform sampler2D texture; \n\
		uniform sampler2D colormap; \n\
		uniform float min; \n\
		uniform float max; \n\
		uniform vec4 color; \n\
		void main(void)\n\
		{\n\
			float i = texture2D(texture,vTextureCoord).r;\n\
			float d = clamp( ( i - min ) / (max - min), 0.0, 1.0 );\n\
			vec4 cmValue = texture2D(colormap, vec2(d,0.));\n\
			gl_FragColor = vec4(cmValue.r,cmValue.g,cmValue.b,color.a);\n\
		}\n\
		";

var defaultCallback = function(gl, renderable, program)
{
	if ( !program )
		program = renderable.polygonProgram;
	gl.uniform1f(program.uniforms["max"], renderable.style.uniformValues.tmax );
	gl.uniform1f(program.uniforms["min"], renderable.style.uniformValues.tmin );

	gl.activeTexture(gl.TEXTURE1);
	gl.bindTexture(gl.TEXTURE_2D, renderable.style.uniformValues.colormapTex);
	gl.uniform1i(program.uniforms["colormap"], 1);
}

/**************************************************************************************************************/

/**
 *	@constructor DynamicImage
 */
var DynamicImage = function(renderContext, pixels, format, dataType, width, height, options)
{
	// Initialize fragment shader and uniformsCallback if needed
	defaultFragmentCode = (options && options.fragmentCode) ? options.fragmentCode : defaultFragmentCode;
	defaultCallback = (options && options.updateUniforms) ? options.updateUniforms : defaultCallback;
	
	this.fragmentCode = defaultFragmentCode;
	this.updateUniforms = defaultCallback;
	this.tmin = 0.;
	this.tmax = 1.;
	this.colormapTex = null;
	this.renderContext = renderContext;

	// Parameters for histogram generation
	this.pixels = pixels;
	this.transferFn = "raw";
	this.inverse = false;

	// Create texture
	var gl = renderContext.gl;
	var tex = gl.createTexture();
	gl.bindTexture(gl.TEXTURE_2D, tex);
    // TODO : Flip around X axis
    //gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
	gl.texImage2D(
		gl.TEXTURE_2D, 0, 
		format, width, height, 0, 
		format, dataType, pixels);


	if ( dataType == gl.FLOAT )
	{	
		// Choose floating point texture filtering depending on extension support
		var float_linear_ext = gl.getExtension("OES_texture_float_linear");
		var float_filtering = float_linear_ext ? gl.LINEAR : gl.NEAREST;
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, float_filtering);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, float_filtering);
	}
	else
	{
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
	}

    // NPOT properties
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

	this.texture = tex;
	this.width = width;
	this.height = height;
	
	this.computeMinMax(pixels);
	renderContext.requestFrame();
}

/**************************************************************************************************************/

/**
 *	Compute min/max of fits data
 *
 *	@param pixels Fits data
 *	@param texture glTexture
 */
DynamicImage.prototype.computeMinMax = function(pixels)
{
	var max = Number.MIN_VALUE;
	var min = Number.MAX_VALUE;
	for ( var i=1; i<pixels.length; i++ )
	{
		var val = pixels[i];
		if ( isNaN(val) )
			continue;
		if ( max < val )
			max = val;
		if ( min > val )
			min = val;
	}
	this.min = min;
	this.max = max;
	this.tmax = max;
	this.tmin = min;
}

/**************************************************************************************************************/

/**
 *	Update colormap of current image
 *
 *	@param transferFn Transfer function("linear", "log", "sqrt", "pow2", "asin")
 *	@param colormap Colormap("grey", "rainbow", "fire", "stern", "eosb")
 *	@param inverse Boolean indicating if colormap is inversed
 */
DynamicImage.prototype.updateColormap = function(transferFn, colormap, inverse)
{
	var gl = this.renderContext.gl;
	if ( transferFn != "raw" )
	{
		this.fragmentCode = defaultFragmentCode;
		this.updateUniforms = defaultCallback;
		// Dispose current texture
		if ( this.colormapTex )
	    	gl.deleteTexture( this.colormapTex );

		this.colormapTex = ColorMap.generateColormap(gl, transferFn, colormap, inverse);
	}
	else
	{
		this.fragmentCode = null;
		this.updateUniforms = null;
	}
	this.transferFn = transferFn;
	this.inverse = inverse;
}

/**************************************************************************************************************/

/**
 *	Dispose textures
 */
DynamicImage.prototype.dispose = function()
{
	var gl = this.renderContext.gl;
	if ( this.colormapTex )
		gl.deleteTexture( this.colormapTex );
	if ( this.texture )
		gl.deleteTexture( this.texture );

	this.colormapTex = null;
	this.texture = null;
}

/**************************************************************************************************************/

return DynamicImage;

});
// Generated by CoffeeScript 1.4.0
(function() {
  var BinaryTable, CompressedImage, DataUnit, Decompress, FITS, File, HDU, Header, HeaderVerify, Image, ImageUtils, Module, Table, Tabular, moduleKeywords,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __slice = [].slice,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  if (this.astro == null) {
    this.astro = {};
  }

  FITS = {};

  FITS.version = '0.2.3';

  this.astro.FITS = FITS;

  moduleKeywords = ['included', 'extended'];

  Module = (function() {

    function Module() {}

    Module.include = function(obj) {
      var key, value, _ref;
      if (!obj) {
        throw 'include(obj) requires obj';
      }
      for (key in obj) {
        value = obj[key];
        if (__indexOf.call(moduleKeywords, key) < 0) {
          this.prototype[key] = value;
        }
      }
      if ((_ref = obj.included) != null) {
        _ref.apply(this);
      }
      return this;
    };

    Module.extend = function(obj) {
      var key, value, _ref;
      if (!obj) {
        throw 'extend(obj) requires obj';
      }
      for (key in obj) {
        value = obj[key];
        if (__indexOf.call(moduleKeywords, key) < 0) {
          this[key] = value;
        }
      }
      if ((_ref = obj.extended) != null) {
        _ref.apply(this);
      }
      return this;
    };

    Module.proxy = function(func) {
      var _this = this;
      return function() {
        return func.apply(_this, arguments);
      };
    };

    Module.prototype.proxy = function(func) {
      var _this = this;
      return function() {
        return func.apply(_this, arguments);
      };
    };

    return Module;

  })();

  this.astro.FITS.Module = Module;

  DataUnit = (function(_super) {

    __extends(DataUnit, _super);

    function DataUnit(view, header) {
      this.view = view;
      this.begin = this.current = view.tell();
      this.length = void 0;
    }

    return DataUnit;

  })(Module);

  this.astro.FITS.DataUnit = DataUnit;

  HeaderVerify = {
    verifyOrder: function(keyword, order) {
      if (order !== this.cardIndex) {
        return console.warn("" + keyword + " should appear at index " + this.cardIndex + " in the FITS header");
      }
    },
    verifyBetween: function(keyword, value, lower, upper) {
      if (!(value >= lower && value <= upper)) {
        throw "The " + keyword + " value of " + value + " is not between " + lower + " and " + upper;
      }
    },
    verifyBoolean: function(value) {
      if (value === "T") {
        return true;
      } else {
        return false;
      }
    },
    Functions: {
      SIMPLE: function() {
        var args, value;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        value = arguments[0];
        this.primary = true;
        this.verifyOrder("SIMPLE", 0);
        return this.verifyBoolean(value);
      },
      XTENSION: function() {
        var args, value;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        value = arguments[0];
        this.extension = true;
        this.extensionType = value;
        this.verifyOrder("XTENSION", 0);
        return value;
      },
      BITPIX: function() {
        var args, key, value;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        key = "BITPIX";
        value = parseInt(arguments[0]);
        this.verifyOrder(key, 1);
        if (value !== 8 && value !== 16 && value !== 32 && value !== 64 && value !== (-32) && value !== (-64)) {
          throw "" + key + " value " + value + " is not permitted";
        }
        return value;
      },
      NAXIS: function() {
        var args, array, key, required, value, _ref;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        key = "NAXIS";
        value = parseInt(arguments[0]);
        array = arguments[1];
        if (!array) {
          this.verifyOrder(key, 2);
          this.verifyBetween(key, value, 0, 999);
          if (this.isExtension()) {
            if ((_ref = this.extensionType) === "TABLE" || _ref === "BINTABLE") {
              required = 2;
              if (value !== required) {
                throw "" + key + " must be " + required + " for TABLE and BINTABLE extensions";
              }
            }
          }
        }
        return value;
      },
      PCOUNT: function() {
        var args, key, order, required, value, _ref;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        key = "PCOUNT";
        value = parseInt(arguments[0]);
        order = 1 + 1 + 1 + this["NAXIS"];
        this.verifyOrder(key, order);
        if (this.isExtension()) {
          if ((_ref = this.extensionType) === "IMAGE" || _ref === "TABLE") {
            required = 0;
            if (value !== required) {
              throw "" + key + " must be " + required + " for the " + this.extensionType + " extensions";
            }
          }
        }
        return value;
      },
      GCOUNT: function() {
        var args, key, order, required, value, _ref;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        key = "GCOUNT";
        value = parseInt(arguments[0]);
        order = 1 + 1 + 1 + this["NAXIS"] + 1;
        this.verifyOrder(key, order);
        if (this.isExtension()) {
          if ((_ref = this.extensionType) === "IMAGE" || _ref === "TABLE" || _ref === "BINTABLE") {
            required = 1;
            if (value !== required) {
              throw "" + key + " must be " + required + " for the " + this.extensionType + " extensions";
            }
          }
        }
        return value;
      },
      EXTEND: function() {
        var args, key, value;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        key = "EXTEND";
        value = arguments[0];
        if (!this.isPrimary()) {
          throw "" + key + " must only appear in the primary header";
        }
        return this.verifyBoolean(value);
      },
      BSCALE: function() {
        var args;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        return parseFloat(arguments[0]);
      },
      BZERO: function() {
        var args;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        return parseFloat(arguments[0]);
      },
      BLANK: function() {
        var args, key, value;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        key = "BLANK";
        value = arguments[0];
        // if (!(this["BITPIX"] > 0)) {
        //   throw "" + key + " is not to be used for BITPIX = " + this['BITPIX'];
        // }
        return parseInt(value);
      },
      DATAMIN: function() {
        var args;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        return parseFloat(arguments[0]);
      },
      DATAMAX: function() {
        var args;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        return parseFloat(arguments[0]);
      },
      EXTVER: function() {
        var args, key, value;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        key = "EXTVER";
        value = arguments[0];
        value = parseInt(value);
        return value;
      },
      EXTLEVEL: function() {
        var args, key, value;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        key = "EXTLEVEL";
        value = arguments[0];
        value = parseInt(value);
        return value;
      },
      TFIELDS: function() {
        var args, key, value;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        key = "TFIELDS";
        value = arguments[0];
        value = parseInt(value);
        this.verifyBetween(key, value, 0, 999);
        return value;
      },
      TBCOL: function() {
        var args, index, key, value;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        key = "TBCOL";
        value = arguments[0];
        index = arguments[2];
        this.verifyBetween(key, index, 0, this["TFIELDS"]);
        return value;
      },
      ZIMAGE: function() {
        var args, key, value;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        key = "ZIMAGE";
        value = arguments[0];
        return this.verifyBoolean(value);
      },
      ZCMPTYPE: function() {
        var args, key, value;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        key = "ZCMPTYPE";
        value = arguments[0];
        if (value !== 'GZIP_1' && value !== 'RICE_1' && value !== 'PLIO_1' && value !== 'HCOMPRESS_1') {
          throw "" + key + " value " + value + " is not permitted";
        }
        if (value !== 'RICE_1' && value !== 'GZIP_1') {
          throw "Compress type " + value + " is not yet implement";
        }
        return value;
      },
      ZBITPIX: function() {
        var args, key, value;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        key = "ZBITPIX";
        value = parseInt(arguments[0]);
        if (value !== 8 && value !== 16 && value !== 32 && value !== 64 && value !== (-32) && value !== (-64)) {
          throw "" + key + " value " + value + " is not permitted";
        }
        return value;
      },
      ZNAXIS: function() {
        var args, array, key, value;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        key = "ZNAXIS";
        value = parseInt(arguments[0]);
        array = arguments[1];
        value = value;
        if (!array) {
          this.verifyBetween(key, value, 0, 999);
        }
        return value;
      },
      ZTILE: function() {
        var args, key;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        key = "ZTILE";
        return parseInt(arguments[0]);
      },
      ZSIMPLE: function() {
        var args;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        if (arguments[0] === "T") {
          return true;
        } else {
          return false;
        }
      },
      ZPCOUNT: function() {
        var args, key;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        key = "ZPCOUNT";
        return parseInt(arguments[0]);
      },
      ZGCOUNT: function() {
        var args, key;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        key = "ZGCOUNT";
        return parseInt(arguments[0]);
      }
    }
  };

  this.astro.FITS.HeaderVerify = HeaderVerify;

  Header = (function(_super) {

    __extends(Header, _super);

    Header.keywordPattern = /^([A-Z0-9_-]+)\s*=\s*(.*)/;

    Header.nonStringPattern = /([^\/]*)\s*\/*(.*)/;

    Header.stringPattern = /'(.*)'\s*\/*(.*)/;

    Header.arrayPattern = /([A-Za-z]+)(\d+)/;

    Header.include(HeaderVerify);

    function Header() {
      this.init = __bind(this.init, this);

      var method, name, _ref;
      this.primary = false;
      this.extension = false;
      this.verifyCard = {};
      _ref = this.Functions;
      for (name in _ref) {
        method = _ref[name];
        this.verifyCard[name] = this.proxy(method);
      }
      this.cards = {};
      this.cardIndex = 0;
    }

    Header.prototype.get = function(key) {
      if (this.contains(key)) {
        return this.cards[key];
      } else {
        return console.warn("Header does not contain the key " + key);
      }
    };

    Header.prototype.getIndex = function(key) {
      if (this.contains(key)) {
        return this.cards[key][0];
      } else {
        return console.warn("Header does not contain the key " + key);
      }
    };

    Header.prototype.getComment = function(key) {
      if (this.contains(key)) {
        if (this.cards[key][2] != null) {
          return this.cards[key][2];
        } else {
          return console.warn("" + key + " does not contain a comment");
        }
      } else {
        return console.warn("Header does not contain the key " + key);
      }
    };

    Header.prototype.getComments = function() {
      if (this.contains('COMMENT')) {
        return this.cards['COMMENT'];
      } else {
        return console.warn("Header does not contain any COMMENT fields");
      }
    };

    Header.prototype.getHistory = function() {
      if (this.contains('HISTORY')) {
        return this.cards['HISTORY'];
      } else {
        return console.warn("Header does not contain any HISTORY fields");
      }
    };

    Header.prototype.set = function(key, value, comment) {
      this.cards[key] = comment ? [this.cardIndex, value, comment] : [this.cardIndex, value];
      return this.cardIndex += 1;
    };

    Header.prototype.setComment = function(comment) {
      if (!this.contains("COMMENT")) {
        this.cards["COMMENT"] = [];
        this.cardIndex += 1;
      }
      return this.cards["COMMENT"].push(comment);
    };

    Header.prototype.setHistory = function(history) {
      if (!this.contains("HISTORY")) {
        this.cards["HISTORY"] = [];
        this.cardIndex += 1;
      }
      return this.cards["HISTORY"].push(history);
    };

    Header.prototype.contains = function(keyword) {
      return this.cards.hasOwnProperty(keyword);
    };

    Header.prototype.readCard = function(line) {
      var array, comment, index, key, keyToVerify, match, value, _ref, _ref1, _ref2, _ref3, _ref4;
      match = line.match(Header.keywordPattern);
      if (match == null) {
        return;
      }
      _ref = match.slice(1), key = _ref[0], value = _ref[1];
      if (key === "COMMENT" || key === "HISTORY") {
        match[1] = value.trim();
      } else if (value[0] === "'") {
        match = value.match(Header.stringPattern);
        match[1] = match[1].trim();
      } else {
        match = value.match(Header.nonStringPattern);
        match[1] = (_ref1 = match[1][0]) === "T" || _ref1 === "F" ? match[1].trim() : parseFloat(match[1]);
      }
      match[2] = match[2].trim();
      _ref2 = match.slice(1), value = _ref2[0], comment = _ref2[1];
      keyToVerify = key;
      _ref3 = [false, void 0], array = _ref3[0], index = _ref3[1];
      match = key.match(Header.arrayPattern);
      if (match != null) {
        keyToVerify = match[1];
        _ref4 = [true, match[2]], array = _ref4[0], index = _ref4[1];
      }
      if (this.verifyCard.hasOwnProperty(keyToVerify)) {
        value = this.verifyCard[keyToVerify](value, array, index);
      }
      switch (key) {
        case "COMMENT":
          return this.setComment(value);
        case "HISTORY":
          return this.setHistory(value);
        default:
          this.set(key, value, comment);
          return this.__defineGetter__(key, function() {
            return this.cards[key][1];
          });
      }
    };

    Header.prototype.init = function(block) {
      var i, line, lineWidth, maxNumLines, numLines, _i, _ref, _results;
      lineWidth = 80;
      numLines = block.length / lineWidth;
      maxNumLines = 600;
      numLines = numLines < maxNumLines ? numLines : maxNumLines;
      _results = [];
      for (i = _i = 0, _ref = numLines - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        line = block.slice(i * lineWidth, (i + 1) * lineWidth);
        _results.push(this.readCard(line));
      }
      return _results;
    };

    Header.prototype.hasDataUnit = function() {
      if (this["NAXIS"] === 0) {
        return false;
      } else {
        return true;
      }
    };

    Header.prototype.isPrimary = function() {
      return this.primary;
    };

    Header.prototype.isExtension = function() {
      return this.extension;
    };

    return Header;

  })(Module);

  this.astro.FITS.Header = Header;

  ImageUtils = {
    initArray: function(arrayType) {
      return this.data = new arrayType(this.width * this.height);
    },
    getExtremes: function() {
      var index, max, min, value, _ref, _ref1;
      if ((this.min != null) && (this.max != null)) {
        return [this.min, this.max];
      }
      index = this.data.length;
      while (index--) {
        value = this.data[index];
        if (isNaN(value)) {
          continue;
        }
        _ref = [value, value], min = _ref[0], max = _ref[1];
        break;
      }
      while (index--) {
        value = this.data[index];
        if (isNaN(value)) {
          continue;
        }
        if (value < min) {
          min = value;
        }
        if (value > max) {
          max = value;
        }
      }
      _ref1 = [min, max], this.min = _ref1[0], this.max = _ref1[1];
      return [this.min, this.max];
    },
    getPixel: function(x, y) {
      return this.data[y * this.width + x];
    }
  };

  this.astro.FITS.ImageUtils = ImageUtils;

  Image = (function(_super) {

    __extends(Image, _super);

    Image.include(ImageUtils);

    function Image(view, header) {
      var bitpix, i, naxis, _i,
        _this = this;
      Image.__super__.constructor.apply(this, arguments);
      naxis = header["NAXIS"];
      bitpix = header["BITPIX"];
      this.naxis = [];
      for (i = _i = 1; 1 <= naxis ? _i <= naxis : _i >= naxis; i = 1 <= naxis ? ++_i : --_i) {
        this.naxis.push(header["NAXIS" + i]);
      }
      this.width = header["NAXIS1"];
      this.height = header["NAXIS2"] || 1;
      this.bzero = header["BZERO"] || 0;
      this.bscale = header["BSCALE"] || 1;
      this.rowByteSize = this.width * Math.abs(bitpix) / 8;
      this.totalRowsRead = 0;
      this.length = this.naxis.reduce(function(a, b) {
        return a * b;
      }) * Math.abs(bitpix) / 8;
      this.data = void 0;
      this.frame = 0;
      switch (bitpix) {
        case 8:
          if (this.bscale % 1 === 0) {
            this.arrayType = Uint8Array;
            this.accessor = function() {
              return _this.bzero + _this.bscale * _this.view.getUint8();
            };
          } else {
            this.arrayType = Float32Array;
            this.accessor = function() {
              return _this.bzero + _this.bscale * _this.view.getUint8();
            };
          }
          break;
        case 16:
          if (this.bscale % 1 === 0) {
            this.arrayType = Int16Array;
            this.accessor = function() {
              return _this.bzero + _this.bscale * _this.view.getInt16();
            };
          } else {
            this.arrayType = Float32Array;
            this.accessor = function() {
              return _this.bzero + _this.bscale * _this.view.getInt16();
            };
          }
          break;
        case 32:
          if (this.bscale % 1 === 0) {
            this.arrayType = Int32Array;
            this.accessor = function() {
              return _this.bzero + _this.bscale * _this.view.getUint32();
            };
          } else {
            this.arrayType = Float32Array;
            this.accessor = function() {
              return _this.bzero + _this.bscale * _this.view.getUint32();
            };
          }
          break;
        case 64:
          this.arrayType = this.bscale % 1 === 0 ? Int32Array : Float32Array;
          console.warn("Unusual behaviour with 64 bit integers.");
          this.accessor = function() {
            var factor, highByte, lowByte, mod, value;
            highByte = Math.abs(_this.view.getInt32());
            lowByte = Math.abs(_this.view.getInt32());
            mod = highByte % 10;
            factor = mod ? -1 : 1;
            highByte -= mod;
            value = factor * ((highByte << 32) | lowByte);
            return _this.bzero + _this.bscale * value;
          };
          break;
        case -32:
          this.arrayType = Float32Array;
          this.accessor = function() {
            return _this.bzero + _this.bscale * _this.view.getFloat32();
          };
          break;
        case -64:
          this.arrayType = Float64Array;
          this.accessor = function() {
            return _this.bzero + _this.bscale * _this.view.getFloat64();
          };
          break;
        default:
          throw "Invalid BITPIX.";
      }
    }

    Image.prototype.getRow = function() {
      var i, _i, _ref;
      this.current = this.begin + this.totalRowsRead * this.rowByteSize;
      this.view.seek(this.current);
      for (i = _i = 0, _ref = this.width - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        this.data[this.width * this.rowsRead + i] = this.accessor();
      }
      this.rowsRead += 1;
      return this.totalRowsRead += 1;
    };

    Image.prototype.getFrame = function(frame) {
      var height;
      this.frame = frame != null ? frame : this.frame;
      if (this.data == null) {
        this.initArray(this.arrayType);
      }
      this.totalRowsRead = this.width * this.frame;
      this.rowsRead = 0;
      height = this.height;
      while (height--) {
        this.getRow();
      }
      this.frame += 1;
      return this.data;
    };

    Image.prototype.seek = function(frame) {
      if (frame == null) {
        frame = 0;
      }
      if (this.naxis.length === 2) {
        this.totalRowsRead = 0;
        return this.frame = 0;
      } else {
        this.totalRowsRead = this.height * frame;
        return this.frame = this.height / this.totalRowsRead - 1;
      }
    };

    Image.prototype.isDataCube = function() {
      if (this.naxis.length > 2) {
        return true;
      } else {
        return false;
      }
    };

    return Image;

  })(DataUnit);

  this.astro.FITS.Image = Image;

  Tabular = (function(_super) {

    __extends(Tabular, _super);

    Tabular.dataAccessors = {
      L: function(view) {
        if (view.getInt8() === 84) {
          return true;
        } else {
          return false;
        }
      },
      X: function(view) {
        throw "Data type not yet implemented";
      },
      B: function(view) {
        return view.getUint8();
      },
      I: function(view) {
        return view.getInt16();
      },
      J: function(view) {
        return view.getInt32();
      },
      K: function(view) {
        var factor, highByte, lowByte, mod, value;
        highByte = Math.abs(view.getInt32());
        lowByte = Math.abs(view.getInt32());
        mod = highByte % 10;
        factor = mod ? -1 : 1;
        highByte -= mod;
        value = factor * ((highByte << 32) | lowByte);
        console.warn("Something funky happens here when dealing with 64 bit integers.  Be wary!!!");
        return value;
      },
      A: function(view) {
        return view.getChar();
      },
      E: function(view) {
        return view.getFloat32();
      },
      D: function(view) {
        return view.getFloat64();
      },
      C: function(view) {
        return [view.getFloat32(), view.getFloat32()];
      },
      M: function(view) {
        return [view.getFloat64(), view.getFloat64()];
      }
    };

    function Tabular(view, header) {
      this.getRow = __bind(this.getRow, this);
      Tabular.__super__.constructor.apply(this, arguments);
      this.rowByteSize = header["NAXIS1"];
      this.rows = header["NAXIS2"];
      this.cols = header["TFIELDS"];
      this.length = this.tableLength = this.rowByteSize * this.rows;
      this.rowsRead = 0;
      this.columns = this.getColumnNames(header);
      this.accessors = [];
    }

    Tabular.prototype.getRow = function(row) {
      var accessor, index, _i, _len, _ref;
      if (row == null) {
        row = null;
      }
      if (row != null) {
        this.rowsRead = row;
      }
      this.current = this.begin + this.rowsRead * this.rowByteSize;
      this.view.seek(this.current);
      row = {};
      _ref = this.accessors;
      for (index = _i = 0, _len = _ref.length; _i < _len; index = ++_i) {
        accessor = _ref[index];
        row[this.columns[index]] = accessor();
      }
      this.rowsRead += 1;
      return row;
    };

    Tabular.prototype.getColumnNames = function(header) {
      var columnNames, i, key, _i, _ref;
      columnNames = [];
      for (i = _i = 1, _ref = this.cols; 1 <= _ref ? _i <= _ref : _i >= _ref; i = 1 <= _ref ? ++_i : --_i) {
        key = "TTYPE" + i;
        if (!header.contains(key)) {
          return null;
        }
        columnNames.push(header[key]);
      }
      return columnNames;
    };

    return Tabular;

  })(DataUnit);

  this.astro.FITS.Tabular = Tabular;

  Table = (function(_super) {

    __extends(Table, _super);

    Table.formPattern = /([AIFED])(\d+)\.*(\d+)*/;

    Table.dataAccessors = {
      A: function(value) {
        return value.trim();
      },
      I: function(value) {
        return parseInt(value);
      },
      F: function(value) {
        return parseFloat(value);
      },
      E: function(value) {
        return parseFloat(value);
      },
      D: function(value) {
        return parseFloat(value);
      }
    };

    function Table(view, header) {
      this.getRow = __bind(this.getRow, this);

      var form, i, match, _fn, _i, _ref,
        _this = this;
      Table.__super__.constructor.apply(this, arguments);
      _fn = function() {
        var accessor, dataType, decimals, length, _ref1;
        _ref1 = match.slice(1), dataType = _ref1[0], length = _ref1[1], decimals = _ref1[2];
        accessor = function(value) {
          return Table.dataAccessors[dataType](value);
        };
        return _this.accessors.push(accessor);
      };
      for (i = _i = 1, _ref = this.cols; 1 <= _ref ? _i <= _ref : _i >= _ref; i = 1 <= _ref ? ++_i : --_i) {
        form = header["TFORM" + i];
        match = form.match(Table.formPattern);
        _fn();
      }
    }

    Table.prototype.getRow = function(row) {
      var i, index, line, value, _i, _j, _len, _ref;
      if (row == null) {
        row = null;
      }
      if (row != null) {
        this.rowsRead = row;
      }
      this.current = this.begin + this.rowsRead * this.rowByteSize;
      this.view.seek(this.current);
      line = "";
      for (i = _i = 1, _ref = this.rowByteSize; 1 <= _ref ? _i <= _ref : _i >= _ref; i = 1 <= _ref ? ++_i : --_i) {
        line += this.view.getChar();
      }
      line = line.trim().split(/\s+/);
      row = {};
      for (index = _j = 0, _len = line.length; _j < _len; index = ++_j) {
        value = line[index];
        row[this.columns[index]] = this.accessors[index](value);
      }
      this.rowsRead += 1;
      return row;
    };

    return Table;

  })(Tabular);

  this.astro.FITS.Table = Table;

  BinaryTable = (function(_super) {

    __extends(BinaryTable, _super);

    BinaryTable.dataTypePattern = /(\d*)([L|X|B|I|J|K|A|E|D|C|M])/;

    BinaryTable.arrayDescriptorPattern = /[0,1]*P([L|X|B|I|J|K|A|E|D|C|M])\((\d*)\)/;

    function BinaryTable(view, header) {
      var dataType, i, keyword, length, match, value, _i, _ref, _ref1,
        _this = this;
      BinaryTable.__super__.constructor.apply(this, arguments);
      for (i = _i = 1, _ref = this.cols; 1 <= _ref ? _i <= _ref : _i >= _ref; i = 1 <= _ref ? ++_i : --_i) {
        keyword = "TFORM" + i;
        value = header[keyword];
        match = value.match(BinaryTable.arrayDescriptorPattern);
        if (match != null) {
          (function() {
            var accessor, dataType;
            dataType = match[1];
            accessor = function() {
              var data, length, offset, _j;
              length = _this.view.getInt32();
              offset = _this.view.getInt32();
              _this.current = _this.view.tell();
              _this.view.seek(_this.begin + _this.tableLength + offset);
              data = [];
              for (i = _j = 1; 1 <= length ? _j <= length : _j >= length; i = 1 <= length ? ++_j : --_j) {
                data.push(BinaryTable.dataAccessors[dataType](_this.view));
              }
              _this.view.seek(_this.current);
              return data;
            };
            return _this.accessors.push(accessor);
          })();
        } else {
          match = value.match(BinaryTable.dataTypePattern);
          _ref1 = match.slice(1), length = _ref1[0], dataType = _ref1[1];
          length = length ? parseInt(length) : 0;
          if (length === 0 || length === 1) {
            (function(dataType) {
              var accessor;
              accessor = function() {
                var data;
                data = BinaryTable.dataAccessors[dataType](_this.view);
                return data;
              };
              return _this.accessors.push(accessor);
            })(dataType);
          } else {
            (function(dataType, length) {
              var accessor, numBytes;
              if (dataType === 'X') {
                numBytes = Math.log(length) / Math.log(2);
                accessor = function() {
                  var bit, bitarray, byte, byte2bits, data, _j, _k, _len;
                  byte2bits = function(byte) {
                    var bitarray;
                    bitarray = [];
                    i = 128;
                    while (i >= 1) {
                      bitarray.push((byte & i ? 1 : 0));
                      i /= 2;
                    }
                    return bitarray;
                  };
                  data = [];
                  for (i = _j = 1; 1 <= numBytes ? _j <= numBytes : _j >= numBytes; i = 1 <= numBytes ? ++_j : --_j) {
                    byte = _this.view.getUint8();
                    bitarray = byte2bits(byte);
                    for (_k = 0, _len = bitarray.length; _k < _len; _k++) {
                      bit = bitarray[_k];
                      data.push(bit);
                    }
                  }
                  return data.slice(0, +(length - 1) + 1 || 9e9);
                };
              } else if (dataType === 'A') {
                accessor = function() {
                  var data, _j;
                  data = '';
                  for (i = _j = 1; 1 <= length ? _j <= length : _j >= length; i = 1 <= length ? ++_j : --_j) {
                    data += BinaryTable.dataAccessors[dataType](_this.view);
                  }
                  return data.trim();
                };
              } else {
                accessor = function() {
                  var data, _j;
                  data = [];
                  for (i = _j = 1; 1 <= length ? _j <= length : _j >= length; i = 1 <= length ? ++_j : --_j) {
                    data.push(BinaryTable.dataAccessors[dataType](_this.view));
                  }
                  return data;
                };
              }
              return _this.accessors.push(accessor);
            })(dataType, length);
          }
        }
      }
    }

    return BinaryTable;

  })(Tabular);

  this.astro.FITS.BinaryTable = BinaryTable;

  Decompress = {
    Rice: function(array, arrayLen, blocksize, bytepix, pixels, nx) {
      var b, bbits, diff, fs, fsbits, fsmax, i, imax, k, lastpix, nbits, nonzeroCount, nzero, pointer, _ref, _ref1;
      bbits = 1 << fsbits;
      _ref = this.RiceSetup[bytepix](array), fsbits = _ref[0], fsmax = _ref[1], lastpix = _ref[2], pointer = _ref[3];
      nonzeroCount = new Uint8Array(256);
      nzero = 8;
      _ref1 = [128, 255], k = _ref1[0], i = _ref1[1];
      while (i >= 0) {
        while (i >= k) {
          nonzeroCount[i] = nzero;
          i -= 1;
        }
        k = k / 2;
        nzero -= 1;
      }
      nonzeroCount[0] = 0;
      b = array[pointer];
      pointer += 1;
      nbits = 8;
      i = 0;
      while (i < nx) {
        nbits -= fsbits;
        while (nbits < 0) {
          b = (b << 8) | array[pointer];
          pointer += 1;
          nbits += 8;
        }
        fs = (b >> nbits) - 1;
        b &= (1 << nbits) - 1;
        imax = i + blocksize;
        if (imax > nx) {
          imax = nx;
        }
        if (fs < 0) {
          while (i < imax) {
            array[i] = lastpix;
            i++;
          }
        } else if (fs === fsmax) {
          while (i < imax) {
            k = bbits - nbits;
            diff = b << k;
            k -= 8;
            while (k >= 0) {
              b = array[pointer];
              pointer += 1;
              diff |= b << k;
              k -= 8;
            }
            if (nbits > 0) {
              b = array[pointer];
              pointer += 1;
              diff |= b >> (-k);
              b &= (1 << nbits) - 1;
            } else {
              b = 0;
            }
            if ((diff & 1) === 0) {
              diff = diff >> 1;
            } else {
              diff = ~(diff >> 1);
            }
            array[i] = diff + lastpix;
            lastpix = array[i];
            i++;
          }
        } else {
          while (i < imax) {
            while (b === 0) {
              nbits += 8;
              b = array[pointer];
              pointer += 1;
            }
            nzero = nbits - nonzeroCount[b];
            nbits -= nzero + 1;
            b ^= 1 << nbits;
            nbits -= fs;
            while (nbits < 0) {
              b = (b << 8) | array[pointer];
              pointer += 1;
              nbits += 8;
            }
            diff = (nzero << fs) | (b >> nbits);
            b &= (1 << nbits) - 1;
            if ((diff & 1) === 0) {
              diff = diff >> 1;
            } else {
              diff = ~(diff >> 1);
            }
            pixels[i] = diff + lastpix;
            lastpix = pixels[i];
            i++;
          }
        }
      }
      return pixels;
    },
    RiceSetup: {
      1: function(array) {
        var fsbits, fsmax, lastpix, pointer;
        pointer = 0;
        fsbits = 3;
        fsmax = 6;
        lastpix = array[pointer];
        pointer += 1;
        return [fsbits, fsmax, lastpix, pointer];
      },
      2: function(array) {
        var bytevalue, fsbits, fsmax, lastpix, pointer;
        pointer = 0;
        fsbits = 4;
        fsmax = 14;
        lastpix = 0;
        bytevalue = array[pointer];
        pointer += 1;
        lastpix = lastpix | (bytevalue << 8);
        bytevalue = array[pointer];
        pointer += 1;
        lastpix = lastpix | bytevalue;
        return [fsbits, fsmax, lastpix, pointer];
      },
      4: function(array) {
        var bytevalue, fsbits, fsmax, lastpix, pointer;
        pointer = 0;
        fsbits = 5;
        fsmax = 25;
        lastpix = 0;
        bytevalue = array[pointer];
        pointer += 1;
        lastpix = lastpix | (bytevalue << 24);
        bytevalue = array[pointer];
        pointer += 1;
        lastpix = lastpix | (bytevalue << 16);
        bytevalue = array[pointer];
        pointer += 1;
        lastpix = lastpix | (bytevalue << 8);
        bytevalue = array[pointer];
        pointer += 1;
        lastpix = lastpix | bytevalue;
        return [fsbits, fsmax, lastpix, pointer];
      }
    },
    gzip: function(array) {
      throw "Not yet implemented";
    },
    plio: function(array, length) {
      throw "Not yet implemented";
    },
    hcompress: function(array, length) {
      throw "Not yet implemented";
    }
  };

  this.astro.FITS.Decompress = Decompress;

  CompressedImage = (function(_super) {

    __extends(CompressedImage, _super);

    CompressedImage.dataTypePattern = /(\d*)([L|X|B|I|J|K|A|E|D|C|M])/;

    CompressedImage.arrayDescriptorPattern = /[0,1]*P([L|X|B|I|J|K|A|E|D|C|M])\((\d*)\)/;

    CompressedImage.include(ImageUtils);

    CompressedImage.extend(Decompress);

    CompressedImage.typedArray = {
      B: Uint8Array,
      I: Int16Array,
      J: Int32Array,
      E: Float32Array,
      D: Float64Array,
      1: Uint8Array,
      2: Uint8Array,
      4: Int16Array,
      8: Int32Array
    };

    function CompressedImage(view, header) {
      var i, key, value, ztile, _i, _ref;
      CompressedImage.__super__.constructor.apply(this, arguments);
      this.length += header["PCOUNT"];
      this.zcmptype = header["ZCMPTYPE"];
      this.zbitpix = header["ZBITPIX"];
      this.znaxis = header["ZNAXIS"];
      this.zblank = CompressedImage.setValue(header, "ZBLANK", void 0);
      this.blank = CompressedImage.setValue(header, "BLANK", void 0);
      this.ztile = [];
      for (i = _i = 1, _ref = this.znaxis; 1 <= _ref ? _i <= _ref : _i >= _ref; i = 1 <= _ref ? ++_i : --_i) {
        ztile = header.contains("ZTILE" + i) ? header["ZTILE" + i] : i === 1 ? header["ZNAXIS1"] : 1;
        this.ztile.push(ztile);
      }
      this.width = header["ZNAXIS1"];
      this.height = header["ZNAXIS2"] || 1;
      this.algorithmParameters = {};
      i = 1;
      while (true) {
        key = "ZNAME" + i;
        if (!header.contains(key)) {
          break;
        }
        value = "ZVAL" + i;
        this.algorithmParameters[header[key]] = header[value];
        i += 1;
      }
      if (this.zcmptype === 'RICE_1') {
        this.setRiceDefaults();
      }
      this.zmaskcmp = CompressedImage.setValue(header, "ZMASKCMP", void 0);
      this.zquantiz = CompressedImage.setValue(header, "ZQUANTIZ", "LINEAR_SCALING");
      this.bzero = CompressedImage.setValue(header, "BZERO", 0);
      this.bscale = CompressedImage.setValue(header, "BSCALE", 1);
      this.defineColumnAccessors(header);
      this.defineGetRow();
    }

    CompressedImage.prototype.defineColumnAccessors = function(header) {
      var accessor, dataType, i, length, match, ttype, value, _i, _ref, _ref1, _results,
        _this = this;
      this.columnNames = {};
      _results = [];
      for (i = _i = 1, _ref = this.cols; 1 <= _ref ? _i <= _ref : _i >= _ref; i = 1 <= _ref ? ++_i : --_i) {
        value = header["TFORM" + i];
        match = value.match(CompressedImage.arrayDescriptorPattern);
        ttype = header["TTYPE" + i].toUpperCase();
        this.columnNames[ttype] = i - 1;
        accessor = null;
        if (match != null) {
          dataType = match[1];
          switch (ttype) {
            case "COMPRESSED_DATA":
              (function(dataType) {
                return accessor = function() {
                  var data, pixels;
                  data = _this._accessor(dataType);
                  if (data == null) {
                    return new Float32Array(_this.ztile[0]);
                  }
                  pixels = new CompressedImage.typedArray[_this.algorithmParameters["BYTEPIX"]](_this.ztile[0]);
                  CompressedImage.Rice(data, length, _this.algorithmParameters["BLOCKSIZE"], _this.algorithmParameters["BYTEPIX"], pixels, _this.ztile[0]);
                  return pixels;
                };
              })(dataType);
              break;
            case "UNCOMPRESSED_DATA":
              (function(dataType) {
                return accessor = _this._accessor(dataType);
              })(dataType);
              break;
            case "GZIP_COMPRESSED_DATA":
              (function(dataType) {
                return accessor = function() {
                  var data, index, item, _j, _len;
                  data = _this._accessor(dataType);
                  if (data != null) {
                    data = new Float32Array(_this.width);
                    for (index = _j = 0, _len = data.length; _j < _len; index = ++_j) {
                      item = data[index];
                      data[index] = NaN;
                    }
                    return data;
                  } else {
                    return null;
                  }
                };
              })(dataType);
              break;
            default:
              (function(dataType) {
                return accessor = _this._accessor(dataType);
              })(dataType);
          }
        } else {
          match = value.match(CompressedImage.dataTypePattern);
          _ref1 = match.slice(1), length = _ref1[0], dataType = _ref1[1];
          length = length != null ? parseInt(length) : 0;
          if (length === 0 || length === 1) {
            (function(dataType) {
              return accessor = function() {
                return CompressedImage.dataAccessors[dataType](_this.view);
              };
            })(dataType);
          } else {
            (function(length, dataType) {
              return accessor = function() {
                var data, _j, _ref2;
                data = new CompressedImage.typedArray[dataType](length);
                for (i = _j = 0, _ref2 = length - 1; 0 <= _ref2 ? _j <= _ref2 : _j >= _ref2; i = 0 <= _ref2 ? ++_j : --_j) {
                  data[i] = CompressedImage.dataAccessors[dataType](_this.view);
                }
                return data;
              };
            })(length, dataType);
          }
        }
        _results.push(this.accessors.push(accessor));
      }
      return _results;
    };

    CompressedImage.prototype.defineGetRow = function() {
      var hasBlanks;
      this.totalRowsRead = 0;
      hasBlanks = (this.zblank != null) || (this.blank != null) || this.columnNames.hasOwnProperty("ZBLANK");
      return this.getRow = hasBlanks ? this.getRowHasBlanks : this.getRowNoBlanks;
    };

    CompressedImage.prototype.setRiceDefaults = function() {
      if (!this.algorithmParameters.hasOwnProperty("BLOCKSIZE")) {
        this.algorithmParameters["BLOCKSIZE"] = 32;
      }
      if (!this.algorithmParameters.hasOwnProperty("BYTEPIX")) {
        return this.algorithmParameters["BYTEPIX"] = 4;
      }
    };

    CompressedImage.setValue = function(header, key, defaultValue) {
      if (header.contains(key)) {
        return header[key];
      } else {
        return defaultValue;
      }
    };

    CompressedImage.prototype.getRowHasBlanks = function() {
      var blank, data, index, location, scale, value, zero, _i, _len, _ref;
      _ref = this._getRow(), data = _ref[0], blank = _ref[1], scale = _ref[2], zero = _ref[3];
      for (index = _i = 0, _len = data.length; _i < _len; index = ++_i) {
        value = data[index];
        location = this.totalRowsRead * this.width + index;
        this.data[location] = value === blank ? NaN : zero + scale * value;
      }
      this.rowsRead += 1;
      return this.totalRowsRead += 1;
    };

    CompressedImage.prototype.getRowNoBlanks = function() {
      var blank, data, index, location, scale, value, zero, _i, _len, _ref;
      _ref = this._getRow(), data = _ref[0], blank = _ref[1], scale = _ref[2], zero = _ref[3];
      for (index = _i = 0, _len = data.length; _i < _len; index = ++_i) {
        value = data[index];
        location = this.totalRowsRead * this.width + index;
        this.data[location] = zero + scale * value;
      }
      this.rowsRead += 1;
      return this.totalRowsRead += 1;
    };

    CompressedImage.prototype.getFrame = function() {
      var height;
      if (this.data == null) {
        this.initArray(Float32Array);
      }
      this.totalRowsRead = 0;
      this.rowsRead = 0;
      height = this.height;
      while (height--) {
        this.getRow();
      }
      return this.data;
    };

    CompressedImage.prototype._accessor = function(dataType) {
      var data, i, length, offset, _i, _ref, _ref1;
      _ref = [this.view.getInt32(), this.view.getInt32()], length = _ref[0], offset = _ref[1];
      if (length === 0) {
        return null;
      }
      data = new CompressedImage.typedArray[dataType](length);
      this.current = this.view.tell();
      this.view.seek(this.begin + this.tableLength + offset);
      for (i = _i = 0, _ref1 = length - 1; 0 <= _ref1 ? _i <= _ref1 : _i >= _ref1; i = 0 <= _ref1 ? ++_i : --_i) {
        data[i] = CompressedImage.dataAccessors[dataType](this.view);
      }
      this.view.seek(this.current);
      return data;
    };

    CompressedImage.prototype._getRow = function() {
      var accessor, blank, data, row, scale, zero, _i, _len, _ref;
      this.current = this.begin + this.totalRowsRead * this.rowByteSize;
      this.view.seek(this.current);
      row = [];
      _ref = this.accessors;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        accessor = _ref[_i];
        row.push(accessor());
      }
      data = row[this.columnNames["COMPRESSED_DATA"]] || row[this.columnNames["UNCOMPRESSED_DATA"]] || row[this.columnNames["GZIP_COMPRESSED_DATA"]];
      blank = row[this.columnNames["ZBLANK"]] || this.zblank;
      scale = row[this.columnNames["ZSCALE"]] || this.bscale;
      zero = row[this.columnNames["ZZERO"]] || this.bzero;
      return [data, blank, scale, zero];
    };

    CompressedImage.subtractiveDither1 = function() {
      throw "Not yet implemented";
    };

    CompressedImage.linearScaling = function() {
      throw "Not yet implemented";
    };

    return CompressedImage;

  })(Tabular);

  this.astro.FITS.CompressedImage = CompressedImage;

  HDU = (function() {

    function HDU(header, data) {
      this.header = header;
      this.data = data;
    }

    HDU.prototype.hasData = function() {
      if (this.data != null) {
        return true;
      } else {
        return false;
      }
    };

    HDU.prototype.getCard = function(key) {
      return this.header[key];
    };

    return HDU;

  })();

  this.astro.FITS.HDU = HDU;

  File = (function() {

    File.LINEWIDTH = 80;

    File.BLOCKLENGTH = 2880;

    File.getType = function(obj) {
      return Object.prototype.toString.call(obj).slice(8, -1).toLowerCase();
    };

    function File(buffer) {
      var name;
      name = File.getType(buffer);
      switch (name) {
        case 'arraybuffer':
          this.initFromBuffer(buffer);
          break;
        case 'object':
          this.initFromObject(buffer);
          break;
        default:
          throw 'fitsjs cannot initialize object';
      }
    }

    File.excessBytes = function(length) {
      return (File.BLOCKLENGTH - (length % File.BLOCKLENGTH)) % File.BLOCKLENGTH;
    };

    File.extendDataView = function(view) {
      var getFloat32, getFloat64, getInt16, getInt32, getInt8, getUint16, getUint32, getUint8;
      DataView.prototype.getString = function(length) {
        var c, i, value, _i, _ref;
        value = '';
        for (i = _i = 0, _ref = length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
          c = this.getUint8();
          value += String.fromCharCode(c > 127 ? 65533 : c);
        }
        return value;
      };
      DataView.prototype.getChar = function() {
        return this.getString(1);
      };
      view.offset = 0;
      getInt8 = view.getInt8;
      getUint8 = view.getUint8;
      getInt16 = view.getInt16;
      getUint16 = view.getUint16;
      getInt32 = view.getInt32;
      getUint32 = view.getUint32;
      getFloat32 = view.getFloat32;
      getFloat64 = view.getFloat64;
      view.getInt8 = function() {
        var value;
        value = getInt8.apply(this, [this.offset]);
        this.offset += 1;
        return value;
      };
      view.getUint8 = function() {
        var value;
        value = getUint8.apply(this, [this.offset]);
        this.offset += 1;
        return value;
      };
      view.getInt16 = function() {
        var value;
        value = getInt16.apply(this, [this.offset, false]);
        this.offset += 2;
        return value;
      };
      view.getUint16 = function() {
        var value;
        value = getUint16.apply(this, [this.offset, false]);
        this.offset += 2;
        return value;
      };
      view.getInt32 = function() {
        var value;
        value = getInt32.apply(this, [this.offset, false]);
        this.offset += 4;
        return value;
      };
      view.getUint32 = function() {
        var value;
        value = getUint32.apply(this, [this.offset, false]);
        this.offset += 4;
        return value;
      };
      view.getFloat32 = function() {
        var value;
        value = getFloat32.apply(this, [this.offset, false]);
        this.offset += 4;
        return value;
      };
      view.getFloat64 = function() {
        var value;
        value = getFloat64.apply(this, [this.offset, false]);
        this.offset += 8;
        return value;
      };
      view.seek = function(offset) {
        return this.offset = offset;
      };
      return view.tell = function() {
        return this.offset;
      };
    };

    File.prototype.initFromBuffer = function(buffer) {
      var data, hdu, header, _results;
      this.length = buffer.byteLength;
      this.view = new DataView(buffer);
      this.hdus = [];
      this.eof = false;
      File.extendDataView(this.view);
      _results = [];
      while (true) {
        header = this.readHeader();
        data = this.readData(header);
        hdu = new HDU(header, data);
        this.hdus.push(hdu);
        if (this.eof) {
          break;
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    File.prototype.initFromObject = function(buffer) {
      this.length = buffer.length;
      this.view = null;
      this.hdus = buffer.hdus;
      return this.eof = true;
    };

    File.prototype.readHeader = function() {
      var beginOffset, block, done, end, endOffset, endPattern, header, i, line, match, start, whitespacePattern;
      whitespacePattern = /\s{80}/;
      endPattern = /^END\s/;
      beginOffset = this.view.tell();
      done = false;
      while (true) {
        if (done) {
          break;
        }
        block = this.view.getString(File.BLOCKLENGTH);
        i = 0;
        while (true) {
          start = File.BLOCKLENGTH - File.LINEWIDTH * (i + 1);
          end = File.BLOCKLENGTH - File.LINEWIDTH * i;
          line = block.slice(start, end);
          match = line.match(whitespacePattern);
          if (match) {
            i += 1;
            continue;
          }
          match = line.match(endPattern);
          if (match) {
            endOffset = this.view.tell();
            this.view.seek(beginOffset);
            block = this.view.getString(endOffset - beginOffset);
            header = new Header();
            header.init(block);
            done = true;
            this.checkEOF();
            return header;
          }
          break;
        }
      }
    };

    File.prototype.readData = function(header) {
      var data, excess;
      if (!header.hasDataUnit()) {
        return;
      }
      if (header.isPrimary()) {
        data = new Image(this.view, header);
      } else if (header.isExtension()) {
        if (header.extensionType === "BINTABLE") {
          if (header.contains("ZIMAGE")) {
            data = new CompressedImage(this.view, header);
          } else {
            data = new BinaryTable(this.view, header);
          }
        } else if (header.extensionType === "TABLE") {
          data = new Table(this.view, header);
        } else if (header.extensionType === "IMAGE") {
          data = new Image(this.view, header);
        }
      }
      excess = File.excessBytes(data.length);
      this.view.seek(this.view.tell() + data.length + excess);
      this.checkEOF();
      return data;
    };

    File.prototype.checkEOF = function() {
      if (this.view.offset >= this.length) {
        return this.eof = true;
      }
    };

    File.prototype.count = function() {
      return this.hdus.length;
    };

    File.prototype.getHDU = function(index) {
      var hdu, _i, _len, _ref;
      if (index == null) {
        index = void 0;
      }
      if ((index != null) && (this.hdus[index] != null)) {
        return this.hdus[index];
      }
      _ref = this.hdus;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        hdu = _ref[_i];
        if (hdu.hasData()) {
          return hdu;
        }
      }
    };

    File.prototype.getHeader = function(index) {
      if (index == null) {
        index = void 0;
      }
      return this.getHDU(index).header;
    };

    File.prototype.getDataUnit = function(index) {
      if (index == null) {
        index = void 0;
      }
      return this.getHDU(index).data;
    };

    File.prototype.getData = function(index) {
      if (index == null) {
        index = void 0;
      }
      return this.getHDU(index).data.getFrame();
    };

    return File;

  })();

  this.astro.FITS.File = File;

}).call(this);

define("fits", function(){});

/******************************************************************************* 
* Copyright 2012, 2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES 
* 
* This file is part of SITools2. 
* 
* SITools2 is free software: you can redistribute it and/or modify 
* it under the terms of the GNU General Public License as published by 
* the Free Software Foundation, either version 3 of the License, or 
* (at your option) any later version. 
* 
* SITools2 is distributed in the hope that it will be useful, 
* but WITHOUT ANY WARRANTY; without even the implied warranty of 
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
* GNU General Public License for more details. 
* 
* You should have received a copy of the GNU General Public License 
* along with SITools2. If not, see <http://www.gnu.org/licenses/>. 
******************************************************************************/ 

 define('FitsLoader', ["fits"], function() {

/**
 *	Parse fits file
 *
 *	@param response XHR response containing fits
 *
 *	@return Parsed data
 */
function parseFits(response)
{
	var FITS = astro.FITS;
    // Initialize the FITS.File object using
    // the array buffer returned from the XHR
    var fits = new FITS.File(response);
    // Grab the first HDU with a data unit
    var hdu = fits.getHDU();
    var data = hdu.data;

    var uintPixels;
    var swapPixels = new Uint8Array( data.view.buffer, data.begin, data.length ); // with gl.UNSIGNED_byte

    var bpe = data.arrayType.BYTES_PER_ELEMENT;
    for ( var i=0; i<swapPixels.length; i+=bpe )
    {
    	var temp;
    	// Swap to little-endian
    	for ( var j=0; j<bpe/2; j++ )
    	{
	        temp = swapPixels[i+j];
	        swapPixels[i+j] = swapPixels[i+bpe-1-j];
	        swapPixels[i+bpe-1-j] = temp;
    	}
    }
    
    return fits;
}

var loadFits = function(url, successCallback, failCallback, onprogressCallback)
{
	var xhr = new XMLHttpRequest();
	xhr.onreadystatechange = function(e)
	{
		if ( xhr.readyState == 4 )
		{
			if ( xhr.status == 200 )
			{
				if ( xhr.response )
				{
					var fits = parseFits(xhr.response);
					if (successCallback)
					{
						successCallback( fits );
					}
				}
			}
			else
			{
				console.log( "Error while loading " + url );
				if ( failCallback )
				{
					failCallback();
				}
			}
		}
	};

	xhr.onprogress = onprogressCallback;
	
	xhr.open("GET", url);
	xhr.responseType = 'arraybuffer';
	xhr.send();
	return xhr;
}

return {
	loadFits: loadFits,
	parseFits: parseFits
};

});
void function(global, callback) {
	if (typeof module === 'object') {
		module.exports = callback();
	} else if (typeof define === 'function') {
		define('crc32',callback);
	} else {
		global.crc32 = callback();
	}
}(this, function() {
	

	var table = [],
		poly = 0xEDB88320; // reverse polynomial

	// build the table
	function makeTable() {
		var c, n, k;

		for (n = 0; n < 256; n += 1) {
			c = n;
			for (k = 0; k < 8; k += 1) {
				if (c & 1) {
					c = poly ^ (c >>> 1);
				} else {
					c = c >>> 1;
				}
			}
			table[n] = c >>> 0;
		}
	}

	function strToArr(str) {
		// sweet hack to turn string into a 'byte' array
		return Array.prototype.map.call(str, function (c) {
			return c.charCodeAt(0);
		});
	}

	/*
	 * Compute CRC of array directly.
	 *
	 * This is slower for repeated calls, so append mode is not supported.
	 */
	function crcDirect(arr) {
		var crc = -1, // initial contents of LFBSR
			i, j, l, temp;

		for (i = 0, l = arr.length; i < l; i += 1) {
			temp = (crc ^ arr[i]) & 0xff;

			// read 8 bits one at a time
			for (j = 0; j < 8; j += 1) {
				if ((temp & 1) === 1) {
					temp = (temp >>> 1) ^ poly;
				} else {
					temp = (temp >>> 1);
				}
			}
			crc = (crc >>> 8) ^ temp;
		}

		// flip bits
		return crc ^ -1;
	}

	/*
	 * Compute CRC with the help of a pre-calculated table.
	 *
	 * This supports append mode, if the second parameter is set.
	 */
	function crcTable(arr, append) {
		var crc, i, l;

		// if we're in append mode, don't reset crc
		// if arr is null or undefined, reset table and return
		if (typeof crcTable.crc === 'undefined' || !append || !arr) {
			crcTable.crc = 0 ^ -1;

			if (!arr) {
				return;
			}
		}

		// store in temp variable for minor speed gain
		crc = crcTable.crc;

		for (i = 0, l = arr.length; i < l; i += 1) {
			crc = (crc >>> 8) ^ table[(crc ^ arr[i]) & 0xff];
		}

		crcTable.crc = crc;

		return crc ^ -1;
	}

	// build the table
	// this isn't that costly, and most uses will be for table assisted mode
	makeTable();

	var exports = function (val, direct) {
		var val = (typeof val === 'string') ? strToArr(val) : val,
			ret = direct ? crcDirect(val) : crcTable(val);

		// convert to 2's complement hex
		return (ret >>> 0).toString(16);
	};
	exports.direct = crcDirect;
	exports.table = crcTable;

	return exports;
});
/*
 * $Id: rawinflate.js,v 0.2 2009/03/01 18:32:24 dankogai Exp $
 *
 * original:
 * http://www.onicos.com/staff/iz/amuse/javascript/expert/inflate.txt
 */

/* Copyright (C) 1999 Masanao Izumo <iz@onicos.co.jp>
 * Version: 1.0.0.1
 * LastModified: Dec 25 1999
 */

/* Interface:
 * data = inflate(src);
 */

define('inflate-js',[],function(){

	/* constant parameters */
	var WSIZE = 32768, // Sliding Window size
		STORED_BLOCK = 0,
		STATIC_TREES = 1,
		DYN_TREES = 2,

	/* for inflate */
		lbits = 9, // bits in base literal/length lookup table
		dbits = 6, // bits in base distance lookup table

	/* variables (inflate) */
		slide,
		wp, // current position in slide
		fixed_tl = null, // inflate static
		fixed_td, // inflate static
		fixed_bl, // inflate static
		fixed_bd, // inflate static
		bit_buf, // bit buffer
		bit_len, // bits in bit buffer
		method,
		eof,
		copy_leng,
		copy_dist,
		tl, // literal length decoder table
		td, // literal distance decoder table
		bl, // number of bits decoded by tl
		bd, // number of bits decoded by td

		inflate_data,
		inflate_pos,


/* constant tables (inflate) */
		MASK_BITS = [
			0x0000,
			0x0001, 0x0003, 0x0007, 0x000f, 0x001f, 0x003f, 0x007f, 0x00ff,
			0x01ff, 0x03ff, 0x07ff, 0x0fff, 0x1fff, 0x3fff, 0x7fff, 0xffff
		],
		// Tables for deflate from PKZIP's appnote.txt.
		// Copy lengths for literal codes 257..285
		cplens = [
			3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
			35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0
		],
/* note: see note #13 above about the 258 in this list. */
		// Extra bits for literal codes 257..285
		cplext = [
			0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2,
			3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 99, 99 // 99==invalid
		],
		// Copy offsets for distance codes 0..29
		cpdist = [
			1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
			257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
			8193, 12289, 16385, 24577
		],
		// Extra bits for distance codes
		cpdext = [
			0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6,
			7, 7, 8, 8, 9, 9, 10, 10, 11, 11,
			12, 12, 13, 13
		],
		// Order of the bit length code lengths
		border = [
			16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15
		];
	/* objects (inflate) */

	function HuftList() {
		this.next = null;
		this.list = null;
	}

	function HuftNode() {
		this.e = 0; // number of extra bits or operation
		this.b = 0; // number of bits in this code or subcode

		// union
		this.n = 0; // literal, length base, or distance base
		this.t = null; // (HuftNode) pointer to next level of table
	}

	/*
	 * @param b-  code lengths in bits (all assumed <= BMAX)
	 * @param n- number of codes (assumed <= N_MAX)
	 * @param s- number of simple-valued codes (0..s-1)
	 * @param d- list of base values for non-simple codes
	 * @param e- list of extra bits for non-simple codes
	 * @param mm- maximum lookup bits
	 */
	function HuftBuild(b, n, s, d, e, mm) {
		this.BMAX = 16; // maximum bit length of any code
		this.N_MAX = 288; // maximum number of codes in any set
		this.status = 0; // 0: success, 1: incomplete table, 2: bad input
		this.root = null; // (HuftList) starting table
		this.m = 0; // maximum lookup bits, returns actual

	/* Given a list of code lengths and a maximum table size, make a set of
	   tables to decode that set of codes. Return zero on success, one if
	   the given code set is incomplete (the tables are still built in this
	   case), two if the input is invalid (all zero length codes or an
	   oversubscribed set of lengths), and three if not enough memory.
	   The code with value 256 is special, and the tables are constructed
	   so that no bits beyond that code are fetched when that code is
	   decoded. */
		var a; // counter for codes of length k
		var c = [];
		var el; // length of EOB code (value 256)
		var f; // i repeats in table every f entries
		var g; // maximum code length
		var h; // table level
		var i; // counter, current code
		var j; // counter
		var k; // number of bits in current code
		var lx = [];
		var p; // pointer into c[], b[], or v[]
		var pidx; // index of p
		var q; // (HuftNode) points to current table
		var r = new HuftNode(); // table entry for structure assignment
		var u = [];
		var v = [];
		var w;
		var x = [];
		var xp; // pointer into x or c
		var y; // number of dummy codes added
		var z; // number of entries in current table
		var o;
		var tail; // (HuftList)

		tail = this.root = null;

		// bit length count table
		for (i = 0; i < this.BMAX + 1; i++) {
			c[i] = 0;
		}
		// stack of bits per table
		for (i = 0; i < this.BMAX + 1; i++) {
			lx[i] = 0;
		}
		// HuftNode[BMAX][]  table stack
		for (i = 0; i < this.BMAX; i++) {
			u[i] = null;
		}
		// values in order of bit length
		for (i = 0; i < this.N_MAX; i++) {
			v[i] = 0;
		}
		// bit offsets, then code stack
		for (i = 0; i < this.BMAX + 1; i++) {
			x[i] = 0;
		}

		// Generate counts for each bit length
		el = n > 256 ? b[256] : this.BMAX; // set length of EOB code, if any
		p = b; pidx = 0;
		i = n;
		do {
			c[p[pidx]]++; // assume all entries <= BMAX
			pidx++;
		} while (--i > 0);
		if (c[0] === n) { // null input--all zero length codes
			this.root = null;
			this.m = 0;
			this.status = 0;
			return;
		}

		// Find minimum and maximum length, bound *m by those
		for (j = 1; j <= this.BMAX; j++) {
			if (c[j] !== 0) {
				break;
			}
		}
		k = j; // minimum code length
		if (mm < j) {
			mm = j;
		}
		for (i = this.BMAX; i !== 0; i--) {
			if (c[i] !== 0) {
				break;
			}
		}
		g = i; // maximum code length
		if (mm > i) {
			mm = i;
		}

		// Adjust last length count to fill out codes, if needed
		for (y = 1 << j; j < i; j++, y <<= 1) {
			if ((y -= c[j]) < 0) {
				this.status = 2; // bad input: more codes than bits
				this.m = mm;
				return;
			}
		}
		if ((y -= c[i]) < 0) {
			this.status = 2;
			this.m = mm;
			return;
		}
		c[i] += y;

		// Generate starting offsets into the value table for each length
		x[1] = j = 0;
		p = c;
		pidx = 1;
		xp = 2;
		while (--i > 0) { // note that i == g from above
			x[xp++] = (j += p[pidx++]);
		}

		// Make a table of values in order of bit lengths
		p = b; pidx = 0;
		i = 0;
		do {
			if ((j = p[pidx++]) !== 0) {
				v[x[j]++] = i;
			}
		} while (++i < n);
		n = x[g]; // set n to length of v

		// Generate the Huffman codes and for each, make the table entries
		x[0] = i = 0; // first Huffman code is zero
		p = v; pidx = 0; // grab values in bit order
		h = -1; // no tables yet--level -1
		w = lx[0] = 0; // no bits decoded yet
		q = null; // ditto
		z = 0; // ditto

		// go through the bit lengths (k already is bits in shortest code)
		for (null; k <= g; k++) {
			a = c[k];
			while (a-- > 0) {
				// here i is the Huffman code of length k bits for value p[pidx]
				// make tables up to required level
				while (k > w + lx[1 + h]) {
					w += lx[1 + h]; // add bits already decoded
					h++;

					// compute minimum size table less than or equal to *m bits
					z = (z = g - w) > mm ? mm : z; // upper limit
					if ((f = 1 << (j = k - w)) > a + 1) { // try a k-w bit table
						// too few codes for k-w bit table
						f -= a + 1; // deduct codes from patterns left
						xp = k;
						while (++j < z) { // try smaller tables up to z bits
							if ((f <<= 1) <= c[++xp]) {
								break; // enough codes to use up j bits
							}
							f -= c[xp]; // else deduct codes from patterns
						}
					}
					if (w + j > el && w < el) {
						j = el - w; // make EOB code end at table
					}
					z = 1 << j; // table entries for j-bit table
					lx[1 + h] = j; // set table size in stack

					// allocate and link in new table
					q = [];
					for (o = 0; o < z; o++) {
						q[o] = new HuftNode();
					}

					if (!tail) {
						tail = this.root = new HuftList();
					} else {
						tail = tail.next = new HuftList();
					}
					tail.next = null;
					tail.list = q;
					u[h] = q; // table starts after link

					/* connect to last table, if there is one */
					if (h > 0) {
						x[h] = i; // save pattern for backing up
						r.b = lx[h]; // bits to dump before this table
						r.e = 16 + j; // bits in this table
						r.t = q; // pointer to this table
						j = (i & ((1 << w) - 1)) >> (w - lx[h]);
						u[h - 1][j].e = r.e;
						u[h - 1][j].b = r.b;
						u[h - 1][j].n = r.n;
						u[h - 1][j].t = r.t;
					}
				}

				// set up table entry in r
				r.b = k - w;
				if (pidx >= n) {
					r.e = 99; // out of values--invalid code
				} else if (p[pidx] < s) {
					r.e = (p[pidx] < 256 ? 16 : 15); // 256 is end-of-block code
					r.n = p[pidx++]; // simple code is just the value
				} else {
					r.e = e[p[pidx] - s]; // non-simple--look up in lists
					r.n = d[p[pidx++] - s];
				}

				// fill code-like entries with r //
				f = 1 << (k - w);
				for (j = i >> w; j < z; j += f) {
					q[j].e = r.e;
					q[j].b = r.b;
					q[j].n = r.n;
					q[j].t = r.t;
				}

				// backwards increment the k-bit code i
				for (j = 1 << (k - 1); (i & j) !== 0; j >>= 1) {
					i ^= j;
				}
				i ^= j;

				// backup over finished tables
				while ((i & ((1 << w) - 1)) !== x[h]) {
					w -= lx[h]; // don't need to update q
					h--;
				}
			}
		}

		/* return actual size of base table */
		this.m = lx[1];

		/* Return true (1) if we were given an incomplete table */
		this.status = ((y !== 0 && g !== 1) ? 1 : 0);
	}


	/* routines (inflate) */

	function GET_BYTE() {
		if (inflate_data.length === inflate_pos) {
			return -1;
		}
		return inflate_data[inflate_pos++] & 0xff;
	}

	function NEEDBITS(n) {
		while (bit_len < n) {
			bit_buf |= GET_BYTE() << bit_len;
			bit_len += 8;
		}
	}

	function GETBITS(n) {
		return bit_buf & MASK_BITS[n];
	}

	function DUMPBITS(n) {
		bit_buf >>= n;
		bit_len -= n;
	}

	function inflate_codes(buff, off, size) {
		// inflate (decompress) the codes in a deflated (compressed) block.
		// Return an error code or zero if it all goes ok.
		var e; // table entry flag/number of extra bits
		var t; // (HuftNode) pointer to table entry
		var n;

		if (size === 0) {
			return 0;
		}

		// inflate the coded data
		n = 0;
		for (;;) { // do until end of block
			NEEDBITS(bl);
			t = tl.list[GETBITS(bl)];
			e = t.e;
			while (e > 16) {
				if (e === 99) {
					return -1;
				}
				DUMPBITS(t.b);
				e -= 16;
				NEEDBITS(e);
				t = t.t[GETBITS(e)];
				e = t.e;
			}
			DUMPBITS(t.b);

			if (e === 16) { // then it's a literal
				wp &= WSIZE - 1;
				buff[off + n++] = slide[wp++] = t.n;
				if (n === size) {
					return size;
				}
				continue;
			}

			// exit if end of block
			if (e === 15) {
				break;
			}

			// it's an EOB or a length

			// get length of block to copy
			NEEDBITS(e);
			copy_leng = t.n + GETBITS(e);
			DUMPBITS(e);

			// decode distance of block to copy
			NEEDBITS(bd);
			t = td.list[GETBITS(bd)];
			e = t.e;

			while (e > 16) {
				if (e === 99) {
					return -1;
				}
				DUMPBITS(t.b);
				e -= 16;
				NEEDBITS(e);
				t = t.t[GETBITS(e)];
				e = t.e;
			}
			DUMPBITS(t.b);
			NEEDBITS(e);
			copy_dist = wp - t.n - GETBITS(e);
			DUMPBITS(e);

			// do the copy
			while (copy_leng > 0 && n < size) {
				copy_leng--;
				copy_dist &= WSIZE - 1;
				wp &= WSIZE - 1;
				buff[off + n++] = slide[wp++] = slide[copy_dist++];
			}

			if (n === size) {
				return size;
			}
		}

		method = -1; // done
		return n;
	}

	function inflate_stored(buff, off, size) {
		/* "decompress" an inflated type 0 (stored) block. */
		var n;

		// go to byte boundary
		n = bit_len & 7;
		DUMPBITS(n);

		// get the length and its complement
		NEEDBITS(16);
		n = GETBITS(16);
		DUMPBITS(16);
		NEEDBITS(16);
		if (n !== ((~bit_buf) & 0xffff)) {
			return -1; // error in compressed data
		}
		DUMPBITS(16);

		// read and output the compressed data
		copy_leng = n;

		n = 0;
		while (copy_leng > 0 && n < size) {
			copy_leng--;
			wp &= WSIZE - 1;
			NEEDBITS(8);
			buff[off + n++] = slide[wp++] = GETBITS(8);
			DUMPBITS(8);
		}

		if (copy_leng === 0) {
			method = -1; // done
		}
		return n;
	}

	function inflate_fixed(buff, off, size) {
		// decompress an inflated type 1 (fixed Huffman codes) block.  We should
		// either replace this with a custom decoder, or at least precompute the
		// Huffman tables.

		// if first time, set up tables for fixed blocks
		if (!fixed_tl) {
			var i; // temporary variable
			var l = []; // 288 length list for huft_build (initialized below)
			var h; // HuftBuild

			// literal table
			for (i = 0; i < 144; i++) {
				l[i] = 8;
			}
			for (null; i < 256; i++) {
				l[i] = 9;
			}
			for (null; i < 280; i++) {
				l[i] = 7;
			}
			for (null; i < 288; i++) { // make a complete, but wrong code set
				l[i] = 8;
			}
			fixed_bl = 7;

			h = new HuftBuild(l, 288, 257, cplens, cplext, fixed_bl);
			if (h.status !== 0) {
				console.error("HufBuild error: " + h.status);
				return -1;
			}
			fixed_tl = h.root;
			fixed_bl = h.m;

			// distance table
			for (i = 0; i < 30; i++) { // make an incomplete code set
				l[i] = 5;
			}
			fixed_bd = 5;

			h = new HuftBuild(l, 30, 0, cpdist, cpdext, fixed_bd);
			if (h.status > 1) {
				fixed_tl = null;
				console.error("HufBuild error: " + h.status);
				return -1;
			}
			fixed_td = h.root;
			fixed_bd = h.m;
		}

		tl = fixed_tl;
		td = fixed_td;
		bl = fixed_bl;
		bd = fixed_bd;
		return inflate_codes(buff, off, size);
	}

	function inflate_dynamic(buff, off, size) {
		// decompress an inflated type 2 (dynamic Huffman codes) block.
		var i; // temporary variables
		var j;
		var l; // last length
		var n; // number of lengths to get
		var t; // (HuftNode) literal/length code table
		var nb; // number of bit length codes
		var nl; // number of literal/length codes
		var nd; // number of distance codes
		var ll = [];
		var h; // (HuftBuild)

		// literal/length and distance code lengths
		for (i = 0; i < 286 + 30; i++) {
			ll[i] = 0;
		}

		// read in table lengths
		NEEDBITS(5);
		nl = 257 + GETBITS(5); // number of literal/length codes
		DUMPBITS(5);
		NEEDBITS(5);
		nd = 1 + GETBITS(5); // number of distance codes
		DUMPBITS(5);
		NEEDBITS(4);
		nb = 4 + GETBITS(4); // number of bit length codes
		DUMPBITS(4);
		if (nl > 286 || nd > 30) {
			return -1; // bad lengths
		}

		// read in bit-length-code lengths
		for (j = 0; j < nb; j++) {
			NEEDBITS(3);
			ll[border[j]] = GETBITS(3);
			DUMPBITS(3);
		}
		for (null; j < 19; j++) {
			ll[border[j]] = 0;
		}

		// build decoding table for trees--single level, 7 bit lookup
		bl = 7;
		h = new HuftBuild(ll, 19, 19, null, null, bl);
		if (h.status !== 0) {
			return -1; // incomplete code set
		}

		tl = h.root;
		bl = h.m;

		// read in literal and distance code lengths
		n = nl + nd;
		i = l = 0;
		while (i < n) {
			NEEDBITS(bl);
			t = tl.list[GETBITS(bl)];
			j = t.b;
			DUMPBITS(j);
			j = t.n;
			if (j < 16) { // length of code in bits (0..15)
				ll[i++] = l = j; // save last length in l
			} else if (j === 16) { // repeat last length 3 to 6 times
				NEEDBITS(2);
				j = 3 + GETBITS(2);
				DUMPBITS(2);
				if (i + j > n) {
					return -1;
				}
				while (j-- > 0) {
					ll[i++] = l;
				}
			} else if (j === 17) { // 3 to 10 zero length codes
				NEEDBITS(3);
				j = 3 + GETBITS(3);
				DUMPBITS(3);
				if (i + j > n) {
					return -1;
				}
				while (j-- > 0) {
					ll[i++] = 0;
				}
				l = 0;
			} else { // j === 18: 11 to 138 zero length codes
				NEEDBITS(7);
				j = 11 + GETBITS(7);
				DUMPBITS(7);
				if (i + j > n) {
					return -1;
				}
				while (j-- > 0) {
					ll[i++] = 0;
				}
				l = 0;
			}
		}

		// build the decoding tables for literal/length and distance codes
		bl = lbits;
		h = new HuftBuild(ll, nl, 257, cplens, cplext, bl);
		if (bl === 0) { // no literals or lengths
			h.status = 1;
		}
		if (h.status !== 0) {
			if (h.status !== 1) {
				return -1; // incomplete code set
			}
			// **incomplete literal tree**
		}
		tl = h.root;
		bl = h.m;

		for (i = 0; i < nd; i++) {
			ll[i] = ll[i + nl];
		}
		bd = dbits;
		h = new HuftBuild(ll, nd, 0, cpdist, cpdext, bd);
		td = h.root;
		bd = h.m;

		if (bd === 0 && nl > 257) { // lengths but no distances
			// **incomplete distance tree**
			return -1;
		}
/*
		if (h.status === 1) {
			// **incomplete distance tree**
		}
*/
		if (h.status !== 0) {
			return -1;
		}

		// decompress until an end-of-block code
		return inflate_codes(buff, off, size);
	}

	function inflate_start() {
		if (!slide) {
			slide = []; // new Array(2 * WSIZE); // slide.length is never called
		}
		wp = 0;
		bit_buf = 0;
		bit_len = 0;
		method = -1;
		eof = false;
		copy_leng = copy_dist = 0;
		tl = null;
	}

	function inflate_internal(buff, off, size) {
		// decompress an inflated entry
		var n, i;

		n = 0;
		while (n < size) {
			if (eof && method === -1) {
				return n;
			}

			if (copy_leng > 0) {
				if (method !== STORED_BLOCK) {
					// STATIC_TREES or DYN_TREES
					while (copy_leng > 0 && n < size) {
						copy_leng--;
						copy_dist &= WSIZE - 1;
						wp &= WSIZE - 1;
						buff[off + n++] = slide[wp++] = slide[copy_dist++];
					}
				} else {
					while (copy_leng > 0 && n < size) {
						copy_leng--;
						wp &= WSIZE - 1;
						NEEDBITS(8);
						buff[off + n++] = slide[wp++] = GETBITS(8);
						DUMPBITS(8);
					}
					if (copy_leng === 0) {
						method = -1; // done
					}
				}
				if (n === size) {
					return n;
				}
			}

			if (method === -1) {
				if (eof) {
					break;
				}

				// read in last block bit
				NEEDBITS(1);
				if (GETBITS(1) !== 0) {
					eof = true;
				}
				DUMPBITS(1);

				// read in block type
				NEEDBITS(2);
				method = GETBITS(2);
				DUMPBITS(2);
				tl = null;
				copy_leng = 0;
			}

			switch (method) {
			case STORED_BLOCK:
				i = inflate_stored(buff, off + n, size - n);
				break;

			case STATIC_TREES:
				if (tl) {
					i = inflate_codes(buff, off + n, size - n);
				} else {
					i = inflate_fixed(buff, off + n, size - n);
				}
				break;

			case DYN_TREES:
				if (tl) {
					i = inflate_codes(buff, off + n, size - n);
				} else {
					i = inflate_dynamic(buff, off + n, size - n);
				}
				break;

			default: // error
				i = -1;
				break;
			}

			if (i === -1) {
				if (eof) {
					return 0;
				}
				return -1;
			}
			n += i;
		}
		return n;
	}

	function inflate(arr) {
		var buff = [], i;

		inflate_start();
		inflate_data = arr;
		inflate_pos = 0;

		do {
			i = inflate_internal(buff, buff.length, 1024);
		} while (i > 0);
		inflate_data = null; // G.C.
		return buff;
	}

	return {
		inflate: inflate
	};


});

/*
 * $Id: rawdeflate.js,v 0.3 2009/03/01 19:05:05 dankogai Exp dankogai $
 *
 * Original:
 *   http://www.onicos.com/staff/iz/amuse/javascript/expert/deflate.txt
 */

/* Copyright (C) 1999 Masanao Izumo <iz@onicos.co.jp>
 * Version: 1.0.1
 * LastModified: Dec 25 1999
 */

/* Interface:
 * data = deflate(src);
 */
define ('deflate-js',[],function(){

	/* constant parameters */
	var WSIZE = 32768, // Sliding Window size
		STORED_BLOCK = 0,
		STATIC_TREES = 1,
		DYN_TREES = 2,

	/* for deflate */
		DEFAULT_LEVEL = 6,
		FULL_SEARCH = false,
		INBUFSIZ = 32768, // Input buffer size
		//INBUF_EXTRA = 64, // Extra buffer
		OUTBUFSIZ = 1024 * 8,
		window_size = 2 * WSIZE,
		MIN_MATCH = 3,
		MAX_MATCH = 258,
		BITS = 16,
	// for SMALL_MEM
		LIT_BUFSIZE = 0x2000,
//		HASH_BITS = 13,
	//for MEDIUM_MEM
	//	LIT_BUFSIZE = 0x4000,
	//	HASH_BITS = 14,
	// for BIG_MEM
	//	LIT_BUFSIZE = 0x8000,
		HASH_BITS = 15,
		DIST_BUFSIZE = LIT_BUFSIZE,
		HASH_SIZE = 1 << HASH_BITS,
		HASH_MASK = HASH_SIZE - 1,
		WMASK = WSIZE - 1,
		NIL = 0, // Tail of hash chains
		TOO_FAR = 4096,
		MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1,
		MAX_DIST = WSIZE - MIN_LOOKAHEAD,
		SMALLEST = 1,
		MAX_BITS = 15,
		MAX_BL_BITS = 7,
		LENGTH_CODES = 29,
		LITERALS = 256,
		END_BLOCK = 256,
		L_CODES = LITERALS + 1 + LENGTH_CODES,
		D_CODES = 30,
		BL_CODES = 19,
		REP_3_6 = 16,
		REPZ_3_10 = 17,
		REPZ_11_138 = 18,
		HEAP_SIZE = 2 * L_CODES + 1,
		H_SHIFT = parseInt((HASH_BITS + MIN_MATCH - 1) / MIN_MATCH, 10),

	/* variables */
		free_queue,
		qhead,
		qtail,
		initflag,
		outbuf = null,
		outcnt,
		outoff,
		complete,
		window,
		d_buf,
		l_buf,
		prev,
		bi_buf,
		bi_valid,
		block_start,
		ins_h,
		hash_head,
		prev_match,
		match_available,
		match_length,
		prev_length,
		strstart,
		match_start,
		eofile,
		lookahead,
		max_chain_length,
		max_lazy_match,
		compr_level,
		good_match,
		nice_match,
		dyn_ltree,
		dyn_dtree,
		static_ltree,
		static_dtree,
		bl_tree,
		l_desc,
		d_desc,
		bl_desc,
		bl_count,
		heap,
		heap_len,
		heap_max,
		depth,
		length_code,
		dist_code,
		base_length,
		base_dist,
		flag_buf,
		last_lit,
		last_dist,
		last_flags,
		flags,
		flag_bit,
		opt_len,
		static_len,
		deflate_data,
		deflate_pos;

	if (LIT_BUFSIZE > INBUFSIZ) {
		console.error("error: INBUFSIZ is too small");
	}
	if ((WSIZE << 1) > (1 << BITS)) {
		console.error("error: WSIZE is too large");
	}
	if (HASH_BITS > BITS - 1) {
		console.error("error: HASH_BITS is too large");
	}
	if (HASH_BITS < 8 || MAX_MATCH !== 258) {
		console.error("error: Code too clever");
	}

	/* objects (deflate) */

	function DeflateCT() {
		this.fc = 0; // frequency count or bit string
		this.dl = 0; // father node in Huffman tree or length of bit string
	}

	function DeflateTreeDesc() {
		this.dyn_tree = null; // the dynamic tree
		this.static_tree = null; // corresponding static tree or NULL
		this.extra_bits = null; // extra bits for each code or NULL
		this.extra_base = 0; // base index for extra_bits
		this.elems = 0; // max number of elements in the tree
		this.max_length = 0; // max bit length for the codes
		this.max_code = 0; // largest code with non zero frequency
	}

	/* Values for max_lazy_match, good_match and max_chain_length, depending on
	 * the desired pack level (0..9). The values given below have been tuned to
	 * exclude worst case performance for pathological files. Better values may be
	 * found for specific files.
	 */
	function DeflateConfiguration(a, b, c, d) {
		this.good_length = a; // reduce lazy search above this match length
		this.max_lazy = b; // do not perform lazy search above this match length
		this.nice_length = c; // quit search above this match length
		this.max_chain = d;
	}

	function DeflateBuffer() {
		this.next = null;
		this.len = 0;
		this.ptr = []; // new Array(OUTBUFSIZ); // ptr.length is never read
		this.off = 0;
	}

	/* constant tables */
	var extra_lbits = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0];
	var extra_dbits = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13];
	var extra_blbits = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7];
	var bl_order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
	var configuration_table = [
		new DeflateConfiguration(0, 0, 0, 0),
		new DeflateConfiguration(4, 4, 8, 4),
		new DeflateConfiguration(4, 5, 16, 8),
		new DeflateConfiguration(4, 6, 32, 32),
		new DeflateConfiguration(4, 4, 16, 16),
		new DeflateConfiguration(8, 16, 32, 32),
		new DeflateConfiguration(8, 16, 128, 128),
		new DeflateConfiguration(8, 32, 128, 256),
		new DeflateConfiguration(32, 128, 258, 1024),
		new DeflateConfiguration(32, 258, 258, 4096)
	];


	/* routines (deflate) */

	function deflate_start(level) {
		var i;

		if (!level) {
			level = DEFAULT_LEVEL;
		} else if (level < 1) {
			level = 1;
		} else if (level > 9) {
			level = 9;
		}

		compr_level = level;
		initflag = false;
		eofile = false;
		if (outbuf !== null) {
			return;
		}

		free_queue = qhead = qtail = null;
		outbuf = []; // new Array(OUTBUFSIZ); // outbuf.length never called
		window = []; // new Array(window_size); // window.length never called
		d_buf = []; // new Array(DIST_BUFSIZE); // d_buf.length never called
		l_buf = []; // new Array(INBUFSIZ + INBUF_EXTRA); // l_buf.length never called
		prev = []; // new Array(1 << BITS); // prev.length never called

		dyn_ltree = [];
		for (i = 0; i < HEAP_SIZE; i++) {
			dyn_ltree[i] = new DeflateCT();
		}
		dyn_dtree = [];
		for (i = 0; i < 2 * D_CODES + 1; i++) {
			dyn_dtree[i] = new DeflateCT();
		}
		static_ltree = [];
		for (i = 0; i < L_CODES + 2; i++) {
			static_ltree[i] = new DeflateCT();
		}
		static_dtree = [];
		for (i = 0; i < D_CODES; i++) {
			static_dtree[i] = new DeflateCT();
		}
		bl_tree = [];
		for (i = 0; i < 2 * BL_CODES + 1; i++) {
			bl_tree[i] = new DeflateCT();
		}
		l_desc = new DeflateTreeDesc();
		d_desc = new DeflateTreeDesc();
		bl_desc = new DeflateTreeDesc();
		bl_count = []; // new Array(MAX_BITS+1); // bl_count.length never called
		heap = []; // new Array(2*L_CODES+1); // heap.length never called
		depth = []; // new Array(2*L_CODES+1); // depth.length never called
		length_code = []; // new Array(MAX_MATCH-MIN_MATCH+1); // length_code.length never called
		dist_code = []; // new Array(512); // dist_code.length never called
		base_length = []; // new Array(LENGTH_CODES); // base_length.length never called
		base_dist = []; // new Array(D_CODES); // base_dist.length never called
		flag_buf = []; // new Array(parseInt(LIT_BUFSIZE / 8, 10)); // flag_buf.length never called
	}

	function deflate_end() {
		free_queue = qhead = qtail = null;
		outbuf = null;
		window = null;
		d_buf = null;
		l_buf = null;
		prev = null;
		dyn_ltree = null;
		dyn_dtree = null;
		static_ltree = null;
		static_dtree = null;
		bl_tree = null;
		l_desc = null;
		d_desc = null;
		bl_desc = null;
		bl_count = null;
		heap = null;
		depth = null;
		length_code = null;
		dist_code = null;
		base_length = null;
		base_dist = null;
		flag_buf = null;
	}

	function reuse_queue(p) {
		p.next = free_queue;
		free_queue = p;
	}

	function new_queue() {
		var p;

		if (free_queue !== null) {
			p = free_queue;
			free_queue = free_queue.next;
		} else {
			p = new DeflateBuffer();
		}
		p.next = null;
		p.len = p.off = 0;

		return p;
	}

	function head1(i) {
		return prev[WSIZE + i];
	}

	function head2(i, val) {
		return (prev[WSIZE + i] = val);
	}

	/* put_byte is used for the compressed output, put_ubyte for the
	 * uncompressed output. However unlzw() uses window for its
	 * suffix table instead of its output buffer, so it does not use put_ubyte
	 * (to be cleaned up).
	 */
	function put_byte(c) {
		outbuf[outoff + outcnt++] = c;
		if (outoff + outcnt === OUTBUFSIZ) {
			qoutbuf();
		}
	}

	/* Output a 16 bit value, lsb first */
	function put_short(w) {
		w &= 0xffff;
		if (outoff + outcnt < OUTBUFSIZ - 2) {
			outbuf[outoff + outcnt++] = (w & 0xff);
			outbuf[outoff + outcnt++] = (w >>> 8);
		} else {
			put_byte(w & 0xff);
			put_byte(w >>> 8);
		}
	}

	/* ==========================================================================
	 * Insert string s in the dictionary and set match_head to the previous head
	 * of the hash chain (the most recent string with same hash key). Return
	 * the previous length of the hash chain.
	 * IN  assertion: all calls to to INSERT_STRING are made with consecutive
	 *    input characters and the first MIN_MATCH bytes of s are valid
	 *    (except for the last MIN_MATCH-1 bytes of the input file).
	 */
	function INSERT_STRING() {
		ins_h = ((ins_h << H_SHIFT) ^ (window[strstart + MIN_MATCH - 1] & 0xff)) & HASH_MASK;
		hash_head = head1(ins_h);
		prev[strstart & WMASK] = hash_head;
		head2(ins_h, strstart);
	}

	/* Send a code of the given tree. c and tree must not have side effects */
	function SEND_CODE(c, tree) {
		send_bits(tree[c].fc, tree[c].dl);
	}

	/* Mapping from a distance to a distance code. dist is the distance - 1 and
	 * must not have side effects. dist_code[256] and dist_code[257] are never
	 * used.
	 */
	function D_CODE(dist) {
		return (dist < 256 ? dist_code[dist] : dist_code[256 + (dist >> 7)]) & 0xff;
	}

	/* ==========================================================================
	 * Compares to subtrees, using the tree depth as tie breaker when
	 * the subtrees have equal frequency. This minimizes the worst case length.
	 */
	function SMALLER(tree, n, m) {
		return tree[n].fc < tree[m].fc || (tree[n].fc === tree[m].fc && depth[n] <= depth[m]);
	}

	/* ==========================================================================
	 * read string data
	 */
	function read_buff(buff, offset, n) {
		var i;
		for (i = 0; i < n && deflate_pos < deflate_data.length; i++) {
			buff[offset + i] = deflate_data[deflate_pos++] & 0xff;
		}
		return i;
	}

	/* ==========================================================================
	 * Initialize the "longest match" routines for a new file
	 */
	function lm_init() {
		var j;

		// Initialize the hash table. */
		for (j = 0; j < HASH_SIZE; j++) {
			// head2(j, NIL);
			prev[WSIZE + j] = 0;
		}
		// prev will be initialized on the fly */

		// Set the default configuration parameters:
		max_lazy_match = configuration_table[compr_level].max_lazy;
		good_match = configuration_table[compr_level].good_length;
		if (!FULL_SEARCH) {
			nice_match = configuration_table[compr_level].nice_length;
		}
		max_chain_length = configuration_table[compr_level].max_chain;

		strstart = 0;
		block_start = 0;

		lookahead = read_buff(window, 0, 2 * WSIZE);
		if (lookahead <= 0) {
			eofile = true;
			lookahead = 0;
			return;
		}
		eofile = false;
		// Make sure that we always have enough lookahead. This is important
		// if input comes from a device such as a tty.
		while (lookahead < MIN_LOOKAHEAD && !eofile) {
			fill_window();
		}

		// If lookahead < MIN_MATCH, ins_h is garbage, but this is
		// not important since only literal bytes will be emitted.
		ins_h = 0;
		for (j = 0; j < MIN_MATCH - 1; j++) {
			// UPDATE_HASH(ins_h, window[j]);
			ins_h = ((ins_h << H_SHIFT) ^ (window[j] & 0xff)) & HASH_MASK;
		}
	}

	/* ==========================================================================
	 * Set match_start to the longest match starting at the given string and
	 * return its length. Matches shorter or equal to prev_length are discarded,
	 * in which case the result is equal to prev_length and match_start is
	 * garbage.
	 * IN assertions: cur_match is the head of the hash chain for the current
	 *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1
	 */
	function longest_match(cur_match) {
		var chain_length = max_chain_length; // max hash chain length
		var scanp = strstart; // current string
		var matchp; // matched string
		var len; // length of current match
		var best_len = prev_length; // best match length so far

		// Stop when cur_match becomes <= limit. To simplify the code,
		// we prevent matches with the string of window index 0.
		var limit = (strstart > MAX_DIST ? strstart - MAX_DIST : NIL);

		var strendp = strstart + MAX_MATCH;
		var scan_end1 = window[scanp + best_len - 1];
		var scan_end = window[scanp + best_len];

		var i, broke;

		// Do not waste too much time if we already have a good match: */
		if (prev_length >= good_match) {
			chain_length >>= 2;
		}

		// Assert(encoder->strstart <= window_size-MIN_LOOKAHEAD, "insufficient lookahead");

		do {
			// Assert(cur_match < encoder->strstart, "no future");
			matchp = cur_match;

			// Skip to next match if the match length cannot increase
			// or if the match length is less than 2:
			if (window[matchp + best_len] !== scan_end  ||
					window[matchp + best_len - 1] !== scan_end1 ||
					window[matchp] !== window[scanp] ||
					window[++matchp] !== window[scanp + 1]) {
				continue;
			}

			// The check at best_len-1 can be removed because it will be made
			// again later. (This heuristic is not always a win.)
			// It is not necessary to compare scan[2] and match[2] since they
			// are always equal when the other bytes match, given that
			// the hash keys are equal and that HASH_BITS >= 8.
			scanp += 2;
			matchp++;

			// We check for insufficient lookahead only every 8th comparison;
			// the 256th check will be made at strstart+258.
			while (scanp < strendp) {
				broke = false;
				for (i = 0; i < 8; i += 1) {
					scanp += 1;
					matchp += 1;
					if (window[scanp] !== window[matchp]) {
						broke = true;
						break;
					}
				}

				if (broke) {
					break;
				}
			}

			len = MAX_MATCH - (strendp - scanp);
			scanp = strendp - MAX_MATCH;

			if (len > best_len) {
				match_start = cur_match;
				best_len = len;
				if (FULL_SEARCH) {
					if (len >= MAX_MATCH) {
						break;
					}
				} else {
					if (len >= nice_match) {
						break;
					}
				}

				scan_end1 = window[scanp + best_len - 1];
				scan_end = window[scanp + best_len];
			}
		} while ((cur_match = prev[cur_match & WMASK]) > limit && --chain_length !== 0);

		return best_len;
	}

	/* ==========================================================================
	 * Fill the window when the lookahead becomes insufficient.
	 * Updates strstart and lookahead, and sets eofile if end of input file.
	 * IN assertion: lookahead < MIN_LOOKAHEAD && strstart + lookahead > 0
	 * OUT assertions: at least one byte has been read, or eofile is set;
	 *    file reads are performed for at least two bytes (required for the
	 *    translate_eol option).
	 */
	function fill_window() {
		var n, m;

	 // Amount of free space at the end of the window.
		var more = window_size - lookahead - strstart;

		// If the window is almost full and there is insufficient lookahead,
		// move the upper half to the lower one to make room in the upper half.
		if (more === -1) {
			// Very unlikely, but possible on 16 bit machine if strstart == 0
			// and lookahead == 1 (input done one byte at time)
			more--;
		} else if (strstart >= WSIZE + MAX_DIST) {
			// By the IN assertion, the window is not empty so we can't confuse
			// more == 0 with more == 64K on a 16 bit machine.
			// Assert(window_size == (ulg)2*WSIZE, "no sliding with BIG_MEM");

			// System.arraycopy(window, WSIZE, window, 0, WSIZE);
			for (n = 0; n < WSIZE; n++) {
				window[n] = window[n + WSIZE];
			}

			match_start -= WSIZE;
			strstart    -= WSIZE; /* we now have strstart >= MAX_DIST: */
			block_start -= WSIZE;

			for (n = 0; n < HASH_SIZE; n++) {
				m = head1(n);
				head2(n, m >= WSIZE ? m - WSIZE : NIL);
			}
			for (n = 0; n < WSIZE; n++) {
			// If n is not on any hash chain, prev[n] is garbage but
			// its value will never be used.
				m = prev[n];
				prev[n] = (m >= WSIZE ? m - WSIZE : NIL);
			}
			more += WSIZE;
		}
		// At this point, more >= 2
		if (!eofile) {
			n = read_buff(window, strstart + lookahead, more);
			if (n <= 0) {
				eofile = true;
			} else {
				lookahead += n;
			}
		}
	}

	/* ==========================================================================
	 * Processes a new input file and return its compressed length. This
	 * function does not perform lazy evaluationof matches and inserts
	 * new strings in the dictionary only for unmatched strings or for short
	 * matches. It is used only for the fast compression options.
	 */
	function deflate_fast() {
		while (lookahead !== 0 && qhead === null) {
			var flush; // set if current block must be flushed

			// Insert the string window[strstart .. strstart+2] in the
			// dictionary, and set hash_head to the head of the hash chain:
			INSERT_STRING();

			// Find the longest match, discarding those <= prev_length.
			// At this point we have always match_length < MIN_MATCH
			if (hash_head !== NIL && strstart - hash_head <= MAX_DIST) {
				// To simplify the code, we prevent matches with the string
				// of window index 0 (in particular we have to avoid a match
				// of the string with itself at the start of the input file).
				match_length = longest_match(hash_head);
				// longest_match() sets match_start */
				if (match_length > lookahead) {
					match_length = lookahead;
				}
			}
			if (match_length >= MIN_MATCH) {
				// check_match(strstart, match_start, match_length);

				flush = ct_tally(strstart - match_start, match_length - MIN_MATCH);
				lookahead -= match_length;

				// Insert new strings in the hash table only if the match length
				// is not too large. This saves time but degrades compression.
				if (match_length <= max_lazy_match) {
					match_length--; // string at strstart already in hash table
					do {
						strstart++;
						INSERT_STRING();
						// strstart never exceeds WSIZE-MAX_MATCH, so there are
						// always MIN_MATCH bytes ahead. If lookahead < MIN_MATCH
						// these bytes are garbage, but it does not matter since
						// the next lookahead bytes will be emitted as literals.
					} while (--match_length !== 0);
					strstart++;
				} else {
					strstart += match_length;
					match_length = 0;
					ins_h = window[strstart] & 0xff;
					// UPDATE_HASH(ins_h, window[strstart + 1]);
					ins_h = ((ins_h << H_SHIFT) ^ (window[strstart + 1] & 0xff)) & HASH_MASK;

				//#if MIN_MATCH !== 3
				//		Call UPDATE_HASH() MIN_MATCH-3 more times
				//#endif

				}
			} else {
				// No match, output a literal byte */
				flush = ct_tally(0, window[strstart] & 0xff);
				lookahead--;
				strstart++;
			}
			if (flush) {
				flush_block(0);
				block_start = strstart;
			}

			// Make sure that we always have enough lookahead, except
			// at the end of the input file. We need MAX_MATCH bytes
			// for the next match, plus MIN_MATCH bytes to insert the
			// string following the next match.
			while (lookahead < MIN_LOOKAHEAD && !eofile) {
				fill_window();
			}
		}
	}

	function deflate_better() {
		// Process the input block. */
		while (lookahead !== 0 && qhead === null) {
			// Insert the string window[strstart .. strstart+2] in the
			// dictionary, and set hash_head to the head of the hash chain:
			INSERT_STRING();

			// Find the longest match, discarding those <= prev_length.
			prev_length = match_length;
			prev_match = match_start;
			match_length = MIN_MATCH - 1;

			if (hash_head !== NIL && prev_length < max_lazy_match && strstart - hash_head <= MAX_DIST) {
				// To simplify the code, we prevent matches with the string
				// of window index 0 (in particular we have to avoid a match
				// of the string with itself at the start of the input file).
				match_length = longest_match(hash_head);
				// longest_match() sets match_start */
				if (match_length > lookahead) {
					match_length = lookahead;
				}

				// Ignore a length 3 match if it is too distant: */
				if (match_length === MIN_MATCH && strstart - match_start > TOO_FAR) {
					// If prev_match is also MIN_MATCH, match_start is garbage
					// but we will ignore the current match anyway.
					match_length--;
				}
			}
			// If there was a match at the previous step and the current
			// match is not better, output the previous match:
			if (prev_length >= MIN_MATCH && match_length <= prev_length) {
				var flush; // set if current block must be flushed

				// check_match(strstart - 1, prev_match, prev_length);
				flush = ct_tally(strstart - 1 - prev_match, prev_length - MIN_MATCH);

				// Insert in hash table all strings up to the end of the match.
				// strstart-1 and strstart are already inserted.
				lookahead -= prev_length - 1;
				prev_length -= 2;
				do {
					strstart++;
					INSERT_STRING();
					// strstart never exceeds WSIZE-MAX_MATCH, so there are
					// always MIN_MATCH bytes ahead. If lookahead < MIN_MATCH
					// these bytes are garbage, but it does not matter since the
					// next lookahead bytes will always be emitted as literals.
				} while (--prev_length !== 0);
				match_available = false;
				match_length = MIN_MATCH - 1;
				strstart++;
				if (flush) {
					flush_block(0);
					block_start = strstart;
				}
			} else if (match_available) {
				// If there was no match at the previous position, output a
				// single literal. If there was a match but the current match
				// is longer, truncate the previous match to a single literal.
				if (ct_tally(0, window[strstart - 1] & 0xff)) {
					flush_block(0);
					block_start = strstart;
				}
				strstart++;
				lookahead--;
			} else {
				// There is no previous match to compare with, wait for
				// the next step to decide.
				match_available = true;
				strstart++;
				lookahead--;
			}

			// Make sure that we always have enough lookahead, except
			// at the end of the input file. We need MAX_MATCH bytes
			// for the next match, plus MIN_MATCH bytes to insert the
			// string following the next match.
			while (lookahead < MIN_LOOKAHEAD && !eofile) {
				fill_window();
			}
		}
	}

	function init_deflate() {
		if (eofile) {
			return;
		}
		bi_buf = 0;
		bi_valid = 0;
		ct_init();
		lm_init();

		qhead = null;
		outcnt = 0;
		outoff = 0;

		if (compr_level <= 3) {
			prev_length = MIN_MATCH - 1;
			match_length = 0;
		} else {
			match_length = MIN_MATCH - 1;
			match_available = false;
		}

		complete = false;
	}

	/* ==========================================================================
	 * Same as above, but achieves better compression. We use a lazy
	 * evaluation for matches: a match is finally adopted only if there is
	 * no better match at the next window position.
	 */
	function deflate_internal(buff, off, buff_size) {
		var n;

		if (!initflag) {
			init_deflate();
			initflag = true;
			if (lookahead === 0) { // empty
				complete = true;
				return 0;
			}
		}

		n = qcopy(buff, off, buff_size);
		if (n === buff_size) {
			return buff_size;
		}

		if (complete) {
			return n;
		}

		if (compr_level <= 3) {
			// optimized for speed
			deflate_fast();
		} else {
			deflate_better();
		}

		if (lookahead === 0) {
			if (match_available) {
				ct_tally(0, window[strstart - 1] & 0xff);
			}
			flush_block(1);
			complete = true;
		}

		return n + qcopy(buff, n + off, buff_size - n);
	}

	function qcopy(buff, off, buff_size) {
		var n, i, j;

		n = 0;
		while (qhead !== null && n < buff_size) {
			i = buff_size - n;
			if (i > qhead.len) {
				i = qhead.len;
			}
			// System.arraycopy(qhead.ptr, qhead.off, buff, off + n, i);
			for (j = 0; j < i; j++) {
				buff[off + n + j] = qhead.ptr[qhead.off + j];
			}

			qhead.off += i;
			qhead.len -= i;
			n += i;
			if (qhead.len === 0) {
				var p;
				p = qhead;
				qhead = qhead.next;
				reuse_queue(p);
			}
		}

		if (n === buff_size) {
			return n;
		}

		if (outoff < outcnt) {
			i = buff_size - n;
			if (i > outcnt - outoff) {
				i = outcnt - outoff;
			}
			// System.arraycopy(outbuf, outoff, buff, off + n, i);
			for (j = 0; j < i; j++) {
				buff[off + n + j] = outbuf[outoff + j];
			}
			outoff += i;
			n += i;
			if (outcnt === outoff) {
				outcnt = outoff = 0;
			}
		}
		return n;
	}

	/* ==========================================================================
	 * Allocate the match buffer, initialize the various tables and save the
	 * location of the internal file attribute (ascii/binary) and method
	 * (DEFLATE/STORE).
	 */
	function ct_init() {
		var n; // iterates over tree elements
		var bits; // bit counter
		var length; // length value
		var code; // code value
		var dist; // distance index

		if (static_dtree[0].dl !== 0) {
			return; // ct_init already called
		}

		l_desc.dyn_tree = dyn_ltree;
		l_desc.static_tree = static_ltree;
		l_desc.extra_bits = extra_lbits;
		l_desc.extra_base = LITERALS + 1;
		l_desc.elems = L_CODES;
		l_desc.max_length = MAX_BITS;
		l_desc.max_code = 0;

		d_desc.dyn_tree = dyn_dtree;
		d_desc.static_tree = static_dtree;
		d_desc.extra_bits = extra_dbits;
		d_desc.extra_base = 0;
		d_desc.elems = D_CODES;
		d_desc.max_length = MAX_BITS;
		d_desc.max_code = 0;

		bl_desc.dyn_tree = bl_tree;
		bl_desc.static_tree = null;
		bl_desc.extra_bits = extra_blbits;
		bl_desc.extra_base = 0;
		bl_desc.elems = BL_CODES;
		bl_desc.max_length = MAX_BL_BITS;
		bl_desc.max_code = 0;

	 // Initialize the mapping length (0..255) -> length code (0..28)
		length = 0;
		for (code = 0; code < LENGTH_CODES - 1; code++) {
			base_length[code] = length;
			for (n = 0; n < (1 << extra_lbits[code]); n++) {
				length_code[length++] = code;
			}
		}
	 // Assert (length === 256, "ct_init: length !== 256");

		// Note that the length 255 (match length 258) can be represented
		// in two different ways: code 284 + 5 bits or code 285, so we
		// overwrite length_code[255] to use the best encoding:
		length_code[length - 1] = code;

		// Initialize the mapping dist (0..32K) -> dist code (0..29) */
		dist = 0;
		for (code = 0; code < 16; code++) {
			base_dist[code] = dist;
			for (n = 0; n < (1 << extra_dbits[code]); n++) {
				dist_code[dist++] = code;
			}
		}
		// Assert (dist === 256, "ct_init: dist !== 256");
		// from now on, all distances are divided by 128
		for (dist >>= 7; code < D_CODES; code++) {
			base_dist[code] = dist << 7;
			for (n = 0; n < (1 << (extra_dbits[code] - 7)); n++) {
				dist_code[256 + dist++] = code;
			}
		}
		// Assert (dist === 256, "ct_init: 256+dist !== 512");

		// Construct the codes of the static literal tree
		for (bits = 0; bits <= MAX_BITS; bits++) {
			bl_count[bits] = 0;
		}
		n = 0;
		while (n <= 143) {
			static_ltree[n++].dl = 8;
			bl_count[8]++;
		}
		while (n <= 255) {
			static_ltree[n++].dl = 9;
			bl_count[9]++;
		}
		while (n <= 279) {
			static_ltree[n++].dl = 7;
			bl_count[7]++;
		}
		while (n <= 287) {
			static_ltree[n++].dl = 8;
			bl_count[8]++;
		}
		// Codes 286 and 287 do not exist, but we must include them in the
		// tree construction to get a canonical Huffman tree (longest code
		// all ones)
		gen_codes(static_ltree, L_CODES + 1);

		// The static distance tree is trivial: */
		for (n = 0; n < D_CODES; n++) {
			static_dtree[n].dl = 5;
			static_dtree[n].fc = bi_reverse(n, 5);
		}

		// Initialize the first block of the first file:
		init_block();
	}

	/* ==========================================================================
	 * Initialize a new block.
	 */
	function init_block() {
		var n; // iterates over tree elements

		// Initialize the trees.
		for (n = 0; n < L_CODES;  n++) {
			dyn_ltree[n].fc = 0;
		}
		for (n = 0; n < D_CODES;  n++) {
			dyn_dtree[n].fc = 0;
		}
		for (n = 0; n < BL_CODES; n++) {
			bl_tree[n].fc = 0;
		}

		dyn_ltree[END_BLOCK].fc = 1;
		opt_len = static_len = 0;
		last_lit = last_dist = last_flags = 0;
		flags = 0;
		flag_bit = 1;
	}

	/* ==========================================================================
	 * Restore the heap property by moving down the tree starting at node k,
	 * exchanging a node with the smallest of its two sons if necessary, stopping
	 * when the heap property is re-established (each father smaller than its
	 * two sons).
	 *
	 * @param tree- tree to restore
	 * @param k- node to move down
	 */
	function pqdownheap(tree, k) {
		var v = heap[k],
			j = k << 1; // left son of k

		while (j <= heap_len) {
			// Set j to the smallest of the two sons:
			if (j < heap_len && SMALLER(tree, heap[j + 1], heap[j])) {
				j++;
			}

			// Exit if v is smaller than both sons
			if (SMALLER(tree, v, heap[j])) {
				break;
			}

			// Exchange v with the smallest son
			heap[k] = heap[j];
			k = j;

			// And continue down the tree, setting j to the left son of k
			j <<= 1;
		}
		heap[k] = v;
	}

	/* ==========================================================================
	 * Compute the optimal bit lengths for a tree and update the total bit length
	 * for the current block.
	 * IN assertion: the fields freq and dad are set, heap[heap_max] and
	 *    above are the tree nodes sorted by increasing frequency.
	 * OUT assertions: the field len is set to the optimal bit length, the
	 *     array bl_count contains the frequencies for each bit length.
	 *     The length opt_len is updated; static_len is also updated if stree is
	 *     not null.
	 */
	function gen_bitlen(desc) { // the tree descriptor
		var tree = desc.dyn_tree;
		var extra = desc.extra_bits;
		var base = desc.extra_base;
		var max_code = desc.max_code;
		var max_length = desc.max_length;
		var stree = desc.static_tree;
		var h; // heap index
		var n, m; // iterate over the tree elements
		var bits; // bit length
		var xbits; // extra bits
		var f; // frequency
		var overflow = 0; // number of elements with bit length too large

		for (bits = 0; bits <= MAX_BITS; bits++) {
			bl_count[bits] = 0;
		}

		// In a first pass, compute the optimal bit lengths (which may
		// overflow in the case of the bit length tree).
		tree[heap[heap_max]].dl = 0; // root of the heap

		for (h = heap_max + 1; h < HEAP_SIZE; h++) {
			n = heap[h];
			bits = tree[tree[n].dl].dl + 1;
			if (bits > max_length) {
				bits = max_length;
				overflow++;
			}
			tree[n].dl = bits;
			// We overwrite tree[n].dl which is no longer needed

			if (n > max_code) {
				continue; // not a leaf node
			}

			bl_count[bits]++;
			xbits = 0;
			if (n >= base) {
				xbits = extra[n - base];
			}
			f = tree[n].fc;
			opt_len += f * (bits + xbits);
			if (stree !== null) {
				static_len += f * (stree[n].dl + xbits);
			}
		}
		if (overflow === 0) {
			return;
		}

		// This happens for example on obj2 and pic of the Calgary corpus

		// Find the first bit length which could increase:
		do {
			bits = max_length - 1;
			while (bl_count[bits] === 0) {
				bits--;
			}
			bl_count[bits]--; // move one leaf down the tree
			bl_count[bits + 1] += 2; // move one overflow item as its brother
			bl_count[max_length]--;
			// The brother of the overflow item also moves one step up,
			// but this does not affect bl_count[max_length]
			overflow -= 2;
		} while (overflow > 0);

		// Now recompute all bit lengths, scanning in increasing frequency.
		// h is still equal to HEAP_SIZE. (It is simpler to reconstruct all
		// lengths instead of fixing only the wrong ones. This idea is taken
		// from 'ar' written by Haruhiko Okumura.)
		for (bits = max_length; bits !== 0; bits--) {
			n = bl_count[bits];
			while (n !== 0) {
				m = heap[--h];
				if (m > max_code) {
					continue;
				}
				if (tree[m].dl !== bits) {
					opt_len += (bits - tree[m].dl) * tree[m].fc;
					tree[m].fc = bits;
				}
				n--;
			}
		}
	}

	  /* ==========================================================================
	   * Generate the codes for a given tree and bit counts (which need not be
	   * optimal).
	   * IN assertion: the array bl_count contains the bit length statistics for
	   * the given tree and the field len is set for all tree elements.
	   * OUT assertion: the field code is set for all tree elements of non
	   *     zero code length.
	   * @param tree- the tree to decorate
	   * @param max_code- largest code with non-zero frequency
	   */
	function gen_codes(tree, max_code) {
		var next_code = []; // new Array(MAX_BITS + 1); // next code value for each bit length
		var code = 0; // running code value
		var bits; // bit index
		var n; // code index

		// The distribution counts are first used to generate the code values
		// without bit reversal.
		for (bits = 1; bits <= MAX_BITS; bits++) {
			code = ((code + bl_count[bits - 1]) << 1);
			next_code[bits] = code;
		}

		// Check that the bit counts in bl_count are consistent. The last code
		// must be all ones.
		// Assert (code + encoder->bl_count[MAX_BITS]-1 === (1<<MAX_BITS)-1, "inconsistent bit counts");
		// Tracev((stderr,"\ngen_codes: max_code %d ", max_code));

		for (n = 0; n <= max_code; n++) {
			var len = tree[n].dl;
			if (len === 0) {
				continue;
			}
			// Now reverse the bits
			tree[n].fc = bi_reverse(next_code[len]++, len);

			// Tracec(tree !== static_ltree, (stderr,"\nn %3d %c l %2d c %4x (%x) ", n, (isgraph(n) ? n : ' '), len, tree[n].fc, next_code[len]-1));
		}
	}

	/* ==========================================================================
	 * Construct one Huffman tree and assigns the code bit strings and lengths.
	 * Update the total bit length for the current block.
	 * IN assertion: the field freq is set for all tree elements.
	 * OUT assertions: the fields len and code are set to the optimal bit length
	 *     and corresponding code. The length opt_len is updated; static_len is
	 *     also updated if stree is not null. The field max_code is set.
	 */
	function build_tree(desc) { // the tree descriptor
		var tree = desc.dyn_tree;
		var stree = desc.static_tree;
		var elems = desc.elems;
		var n, m; // iterate over heap elements
		var max_code = -1; // largest code with non zero frequency
		var node = elems; // next internal node of the tree

		// Construct the initial heap, with least frequent element in
		// heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].
		// heap[0] is not used.
		heap_len = 0;
		heap_max = HEAP_SIZE;

		for (n = 0; n < elems; n++) {
			if (tree[n].fc !== 0) {
				heap[++heap_len] = max_code = n;
				depth[n] = 0;
			} else {
				tree[n].dl = 0;
			}
		}

		// The pkzip format requires that at least one distance code exists,
		// and that at least one bit should be sent even if there is only one
		// possible code. So to avoid special checks later on we force at least
		// two codes of non zero frequency.
		while (heap_len < 2) {
			var xnew = heap[++heap_len] = (max_code < 2 ? ++max_code : 0);
			tree[xnew].fc = 1;
			depth[xnew] = 0;
			opt_len--;
			if (stree !== null) {
				static_len -= stree[xnew].dl;
			}
			// new is 0 or 1 so it does not have extra bits
		}
		desc.max_code = max_code;

		// The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,
		// establish sub-heaps of increasing lengths:
		for (n = heap_len >> 1; n >= 1; n--) {
			pqdownheap(tree, n);
		}

		// Construct the Huffman tree by repeatedly combining the least two
		// frequent nodes.
		do {
			n = heap[SMALLEST];
			heap[SMALLEST] = heap[heap_len--];
			pqdownheap(tree, SMALLEST);

			m = heap[SMALLEST]; // m = node of next least frequency

			// keep the nodes sorted by frequency
			heap[--heap_max] = n;
			heap[--heap_max] = m;

			// Create a new node father of n and m
			tree[node].fc = tree[n].fc + tree[m].fc;
			//	depth[node] = (char)(MAX(depth[n], depth[m]) + 1);
			if (depth[n] > depth[m] + 1) {
				depth[node] = depth[n];
			} else {
				depth[node] = depth[m] + 1;
			}
			tree[n].dl = tree[m].dl = node;

			// and insert the new node in the heap
			heap[SMALLEST] = node++;
			pqdownheap(tree, SMALLEST);

		} while (heap_len >= 2);

		heap[--heap_max] = heap[SMALLEST];

		// At this point, the fields freq and dad are set. We can now
		// generate the bit lengths.
		gen_bitlen(desc);

		// The field len is now set, we can generate the bit codes
		gen_codes(tree, max_code);
	}

	/* ==========================================================================
	 * Scan a literal or distance tree to determine the frequencies of the codes
	 * in the bit length tree. Updates opt_len to take into account the repeat
	 * counts. (The contribution of the bit length codes will be added later
	 * during the construction of bl_tree.)
	 *
	 * @param tree- the tree to be scanned
	 * @param max_code- and its largest code of non zero frequency
	 */
	function scan_tree(tree, max_code) {
		var n, // iterates over all tree elements
			prevlen = -1, // last emitted length
			curlen, // length of current code
			nextlen = tree[0].dl, // length of next code
			count = 0, // repeat count of the current code
			max_count = 7, // max repeat count
			min_count = 4; // min repeat count

		if (nextlen === 0) {
			max_count = 138;
			min_count = 3;
		}
		tree[max_code + 1].dl = 0xffff; // guard

		for (n = 0; n <= max_code; n++) {
			curlen = nextlen;
			nextlen = tree[n + 1].dl;
			if (++count < max_count && curlen === nextlen) {
				continue;
			} else if (count < min_count) {
				bl_tree[curlen].fc += count;
			} else if (curlen !== 0) {
				if (curlen !== prevlen) {
					bl_tree[curlen].fc++;
				}
				bl_tree[REP_3_6].fc++;
			} else if (count <= 10) {
				bl_tree[REPZ_3_10].fc++;
			} else {
				bl_tree[REPZ_11_138].fc++;
			}
			count = 0; prevlen = curlen;
			if (nextlen === 0) {
				max_count = 138;
				min_count = 3;
			} else if (curlen === nextlen) {
				max_count = 6;
				min_count = 3;
			} else {
				max_count = 7;
				min_count = 4;
			}
		}
	}

	/* ==========================================================================
	 * Send a literal or distance tree in compressed form, using the codes in
	 * bl_tree.
	 *
	 * @param tree- the tree to be scanned
	 * @param max_code- and its largest code of non zero frequency
	 */
	function send_tree(tree, max_code) {
		var n; // iterates over all tree elements
		var prevlen = -1; // last emitted length
		var curlen; // length of current code
		var nextlen = tree[0].dl; // length of next code
		var count = 0; // repeat count of the current code
		var max_count = 7; // max repeat count
		var min_count = 4; // min repeat count

		// tree[max_code+1].dl = -1; */  /* guard already set */
		if (nextlen === 0) {
			max_count = 138;
			min_count = 3;
		}

		for (n = 0; n <= max_code; n++) {
			curlen = nextlen;
			nextlen = tree[n + 1].dl;
			if (++count < max_count && curlen === nextlen) {
				continue;
			} else if (count < min_count) {
				do {
					SEND_CODE(curlen, bl_tree);
				} while (--count !== 0);
			} else if (curlen !== 0) {
				if (curlen !== prevlen) {
					SEND_CODE(curlen, bl_tree);
					count--;
				}
			// Assert(count >= 3 && count <= 6, " 3_6?");
				SEND_CODE(REP_3_6, bl_tree);
				send_bits(count - 3, 2);
			} else if (count <= 10) {
				SEND_CODE(REPZ_3_10, bl_tree);
				send_bits(count - 3, 3);
			} else {
				SEND_CODE(REPZ_11_138, bl_tree);
				send_bits(count - 11, 7);
			}
			count = 0;
			prevlen = curlen;
			if (nextlen === 0) {
				max_count = 138;
				min_count = 3;
			} else if (curlen === nextlen) {
				max_count = 6;
				min_count = 3;
			} else {
				max_count = 7;
				min_count = 4;
			}
		}
	}

	/* ==========================================================================
	 * Construct the Huffman tree for the bit lengths and return the index in
	 * bl_order of the last bit length code to send.
	 */
	function build_bl_tree() {
		var max_blindex; // index of last bit length code of non zero freq

		// Determine the bit length frequencies for literal and distance trees
		scan_tree(dyn_ltree, l_desc.max_code);
		scan_tree(dyn_dtree, d_desc.max_code);

		// Build the bit length tree:
		build_tree(bl_desc);
		// opt_len now includes the length of the tree representations, except
		// the lengths of the bit lengths codes and the 5+5+4 bits for the counts.

		// Determine the number of bit length codes to send. The pkzip format
		// requires that at least 4 bit length codes be sent. (appnote.txt says
		// 3 but the actual value used is 4.)
		for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
			if (bl_tree[bl_order[max_blindex]].dl !== 0) {
				break;
			}
		}
		// Update opt_len to include the bit length tree and counts */
		opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
		// Tracev((stderr, "\ndyn trees: dyn %ld, stat %ld",
		// encoder->opt_len, encoder->static_len));

		return max_blindex;
	}

	/* ==========================================================================
	 * Send the header for a block using dynamic Huffman trees: the counts, the
	 * lengths of the bit length codes, the literal tree and the distance tree.
	 * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.
	 */
	function send_all_trees(lcodes, dcodes, blcodes) { // number of codes for each tree
		var rank; // index in bl_order

		// Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, "not enough codes");
		// Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES, "too many codes");
		// Tracev((stderr, "\nbl counts: "));
		send_bits(lcodes - 257, 5); // not +255 as stated in appnote.txt
		send_bits(dcodes - 1,   5);
		send_bits(blcodes - 4,  4); // not -3 as stated in appnote.txt
		for (rank = 0; rank < blcodes; rank++) {
			// Tracev((stderr, "\nbl code %2d ", bl_order[rank]));
			send_bits(bl_tree[bl_order[rank]].dl, 3);
		}

		// send the literal tree
		send_tree(dyn_ltree, lcodes - 1);

		// send the distance tree
		send_tree(dyn_dtree, dcodes - 1);
	}

	/* ==========================================================================
	 * Determine the best encoding for the current block: dynamic trees, static
	 * trees or store, and output the encoded block to the zip file.
	 */
	function flush_block(eof) { // true if this is the last block for a file
		var opt_lenb, static_lenb, // opt_len and static_len in bytes
			max_blindex, // index of last bit length code of non zero freq
			stored_len, // length of input block
			i;

		stored_len = strstart - block_start;
		flag_buf[last_flags] = flags; // Save the flags for the last 8 items

		// Construct the literal and distance trees
		build_tree(l_desc);
		// Tracev((stderr, "\nlit data: dyn %ld, stat %ld",
		// encoder->opt_len, encoder->static_len));

		build_tree(d_desc);
		// Tracev((stderr, "\ndist data: dyn %ld, stat %ld",
		// encoder->opt_len, encoder->static_len));
		// At this point, opt_len and static_len are the total bit lengths of
		// the compressed block data, excluding the tree representations.

		// Build the bit length tree for the above two trees, and get the index
		// in bl_order of the last bit length code to send.
		max_blindex = build_bl_tree();

	 // Determine the best encoding. Compute first the block length in bytes
		opt_lenb = (opt_len + 3 + 7) >> 3;
		static_lenb = (static_len + 3 + 7) >> 3;

	//  Trace((stderr, "\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u dist %u ", opt_lenb, encoder->opt_len, static_lenb, encoder->static_len, stored_len, encoder->last_lit, encoder->last_dist));

		if (static_lenb <= opt_lenb) {
			opt_lenb = static_lenb;
		}
		if (stored_len + 4 <= opt_lenb && block_start >= 0) { // 4: two words for the lengths
			// The test buf !== NULL is only necessary if LIT_BUFSIZE > WSIZE.
			// Otherwise we can't have processed more than WSIZE input bytes since
			// the last block flush, because compression would have been
			// successful. If LIT_BUFSIZE <= WSIZE, it is never too late to
			// transform a block into a stored block.
			send_bits((STORED_BLOCK << 1) + eof, 3);  /* send block type */
			bi_windup();         /* align on byte boundary */
			put_short(stored_len);
			put_short(~stored_len);

			// copy block
			/*
				p = &window[block_start];
				for (i = 0; i < stored_len; i++) {
					put_byte(p[i]);
				}
			*/
			for (i = 0; i < stored_len; i++) {
				put_byte(window[block_start + i]);
			}
		} else if (static_lenb === opt_lenb) {
			send_bits((STATIC_TREES << 1) + eof, 3);
			compress_block(static_ltree, static_dtree);
		} else {
			send_bits((DYN_TREES << 1) + eof, 3);
			send_all_trees(l_desc.max_code + 1, d_desc.max_code + 1, max_blindex + 1);
			compress_block(dyn_ltree, dyn_dtree);
		}

		init_block();

		if (eof !== 0) {
			bi_windup();
		}
	}

	/* ==========================================================================
	 * Save the match info and tally the frequency counts. Return true if
	 * the current block must be flushed.
	 *
	 * @param dist- distance of matched string
	 * @param lc- (match length - MIN_MATCH) or unmatched char (if dist === 0)
	 */
	function ct_tally(dist, lc) {
		l_buf[last_lit++] = lc;
		if (dist === 0) {
			// lc is the unmatched char
			dyn_ltree[lc].fc++;
		} else {
			// Here, lc is the match length - MIN_MATCH
			dist--; // dist = match distance - 1
			// Assert((ush)dist < (ush)MAX_DIST && (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) && (ush)D_CODE(dist) < (ush)D_CODES,  "ct_tally: bad match");

			dyn_ltree[length_code[lc] + LITERALS + 1].fc++;
			dyn_dtree[D_CODE(dist)].fc++;

			d_buf[last_dist++] = dist;
			flags |= flag_bit;
		}
		flag_bit <<= 1;

		// Output the flags if they fill a byte
		if ((last_lit & 7) === 0) {
			flag_buf[last_flags++] = flags;
			flags = 0;
			flag_bit = 1;
		}
		// Try to guess if it is profitable to stop the current block here
		if (compr_level > 2 && (last_lit & 0xfff) === 0) {
			// Compute an upper bound for the compressed length
			var out_length = last_lit * 8;
			var in_length = strstart - block_start;
			var dcode;

			for (dcode = 0; dcode < D_CODES; dcode++) {
				out_length += dyn_dtree[dcode].fc * (5 + extra_dbits[dcode]);
			}
			out_length >>= 3;
			// Trace((stderr,"\nlast_lit %u, last_dist %u, in %ld, out ~%ld(%ld%%) ", encoder->last_lit, encoder->last_dist, in_length, out_length, 100L - out_length*100L/in_length));
			if (last_dist < parseInt(last_lit / 2, 10) && out_length < parseInt(in_length / 2, 10)) {
				return true;
			}
		}
		return (last_lit === LIT_BUFSIZE - 1 || last_dist === DIST_BUFSIZE);
		// We avoid equality with LIT_BUFSIZE because of wraparound at 64K
		// on 16 bit machines and because stored blocks are restricted to
		// 64K-1 bytes.
	}

	  /* ==========================================================================
	   * Send the block data compressed using the given Huffman trees
	   *
	   * @param ltree- literal tree
	   * @param dtree- distance tree
	   */
	function compress_block(ltree, dtree) {
		var dist; // distance of matched string
		var lc; // match length or unmatched char (if dist === 0)
		var lx = 0; // running index in l_buf
		var dx = 0; // running index in d_buf
		var fx = 0; // running index in flag_buf
		var flag = 0; // current flags
		var code; // the code to send
		var extra; // number of extra bits to send

		if (last_lit !== 0) {
			do {
				if ((lx & 7) === 0) {
					flag = flag_buf[fx++];
				}
				lc = l_buf[lx++] & 0xff;
				if ((flag & 1) === 0) {
					SEND_CODE(lc, ltree); /* send a literal byte */
					//	Tracecv(isgraph(lc), (stderr," '%c' ", lc));
				} else {
					// Here, lc is the match length - MIN_MATCH
					code = length_code[lc];
					SEND_CODE(code + LITERALS + 1, ltree); // send the length code
					extra = extra_lbits[code];
					if (extra !== 0) {
						lc -= base_length[code];
						send_bits(lc, extra); // send the extra length bits
					}
					dist = d_buf[dx++];
					// Here, dist is the match distance - 1
					code = D_CODE(dist);
					//	Assert (code < D_CODES, "bad d_code");

					SEND_CODE(code, dtree); // send the distance code
					extra = extra_dbits[code];
					if (extra !== 0) {
						dist -= base_dist[code];
						send_bits(dist, extra); // send the extra distance bits
					}
				} // literal or match pair ?
				flag >>= 1;
			} while (lx < last_lit);
		}

		SEND_CODE(END_BLOCK, ltree);
	}

	/* ==========================================================================
	 * Send a value on a given number of bits.
	 * IN assertion: length <= 16 and value fits in length bits.
	 *
	 * @param value- value to send
	 * @param length- number of bits
	 */
	var Buf_size = 16; // bit size of bi_buf
	function send_bits(value, length) {
		// If not enough room in bi_buf, use (valid) bits from bi_buf and
		// (16 - bi_valid) bits from value, leaving (width - (16-bi_valid))
		// unused bits in value.
		if (bi_valid > Buf_size - length) {
			bi_buf |= (value << bi_valid);
			put_short(bi_buf);
			bi_buf = (value >> (Buf_size - bi_valid));
			bi_valid += length - Buf_size;
		} else {
			bi_buf |= value << bi_valid;
			bi_valid += length;
		}
	}

	/* ==========================================================================
	 * Reverse the first len bits of a code, using straightforward code (a faster
	 * method would use a table)
	 * IN assertion: 1 <= len <= 15
	 *
	 * @param code- the value to invert
	 * @param len- its bit length
	 */
	function bi_reverse(code, len) {
		var res = 0;
		do {
			res |= code & 1;
			code >>= 1;
			res <<= 1;
		} while (--len > 0);
		return res >> 1;
	}

	/* ==========================================================================
	 * Write out any remaining bits in an incomplete byte.
	 */
	function bi_windup() {
		if (bi_valid > 8) {
			put_short(bi_buf);
		} else if (bi_valid > 0) {
			put_byte(bi_buf);
		}
		bi_buf = 0;
		bi_valid = 0;
	}

	function qoutbuf() {
		var q, i;
		if (outcnt !== 0) {
			q = new_queue();
			if (qhead === null) {
				qhead = qtail = q;
			} else {
				qtail = qtail.next = q;
			}
			q.len = outcnt - outoff;
			// System.arraycopy(outbuf, outoff, q.ptr, 0, q.len);
			for (i = 0; i < q.len; i++) {
				q.ptr[i] = outbuf[outoff + i];
			}
			outcnt = outoff = 0;
		}
	}

	function deflate(arr, level) {
		var i, j, buff;

		deflate_data = arr;
		deflate_pos = 0;
		if (typeof level === "undefined") {
			level = DEFAULT_LEVEL;
		}
		deflate_start(level);

		buff = [];

		do {
			i = deflate_internal(buff, buff.length, 1024);
		} while (i > 0);

		deflate_data = null; // G.C.
		return buff;
	}

	return {
		deflate: deflate
	};

});

define('gzip',['crc32', 'inflate-js', 'deflate-js'], function(crc32, inflate, deflate){
			
		// magic numbers marking this file as GZIP
		ID1 = 0x1F,
		ID2 = 0x8B,
		compressionMethods = {
			'deflate': 8
		},
		possibleFlags = {
			'FTEXT': 0x01,
			'FHCRC': 0x02,
			'FEXTRA': 0x04,
			'FNAME': 0x08,
			'FCOMMENT': 0x10
		},
		osMap = {
			'fat': 0, // FAT file system (DOS, OS/2, NT) + PKZIPW 2.50 VFAT, NTFS
			'amiga': 1, // Amiga
			'vmz': 2, // VMS (VAX or Alpha AXP)
			'unix': 3, // Unix
			'vm/cms': 4, // VM/CMS
			'atari': 5, // Atari
			'hpfs': 6, // HPFS file system (OS/2, NT 3.x)
			'macintosh': 7, // Macintosh
			'z-system': 8, // Z-System
			'cplm': 9, // CP/M
			'tops-20': 10, // TOPS-20
			'ntfs': 11, // NTFS file system (NT)
			'qdos': 12, // SMS/QDOS
			'acorn': 13, // Acorn RISC OS
			'vfat': 14, // VFAT file system (Win95, NT)
			'vms': 15, // MVS (code also taken for PRIMOS)
			'beos': 16, // BeOS (BeBox or PowerMac)
			'tandem': 17, // Tandem/NSK
			'theos': 18 // THEOS
		},
		os = 'unix',
		DEFAULT_LEVEL = 6;

	function putByte(n, arr) {
		arr.push(n & 0xFF);
	}

	// LSB first
	function putShort(n, arr) {
		arr.push(n & 0xFF);
		arr.push(n >>> 8);
	}

	// LSB first
	function putLong(n, arr) {
		putShort(n & 0xffff, arr);
		putShort(n >>> 16, arr);
	}

	function putString(s, arr) {
		var i, len = s.length;
		for (i = 0; i < len; i += 1) {
			putByte(s.charCodeAt(i), arr);
		}
	}

	function readByte(arr) {
		return arr.shift();
	}

	function readShort(arr) {
		return arr.shift() | (arr.shift() << 8);
	}

	function readLong(arr) {
		var n1 = readShort(arr),
			n2 = readShort(arr);

		// JavaScript can't handle bits in the position 32
		// we'll emulate this by removing the left-most bit (if it exists)
		// and add it back in via multiplication, which does work
		if (n2 > 32768) {
			n2 -= 32768;

			return ((n2 << 16) | n1) + 32768 * Math.pow(2, 16);
		}

		return (n2 << 16) | n1;
	}

	function readString(arr) {
		var charArr = [];

		// turn all bytes into chars until the terminating null
		while (arr[0] !== 0) {
			charArr.push(String.fromCharCode(arr.shift()));
		}

		// throw away terminating null
		arr.shift();

		// join all characters into a cohesive string
		return charArr.join('');
	}

	/*
	 * Reads n number of bytes and return as an array.
	 *
	 * @param arr- Array of bytes to read from
	 * @param n- Number of bytes to read
	 */
	function readBytes(arr, n) {
		var i, ret = [];
		for (i = 0; i < n; i += 1) {
			ret.push(arr.shift());
		}

		return ret;
	}

	/*
	 * ZIPs a file in GZIP format. The format is as given by the spec, found at:
	 * http://www.gzip.org/zlib/rfc-gzip.html
	 *
	 * Omitted parts in this implementation:
	 */
	function zip(data, options) {
		var flags = 0,
			level,
			crc, out = [];

		if (!options) {
			options = {};
		}
		level = options.level || DEFAULT_LEVEL;

		if (typeof data === 'string') {
			data = Array.prototype.map.call(data, function (char) {
				return char.charCodeAt(0);
			});
		}

		// magic number marking this file as GZIP
		putByte(ID1, out);
		putByte(ID2, out);

		putByte(compressionMethods['deflate'], out);

		if (options.name) {
			flags |= possibleFlags['FNAME'];
		}

		putByte(flags, out);
		putLong(options.timestamp || parseInt(Date.now() / 1000, 10), out);

		// put deflate args (extra flags)
		if (level === 1) {
			// fastest algorithm
			putByte(4, out);
		} else if (level === 9) {
			// maximum compression (fastest algorithm)
			putByte(2, out);
		} else {
			putByte(0, out);
		}

		// OS identifier
		putByte(osMap[os], out);

		if (options.name) {
			// ignore the directory part
			putString(options.name.substring(options.name.lastIndexOf('/') + 1), out);

			// terminating null
			putByte(0, out);
		}

		deflate.deflate(data, level).forEach(function (byte) {
			putByte(byte, out);
		});

		putLong(parseInt(crc32(data), 16), out);
		putLong(data.length, out);

		return out;
	}

	function unzip(data, options) {
		// start with a copy of the array
		var arr = Array.prototype.slice.call(data, 0),
			t,
			compressionMethod,
			flags,
			mtime,
			xFlags,
			key,
			os,
			crc,
			size,
			res;

		// check the first two bytes for the magic numbers
		if (readByte(arr) !== ID1 || readByte(arr) !== ID2) {
			throw 'Not a GZIP file';
		}

		t = readByte(arr);
		t = Object.keys(compressionMethods).some(function (key) {
			compressionMethod = key;
			return compressionMethods[key] === t;
		});

		if (!t) {
			throw 'Unsupported compression method';
		}

		flags = readByte(arr);
		mtime = readLong(arr);
		xFlags = readByte(arr);
		t = readByte(arr);
		Object.keys(osMap).some(function (key) {
			if (osMap[key] === t) {
				os = key;
				return true;
			}
		});

		// just throw away the bytes for now
		if (flags & possibleFlags['FEXTRA']) {
			t = readShort(arr);
			readBytes(arr, t);
		}

		// just throw away for now
		if (flags & possibleFlags['FNAME']) {
			readString(arr);
		}

		// just throw away for now
		if (flags & possibleFlags['FCOMMENT']) {
			readString(arr);
		}

		// just throw away for now
		if (flags & possibleFlags['FHCRC']) {
			readShort(arr);
		}
		
		if (compressionMethod === 'deflate') {
			// give deflate everything but the last 8 bytes
			// the last 8 bytes are for the CRC32 checksum and filesize
			res = inflate.inflate(arr.splice(0, arr.length - 8));
		}

		if (flags & possibleFlags['FTEXT']) {
			res = Array.prototype.map.call(res, function (byte) {
				return String.fromCharCode(byte);
			}).join('');
		}
	
		crc = readLong(arr);
		if (crc !== parseInt(crc32(res), 16)) {
			throw 'Checksum does not match';
		}

		size = readLong(arr);
		if (size !== res.length) {
			throw 'Size of decompressed file not correct';
		}

		return res;
	}

	return {
		zip: zip,
		unzip: unzip,
		get DEFAULT_LEVEL() {
			return DEFAULT_LEVEL;
		}
	};
});

/******************************************************************************* 
* Copyright 2012, 2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES 
* 
* This file is part of SITools2. 
* 
* SITools2 is free software: you can redistribute it and/or modify 
* it under the terms of the GNU General Public License as published by 
* the Free Software Foundation, either version 3 of the License, or 
* (at your option) any later version. 
* 
* SITools2 is distributed in the hope that it will be useful, 
* but WITHOUT ANY WARRANTY; without even the implied warranty of 
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
* GNU General Public License for more details. 
* 
* You should have received a copy of the GNU General Public License 
* along with SITools2. If not, see <http://www.gnu.org/licenses/>. 
******************************************************************************/ 

define('FitsRequest',['gw/ImageRequest'], function(ImageRequest){

/**************************************************************************************************************/

/*
 *	Override send function to handle fits requests
 */
ImageRequest.prototype.send = function(url)
{
	var self = this;
	if ( url.search("fits") > 0 )
	{
		// Fits
		var xhr = new XMLHttpRequest();
		xhr.onreadystatechange = function(e)
		{
			if ( xhr && xhr.readyState == 4 )
			{
				if ( xhr.status == 200 )
				{
					if ( xhr.response )
					{
						self.image = xhr.response;
						if (self.successCallback)
						{
							self.successCallback(self);
						}
					}
				}
				else
				{
					if ( xhr.status != 0 )
					{
						// Fail
	                    console.log( "Error while loading " + url );
						if ( self.failCallback )
						{
							self.failCallback(self);
						}
					}
				}
				xhr = null;
			}
		};

		xhr.onabort = function(e)
		{
			if ( self.abortCallback )
			{
				self.abortCallback(self);
			}
			self.xhr = null;
		}

		xhr.open("GET", url);
		xhr.responseType = 'arraybuffer';
		xhr.send();
		this.xhr = xhr;
	}
	else
	{
		this.image = new Image();
		this.image.aborted = false;
		this.image.crossOrigin = '';
		this.image.dataType = "byte";
		this.image.onload = function(){
			var isComplete = self.image.naturalWidth != 0 && self.image.complete;
			if ( isComplete && !this.aborted )
			{
				self.successCallback.call(self);
			}
		}
		this.image.onerror = function(){
			if ( self.failCallback && !this.aborted )
				self.failCallback(self);
		};
		this.image.src = url;
	}
}

/**************************************************************************************************************/

/*
 *	Override abort
 */
ImageRequest.prototype.abort = function()
{
	if ( this.xhr )
	{
		this.xhr.abort();
	}
	else
	{
		if ( this.abortCallback )
		{
			this.image.aborted = true;
			this.abortCallback(this);
		}
		this.image.src = '';
	}
}

/**************************************************************************************************************/

});


/******************************************************************************* 
* Copyright 2012, 2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES 
* 
* This file is part of SITools2. 
* 
* SITools2 is free software: you can redistribute it and/or modify 
* it under the terms of the GNU General Public License as published by 
* the Free Software Foundation, either version 3 of the License, or 
* (at your option) any later version. 
* 
* SITools2 is distributed in the hope that it will be useful, 
* but WITHOUT ANY WARRANTY; without even the implied warranty of 
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
* GNU General Public License for more details. 
* 
* You should have received a copy of the GNU General Public License 
* along with SITools2. If not, see <http://www.gnu.org/licenses/>. 
******************************************************************************/ 

define('HEALPixFITSLayer',['gw/Utils', 'gw/HEALPixTiling', 'gw/RasterLayer', 'gw/DynamicImage', './FitsLoader', 'gzip', 'gw/ImageRequest', './FitsRequest'], 
	function(Utils, HEALPixTiling, RasterLayer, DynamicImage, FitsLoader, gZip, ImageRequest) {

/**************************************************************************************************************/

/** @export
	@constructor
	HEALPixFITSLayer constructor
*/
var HEALPixFITSLayer = function(options)
{
	RasterLayer.prototype.constructor.call( this, options );
	
	this.tilePixelSize = options.tilePixelSize || 512;
	this.tiling = new HEALPixTiling( options.baseLevel || 2, options );
	this.numberOfLevels = options.numberOfLevels || 10;
	this.type = "ImageryRaster";
	this.baseUrl = options['baseUrl'];
	this.dataType = options.dataType || "fits";
	this.coordSystem = options.coordSystem || "EQ";
	this._ready = false;
	this.fitsSupported = true;
	
	// allsky
	this.levelZeroImage = null;

	// TODO use DynamicImage shaders by unifying shader programs between TileManager and ConvexPolygonRenderer
	//		* inverse Y coordinates, some var names refactor..
	this.rawFragShader = "\
		precision lowp float; \n\
		varying vec2 texCoord;\n\
		uniform sampler2D colorTexture; \n\
		uniform float opacity; \n\
		uniform float inversed; \n\
		bool isnan(float val) {\n\
				return (val <= 0.0 || 0.0 <= val) ? ((val == 5e-324) ? true : false) : true;\n\
		}\n\
		void main(void)\n\
		{\n\
			vec4 color = texture2D(colorTexture, vec2(texCoord.x, (inversed == 1.) ? 1.0 - texCoord.y : texCoord.y));\n\
			gl_FragColor = vec4(color.r,color.g,color.b, color.a*opacity);\n\
			if (isnan( (gl_FragColor.r + gl_FragColor.g + gl_FragColor.b) / 3. ) )\n\
			{\n\
				gl_FragColor.a = 0.;\n\
			}\n\
		}\n\
		";

	this.colormapFragShader = "\
		precision lowp float; \n\
		varying vec2 texCoord;\n\
		uniform sampler2D colorTexture; \n\
		uniform sampler2D colormap; \n\
		uniform float min; \n\
		uniform float max; \n\
		uniform float opacity; \n\
		bool isnan(float val) {\n\
			return (val <= 0.0 || 0.0 <= val) ? false : true;\n\
		}\n\
		void main(void)\n\
		{\n\
			float i = texture2D(colorTexture,vec2(texCoord.x, 1.0 - texCoord.y)).r;\n\
			float d = clamp( ( i - min ) / (max - min), 0.0, 1.0 );\n\
			vec4 cmValue = texture2D(colormap, vec2(d,0.));\n\
			gl_FragColor = vec4(cmValue.r,cmValue.g,cmValue.b, cmValue.a*opacity);\n\
			if (isnan( i ) )\n\
			{\n\
				 gl_FragColor.a = 0.;\n\
			}\n\
		}\n\
		";

	this.customShader = {
		fragmentCode: this.rawFragShader,
		updateUniforms : function(gl, program){
			// Level zero image is required to init uniforms
			gl.uniform1f(program.uniforms["inversed"], self.inversed );
			if ( self.levelZeroImage )
			{
				gl.uniform1f(program.uniforms["max"], self.levelZeroImage.tmax );
				gl.uniform1f(program.uniforms["min"], self.levelZeroImage.tmin );

				gl.activeTexture(gl.TEXTURE1);
				gl.bindTexture(gl.TEXTURE_2D, self.levelZeroImage.colormapTex);
				gl.uniform1i(program.uniforms["colormap"], 1);
				gl.uniform1f(program.uniforms["opacity"], self.opacity() );
			}
		}
	}

	var self = this;
	// Request for level zero image
	this.imageRequest = new ImageRequest({
		successCallback: function(){

			self._ready = true;

			if ( self.dataType == "fits" )
			{
				// Unzip if g-zipped
				try {
					var data = new Uint8Array(self.imageRequest.image);
					var res = gZip.unzip( data );
					self.imageRequest.image = new Uint8Array( res ).buffer;
				}
				catch ( err )
				{
					if ( err != 'Not a GZIP file' )
					{
						// G-zip error
						console.error(err);
						this.failCallback();
						return;
					} else {
						// Image isn't g-zipped, handle image as fits
						console.log("not gzipped");
						data = null;
					}
				}

				self.handleImage(self.imageRequest);
				var fitsData = self.imageRequest.image;
				if ( self.globe )
				{
					// Create level zero image
					var gl = self.globe.renderContext.gl;
					self.levelZeroImage = new DynamicImage(self.globe.renderContext, fitsData.typedArray, gl.LUMINANCE, gl.FLOAT, fitsData.width, fitsData.height);
					self.getLevelZeroTexture = function()
					{
						return self.levelZeroImage.texture;
					}
				}
			}
			else
			{
				self.levelZeroImage = this.image;
				self.getLevelZeroTexture = null;
			}

			// Call callback if set
			if (options.onready && options.onready instanceof Function)
			{
				options.onready(self);
			}

			// Request a frame
			if ( self.globe )
			{
				self.globe.renderContext.requestFrame();
			}
		},
		failCallback: function(){
			if ( self.globe )
			{
				self.globe.publish("baseLayersError", self);
				self._ready = false;
				console.log( "Error while loading background");
			}
		},
		abortCallback: function(iq){
			self._ready = false;
			console.log("Background image request has been aborted");
		}
	});
}

/**************************************************************************************************************/

Utils.inherits(RasterLayer, HEALPixFITSLayer);

/**************************************************************************************************************/

/** 
 *	Attach the HEALPixFits layer to the globe
 */
HEALPixFITSLayer.prototype._attach = function( g )
{
	RasterLayer.prototype._attach.call( this, g );

	// Enable float texture extension to have higher luminance range
	var gl = this.globe.renderContext.gl;

	this.requestLevelZeroImage();
	var ext = gl.getExtension("OES_texture_float");

	if (!ext) {
		// TODO 
		console.error("no OES_texture_float");
		this.fitsSupported = false;
		//return;
	}
}

/**************************************************************************************************************/

/**
 *	Detach the HEALPixFits layer from the globe
 */
HEALPixFITSLayer.prototype._detach = function()
{
	// Abort image request if in progress
	if ( !this._ready )
	{
		this.imageRequest.abort();
	}
	this._ready = false;
	this.disposeResources();

	RasterLayer.prototype._detach.call( this );

}

/**************************************************************************************************************/

/**
 *	Get url from a given tile
 */
HEALPixFITSLayer.prototype.getUrl = function(tile)
{
	var url = this.baseUrl;
	
	url += "/Norder";
	url += tile.order;
	
	url += "/Dir";
	var indexDirectory = Math.floor(tile.pixelIndex/10000) * 10000;
	url += indexDirectory;
	
	url += "/Npix";
	url += tile.pixelIndex;
	url += "."+this.dataType;
	
	return url;
}

/**************************************************************************************************************/

/**
 *	Extract fits data from levelZeroImage.pixels to fitsPixel according to pixel index
 *
 *	@param pi Pixel index
 *	@param fitsPixel Resulting typed vector containing fits data
 *	@param sx X-offset of fitsPixel
 *	@param sy Y-offset of fitsPixel
 */
HEALPixFITSLayer.prototype.extractFitsData = function( pi, fitsPixel, sx, sy )
{
	var size = 64;
	var height = this.levelZeroImage.height;
	var width = this.levelZeroImage.width;
	var pixels = this.levelZeroImage.pixels;

	var startIndex = size * width * ( 28 - Math.floor(pi /27) ) + ( pi % 27 ) * size;

	// Extract fits data
	var typedLine;
	for ( var i=0; i<size; i++ )
	{
		typedLine = pixels.subarray( startIndex + i*width, startIndex + i*width + size );
		fitsPixel.set(typedLine, sy + i*128 + sx);
	}
}

/**************************************************************************************************************/

/**
 *	Generate the level0 texture for the tiles
 */
HEALPixFITSLayer.prototype.generateLevel0Textures = function(tiles,tilePool)
{
	if ( this.dataType != "fits" )
	{
		// Create a canvas to build the texture
		var canvas = document.createElement("canvas");
		canvas.width = 128;
		canvas.height = 128;
		
		var context = canvas.getContext("2d");
		
		for ( var i = 0; i < tiles.length; i++ )
		{
			var tile = tiles[i];
			
			// Top left
			var pi = tile.pixelIndex * 4;
			var sx = ( pi % 27) * 64;
			var sy = ( Math.floor(pi /27) ) * 64;
			context.drawImage(this.levelZeroImage,sx,sy,64,64,0,0,64,64);
			
			// Top right
			pi = tile.pixelIndex * 4 + 2;
			var sx = ( pi % 27) * 64;
			var sy = ( Math.floor(pi /27) ) * 64;
			context.drawImage(this.levelZeroImage,sx,sy,64,64,64,0,64,64);
			
			// Bottom left
			pi = tile.pixelIndex * 4 + 1;
			var sx = ( pi % 27) * 64;
			var sy = ( Math.floor(pi /27) ) * 64;
			context.drawImage(this.levelZeroImage,sx,sy,64,64,0,64,64,64);
			
			// Bottom right
			pi = tile.pixelIndex * 4 + 3;
			var sx = ( pi % 27) * 64;
			var sy = ( Math.floor(pi /27) ) * 64;
			context.drawImage(this.levelZeroImage,sx,sy,64,64,64,64,64,64);

			var imgData = context.getImageData(0, 0, 128, 128);
			imgData.dataType = 'byte';
			
			tile.texture = tilePool.createGLTexture( imgData );
			tile.imageSize = 128;
		}
	}
	else
	{
		for ( var i = 0; i < tiles.length; i++ )
		{
			var tile = tiles[i];		
			var fitsPixel = new Float32Array(128*128);

			// Top left
			var pi = tile.pixelIndex * 4;
			this.extractFitsData(pi, fitsPixel, 0, 128*64);
			
			// Top right
			pi = tile.pixelIndex * 4 + 2;
			this.extractFitsData(pi, fitsPixel, 64, 128*64);
			
			// Bottom left
			pi = tile.pixelIndex * 4 + 1;
			this.extractFitsData(pi, fitsPixel, 0, 0);
			
			// Bottom right
			pi = tile.pixelIndex * 4 + 3;
			this.extractFitsData(pi, fitsPixel, 64, 0);

			var imgData = {
				typedArray : fitsPixel,
				width : 128,
				height : 128,
				dataType : 'float'
			}
			
			tile.texture = tilePool.createGLTexture( imgData );
			tile.imageSize = 128;
		}
	}
}

/**************************************************************************************************************/

/**
 *	Handle fits image
 */
HEALPixFITSLayer.prototype.handleImage = function(imgRequest)
{
 	if ( !(imgRequest.image instanceof Image) )
 	{
	 	var fits = FitsLoader.parseFits( imgRequest.image );
	 	var fitsData = fits.getHDU().data;
	 	var bpe = fitsData.arrayType.BYTES_PER_ELEMENT;
	 	var float32array;
	 	if ( fitsData.arrayType.name == "Float64Array" )
	 	{
	 		var float64array = new Float64Array( fitsData.view.buffer, fitsData.begin, fitsData.length/bpe ); // bpe = 8
	 		var float32array = new Float32Array( fitsData.length/bpe );
	 		// Create Float32Array from Float64Array
	 		for ( var i=0; i<float64array.length; i++ )
	 		{
	 			float32array[i] = float64array[i];
	 		}
	 	}
	 	else
	 	{
	 		float32array = new Float32Array( fitsData.view.buffer, fitsData.begin, fitsData.length/bpe ); // with gl.FLOAT, bpe = 4
	 	}

	 	// // Handle different types/formats.. just in case.
	 	// var dataType;
	 	// var typedArray;
	 	// var gl = this.globe.renderContext.gl;
	 	// var glType;
	 	// if ( fitsData.arrayType.name == "Float32Array" )
	 	// {
	 	// 	typedArray = new Float32Array( fitsData.view.buffer, fitsData.begin, fitsData.length/fitsData.arrayType.BYTES_PER_ELEMENT );
	 	// 	dataType = "float";
	 	// 	glType = gl.FLOAT;
	 	// 	glFormat = gl.LUMINANCE;
	 	// }
	 	// else if ( fitsData.arrayType.name == "Uint8Array" )
	 	// {
	 	// 	typedArray = new Uint8Array( fitsData.view.buffer, fitsData.begin, fitsData.length/fitsData.arrayType.BYTES_PER_ELEMENT )
	 	// 	dataType = "int";
	 	// 	glType = gl.UNSIGNED_BYTE;
	 	// 	glFormat = gl.LUMINANCE;
	 	// }

	 	imgRequest.image = {
			typedArray: float32array,
			width: fitsData.width,
			height: fitsData.height,
			dataType: "float"
		};
		
	}
}

/**************************************************************************************************************/

/**
 *	Request level zero image
 */
HEALPixFITSLayer.prototype.requestLevelZeroImage = function()
{
	// Set dataType always to jpg if fits isn't supported by graphic card
	if ( !this.fitsSupported )
	{
		this.dataType = 'jpg';
	}

	// Revert to raw rendering
	this.customShader.fragmentCode = this.rawFragShader;
	if ( this.dataType == "fits" )
	{
		this.inversed = 1.;
	}
	else
	{
		this.inversed = 0.;
	}

	var url = this.baseUrl + "/Norder3/Allsky."+this.dataType;
	this.imageRequest.send(url);
}

/**************************************************************************************************************/

/**
 *	Dispose the allocated resources
 */
HEALPixFITSLayer.prototype.disposeResources = function()
{
	// Dispose level zero image & texture
	if ( this.levelZeroImage && this.levelZeroImage.dispose )
		this.levelZeroImage.dispose();
	if ( this.levelZeroTexture )
		this.globe.renderContext.gl.deleteTexture(this.levelZeroTexture);
	
	this.levelZeroImage = null;
	this.levelZeroTexture = null;
}

/**************************************************************************************************************/

/**
 *	Set datatype
 */
HEALPixFITSLayer.prototype.setDatatype = function(isFits)
{
	// Abort image request if in progress
	if ( !this._ready )
	{
		this.imageRequest.abort();
	}
	this._ready = false;
	//this.disposeResources();

	this.dataType = (isFits) ? 'fits' : 'jpg';
	//this.requestLevelZeroImage();
}

/**************************************************************************************************************/

return HEALPixFITSLayer;

});
/******************************************************************************* 
* Copyright 2012, 2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES 
* 
* This file is part of SITools2. 
* 
* SITools2 is free software: you can redistribute it and/or modify 
* it under the terms of the GNU General Public License as published by 
* the Free Software Foundation, either version 3 of the License, or 
* (at your option) any later version. 
* 
* SITools2 is distributed in the hope that it will be useful, 
* but WITHOUT ANY WARRANTY; without even the implied warranty of 
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
* GNU General Public License for more details. 
* 
* You should have received a copy of the GNU General Public License 
* along with SITools2. If not, see <http://www.gnu.org/licenses/>. 
******************************************************************************/ 

/**
 * IFrame module : popup appearing when clicking on external link
 */
define('IFrame',["jquery"], function($) {

var iframe = 
	'<div id="externalIFrame" class="contentBox">\
		<div id="IFrameToolbar" class="ui-widget-header ui-widget-header ui-corner-all">\
		  <button id="previous">Previous page</button>\
		  <button id="next">Next page</button>\
		</div>\
		<div class="closeBtn">\
			<span class="defaultImg"></span>\
			<span style="opacity: 0" class="hoverImg"></span>\
		</div>\
		<iframe src=""><p>Your browser does not support iframes.</p></iframe>\
	</div>';
	
/**
 * Private variables for the module
 */
var $iframeDiv;
var history;

/**
 * Init the module
 */
function _init() {
	// Create the frame div and append it to the page
	$iframeDiv = $(iframe).appendTo('body');

	// Create the object to manage history
	history = {
		pile : [],
		index: 0,
		clicked: false,
		clean: function()
		{
			this.pile.length = 0;
			this.index = 0;
			this.clicked = false;
		}
	};

	$( "#previous" ).button({
		width: 20,
		height: 20,
		text: false,
		icons: {
			primary: "ui-icon-circle-triangle-w"
		}
	}).click(function(event){
		event.preventDefault();
		//console.log('prev : '+history.index);
		if ( history.index > 1 )
		{
			history.index--;
			history.clicked = true;
			$iframeDiv.find('iframe')[0].contentWindow.history.back();
		}
	});

	$( "#next" ).button({
		width: 20,
		height: 20,
		text: false,
		icons: {
			secondary: "ui-icon-circle-triangle-e"
		}
	}).click(function(event){
		event.preventDefault();
		//console.log('next : '+history.index);
		if ( history.index != history.pile.length )
		{
			history.index++;
			history.clicked = true;
			$iframeDiv.find('iframe')[0].contentWindow.history.forward();
		}
	});

	$iframeDiv.find('iframe').on('load', function(){
		//console.log('onLoad : clicked: '+history.clicked+'index : '+history.index);
		if ( history.clicked )
		{
			history.clicked = false;
			return false;
		}
		
		// Update history
		history.pile.splice(history.index);
		history.pile.push($iframeDiv.find('iframe')[0].attributes.src.nodeValue);
		history.index++;
	});
};

return {
	/**
	 *	Hide iframe
	 */
	hide: function() {
		if ($iframeDiv) {
			$iframeDiv.animate({top: -1000}, 800);
		}
	},

	/**
	 *	Show iframe
	 *
	 *	@param html External link url
	 */
	show: function( html ){
	
		if (!$iframeDiv) {
			_init();
		}
		
		history.clean();
		historyClick = false;
		var canvasWidth = parseInt( $('#GlobWebCanvas').css("width") );
		var canvasHeight = parseInt( $('#GlobWebCanvas').css("height") );
		var optimalWidth = canvasWidth * 0.8;
		var optimalHeight = canvasHeight * 0.8;
		var optimalTop = canvasHeight * 0.1;
		$iframeDiv.find('iframe').css({ width: optimalWidth, height: optimalHeight }).attr('src',html);
		$iframeDiv.animate({top: optimalTop}, 800);
	}
};

});

/******************************************************************************* 
* Copyright 2012, 2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES 
* 
* This file is part of SITools2. 
* 
* SITools2 is free software: you can redistribute it and/or modify 
* it under the terms of the GNU General Public License as published by 
* the Free Software Foundation, either version 3 of the License, or 
* (at your option) any later version. 
* 
* SITools2 is distributed in the hope that it will be useful, 
* but WITHOUT ANY WARRANTY; without even the implied warranty of 
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
* GNU General Public License for more details. 
* 
* You should have received a copy of the GNU General Public License 
* along with SITools2. If not, see <http://www.gnu.org/licenses/>. 
******************************************************************************/ 

/**
 * 	JSON processor module
 *
 *	Module processing feature collection
 *
 */
define('JsonProcessor',["gw/HEALPixLayer", "gw/CoordinateSystem"], function(HEALPixLayer, CoordinateSystem) {

var gid = 0;

/**
 *	Handle services of feature
 */
function handleServices( gwLayer, feature )
{
	for ( var x in feature.services )
	{
		var service = feature.services[x];
		if ( !gwLayer.subLayers )
		{
			gwLayer.subLayers = [];
		}
		switch (service.type)
		{
			case "healpix":
				service.layer = new HEALPixLayer({ dataType: service.dataType, baseUrl: service.url, name: service.name, visible: false, coordinates: feature.geometry.coordinates[0] });
				gwLayer.subLayers.push(service.layer);
				if ( gwLayer.globe && gwLayer.visible() )
				{
					// Add sublayer to engine
					gwLayer.globe.addLayer( service.layer );
				}
				break;
			default:
				break;
		}
	}
}

return {
	/**
	 *	Handles feature collection
	 * 	Recompute geometry from equatorial coordinates to geo for each feature
	 *	Handle feature services
	 *	Add gid
	 *
	 *	@param gwLayer Layer of feature
	 *	@param featureCollection GeoJSON FeatureCollection
	 *
	 */
	handleFeatureCollection: function( gwLayer, featureCollection )
	{
		var features = featureCollection['features'];

		for ( var i=0; i<features.length; i++ )
		{
			var currentFeature = features[i];
			
			var coordSystem = "EQ"; // default coordinate system of json data
			// Apply crs if defined
			if ( currentFeature.properties.crs )
			{
				var crsName = currentFeature.properties.crs.properties.name;
				coordSystem = crsName.substr(0, crsName.indexOf('.'));
				if ( coordSystem.length > 3 )
				{
					switch( coordSystem.toLowerCase() ) {
						case "equatorial":
							coordSystem = "EQ";
							break;
						case "galactic":
							coordSystem = "GAL";
							break;
						default:
							console.log("Not implemented");
							break;
					}
				}
			}
			switch ( currentFeature.geometry.type )
			{
				case "Point":
					if ( !gwLayer.dataType )
						gwLayer.dataType = "point";
					else if ( gwLayer.dataType != 'point' )
						gwLayer.dataType = "none";

					// Convert to EQUATORIAL coordinate system if needed
					if ( 'EQ' != coordSystem )
					{
						currentFeature.geometry.coordinates = CoordinateSystem.convert(currentFeature.geometry.coordinates, coordSystem, 'EQ');
					}

					// Convert to geographic representation
					if ( currentFeature.geometry.coordinates[0] > 180 )
						currentFeature.geometry.coordinates[0] -= 360;
					break;
				case "Polygon":
				case "MultiPolygon":

					if ( !gwLayer.dataType )
						gwLayer.dataType = "line";
					else if ( gwLayer.dataType != 'line' )
						gwLayer.dataType = "none";

					var rings = [];
					var geometry = currentFeature.geometry;
					if ( geometry['type'] == 'MultiPolygon' )
					{
						for ( var j=0; j<geometry['coordinates'].length; j++ )
						{
							rings.push( geometry['coordinates'][j][0] );
						}
					}
					else
					{
						rings.push( geometry['coordinates'][0] );
					}

					for ( var r=0; r<rings.length; r++ )
					{
						var coords = rings[r];
						var numPoints = coords.length;
						for ( var j=0; j<numPoints; j++ )
						{
							// Convert to default coordinate system if needed
							if ( 'EQ' != coordSystem )
							{
								coords[j] = CoordinateSystem.convert(coords[j], coordSystem, 'EQ');
							}

							// Convert to geographic representation
							if ( coords[j][0] > 180 )
								coords[j][0] -= 360;
						}
					}
					
					if ( currentFeature.properties._imageCoordinates )
					{
						// Set _imageCoordinates as geometry's property (may be modified later)
						for ( var r=0; r<currentFeature.properties._imageCoordinates[0].length; r++ )
						{
							// Convert to geographic representation
							if ( currentFeature.properties._imageCoordinates[0][r][0] > 180 )
								currentFeature.properties._imageCoordinates[0][r][0] -= 360;
							
						}
						currentFeature.geometry._imageCoordinates = currentFeature.properties._imageCoordinates;
					}

					break;
				default:
					break;
			}
			currentFeature.geometry.gid = "jsonProc_"+gid;
			gid++;

			if ( currentFeature.services )
			{
				handleServices(gwLayer, currentFeature);
			}

		}
	}
};

});
// Generated by CoffeeScript 1.3.3
(function() {
  var WCS,
    __bind = function(fn, me){
      return function(){
        return fn.apply(me, arguments);
      };
    },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  WCS = (typeof exports !== "undefined" && exports !== null) && this || (this.WCS = {});

  WCS.Math = {};

  WCS.Math.R2D = 180 / Math.PI;

  WCS.Math.D2R = Math.PI / 180;

  WCS.Math.WCSTRIG_TOL = 1e-10;

  WCS.Math.cosd = function(angle) {
    var i;
    if (angle % 90 === 0) {
      i = Math.abs(Math.floor(angle / 90 + 0.5)) % 4;
      switch (i) {
        case 0:
          return 1;
        case 1:
          return 0;
        case 2:
          return -1;
        case 3:
          return 0;
      }
    }
    return Math.cos(angle * WCS.Math.D2R);
  };

  WCS.Math.sind = function(angle) {
    var i;
    if (angle % 90 === 0) {
      i = Math.abs(Math.floor(angle / 90 - 0.5)) % 4;
      switch (i) {
        case 0:
          return 1;
        case 1:
          return 0;
        case 2:
          return -1;
        case 3:
          return 0;
      }
    }
    return Math.sin(angle * WCS.Math.D2R);
  };

  WCS.Math.sincosd = function(angle) {
    var c, i, s, _ref, _ref1;
    if (angle % 90 === 0) {
      i = Math.abs(Math.floor(angle / 90 + 0.5)) % 4;
      switch (i) {
        case 0:
          s = 0;
          c = 1;
          break;
        case 1:
          s = (_ref = angle > 0) != null ? _ref : {
            1: -1
          };
          c = 0;
          break;
        case 2:
          s = 0;
          c = -1;
          break;
        case 3:
          s = (_ref1 = angle > 0) != null ? _ref1 : -{
            1: 1
          };
          c = 0;
      }
      return s * c;
    }
    s = Math.sin(angle * WCS.Math.D2R);
    c = Math.cos(angle * WCS.Math.D2R);
    return s * c;
  };

  WCS.Math.tand = function(angle) {
    var resid;
    resid = angle & 360;
    if (resid === 0 || Math.abs(resid) === 180) {
      return 0;
    } else if (resid === 45 || resid === 225) {
      return 1;
    } else if (resid === -135 || resid === -315) {
      return -1;
    }
    return Math.tan(angle * WCS.Math.D2R);
  };

  WCS.Math.acosd = function(v) {
    if (v >= 1) {
      if (v - 1 < WCS.Math.WCSTRIG_TOL) {
        return 0;
      }
    } else if (v === 0) {
      return 90;
    } else if (v <= -1) {
      if (v + 1 > -WCS.Math.WCSTRIG_TOL) {
        return 180;
      }
    }
    return Math.acos(v) * WCS.Math.R2D;
  };

  WCS.Math.asind = function(v) {
    if (v <= -1) {
      if (v + 1 > -WCS.Math.WCSTRIG_TOL) {
        return -90;
      } else if (v === 0) {
        return 0;
      } else if (v >= 1) {
        if (v - 1 < WCS.Math.WCSTRIG_TOL) {
          return 90;
        }
      }
    }
    return Math.asin(v) * WCS.Math.R2D;
  };

  WCS.Math.atand = function(v) {
    if (v === -1) {
      return -45;
    } else if (v === 0) {
      return 0;
    } else if (v === 1) {
      return 45;
    }
    return Math.atan(v) * WCS.Math.R2D;
  };

  WCS.Math.atan2d = function(y, x) {
    if (y === 0) {
      if (x >= 0) {
        return 0;
      } else if (x < 0) {
        return 180;
      }
    } else if (x === 0) {
      if (y > 0) {
        return 90;
      } else if (y < 0) {
        return -90;
      }
    }
    return Math.atan2(y, x) * WCS.Math.R2D;
  };

  WCS.Math.toRightTriangular = function(mat) {
    var els, i, j, k, kp, multiplier, n, np, p;
    n = mat.length;
    k = n;
    kp = mat[0].length;
    while (true) {
      i = k - n;
      if (mat[i][i] === 0) {
        j = i + 1;
        while (j < k) {
          if (mat[j][i] !== 0) {
            els = [];
            np = kp;
            while (true) {
              p = kp - np;
              els.push(mat[i][p] + mat[j][p]);
              if (!--np) {
                break;
              }
            }
            mat[i] = els;
            break;
          }
          j += 1;
        }
      }
      if (mat[i][i] !== 0) {
        j = i + 1;
        while (j < k) {
          multiplier = mat[j][i] / mat[i][i];
          els = [];
          np = kp;
          while (true) {
            p = kp - np;
            els.push((p <= i ? 0 : mat[j][p] - mat[i][p] * multiplier));
            if (!--np) {
              break;
            }
          }
          mat[j] = els;
          j += 1;
        }
      }
      if (!--n) {
        break;
      }
    }
    return mat;
  };

  WCS.Math.determinant = function(mat) {
    var det, i, k, m, n;
    m = WCS.Math.toRightTriangular(mat);
    det = m[0][0];
    n = m.length - 1;
    k = n;
    while (true) {
      i = k - n + 1;
      det = det * m[i][i];
      if (!--n) {
        break;
      }
    }
    return det;
  };

  WCS.Math.matrixInverse = function(m) {
    var I, h, i, inv, j, mat, temp, w;
    w = m[0].length;
    h = m.length;
    I = new Array(h);
    inv = new Array(h);
    temp = [];
    mat = [];
    j = 0;
    while (j < h) {
      mat[j] = [];
      i = 0;
      while (i < w) {
        mat[j][i] = m[j][i];
        i += 1;
      }
      j += 1;
    }
    j = 0;
    while (j < h) {
      I[j] = new Array(w);
      inv[j] = new Array(w);
      i = 0;
      while (i < w) {
        I[j][i] = (i === j ? 1 : 0);
        i += 1;
      }
      temp[j] = mat[j].concat(I[j]);
      j += 1;
    }
    WCS.Math.gaussJordan(temp);
    j = 0;
    while (j < h) {
      inv[j] = temp[j].slice(w, 2 * w);
      j += 1;
    }
    return inv;
  };

  WCS.Math.gaussJordan = function (m, eps) {
  if (!eps) eps = 1e-10;
  var h, w, y, y2, x, maxrow, tmp, c;
  h = m.length;
  w = m[0].length;
  y = -1;

  while (++y < h) {
    maxrow = y;

    // Find max pivot.
    y2 = y;
    while (++y2 < h) {
      if (Math.abs(m[y2][y]) > Math.abs(m[maxrow][y]))
        maxrow = y2;
    }

    // Swap.
    tmp = m[y];
    m[y] = m[maxrow];
    m[maxrow] = tmp;

    // Singular?
    if (Math.abs(m[y][y]) <= eps)
      return false;

    // Eliminate column y.
    y2 = y;
    while (++y2 < h) {
      c = m[y2][y] / m[y][y];
      x = y - 1;
      while (++x < w) {
        m[y2][x] -= m[y][x] * c;
      }
    }
  }

  // Backsubstitute.
  y = h;
  while (--y >= 0) {
    c = m[y][y];
    y2 = -1;
    while (++y2 < y) {
      x = w;
      while (--x >= y) {
        m[y2][x] -=  m[y][x] * m[y2][y] / c;
      }
    }
    m[y][y] /= c;
    // Normalize row y.
    x = h - 1;
    while (++x < w) {
      m[y][x] /= c;
    }
  }
  return true;
};;

  WCS.Mapper = (function() {

    function Mapper(header) {
      this.coordinateToPixel = __bind(this.coordinateToPixel, this);

      this.pixelToCoordinate = __bind(this.pixelToCoordinate, this);

      this.fromCelestial = __bind(this.fromCelestial, this);

      this.toCelestial = __bind(this.toCelestial, this);

      this.fromIntermediate = __bind(this.fromIntermediate, this);

      this.toIntermediate = __bind(this.toIntermediate, this);

      this.computeCelestialParameters = __bind(this.computeCelestialParameters, this);

      this.getSipCoefficients = __bind(this.getSipCoefficients, this);

      this.setProjection = __bind(this.setProjection, this);

      this.derivePC = __bind(this.derivePC, this);

      this.checkCard = __bind(this.checkCard, this);

      this.verifyHeader = __bind(this.verifyHeader, this);
      this.wcsobj = {};
      this.projection = void 0;
      this.longitudeAxis = void 0;
      this.latitudeAxis = void 0;
      this.sip = void 0;
      this.verifyHeader(header);
      this.setProjection(header);
    }

    Mapper.prototype.verifyHeader = function(header) {
      var arrayName, axis, date, j, key, naxis, requiredCards, _i, _j, _k, _ref;
      this.wcsobj.naxis = naxis = header['NAXIS'] || header['WCSAXES'] || 2;
      this.wcsobj.radesys = header['RADESYS'] || 'ICRS';
      requiredCards = ['CRPIX', 'CRVAL', 'CTYPE'];
      this.wcsobj.crpix = [];
      this.wcsobj.crval = [];
      this.wcsobj.ctype = [];
      for (axis = _i = 1; 1 <= naxis ? _i <= naxis : _i >= naxis; axis = 1 <= naxis ? ++_i : --_i) {
        for (j = _j = 0, _ref = requiredCards.length - 1; 0 <= _ref ? _j <= _ref : _j >= _ref; j = 0 <= _ref ? ++_j : --_j) {
          key = requiredCards[j] + axis;
          if (!header.hasOwnProperty(key)) {
            throw "Not enough information to compute WCS, missing required keyword " + key;
          }
          arrayName = requiredCards[j].toLowerCase();
          this.wcsobj[arrayName].push(header[key]);
        }
      }
      this.wcsobj.cunit = [];
      this.wcsobj.cdelt = [];
      for (axis = _k = 1; 1 <= naxis ? _k <= naxis : _k >= naxis; axis = 1 <= naxis ? ++_k : --_k) {
        key = 'CUNIT' + axis;
        this.wcsobj.cunit.push(header[key] || 'deg');
        key = 'CDELT' + axis;
        this.wcsobj.cdelt.push(header[key] || 1);
      }
      this.wcsobj.lonpole = header['LONPOLE'] || 0;
      this.wcsobj.latpole = header['LATPOLE'] || 0;
      this.wcsobj.equinox = header['EQUINOX'] || 2000;
      date = new Date();
      this.wcsobj.dateObs = header['DATE_OBS'] || (date.getFullYear() + '-' + (date.getMonth() + 1) + '-' + date.getDate());
      this.wcsobj.dateObs = header['DATE_OBS'] || ("" + (date.getFullYear()) + "-" + (date.getMonth() + 1) + "-" + (date.getDate()));
      this.wcsobj.pc = this.checkCard(header, 'PC', naxis) || this.derivePC(header);
      this.wcsobj.pcInv = WCS.Math.matrixInverse(this.wcsobj.pc);
      this.wcsobj.cd = this.checkCard(header, 'CD', naxis);
      if (this.wcsobj.cd != null) {
        return this.wcsobj.cdInv = WCS.Math.matrixInverse(this.wcsobj.cd);
      }
    };

    Mapper.prototype.checkCard = function(header, key, dimensions) {
      var fullKey, i, j, obj, _i, _j;
      obj = [];
      for (i = _i = 1; 1 <= dimensions ? _i <= dimensions : _i >= dimensions; i = 1 <= dimensions ? ++_i : --_i) {
        obj[i - 1] = [];
        for (j = _j = 1; 1 <= dimensions ? _j <= dimensions : _j >= dimensions; j = 1 <= dimensions ? ++_j : --_j) {
          fullKey = "" + key + i + "_" + j;
          if (!header.hasOwnProperty(fullKey)) {
            return;
          }
          obj[i - 1].push(header[fullKey]);
        }
      }
      return obj;
    };

    Mapper.prototype.derivePC = function(header) {
      var cd, cd11, cd12, cd21, cd22, cos_rho, crota, lambda, rho_a, rho_b, _ref;
      if (header.hasOwnProperty('CROTA2')) {
        crota = header['CROTA2'];
        lambda = this.wcsobj.cdelt[1] / this.wcsobj.cdelt[0];
      } else {
        cd = this.checkCard(header, 'CD', this.wcsobj.naxis);
        if (cd == null) {
          _ref = [0, 1], crota = _ref[0], lambda = _ref[1];
        } else {
          cd11 = cd[0][0];
          cd12 = cd[0][1];
          cd21 = cd[1][0];
          cd22 = cd[1][1];
          if (cd21 > 0) {
            rho_a = Math.atan2(cd21, cd11);
          } else if (cd21 === 0) {
            rho_a = 0;
          } else {
            rho_a = Math.atan2(-cd21, -cd11);
          }
          if (cd12 > 0) {
            rho_b = Math.atan2(cd12, -cd22);
          } else if (cd12 === 0) {
            rho_b = 0;
          } else {
            rho_b = Math.atan2(-cd21, cd22);
          }
          crota = 0.5 * (rho_a + rho_b);
          cos_rho = Math.cos(crota);
          this.wcsobj.cdelt1 = cd11 / cos_rho;
          this.wcsobj.cdelt2 = cd22 / cos_rho;
          lambda = this.wcsobj.cdelt2 / this.wcsobj.cdelt1;
        }
      }
      return cd;
    };

    Mapper.prototype.setProjection = function(header) {
      var conic, cylindrical, key, key1, key2, key3, polyConic, quadCube, zenithal, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8,
        _this = this;
      zenithal = ['AIR', 'ARC', 'AZP', 'NCP', 'SIN', 'STG', 'SZP', 'TAN', 'TAN-SIP', 'ZEA', 'ZPN'];
      cylindrical = ['CYP', 'CEA', 'CAR', 'MER', 'SFL', 'PAR', 'MOL', 'AIT'];
      conic = ['COP', 'COE', 'COD', 'COO'];
      polyConic = ['BON', 'PCO'];
      quadCube = ['TSC', 'CSC', 'QSC'];
      this.projection = this.wcsobj.ctype[0].slice(5);
      this.longitudeAxis = this.wcsobj.ctype[0].match("RA|GLON|ELON|HLON|SLON") ? 1 : 2;
      this.latitudeAxis = this.wcsobj.ctype[1].match("DEC|GLAT|ELAT|HLAT|SLAT") ? 2 : 1;
      if (_ref = this.projection, __indexOf.call(zenithal, _ref) >= 0) {
        this.wcsobj.phi0 = 0;
        this.wcsobj.theta0 = 90;
        this.wcsobj.alphaP = this.wcsobj.crval[0];
        this.wcsobj.deltaP = this.wcsobj.crval[1];
        this.wcsobj.lonpole = this.wcsobj.crval[1] >= this.wcsobj.theta0 ? 0 : 180;
        switch (this.projection) {
          case 'AIR':
            key = "PV" + this.latitudeAxis + "_1";
            this.wcsobj.thetaB = header.hasOwnProperty(key) ? parseFloat(header[key]) : 90;
            this.wcsobj.etaB = (90 - this.wcsobj.thetaB) / 2;
            ({
              toSpherical: function(x, y) {
                throw 'Sorry, not yet implemented!';
              },
              fromSpherical: function(phi, theta) {
                throw 'Sorry, not yet implemented!';
              }
            });
            break;
          case 'ARC':
            this.toSpherical = function(x, y) {
              var phi, r, theta;
              r = Math.sqrt(x * x + y * y);
              theta = _this.wcsobj.theta0 - r;
              phi = WCS.Math.atan2d(x, -y);
              return [phi, theta];
            };
            this.fromSpherical = function(phi, theta) {
              var r, x, y;
              r = 90 - theta;
              x = r * WCS.Math.sind(phi);
              y = -r * WCS.Math.cosd(phi);
              return [x, y];
            };
            break;
          case 'AZP':
            _ref1 = ["PV" + this.latitudeAxis + "_1", "PV" + this.latitudeAxis + "_2"], key1 = _ref1[0], key2 = _ref1[1];
            this.wcsobj.mu = header.hasOwnProperty(key1) ? parseFloat(header[key1]) : 0;
            this.wcsobj.gamma = header.hasOwnProperty(key2) ? parseFloat(header[key2]) : 0;
            this.toSpherical = function(x, y) {
              throw 'Sorry, not yet implemented!';
            };
            this.fromSpherical = function(phi, theta) {
              throw 'Sorry, not yet implemented!';
            };
            break;
          case 'NCP':
            this.toSpherical = function(x, y) {
              throw 'Sorry, not yet implemented!';
            };
            this.fromSpherical = function(phi, theta) {
              throw 'Sorry, not yet implemented!';
            };
            break;
          case 'SIN':
            _ref2 = ["PV" + this.latitudeAxis + "_1", "PV" + this.latitudeAxis + "_2"], key1 = _ref2[0], key2 = _ref2[1];
            this.wcsobj.eta = header.hasOwnProperty(key1) ? parseFloat(header[key1]) : 0;
            this.wcsobj.nu = header.hasOwnProperty(key2) ? parseFloat(header[key2]) : 0;
            this.toSpherical = function(x, y) {
              var phi, r, theta;
              r = Math.sqrt(x * x + y * y);
              theta = WCS.Math.acosd(Math.PI * r / 180);
              phi = WCS.Math.atan2d(x, -y);
              return [phi, theta];
            };
            this.fromSpherical = function(phi, theta) {
              var r, x, y;
              r = 180 / Math.PI * WCS.Math.cosd(theta);
              x = r * WCS.Math.sind(phi);
              y = -r * WCS.Math.cosd(phi);
              return [x, y];
            };
            break;
          case 'STG':
            this.toSpherical = function(x, y) {
              var phi, r, theta;
              r = Math.sqrt(x * x + y * y);
              theta = _this.wcsobj.theta0 - 2 * WCS.Math.atand(Math.PI * r / 360);
              phi = WCS.Math.atan2d(x, -y);
              return [phi, theta];
            };
            this.fromSpherical = function(phi, theta) {
              var r, x, y;
              r = 360 / Math.PI * WCS.Math.tand((90 - theta) / 2);
              x = r * WCS.Math.sind(phi);
              y = -r * WCS.Math.cosd(phi);
              return [x, y];
            };
            break;
          case 'SZP':
            _ref3 = ["PV" + this.latitudeAxis + "_1", "PV" + this.latitudeAxis + "_2", "PV" + this.latitudeAxis + "_3"], key1 = _ref3[0], key2 = _ref3[1], key3 = _ref3[2];
            this.wcsobj.mu = header.hasOwnProperty(key1) ? parseFloat(header[key1]) : 0;
            this.wcsobj.phiC = header.hasOwnProperty(key2) ? parseFloat(header[key2]) : 0;
            this.wcsobj.thetaC = header.hasOwnProperty(key3) ? parseFloat(header[key3]) : 90;
            this.wcsobj.xp = -this.wcsobj.mu * WCS.Math.cosd(this.wcsobj.thetaC) * WCS.Math.sind(this.wcsobj.phiC);
            this.wcsobj.yp = this.wcsobj.mu * WCS.Math.cosd(this.wcsobj.thetaC) * WCS.Math.cosd(this.wcsobj.phiC);
            this.wcsobj.zp = this.wcsobj.mu * WCS.Math.sind(this.wcsobj.thetaC) + 1;
            this.toSpherical = function(x, y) {
              throw 'Sorry, not yet implemented';
            };
            this.fromSpherical = function(phi, theta) {
              var divisor, x, y;
              throw 'Sorry, not yet implemented';
              divisor = _this.wcsobj.zp - 1 + WCS.Math.sind(theta);
              x = (180 / Math.PI) * (_this.wcsobj.zp * WCS.Math.cosd(theta) * WCS.Math.sind(phi) - _this.wcsobj.xp * (1 - WCS.Math.sind(theta))) / divisor;
              y = (-180 / Math.PI) * (_this.wcsobj.zp * WCS.Math.cosd(theta) * WCS.Math.cosd(phi) + _this.wcsobj.yp * (1 - WCS.Math.sind(theta))) / divisor;
              return [x, y];
            };
            break;
          case 'TAN':
            this.toSpherical = function(x, y) {
              var phi, r, theta;
              r = Math.sqrt(x * x + y * y);
              theta = WCS.Math.atand(180 / (Math.PI * r));
              phi = WCS.Math.atan2d(x, -y);
              return [phi, theta];
            };
            this.fromSpherical = function(phi, theta) {
              var r, x, y;
              r = 180 / (Math.PI * WCS.Math.tand(theta));
              x = r * WCS.Math.sind(phi);
              y = -r * WCS.Math.cosd(phi);
              return [x, y];
            };
            break;
          case 'TAN-SIP':
            this.getSipCoefficients(header);
            this.f = function(u, v, coeffs) {
              var order, p, q, value, _i, _j;
              value = 0;
              order = coeffs[0].length - 1;
              for (p = _i = 0; 0 <= order ? _i <= order : _i >= order; p = 0 <= order ? ++_i : --_i) {
                for (q = _j = 0; 0 <= order ? _j <= order : _j >= order; q = 0 <= order ? ++_j : --_j) {
                  value += coeffs[p][q] * Math.pow(u, p) * Math.pow(v, q);
                }
              }
              return value;
            };
            this.toIntermediate = function(points) {
              var dx, dy, i, j, proj, u, v, _i, _j, _ref4, _ref5;
              proj = [];
              u = points[0] - _this.wcsobj.crpix[0];
              v = points[1] - _this.wcsobj.crpix[1];
              dx = dy = 0;
              dx = _this.f(u, v, _this.sip.aCoeffs);
              dy = _this.f(u, v, _this.sip.bCoeffs);
              points[0] = points[0] + dx;
              points[1] = points[1] + dy;
              for (i = _i = 0, _ref4 = _this.wcsobj.naxis - 1; 0 <= _ref4 ? _i <= _ref4 : _i >= _ref4; i = 0 <= _ref4 ? ++_i : --_i) {
                proj[i] = 0;
                points[i] -= _this.wcsobj.crpix[i];
                for (j = _j = 0, _ref5 = _this.wcsobj - 1; 0 <= _ref5 ? _j <= _ref5 : _j >= _ref5; j = 0 <= _ref5 ? ++_j : --_j) {
                  proj[i] += _this.wcsobj.cd[i][j] * points[j];
                }
              }
              return proj;
            };
            this.fromIntermediate = function(proj) {
              var dx, dy, i, j, points, tmp, _i, _j, _ref4, _ref5;
              tmp = [];
              for (i = _i = 0, _ref4 = _this.wcsobj.naxis - 1; 0 <= _ref4 ? _i <= _ref4 : _i >= _ref4; i = 0 <= _ref4 ? ++_i : --_i) {
                tmp[i] = 0;
                for (j = _j = 0, _ref5 = _this.wcsobj.naxis - 1; 0 <= _ref5 ? _j <= _ref5 : _j >= _ref5; j = 0 <= _ref5 ? ++_j : --_j) {
                  tmp[i] += _this.wcsobj.cdInv[i][j] * proj[j];
                }
                tmp[i] += _this.wcsobj.crpix[i];
              }
              dx = dy = 0;
              dx = _this.f(tmp[0], tmp[1], _this.sip.apCoeffs);
              dy = _this.f(tmp[0], tmp[1], _this.sip.bpCoeffs);
              points = [];
              points[0] = tmp[0] + dx;
              points[1] = tmp[1] + dy;
              points[0] += _this.wcsobj.crpix[0];
              points[1] += _this.wcsobj.crpix[1];
              return points;
            };
            this.toSpherical = function(x, y) {
              var phi, r, theta;
              r = Math.sqrt(x * x + y * y);
              theta = WCS.Math.atand(180 / (Math.PI * r));
              phi = WCS.Math.atan2d(x, -y);
              return [phi, theta];
            };
            this.fromSpherical = function(phi, theta) {
              var r, x, y;
              r = 180 / (Math.PI * WCS.Math.tand(theta));
              x = r * WCS.Math.sind(phi);
              y = -r * WCS.Math.cosd(phi);
              return [x, y];
            };
            break;
          case 'ZEA':
            this.toSpherical = function(x, y) {
              var phi, r, theta;
              r = Math.sqrt(x * x + y * y);
              theta = _this.wcsobj.theta0 - 2 * WCS.Math.asind(Math.PI * r / 360);
              phi = WCS.Math.atan2d(x, -y);
              return [phi, theta];
            };
            this.fromSpherical = function(phi, theta) {
              var r, x, y;
              r = 360 / Math.PI * WCS.Math.sind((90 - theta) / 2);
              x = r * WCS.Math.sind(phi);
              y = -r * WCS.Math.cosd(phi);
              return [x, y];
            };
            break;
          case 'ZPN':
            this.toSpherical = function(x, y) {
              throw 'Sorry, not yet implemented!';
            };
            this.fromSpherical = function(phi, theta) {
              throw 'Sorry, not yet implemented!';
            };
        }
      }
      if (_ref4 = this.projection, __indexOf.call(cylindrical, _ref4) >= 0) {
        this.wcsobj.phi0 = 0;
        this.wcsobj.theta0 = 0;
        this.computeCelestialParameters(this.wcsobj.phi0, this.wcsobj.theta0);
        switch (this.projection) {
          case 'CYP':
            _ref5 = ["PV" + this.latitudeAxis + "_1,", "PV" + this.latitudeAxis + "_2"], key1 = _ref5[0], key2 = _ref5[1];
            this.wcsobj.mu = header.hasOwnProperty(key1) ? parseFloat(header[key1]) : 1;
            this.wcsobj.lambda = header.hasOwnProperty(key2) ? parseFloat(header[key2]) : 1;
            if (this.wcsobj.mu + this.wcsobj.lambda === 0) {
              raise("Divide by zero error");
            }
            this.toSpherical = function(x, y) {
              var nu, phi, theta;
              nu = (Math.PI * y) / (180 * (_this.wcsobj.mu + _this.wcsobj.lambda));
              theta = WCS.Math.atan2d(nu, 1) + WCS.Math.asind(nu * _this.wcsobj.mu / Math.sqrt(nu * nu + 1));
              phi = x / _this.wcsobj.lambda;
              return [phi, theta];
            };
            this.fromSpherical = function(phi, theta) {
              var x, y;
              x = _this.wcsobj.lambda * phi;
              y = (180 / Math.PI) * ((_this.wcsobj.mu + _this.wcsobj.lambda) / (_this.wcsobj.mu + WCS.Math.cosd(theta))) * WCS.Math.sind(theta);
              return [x, y];
            };
            break;
          case 'CEA':
            key = "PV" + this.latitudeAxis + "_1";
            this.wcsobj.lambda = header.hasOwnProperty(key) ? parseFloat(header[key]) : 1;
            this.toSpherical = function(x, y) {
              var theta;
              theta = WCS.Math.asind(Math.PI * _this.wcsobj.lambda * y / 180);
              return [x, theta];
            };
            this.fromSpherical = function(phi, theta) {
              var y;
              y = 180 / Math.PI * WCS.Math.sind(theta) / _this.wcsobj.lambda;
              return [phi, y];
            };
            break;
          case 'CAR':
            this.toSpherical = function(x, y) {
              return [x, y];
            };
            this.fromSpherical = function(phi, theta) {
              return [phi, theta];
            };
            break;
          case 'MER':
            this.toSpherical = function(x, y) {
              var theta;
              theta = 2 * WCS.Math.atand(Math.exp(y * Math.PI / 180)) - 90;
              return [x, theta];
            };
            this.fromSpherical = function(phi, theta) {
              var y;
              y = (180 / Math.PI) * Math.log(WCS.Math.tand((90 + theta) / 2));
              return [phi, y];
            };
            break;
          case 'SFL':
            this.toSpherical = function(x, y) {
              var phi;
              phi = x / WCS.Math.cosd(y);
              return [phi, y];
            };
            this.fromSpherical = function(phi, theta) {
              var x;
              x = phi * WCS.Math.cosd(theta);
              return [x, theta];
            };
            break;
          case 'PAR':
            this.toSpherical = function(x, y) {
              var phi, theta;
              theta = 3 * WCS.Math.asind(y / 180);
              phi = x / (1 - 4 * Math.pow(y / 180, 2));
              return [phi, theta];
            };
            this.fromSpherical = function(phi, theta) {
              var x, y;
              x = phi * (2 * WCS.Math.cosd(2 * theta / 3) - 1);
              y = 180 * WCS.Math.sind(theta / 3);
              return [x, y];
            };
            break;
          case 'MOL':
            this.toSpherical = function(x, y) {
              var phi, theta;
              theta = WCS.Math.asind(WCS.Math.asind((Math.PI * y) / (180 * Math.sqrt(2))) / 90 + (y / 180) * Math.sqrt(2 - Math.pow(Math.PI * y / 180, 2)));
              phi = (Math.PI * x) / (2 * Math.sqrt(2 - Math.pow(Math.PI * y / 180, 2)));
              return [phi, theta];
            };
            this.fromSpherical = function(phi, theta) {
              var x, y;
              throw 'Sorry, not yet implemented!';
              x = 2 * Math.sqrt(2) / Math.PI * phi * WCS.Math.cosd(gamma);
              y = Math.sqrt(2) * 180 / Math.PI * WCS.Math.sind(gamma);
              return [x, y];
            };
            break;
          case 'AIT':
            this.toSpherical = function(x, y) {
              var phi, theta, x_z, y_z, z;
              x_z = Math.pow((Math.PI * x) / (4 * 180), 2);
              y_z = Math.pow((Math.PI * y) / (2 * 180), 2);
              z = Math.sqrt(1 - x_z - y_z);
              theta = WCS.Math.asind(Math.PI * y * z / 180);
              phi = 2 * WCS.Math.atan2d(Math.PI * z * x / (2 * 180), 2 * z * z - 1);
              return [phi, theta];
            };
            this.fromSpherical = function(phi, theta) {
              var gamma, x, y;
              gamma = 180 / Math.PI * Math.sqrt(2 / (1 + WCS.Math.cosd(theta) * WCS.Math.cosd(phi / 2)));
              x = 2 * gamma * WCS.Math.cosd(theta) * WCS.Math.sind(phi / 2);
              y = gamma * WCS.Math.sind(theta);
              return [x, y];
            };
        }
      }
      if (_ref6 = this.projection, __indexOf.call(conic, _ref6) >= 0) {
        key = "PV" + this.latitudeAxis + "_1";
        this.wcsobj.phi0 = 0;
        this.wcsobj.theta0 = header.hasOwnProperty(key) ? header[key] : 0;
        throw 'Sorry, not yet implemented!';
      }
      if (_ref7 = this.projection, __indexOf.call(polyConic, _ref7) >= 0) {
        this.wcsobj.phi0 = 0;
        this.wcsobj.theta0 = 0;
        throw 'Sorry, not yet implemented!';
      }
      if (_ref8 = this.projection, __indexOf.call(quadCube, _ref8) >= 0) {
        this.wcsobj.phi0 = 0;
        this.wcsobj.theta0 = 0;
        throw 'Sorry, not yet implemented!';
      }
    };

    Mapper.prototype.getSipCoefficients = function(header) {
      var i, j, key, _i, _j, _k, _l, _m, _n, _o, _p, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7;
      if (!(header.hasOwnProperty('A_ORDER') || header.hasOwnProperty('B_ORDER'))) {
        throw "What's the polynomial order, man!";
      }
      this.sip = {};
      this.sip.aOrder = header.A_ORDER;
      this.sip.bOrder = header.B_ORDER;
      this.sip.apOrder = header.AP_ORDER || 0;
      this.sip.bpOrder = header.BP_ORDER || 0;
      this.sip.aCoeffs = [];
      this.sip.bCoeffs = [];
      this.sip.apCoeffs = [];
      this.sip.bpCoeffs = [];
      for (i = _i = 0, _ref = this.sip.aOrder; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        this.sip.aCoeffs[i] = [];
        for (j = _j = 0, _ref1 = this.sip.aOrder; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; j = 0 <= _ref1 ? ++_j : --_j) {
          key = "A_" + i + "_" + j;
          this.sip.aCoeffs[i][j] = header[key] || 0;
        }
      }
      for (i = _k = 0, _ref2 = this.sip.bOrder; 0 <= _ref2 ? _k <= _ref2 : _k >= _ref2; i = 0 <= _ref2 ? ++_k : --_k) {
        this.sip.bCoeffs[i] = [];
        for (j = _l = 0, _ref3 = this.sip.bOrder; 0 <= _ref3 ? _l <= _ref3 : _l >= _ref3; j = 0 <= _ref3 ? ++_l : --_l) {
          key = "B_" + i + "_" + j;
          this.sip.bCoeffs[i][j] = header[key] || 0;
        }
      }
      for (i = _m = 0, _ref4 = this.sip.apOrder; 0 <= _ref4 ? _m <= _ref4 : _m >= _ref4; i = 0 <= _ref4 ? ++_m : --_m) {
        this.sip.apCoeffs[i] = [];
        for (j = _n = 0, _ref5 = this.sip.apOrder; 0 <= _ref5 ? _n <= _ref5 : _n >= _ref5; j = 0 <= _ref5 ? ++_n : --_n) {
          key = "AP_" + i + "_" + j;
          this.sip.apCoeffs[i][j] = header[key] || 0;
        }
      }
      for (i = _o = 0, _ref6 = this.sip.bpOrder; 0 <= _ref6 ? _o <= _ref6 : _o >= _ref6; i = 0 <= _ref6 ? ++_o : --_o) {
        this.sip.bpCoeffs[i] = [];
        for (j = _p = 0, _ref7 = this.sip.bpOrder; 0 <= _ref7 ? _p <= _ref7 : _p >= _ref7; j = 0 <= _ref7 ? ++_p : --_p) {
          key = "BP_" + i + "_" + j;
          this.sip.bpCoeffs[i][j] = header[key] || 0;
        }
      }
      if (!(this.sip.aCoeffs || this.sip.bCoeffs)) {
        throw "Where are the coefficients dude!";
      }
    };

    Mapper.prototype.computeCelestialParameters = function(phi0, theta0) {
      var alpha0, delta0, deltaP1, deltaP2, dist1, dist2, phiP, sol1, sol2, thetaP, _ref, _ref1;
      _ref = this.wcsobj.crval, alpha0 = _ref[0], delta0 = _ref[1];
      _ref1 = [this.wcsobj.lonpole, this.wcsobj.latpole], phiP = _ref1[0], thetaP = _ref1[1];
      deltaP1 = WCS.Math.atan2d(WCS.Math.sind(this.wcsobj.theta0), WCS.Math.cosd(this.wcsobj.theta0 * WCS.Math.cosd(phiP - this.wcsobj.phi0)));
      deltaP2 = WCS.Math.acosd(WCS.Math.sind(delta0) / Math.sqrt(1 - Math.pow(WCS.Math.cosd(this.wcsobj.theta0), 2) * Math.pow(WCS.Math.sind(phiP - this.wcsobj.phi0), 2)));
      sol1 = sol2 = false;
      if (deltaP1 + deltaP2 >= -90 && deltaP1 + deltaP2 <= 90) {
        sol1 = true;
      }
      if (deltaP1 - deltaP2 >= -90 && deltaP1 - deltaP2 <= 90) {
        sol2 = true;
      }
      if (sol1 && sol2) {
        dist1 = Math.abs(deltaP1 + deltaP2 - thetaP);
        dist2 = Math.abs(deltaP1 - deltaP2 - thetaP);
        this.wcsobj.deltaP = dist1 < dist2 ? deltaP1 + deltaP2 : deltaP1 - deltaP2;
      } else if (sol1) {
        this.wcsobj.deltaP = deltaP1 + deltaP2;
      } else if (sol2) {
        this.wcsobj.deltaP = deltaP1 - deltaP2;
      } else {
        this.wcsobj.deltaP = thetaP;
      }
      return this.wcsobj.alphaP = Math.abs(delta0) === 90 ? alpha0 : alpha0 - WCS.Math.asind(WCS.Math.sind(phiP - this.wcsobj.phi0) * WCS.Math.cosd(this.wcsobj.theta0) / WCS.Math.cosd(delta0));
    };

    Mapper.prototype.toIntermediate = function(points) {
      var i, j, proj, _i, _j, _ref, _ref1;
      proj = [];
      for (i = _i = 0, _ref = this.wcsobj.naxis - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        proj[i] = 0;
        points[i] -= this.wcsobj.crpix[i];
        for (j = _j = 0, _ref1 = this.wcsobj.naxis - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; j = 0 <= _ref1 ? ++_j : --_j) {
          proj[i] += this.wcsobj.cdelt[i] * this.wcsobj.pc[i][j] * points[j];
        }
      }
      return proj;
    };

    Mapper.prototype.fromIntermediate = function(proj) {
      var i, j, points, _i, _j, _ref, _ref1;
      points = [];
      for (i = _i = 0, _ref = this.wcsobj.naxis - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        points[i] = 0;
        for (j = _j = 0, _ref1 = this.wcsobj.naxis - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; j = 0 <= _ref1 ? ++_j : --_j) {
          points[i] += this.wcsobj.pcInv[i][j] * proj[j] / this.wcsobj.cdelt[i];
        }
        points[i] += this.wcsobj.crpix[i];
      }
      return points;
    };

    Mapper.prototype.toCelestial = function(phi, theta) {
      var cosDecP, cosDphi, cosTheta, dec, ra, sinDecP, sinDphi, sinTheta, xTemp, yTemp, zTemp;
      sinTheta = WCS.Math.sind(theta);
      cosTheta = WCS.Math.cosd(theta);
      sinDphi = WCS.Math.sind(phi - this.wcsobj.lonpole);
      cosDphi = WCS.Math.cosd(phi - this.wcsobj.lonpole);
      sinDecP = WCS.Math.sind(this.wcsobj.deltaP);
      cosDecP = WCS.Math.cosd(this.wcsobj.deltaP);
      xTemp = sinTheta * cosDecP - cosTheta * sinDecP * cosDphi;
      yTemp = -cosTheta * sinDphi;
      zTemp = sinTheta * sinDecP + cosTheta * cosDecP * cosDphi;
      ra = WCS.Math.atan2d(yTemp, xTemp) + this.wcsobj.alphaP;
      ra = (ra + 360) % 360;
      dec = WCS.Math.asind(zTemp);
      return [ra, dec];
    };

    Mapper.prototype.fromCelestial = function(ra, dec) {
      var cosDalpha, cosDelta, cosDp, phi, sinDalpha, sinDelta, sinDp, theta, xTemp, yTemp;
      sinDelta = WCS.Math.sind(dec);
      cosDelta = WCS.Math.cosd(dec);
      sinDp = WCS.Math.sind(this.wcsobj.deltaP);
      cosDp = WCS.Math.cosd(this.wcsobj.deltaP);
      sinDalpha = WCS.Math.sind(ra - this.wcsobj.alphaP);
      cosDalpha = WCS.Math.cosd(ra - this.wcsobj.alphaP);
      xTemp = sinDelta * cosDp - cosDelta * sinDp * cosDalpha;
      yTemp = -cosDelta * sinDalpha;
      phi = this.wcsobj.lonpole + WCS.Math.atan2d(yTemp, xTemp);
      theta = WCS.Math.asind(sinDelta * sinDp + cosDelta * cosDp * cosDalpha);
      return [phi, theta];
    };

    Mapper.prototype.pixelToCoordinate = function() {
      var coords;
      coords = this.toIntermediate(arguments[0], arguments[1]);
      coords = this.toSpherical(coords[0], coords[1]);
      coords = this.toCelestial(coords[0], coords[1]);
      return {
        ra: coords[this.longitudeAxis - 1],
        dec: coords[this.latitudeAxis - 1]
      };
    };

    Mapper.prototype.coordinateToPixel = function() {
      var coords;
      coords = this.fromCelestial(arguments[0], arguments[1]);
      coords = this.fromSpherical(coords[0], coords[1]);
      coords = this.fromIntermediate(coords);
      return {
        x: coords[0],
        y: coords[1]
      };
    };

    return Mapper;

  })();

}).call(this);

define("wcs", function(){});

/******************************************************************************* 
* Copyright 2012, 2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES 
* 
* This file is part of SITools2. 
* 
* SITools2 is free software: you can redistribute it and/or modify 
* it under the terms of the GNU General Public License as published by 
* the Free Software Foundation, either version 3 of the License, or 
* (at your option) any later version. 
* 
* SITools2 is distributed in the hope that it will be useful, 
* but WITHOUT ANY WARRANTY; without even the implied warranty of 
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
* GNU General Public License for more details. 
* 
* You should have received a copy of the GNU General Public License 
* along with SITools2. If not, see <http://www.gnu.org/licenses/>. 
******************************************************************************/ 

/**
 * Utility module : contains various functions useful for differnt modules
 */
 define('Utils',["gw/CoordinateSystem", "wcs"], function( CoordinateSystem ) {

var globe;

/**
 *	HSV values in [0..1[
 *	returns [r, g, b] values from 0 to 255
 */
function hsv_to_rgb(h, s, v) {
	var h_i = Math.floor(h*6);
	var f = h*6 - h_i;
	var p = v * (1 - s);
	var q = v * (1 - f*s);
	var t = v * (1 - (1 - f) * s);
	switch (h_i)
	{
		case 0:
			r = v; g = t; b = p;
			break;
		case 1:
			r = q; g = v; b = p;
			break;
		case 2:
			r = p; g = v; b = t;
			break;
		case 3:
			r = p; g = q; b = v;
			break;
		case 4:
			r = t; g = p; b = v;
			break;
		case 5:
			r = v; g = p; b = q;
			break;
		default:
			r = 1; g = 1; b = 1;
	}
	return [r, g, b];
}

/**
 *	Create geographic coordinate from x,y image pixel using WCS
 */
function createCoordinate( x, y )
{
	var coordinate = wcs.pixelToCoordinate([x,y]);
	// Convert to geographic representation
	if ( coordinate.ra > 180 )
		coordinate.ra -= 360;
	return [coordinate.ra, coordinate.dec];
}

return {
  	
	init: function(gl)
	{
		globe = gl;
	},

	roundNumber : function (num, dec) {
		var result = Math.round(num*Math.pow(10,dec))/Math.pow(10,dec);
		return result;
	},

	inherits : function(base, sub) 
	{
		function tempCtor() {}
		tempCtor.prototype = base.prototype;
		sub.prototype = new tempCtor();
		sub.prototype.constructor = sub;
	},

	/**
	 *	Generate eye-friendly color based on hsv
	 */
	generateColor : function()
	{
		//use golden ratio
		var golden_ratio_conjugate = 0.618033988749895;
		var h = Math.random();
		h += golden_ratio_conjugate;
	  	h %= 1;
		return hsv_to_rgb(h, 0.5, 0.95);
	},

	/**
	 *	Format coordinates according to default coordinate system
	 */
	formatCoordinates : function(geo)
	{
		var astro = [];
		if ( CoordinateSystem.type == "EQ" )
		{
			CoordinateSystem.fromGeoToEquatorial([geo[0], geo[1]], astro);	
		}
		else 
		{
			geo = CoordinateSystem.convert( geo, 'EQ', CoordinateSystem.type );

			// convert longitude to positive [0..360]
			if (geo[0] < 0)
				geo[0]+=360;
			
			astro[0] = this.roundNumber(geo[0],4);
			astro[0]+="";
			astro[1] = this.roundNumber(geo[1],4);
			astro[1]+="";
		}
		return astro;
	},

	/**
	 *	Format the given feature identifier to remove special caracters(as ?, [, ], ., etc..) which cannot be used as HTML id's
	 */
	formatId : function(id)
	{
		return id.replace(/\s{1,}|\.{1,}|\[{1,}|\]{1,}|\({1,}|\){1,}|\~{1,}|\+{1,}|\{1,}|\-{1,}|\'{1,}|\"{1,}/g, "");
	},
	
	/**
	 *	Get GeoJson polygon coordinates representing fits using wcs data from header
	 */
	getPolygonCoordinatesFromFits: function(fits)
	{
		var hdu = fits.getHDU();
		var fitsData = hdu.data;
			
		// Create mapper
		wcs = new WCS.Mapper(hdu.header);
		var coords = [];

		// Debug test: isn't working currently
		var test = wcs.coordinateToPixel(99.77120833333333, 5.540722222222222);
		var iTest = wcs.pixelToCoordinate([4844.563607341353, 0.46768419804220684]);

		// Find coordinates of coming fits
		coords.push( createCoordinate(0,fitsData.height) );
		coords.push( createCoordinate(fitsData.width,fitsData.height) );
		coords.push( createCoordinate(fitsData.width,0) );
		coords.push( createCoordinate(0,0) );
		// Close the polygon
		coords.push(coords[0]);
		return coords;
	},

	/**
	 *	Compute barycenter of the given GeoJSON geometry
	 */
	computeGeometryBarycenter: function(geometry)
	{
		switch (geometry.type)
		{
			case "Point":
				return [ geometry.coordinates[0], geometry.coordinates[1] ];
				break;
			case "Polygon":
				var sLon = 0;
				var sLat = 0;
				var nbPoints = 0;
				for( var i=0; i<geometry.coordinates[0].length-1; i++ )
				{
					sLon+=geometry.coordinates[0][i][0];
					sLat+=geometry.coordinates[0][i][1];
					nbPoints++;
				}
				break;
			case "MultiPolygon":
				var sLon = 0;
				var sLat = 0;
				var nbPoints = 0;
				for ( var i=0; i<geometry.coordinates.length; i++ )
				{
					var polygon = geometry.coordinates[i][0];
					for ( var j=0; j<polygon.length-1; j++ )
					{
						sLon+=polygon[j][0];
						sLat+=polygon[j][1];
						nbPoints++;
					}
				}
				break;
			default:
				return;
				break;
		}

		return [sLon/nbPoints, sLat/nbPoints];
	},

	/**
	*	Determine if a point lies inside a polygon
	* 
	* 	@param {Float[]} point Point in geographic coordinates
	* 	@param {Float[][]} ring Array of points representing the polygon
	*/
	pointInRing: function( point, ring )
	{
		var nvert = ring.length;
		if ( ring[0][0] == ring[nvert-1][0] && ring[0][1] == ring[nvert-1][1] )
		{
			nvert--;
		}
		var inPoly = false;
		var j = nvert-1;
		for (var i = 0; i < nvert; j = i++)
		{
			if ( ((ring[i][1] > point[1]) != (ring[j][1] > point[1])) &&
				(point[0] < (ring[j][0] - ring[i][0]) * (point[1] - ring[i][1]) / (ring[j][1] - ring[i][1]) + ring[i][0]) )
			{
				inPoly = !inPoly;
			}
		}
		return inPoly;
	},

	/**
	 *	Determine if a point lies inside a sphere of radius depending on viewport
	 */
	pointInSphere: function( point, sphere, pointTextureHeight )
	{
		var point3D = [];
		var sphere3D = [];

		// Compute pixel size vector to offset the points from the earth
		var pixelSizeVector = globe.renderContext.computePixelSizeVector();

		CoordinateSystem.fromGeoTo3D( point, point3D );
		CoordinateSystem.fromGeoTo3D( sphere, sphere3D );

		var radius = pointTextureHeight * (pixelSizeVector[0] * sphere3D[0] + pixelSizeVector[1] * sphere3D[1] + pixelSizeVector[2] * sphere3D[2] + pixelSizeVector[3]);

		//Calculate the squared distance from the point to the center of the sphere
		var vecDist = [];
		vec3.subtract(point3D, sphere3D, vecDist);
		vecDist = vec3.dot(vecDist, vecDist);

		//Calculate if the squared distance between the sphere's center and the point
		//is less than the squared radius of the sphere
		if( vecDist < radius * radius )
		{
		    return true;
		}

		//If not, return false
		return false;
	}
 
};

});

/******************************************************************************* 
* Copyright 2012, 2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES 
* 
* This file is part of SITools2. 
* 
* SITools2 is free software: you can redistribute it and/or modify 
* it under the terms of the GNU General Public License as published by 
* the Free Software Foundation, either version 3 of the License, or 
* (at your option) any later version. 
* 
* SITools2 is distributed in the hope that it will be useful, 
* but WITHOUT ANY WARRANTY; without even the implied warranty of 
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
* GNU General Public License for more details. 
* 
* You should have received a copy of the GNU General Public License 
* along with SITools2. If not, see <http://www.gnu.org/licenses/>. 
******************************************************************************/ 

/**
 * Tool designed to select areas on globe
 */

define('SelectionTool', [ "jquery", "gw/VectorLayer", "gw/FeatureStyle", "gw/Numeric", "gw/CoordinateSystem", "./Utils", "gw/glMatrix" ],
	function($, VectorLayer, FeatureStyle, Numeric, CoordinateSystem, Utils){



/**
 *	@constructor
 *	@param options Configuration options
 *		<ul>
 *			<li>globe: Globe</li>
 *			<li>navigation: Navigation</li>
 *			<li>onselect: On selection callback</li>
 *			<li>style: Selection tool style</li>
 *		</ul>
 */
var SelectionTool = function(options)
{
	// Required options
	var globe = options.globe;
	var navigation = options.navigation;
	var onselect = options.onselect;

	this.activated = false;
	this.renderContext = globe.renderContext;

	// Set style
	var style;
	if ( options && options['style'] )
	{
		style = options['style'];
	}
	else
	{
		style = new FeatureStyle();
	}
	style.zIndex = 2;

	// Layer containing selection feature
	this.selectionLayer = new VectorLayer({
		style: style
	});
	globe.addLayer(this.selectionLayer);
	
	this.selectionFeature = null;

	// Selection attributes
	this.radius;	// Window radius
	this.pickPoint; // Window pick point
	this.geoRadius; // Radius in geographic reference
	this.geoPickPoint; // Pick point in geographic reference

	var self = this;
	var dragging = false;
	var state;
	
	this.renderContext.canvas.addEventListener("mousedown", function(event){

		var pickPoint = [event.clientX, event.clientY];
		var geoPickPoint = globe.getLonLatFromPixel(event.clientX, event.clientY);

		if ( !self.activated && !self.selectionFeature )
			return;

		// Dragging : moving/resizing OR drawing selection
		if ( self.activated )
		{
			// Draw
			navigation.stop();
			dragging = true;
			self.pickPoint = pickPoint;
			self.geoPickPoint = geoPickPoint;
			self.radius = 0.;
			state = "resize";
		}
		else
		{
			var pickIsInside = Utils.pointInRing( geoPickPoint, self.selectionFeature.geometry.coordinates[0] );
			if ( !pickIsInside )
				return;

			navigation.stop();
			dragging = true;
			// Resize/move
			var inside = false;
			// Check if user clicked on one of control points
			for ( var i=0; i<self.selectionFeature.geometry.coordinates[0].length; i++ )
			{
				var controlPoint = self.selectionFeature.geometry.coordinates[0][i];
				inside |= Utils.pointInSphere( geoPickPoint, controlPoint, 20 );
			}

			if ( inside )
			{
				state = "resize";
			}
			else
			{
				state = "move";
			}
		}
	});

	this.renderContext.canvas.addEventListener("mousemove", function(event){
		if ( !dragging )
			return;

		var geoPickPoint = globe.getLonLatFromPixel( event.clientX, event.clientY );
		if ( state == "resize" )
		{
			// Update radius
			self.radius = Math.sqrt( Math.pow(event.clientX - self.pickPoint[0], 2) + Math.pow(event.clientY - self.pickPoint[1], 2) );
			self.computeGeoRadius( geoPickPoint );
		}
		else if ( state == "move" )
		{
			// Update pick point position
			self.pickPoint = [event.clientX, event.clientY];
			self.geoPickPoint = globe.getLonLatFromPixel(event.clientX, event.clientY);

			// TODO: scale radius of selection shape if fov has been changed(or not?)
		}
		self.updateSelection();
	});

	this.renderContext.canvas.addEventListener("mouseup", function(event){
		if ( !dragging )
			return;

		// Compute geo radius
		var stopPickPoint = globe.getLonLatFromPixel(event.clientX, event.clientY);

		if ( self.activated && onselect )
		{
			onselect();
		}

		// Reactivate standard navigation events
		navigation.start();
		dragging = false;
	});
}

/**********************************************************************************************/

/**
 *	Compute selection tool radius between pickPoint and the given point
 */
SelectionTool.prototype.computeGeoRadius = function(pt)
{
	// Find angle between start and stop vectors which is in fact the radius
	var dotProduct = vec3.dot( CoordinateSystem.fromGeoTo3D(pt), CoordinateSystem.fromGeoTo3D(this.geoPickPoint) );
	var theta = Math.acos(dotProduct);
	this.geoRadius = Numeric.toDegree(theta);
}

/**********************************************************************************************/

/**
 *	Compute selection for the given pick point depending on radius
 */
SelectionTool.prototype.computeSelection = function()
{
	var rc = this.renderContext;
	var tmpMat = mat4.create();
	
	// Compute eye in world space
	mat4.inverse(rc.viewMatrix, tmpMat);
	var eye = [tmpMat[12], tmpMat[13], tmpMat[14]];
	
	// Compute the inverse of view/proj matrix
	mat4.multiply(rc.projectionMatrix, rc.viewMatrix, tmpMat);
	mat4.inverse(tmpMat);
	
	// Scale to [-1,1]
	var widthScale = 2/rc.canvas.width;
	var heightScale = 2/rc.canvas.height;
	var points = [
		[ (this.pickPoint[0]-this.radius)*widthScale-1., ((rc.canvas.height-this.pickPoint[1])-this.radius)*heightScale-1., 1, 1 ],
		[ (this.pickPoint[0]-this.radius)*widthScale-1., ((rc.canvas.height-this.pickPoint[1])+this.radius)*heightScale-1., 1, 1 ],
		[ (this.pickPoint[0]+this.radius)*widthScale-1., ((rc.canvas.height-this.pickPoint[1])+this.radius)*heightScale-1., 1, 1 ],
		[ (this.pickPoint[0]+this.radius)*widthScale-1., ((rc.canvas.height-this.pickPoint[1])-this.radius)*heightScale-1., 1, 1 ]
	];	

	// Transform the four corners of selection shape into world space
	// and then for each corner compute the intersection of ray starting from the eye with the sphere
	var tmpPt = vec3.create();
	var worldCenter = [ 0, 0, 0 ];
	for ( var i = 0; i < 4; i++ )
	{
		mat4.multiplyVec4( tmpMat, points[i] );
		vec3.scale( points[i], 1.0 / points[i][3] );
		vec3.subtract(points[i], eye, points[i]);
		vec3.normalize( points[i] );
		
		var t = Numeric.raySphereIntersection( eye, points[i], worldCenter, CoordinateSystem.radius);
		if ( t < 0.0 )
			return null;

		points[i] = CoordinateSystem.from3DToGeo( Numeric.pointOnRay(eye, points[i], t, tmpPt) );
	}

	return points;
}

/**************************************************************************************************************/

/**
 *	Update selection coordinates
 */
SelectionTool.prototype.updateSelection = function()
{
	if ( this.selectionFeature )
		this.selectionLayer.removeFeature(this.selectionFeature);

	var coordinates = this.computeSelection();
	// Close the polygon
	coordinates.push(coordinates[0]);

	this.selectionFeature = {
		"geometry": {
			"gid": "selectionShape",
			"coordinates": [coordinates],
			"type": "Polygon"
		},
		"type": "Feature"
	};
	
	this.selectionLayer.addFeature( this.selectionFeature );
}

/**************************************************************************************************************/

/**
 *	Activate/desactivate the tool
 */
SelectionTool.prototype.toggle = function()
{
	this.activated = !this.activated;
	if ( this.activated )
	{
		// TODO : Find more sexy image for cursor
		$(this.renderContext.canvas).css('cursor', 'url(css/images/selectionCursor.png)');
	}
	else
	{
		$(this.renderContext.canvas).css('cursor', 'default');
	}
}

/**************************************************************************************************************/

/**
 *	Clear selection
 */
SelectionTool.prototype.clear = function()
{
	if ( this.selectionFeature )
		this.selectionLayer.removeFeature(this.selectionFeature);

	this.pickPoint = null;
	this.radius = null;
	this.geoPickPoint = null;
	this.geoRadius = null;
}

/**************************************************************************************************************/

return SelectionTool;

});
/******************************************************************************* 
* Copyright 2012, 2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES 
* 
* This file is part of SITools2. 
* 
* SITools2 is free software: you can redistribute it and/or modify 
* it under the terms of the GNU General Public License as published by 
* the Free Software Foundation, either version 3 of the License, or 
* (at your option) any later version. 
* 
* SITools2 is distributed in the hope that it will be useful, 
* but WITHOUT ANY WARRANTY; without even the implied warranty of 
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
* GNU General Public License for more details. 
* 
* You should have received a copy of the GNU General Public License 
* along with SITools2. If not, see <http://www.gnu.org/licenses/>. 
******************************************************************************/ 

define('UWSBase', [ "jquery" ], function($) {

/**************************************************************************************************************/

/**
 * UWSBase service
 */
var UWSBase = function(name, baseUrl, options)
{
	this.name = name;
	this.baseUrl = baseUrl;

	this.successCallback = null;
	this.failCallback = null;
	this.onloadCallback = null;

	this.checkFn = null; // Interval function
	this.checkDelay = options && options.hasOwnProperty('checkDelay') ? options.checkDelay : 2000;
	this.currentJob;
}

/**************************************************************************************************************/

/**
  *	Send xhr to get results of current job
  */
UWSBase.prototype.getJobResults = function()
{
	var self = this;
	$.ajax({
		type: "GET",
		url: this.baseUrl + "/" + this.currentJob + '/results?media=json',
		success: function(response, textStatus, xhr){
			if ( self.successCallback )
				self.successCallback(response, self.currentJob);
		},
		error: function(xhr, textStatus, thrownError){
			if ( self.failCallback )
				self.failCallback('Internal server error');
		}
	});
}

/**************************************************************************************************************/

/**
  *	Send GET request to know the phase of current job
  */
UWSBase.prototype.checkPhase = function()
{
	var self = this;
	$.ajax({
		type: "GET",
		url: this.baseUrl + "/" + this.currentJob + '/phase',
		success: function(response, textStatus, xhr){
			// Response is a phase
			if ( self.onloadCallback )
				self.onloadCallback(response);

			if ( response == "COMPLETED" )
			{
				window.clearInterval(self.checkFn);;
				self.getJobResults();
			} 
			else if ( response == "ERROR" )
			{
				window.clearInterval(self.checkFn);
				if ( self.failCallback )
					self.failCallback('Internal server error');
			}
		},
		error: function (xhr, textStatus, thrownError) {
			window.clearInterval(self.checkFn);
			if ( self.failCallback )
				self.failCallback(self.name + ' service: '+ thrownError);
			console.error( xhr.responseText );
		}
	});
}

/**************************************************************************************************************/

/**
 *	Send POST request to launch the job of current service
 */
UWSBase.prototype.post = function(parameters, options)
{
	this.successCallback = options.successCallback;
	this.onloadCallback = options.onloadCallback;
	this.failCallback = options.failCallback;

	if ( !this.baseUrl )
	{
		if ( this.failCallback )	
			this.failCallback(this.name + ' service: baseUrl is undefined');
		console.error(this.name + ' service baseUrl is undefined');
	}
	else
	{
		window.clearInterval(this.checkFn);
		var self = this;
		$.ajax({
			type: "POST",
			url: this.baseUrl,
			dataType: "xml",
			data: parameters,
			success: function(response, textStatus, xhr){
				var xmlDoc = $.parseXML( xhr.responseText );
				self.currentJob = $(xmlDoc).find('uws\\:jobId, jobId').text();

				// Check job phase every "checkDelay" seconds
				self.checkFn = window.setInterval( function(){
					self.checkPhase.call(self);
				}, self.checkDelay );
			},
			error: function (xhr, textStatus, thrownError) {
				window.clearInterval(self.checkFn);
				if ( self.failCallback )
					self.failCallback(self.name + ' service: ' + thrownError);
				console.error( xhr.responseText );
			}
		});
	}
}

/**************************************************************************************************************/

/**
 *	Send DELETE request to remove the results of the given job
 */
UWSBase.prototype.delete = function(jobId, options)
{
	var successCallback = options.successCallback;
	var failCallback = options.failCallback;

	if ( !this.baseUrl )
	{
		if ( this.failCallback )	
			this.failCallback(this.name + ' service: baseUrl is undefined');
		console.error(this.name + ' service baseUrl is undefined');
	}
	else
	{
		var self = this;
		$.ajax({
			type: "DELETE",
			url: this.baseUrl + "/" + jobId,
			success: function(response, textStatus, xhr){
				if ( successCallback )
					successCallback();
			},
			error: function (xhr, textStatus, thrownError) {
				if ( failCallback )
					failCallback(self.name + ' service: ' + thrownError);
				console.error( xhr.responseText );
			}
		});
	}
}

/**************************************************************************************************************/

return UWSBase;

/**************************************************************************************************************/

});
/******************************************************************************* 
* Copyright 2012, 2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES 
* 
* This file is part of SITools2. 
* 
* SITools2 is free software: you can redistribute it and/or modify 
* it under the terms of the GNU General Public License as published by 
* the Free Software Foundation, either version 3 of the License, or 
* (at your option) any later version. 
* 
* SITools2 is distributed in the hope that it will be useful, 
* but WITHOUT ANY WARRANTY; without even the implied warranty of 
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
* GNU General Public License for more details. 
* 
* You should have received a copy of the GNU General Public License 
* along with SITools2. If not, see <http://www.gnu.org/licenses/>. 
******************************************************************************/ 

/**
 * UWS Manager
 */

define('UWSManager', [ "./UWSBase" ],
	function(UWSBase) {

var cutOutService;
var zScaleService;
var healpixCutService;

return {
	init: function(conf)
 	{
 		if ( conf.cutOut )
 		{
 			cutOutService = new UWSBase( 'CutOut', conf.cutOut.baseUrl );
 		}

 		if ( conf.healpixcut )
 		{
 			healpixCutService = new UWSBase( 'HealpixCut', conf.healpixcut.baseUrl );
 		}

 		if ( conf.zScale )
 		{
 			zScaleService = new UWSBase( 'ZScale', conf.zScale.baseUrl );
 		}
 	},

 	post: function(serviceName, params, options)
 	{
 		switch(serviceName)
 		{
 			case "cutout":
 				cutOutService.post(params, options);
 				break;
 			case "healpixcut":
 				healpixCutService.post(params, options);
 				break;
 			case "zscale":
 				zScaleService.post(params, options);
 				break;
 			default:
 				console.error("Not supported");
 		}
 	},

 	delete: function(serviceName, jobId, options)
 	{
 		switch(serviceName)
 		{
 			case "cutout":
 				cutOutService.delete(jobId, options)
 				break;
 			case "healpixcut":
 				healpixCutService.delete(jobId, options);
 				break;
 			case "zscale":
 				zScaleService.delete(jobId, options);
 				break;
 			default:
 				console.error("Not supported");
 		}
 	}
}

});
// samp
// ----
// Provides capabilities for using the SAMP Web Profile from JavaScript.
// Exported tokens are in the samp.* namespace.
// Inline documentation is somewhat patchy (partly because I don't know
// what javascript documentation is supposed to look like) - it is
// suggested to use it conjunction with the provided examples,
// currently visible at http://astrojs.github.com/sampjs/
// (gh-pages branch of github sources).

var samp = (function() {

    // Constants defining well-known location of SAMP Web Profile hub etc.
    var WEBSAMP_PORT = 21012;
    var WEBSAMP_PATH = "/";
    var WEBSAMP_PREFIX = "samp.webhub.";
    var WEBSAMP_CLIENT_PREFIX = "";

    // Tokens representing permissible types in a SAMP object (e.g. a message)
    TYPE_STRING = "string";
    TYPE_LIST = "list";
    TYPE_MAP = "map";

    var heir = function(proto) {
        function F() {};
        F.prototype = proto;
        return new F();
    };

    // Utility functions for navigating DOM etc.
    // -----------------------------------------

    var getSampType = function(obj) {
        if (typeof obj === "string") {
            return TYPE_STRING;
        }
        else if (obj instanceof Array) {
            return TYPE_LIST;
        }
        else if (obj instanceof Object && obj !== null) {
            return TYPE_MAP;
        }
        else {
            throw new Error("Not legal SAMP object type: " + obj);
        }
    };
    var getChildElements = function(el, childTagName) {
        var children = el.childNodes;
        var child;
        var childEls = [];
        var i;
        for (i = 0; i < children.length; i++) {
            child = children[i];
            if (child.nodeType === 1) {  // Element
                if (childTagName && (child.tagName !== childTagName)) {
                    throw new Error("Child <" + children[i].tagName + ">"
                                  + " of <" + el.tagName + ">"
                                  + " is not a <" + childTagName + ">");
                }
                childEls.push(child);
            }
        }
        return childEls;
    };
    var getSoleChild = function(el, childTagName) {
        var children = getChildElements(el, childTagName);
        if (children.length === 1 ) {
            return children[0];
        }
        else {
            throw new Error("No sole child of <" + el.tagName + ">");
        }
    };
    var getTextContent = function(el) {
        var txt = "";
        var i;
        var child;
        for (i = 0; i < el.childNodes.length; i++ ) {
            child = el.childNodes[i];
            if (child.nodeType === 1) {           // Element 
                throw new Error("Element found in text content");
            }
            else if (child.nodeType === 3 ||      // Text
                     child.nodeType === 4 ) {     // CDATASection
                txt += child.nodeValue;
            }
        }
        return txt;
    };
    var stringify = function(obj) {
        return typeof JSON === "undefined" ? "..." : JSON.stringify(obj);
    };

    // XmlRpc class:
    // Utilities for packing and unpacking XML-RPC messages.
    // See xml-rpc.com.

    var XmlRpc = {};

    // Takes text and turns it into something suitable for use as the content
    // of an XML-RPC string - special characters are escaped.
    XmlRpc.escapeXml = function(s) {
        return s.replace(/&/g, "&amp;")
                .replace(/</g, "&lt;")
                .replace(/>/g, "&gt;");
    };

    // Asserts that the elements of paramList match the types given by typeList.
    // TypeList must be an array containing only TYPE_STRING, TYPE_LIST
    // and TYPE_MAP objects in some combination.  paramList must be the
    // same length.
    // In case of mismatch an error is thrown.
    XmlRpc.checkParams = function(paramList, typeList) {
        var i;
        for (i = 0; i < typeList.length; i++) {
            if (typeList[i] !== TYPE_STRING &&
                typeList[i] !== TYPE_LIST &&
                typeList[i] !== TYPE_MAP) {
                throw new Error("Unknown type " + typeList[i]
                              + " in check list");
            }
        }
        var npar = paramList.length;
        var actualTypeList = [];
        var ok = true;
        for (i = 0; i < npar; i++) {
            actualTypeList.push(getSampType(paramList[i]));
        }
        ok = ok && (typeList.length === npar);
        for (i = 0; ok && i < npar; i++ ) {
            ok = ok && typeList[i] === actualTypeList[i];
        }
        if (!ok) {
            throw new Error("Param type list mismatch: " 
                          + "[" + typeList + "] != "
                          + "[" + actualTypeList + "]");
        }
    };

    // Turns a SAMP object (structure of strings, lists, maps) into an
    // XML string suitable for use with XML-RPC.
    XmlRpc.valueToXml = function v2x(obj, prefix) {
        prefix = prefix || "";
        var a;
        var i;
        var result;
        var type = getSampType(obj);
        if (type === TYPE_STRING) {
            return prefix
                 + "<value><string>"
                 + XmlRpc.escapeXml(obj)
                 + "</string></value>";
        }
        else if (type === TYPE_LIST) {
            result = [];
            result.push(prefix + "<value>",
                        prefix + "  <array>",
                        prefix + "    <data>");
            for (i = 0; i < obj.length; i++) {
                result.push(v2x(obj[i], prefix + "      "));
            }
            result.push(prefix + "    </data>",
                        prefix + "  </array>",
                        prefix + "</value>");
          
            return result.join("\n");
        }
        else if (type === TYPE_MAP) {
            result = [];
            result.push(prefix + "<value>");
            result.push(prefix + "  <struct>");
            for (i in obj) {
                result.push(prefix + "    <member>");
                result.push(prefix + "      <name>"
                          + XmlRpc.escapeXml(i)
                          + "</name>");
                result.push(v2x(obj[i], prefix + "      "));
                result.push(prefix + "    </member>");
            }
            result.push(prefix + "  </struct>");
            result.push(prefix + "</value>");
            return result.join("\n");
        }
        else {
            throw new Error("bad type");  // shouldn't get here
        }
    };

    // Turns an XML string from and XML-RPC message into a SAMP object
    // (structure of strings, lists, maps).
    XmlRpc.xmlToValue = function x2v(valueEl, allowInt) {
        var childEls = getChildElements(valueEl);
        var i;
        var j;
        var txt;
        var node;
        var childEl;
        var elName;
        if (childEls.length === 0) {
            return getTextContent(valueEl);
        }
        else if (childEls.length === 1) {
            childEl = childEls[0];
            elName = childEl.tagName;
            if (elName === "string") {
                return getTextContent(childEl);
            }
            else if (elName === "array") {
                var valueEls =
                    getChildElements(getSoleChild(childEl, "data"), "value");
                var list = [];
                for (i = 0; i < valueEls.length; i++) {
                    list.push(x2v(valueEls[i], allowInt));
                }
                return list;
            }
            else if (elName === "struct") {
                var memberEls = getChildElements(childEl, "member");
                var map = {};
                var s_name;
                var s_value;
                var jc;
                for (i = 0; i < memberEls.length; i++) {
                    s_name = undefined;
                    s_value = undefined;
                    for (j = 0; j < memberEls[i].childNodes.length; j++) {
                        jc = memberEls[i].childNodes[j];
                        if (jc.nodeType == 1) {
                            if (jc.tagName === "name") {
                                s_name = getTextContent(jc);
                            }
                            else if (jc.tagName === "value") {
                                s_value = x2v(jc, allowInt);
                            }
                        }
                    }
                    if (s_name !== undefined && s_value !== undefined) {
                        map[s_name] = s_value;
                    }
                    else {
                        throw new Error("No <name> and/or <value> "
                                      + "in <member>?");
                    }
                }
                return map;
            }
            else if (allowInt && (elName === "int" || elName === "i4")) {
                return getTextContent(childEl);
            }
            else {
                throw new Error("Non SAMP-friendly value content: "
                              + "<" + elName + ">");
            }
        }
        else {
            throw new Error("Bad XML-RPC <value> content - multiple elements");
        }
    };

    // Turns the content of an XML-RPC <params> element into an array of
    // SAMP objects.
    XmlRpc.decodeParams = function(paramsEl) {
        var paramEls = getChildElements(paramsEl, "param");
        var i;
        var results = [];
        for (i = 0; i < paramEls.length; i++) {
            results.push(XmlRpc.xmlToValue(getSoleChild(paramEls[i], "value")));
        }
        return results;
    };

    // Turns the content of an XML-RPC <fault> element into an XmlRpc.Fault
    // object.
    XmlRpc.decodeFault = function(faultEl) {
        var faultObj = XmlRpc.xmlToValue(getSoleChild(faultEl, "value"), true);
        return new XmlRpc.Fault(faultObj.faultString, faultObj.faultCode);
    };

    // Turns an XML-RPC response element (should be <methodResponse>) into
    // either a SAMP response object or an XmlRpc.Fault object.
    // Note that a fault response does not throw an error, so check for
    // the type of the result if you want to know whether a fault occurred.
    // An error will however be thrown if the supplied XML does not
    // correspond to a legal XML-RPC response.
    XmlRpc.decodeResponse = function(xml) {
        var mrEl = xml.documentElement;
        if (mrEl.tagName !== "methodResponse") {
            throw new Error("Response element is not <methodResponse>");
        }
        var contentEl = getSoleChild(mrEl);
        if (contentEl.tagName === "fault") {
            return XmlRpc.decodeFault(contentEl);
        }
        else if (contentEl.tagName === "params") {
            return XmlRpc.decodeParams(contentEl)[0];
        }
        else {
            throw new Error("Bad XML-RPC response - unknown element"
                          + " <" + contentEl.tagName + ">");
        }
    };

    // XmlRpc.Fault class:
    // Represents an XML-RPC Fault response.
    XmlRpc.Fault = function(faultString, faultCode) {
        this.faultString = faultString;
        this.faultCode = faultCode;
    };
    XmlRpc.Fault.prototype.toString = function() {
        return "XML-RPC Fault (" + this.faultCode + "): " + this.faultString;
    };

    // XmlRpcRequest class:
    // Represents an call which can be sent to an XML-RPC server.
    var XmlRpcRequest = function(methodName, params) {
        this.methodName = methodName;
        this.params = params || [];
    }
    XmlRpcRequest.prototype.toString = function() {
        return this.methodName + "(" + stringify(this.params) + ")";
    };
    XmlRpcRequest.prototype.addParam = function(param) {
        this.params.push(param);
        return this;
    };
    XmlRpcRequest.prototype.addParams = function(params) {
        var i;
        for (i = 0; i < params.length; i++) {
            this.params.push(params[i]);
        }
        return this;
    };
    XmlRpcRequest.prototype.checkParams = function(typeList) {
        XmlRpc.checkParams(this.params, typeList);
    };
    XmlRpcRequest.prototype.toXml = function() {
        var lines = [];
        lines.push(
           "<?xml version='1.0'?>",
           "<methodCall>",
           "  <methodName>" + this.methodName + "</methodName>",
           "  <params>");
        for (var i = 0; i < this.params.length; i++) {
            lines.push("    <param>",
                       XmlRpc.valueToXml(this.params[i], "      "),
                       "    </param>");
        }
        lines.push(
           "  </params>",
           "</methodCall>");
        return lines.join("\n");
    };

    // XmlRpcClient class:
    // Object capable of sending XML-RPC calls to an XML-RPC server.
    // That server will typically reside on the host on which the
    // javascript is running; it is not likely to reside on the host
    // which served the javascript.  That means that sandboxing restrictions
    // will be in effect.  Much of the work done here is therefore to
    // do the client-side work required to potentially escape the sandbox.
    // The endpoint parameter, if supplied, is the URL of the XML-RPC server.
    // If absent, the default SAMP Web Profile server is used.
    var XmlRpcClient = function(endpoint) {
        this.endpoint = endpoint ||
                        "http://localhost:" + WEBSAMP_PORT + WEBSAMP_PATH;
    };

    // Creates an XHR facade - an object that presents an interface
    // resembling that of an XMLHttpRequest Level 2.
    // This facade may be based on an actual XMLHttpRequest Level 2 object
    // (on browsers that support it), or it may fake one using other
    // available technology.
    //
    // The created facade in any case presents the following interface:
    //
    //    open(method, url)
    //    send(body)
    //    abort()
    //    setContentType()
    //    responseText
    //    responseXML
    //    onload
    //    onerror(err)  - includes timeout; abort is ignored
    //
    // See the documentation at http://www.w3.org/TR/XMLHttpRequest/
    // for semantics.
    //
    // XMLHttpRequest Level 2 supports Cross-Origin Resource Sharing (CORS)
    // which makes sandbox evasion possible.  Faked XHRL2s returned by
    // this method may use CORS or some other technology to evade the
    // sandbox.  The SAMP hub itself may selectively allow some of these
    // technologies and not others, according to configuration.
    XmlRpcClient.createXHR = function() {

        // Creates an XHR facade based on a genuine XMLHttpRequest Level 2.
        var XhrL2 = function(xhr) {
            this.xhr = xhr;
            xhr.onreadystatechange = (function(l2) {
                return function() {
                    if (xhr.readyState !== 4) {
                        return;
                    }
                    else if (!l2.completed) {
                        if (+xhr.status === 200) {
                            l2.completed = true;
                            l2.responseText = xhr.responseText;
                            l2.responseXML = xhr.responseXML;
                            if (l2.onload) {
                                l2.onload();
                            }
                        }
                    }
                };
            })(this);
            xhr.onerror = (function(l2) {
                return function(event) {
                    if (!l2.completed) {
                        l2.completed = true;
                        if (l2.onerror) {
                            if (event) {
                                event.toString = function() {return "No hub?";};
                            }
                            else {
                                event = "No hub?";
                            }
                            l2.onerror(event);
                        }
                    }
                };
            })(this);
            xhr.ontimeout = (function(l2) {
                return function(event) {
                    if (!l2.completed) {
                        l2.completed = true;
                        if (l2.onerror) {
                            l2.onerror("timeout");
                        }
                    }
                };
            })(this);
        };
        XhrL2.prototype.open = function(method, url) {
            this.xhr.open(method, url);
        };
        XhrL2.prototype.send = function(body) {
            this.xhr.send(body);
        };
        XhrL2.prototype.abort = function() {
            this.xhr.abort();
        }
        XhrL2.prototype.setContentType = function(mimeType) {
            if ("setRequestHeader" in this.xhr) {
                this.xhr.setRequestHeader("Content-Type", mimeType);
            }
        }

        // Creates an XHR facade based on an XDomainRequest (IE8+ only).
        var XdrL2 = function(xdr) {
            this.xdr = xdr;
            xdr.onload = (function(l2) {
                return function() {
                    var e;
                    l2.responseText = xdr.responseText;
                    if (xdr.contentType === "text/xml" ||
                        xdr.contentType === "application/xml" ||
                        /\/x-/.test(xdr.contentType)) {
                        try {
                            var xdoc = new ActiveXObject("Microsoft.XMLDOM");
                            xdoc.loadXML(xdr.responseText);
                            l2.responseXML = xdoc;
                        }
                        catch (e) {
                            l2.responseXML = e;
                        }
                    }
                    if (l2.onload) {
                        l2.onload();
                    }
                };
            })(this);
            xdr.onerror = (function(l2) {
                return function(event) {
                    if (l2.onerror) {
                        l2.onerror(event);
                    }
                };
            })(this);
            xdr.ontimeout = (function(l2) {
                return function(event) {
                    if (l2.onerror) {
                        l2.onerror(event);
                    }
                };
            })(this);
        };
        XdrL2.prototype.open = function(method, url) {
            this.xdr.open(method, url);
        };
        XdrL2.prototype.send = function(body) {
            this.xdr.send(body);
        };
        XdrL2.prototype.abort = function() {
            this.xdr.abort();
        };
        XdrL2.prototype.setContentType = function(mimeType) {
            // can't do it.
        };

        // Creates an XHR Facade based on available XMLHttpRequest-type
        // capabilibities.
        // If an actual XMLHttpRequest Level 2 is available, use that.
        if (typeof XMLHttpRequest !== "undefined") {
            var xhr = new XMLHttpRequest();
            if ("withCredentials" in xhr) {
                return new XhrL2(xhr);
            }
        }

        // Else if an XDomainRequest is available, use that.
        if (typeof XDomainRequest !== "undefined") {
            return new XdrL2(new XDomainRequest());
        }

        // Else fake an XMLHttpRequest using Flash/flXHR, if available
        // and use that.
        if (typeof flensed.flXHR !== "undefined") {
            return new XhrL2(new flensed.flXHR({instancePooling: true}));
        }

        // No luck.
        throw new Error("no cross-origin mechanism available");
    };

    // Executes a request by passing it to the XML-RPC server.
    // On success, the result is passed to the resultHandler.
    // On failure, the errHandler is called with one of two possible
    // arguments: an XmlRpc.Fault object, or an Error object.
    XmlRpcClient.prototype.execute = function(req, resultHandler, errHandler) {
        (function(xClient) {
            var xhr;
            var e;
            try {
                xhr = XmlRpcClient.createXHR();
                xhr.open("POST", xClient.endpoint);
                xhr.setContentType("text/xml");
            }
            catch (e) {
                errHandler(e);
                throw e;
            }
            xhr.onload = function() {
                var xml = xhr.responseXML;
                var result;
                var e;
                if (xml) {
                    try {
                        result = XmlRpc.decodeResponse(xml);
                    }
                    catch (e) {
                        if (errHandler) {
                            errHandler(e);
                        }
                        return;
                    }
                }
                else {
                    if (errHandler) {
                        errHandler("no XML response");
                    }
                    return;
                }
                if (result instanceof XmlRpc.Fault) {
                    if (errHandler) {
                        errHandler(result);
                    }
                }
                else {
                    if (resultHandler) {
                        resultHandler(result);
                    }
                }
            };
            xhr.onerror = function(event) {
                if (event) {
                    event.toString = function() {return "No hub?";}
                }
                else {
                    event = "No hub";
                }
                if (errHandler) {
                    errHandler(event);
                }
            };
            xhr.send(req.toXml());
            return xhr;
        })(this);
    };

    // Message class:
    // Aggregates an MType string and a params map.
    var Message = function(mtype, params) {
        this["samp.mtype"] = mtype;
        this["samp.params"] = params;
    };

    // Connection class:
    // this is what clients use to communicate with the hub.
    //
    // All the methods from the Hub Abstract API as described in the
    // SAMP standard are available as methods of a Connection object.
    // The initial private-key argument required by the Web Profile is
    // handled internally by this object - you do not need to supply it
    // when calling one of the methods.
    //
    // All these calls have the same form:
    //
    //    connection.method([method-args], resultHandler, errorHandler)
    //
    // the first argument is an array of the arguments (as per the SAMP
    // abstract hub API), the second argument is a function which is
    // called on successful completion with the result of the SAMP call
    // as its argument, and the third argument is a function which is
    // called on unsuccessful completion with an error object as its
    // argument.  The resultHandler and errorHandler arguments are optional.
    //
    // So for instance if you have a Connection object conn,
    // you can send a notify message to all other clients by doing, e.g.:
    //
    //    conn.notifyAll([new samp.Message(mtype, params)])
    //
    // Connection has other methods as well as the hub API ones
    // as documented below.
    var Connection = function(regInfo) {
        this.regInfo = regInfo;
        this.privateKey = regInfo["samp.private-key"];
        if (! typeof(this.privateKey) === "string") {
            throw new Error("Bad registration object");
        }
        this.xClient = new XmlRpcClient();
    };
    (function() {
        var connMethods = {
            call: [TYPE_STRING, TYPE_STRING, TYPE_MAP],
            callAll: [TYPE_STRING, TYPE_MAP],
            callAndWait: [TYPE_STRING, TYPE_MAP, TYPE_STRING],
            declareMetadata: [TYPE_MAP],
            declareSubscriptions: [TYPE_MAP],
            getMetadata: [TYPE_STRING],
            getRegisteredClients: [],
            getSubscribedClients: [TYPE_STRING],
            getSubscriptions: [TYPE_STRING],
            notify: [TYPE_STRING, TYPE_MAP],
            notifyAll: [TYPE_MAP],
            ping: [],
            reply: [TYPE_STRING, TYPE_MAP]
        };
        var fn;
        var types;
        for (fn in connMethods) {
            (function(fname, types) {
                // errHandler may be passed an XmlRpc.Fault or a thrown Error.
                Connection.prototype[fname] =
                        function(sampArgs, resultHandler, errHandler) {
                    var closer =
                        (function(c) {return function() {c.close()}})(this);
                    errHandler = errHandler || closer
                    XmlRpc.checkParams(sampArgs, types);
                    var request = new XmlRpcRequest(WEBSAMP_PREFIX + fname);
                    request.addParam(this.privateKey);
                    request.addParams(sampArgs);
                    return this.xClient.
                           execute(request, resultHandler, errHandler);
                };
            })(fn, connMethods[fn]);
        }
    })();
    Connection.prototype.unregister = function() {
        var e;
        if (this.callbackRequest) {
            try {
                this.callbackRequest.abort();
            }
            catch (e) {
            }
        }
        var request = new XmlRpcRequest(WEBSAMP_PREFIX + "unregister");
        request.addParam(this.privateKey);
        try {
            this.xClient.execute(request);
        }
        catch (e) {
            // log unregister failed
        }
        delete this.regInfo;
        delete this.privateKey;
    };

    // Closes this connection.  It unregisters from the hub if still
    // registered, but may harmlessly be called multiple times.
    Connection.prototype.close = function() {
        var e;
        if (this.closed) {
            return;
        }
        this.closed = true;
        try {
            if (this.regInfo) {
                this.unregister();
            }
        }
        catch (e) {
        }
        if (this.onclose) {
            oc = this.onclose;
            delete this.onclose;
            try {
                oc();
            }
            catch (e) {
            }
        }
    };

    // Arranges for this connection to receive callbacks.
    //
    // The callableClient argument must be an object implementing the
    // SAMP callable client API, i.e. it must have the following methods:
    //
    //     receiveNotification(string sender-id, map message)
    //     receiveCall(string sender-id, string msg-id, map message)
    //     receiveResponse(string responder-id, string msg-tag, map response)
    // 
    // The successHandler argument will be called with no arguments if the
    // allowCallbacks hub method completes successfully - it is a suitable
    // hook to use for declaring subscriptions.
    //
    // The CallableClient class provides a suitable implementation, see below.
    Connection.prototype.setCallable = function(callableClient,
                                                successHandler) {
        var e;
        if (this.callbackRequest) {
            try {
                this.callbackRequest.abort();
            }
            catch (e) {
            }
            finally {
                delete this.callbackRequest;
            }
        }
        if (!callableClient && !this.regInfo) {
            return;
        }
        var request =
            new XmlRpcRequest(WEBSAMP_PREFIX + "allowReverseCallbacks");
        request.addParam(this.privateKey);
        request.addParam(callableClient ? "1" : "0");
        var closer = (function(c) {return function() {c.close()}})(this);
        if (callableClient) {
            (function(connection) {
                var invokeCallback = function(callback) {
                    var methodName = callback["samp.methodName"];
                    var methodParams = callback["samp.params"];
                    var handlerFunc = undefined;
                    if (methodName === WEBSAMP_CLIENT_PREFIX
                                     + "receiveNotification") {
                        handlerFunc = callableClient.receiveNotification;
                    }
                    else if (methodName === WEBSAMP_CLIENT_PREFIX
                                          + "receiveCall") {
                        handlerFunc = callableClient.receiveCall;
                    }
                    else if (methodName === WEBSAMP_CLIENT_PREFIX
                                          + "receiveResponse") {
                        handlerFunc = callableClient.receiveResponse;
                    }
                    else {
                        // unknown callback??
                    }
                    if (handlerFunc) {
                        handlerFunc.apply(callableClient, methodParams);
                    }
                };
                var startTime;
                var resultHandler = function(result) {
                    if (getSampType(result) != TYPE_LIST) {
                        errHandler(new Error("pullCallbacks result not List"));
                        return;
                    }
                    var i;
                    var e;
                    for (i = 0; i < result.length; i++) {
                        try {
                            invokeCallback(result[i]);
                        }
                        catch (e) {
                            // log here?
                        }
                    }
                    callWaiter();
                };
                var errHandler = function(error) {
                    var elapsed = new Date().getTime() - startTime;
                    if (elapsed < 1000) {
                        connection.close()
                    }
                    else {
                        // probably a timeout
                        callWaiter();
                    }
                };
                var callWaiter = function() {
                    if (!connection.regInfo) {
                        return;
                    }
                    var request =
                        new XmlRpcRequest(WEBSAMP_PREFIX + "pullCallbacks");
                    request.addParam(connection.privateKey);
                    request.addParam("600");
                    startTime = new Date().getTime();
                    connection.callbackRequest =
                        connection.xClient.
                                   execute(request, resultHandler, errHandler);
                };
                var sHandler = function() {
                    callWaiter();
                    successHandler();
                };
                connection.xClient.execute(request, sHandler, closer);
            })(this);
        }
        else {
            this.xClient.execute(request, successHandler, closer);
        }
    };

    // Takes a public URL and returns a URL that can be used from within
    // this javascript context.  Some translation may be required, since
    // a URL sent by an external application may be cross-domain, in which
    // case browser sandboxing would typically disallow access to it.
    Connection.prototype.translateUrl = function(url) {
        var translator = this.regInfo["samp.url-translator"] || "";
        return translator + url;
    };
    Connection.Action = function(actName, actArgs, resultKey) {
        this.actName = actName;
        this.actArgs = actArgs;
        this.resultKey = resultKey;
    };

    // Suitable implementation for a callable client object which can
    // be supplied to Connection.setCallable().
    // Its callHandler and replyHandler members are string->function maps
    // which can be used to provide handler functions for MTypes and
    // message tags respectively.
    //
    // In more detail:
    // The callHandler member maps a string representing an MType to
    // a function with arguments (senderId, message, isCall).
    // The replyHandler member maps a string representing a message tag to
    // a function with arguments (responderId, msgTag, response).
    var CallableClient = function(connection) {
        this.callHandler = {};
        this.replyHandler = {};
    };
    CallableClient.prototype.init = function(connection) {
    };
    CallableClient.prototype.receiveNotification = function(senderId, message) {
        var mtype = message["samp.mtype"];
        var handled = false;
        var e;
        if (mtype in this.callHandler) {
            try {
                this.callHandler[mtype](senderId, message, false);
            }
            catch (e) {
            }
            handled = true;
        }
        return handled;
    };
    CallableClient.prototype.receiveCall = function(senderId, msgId, message) {
        var mtype = message["samp.mtype"];
        var handled = false;
        var response;
        var result;
        var e;
        if (mtype in this.callHandler) {
            try {
                result = this.callHandler[mtype](senderId, message, true) || {};
                response = {"samp.status": "samp.ok",
                            "samp.result": result};
                handled = true;
            }
            catch (e) {
                response = {"samp.status": "samp.error",
                            "samp.error": {"samp.errortxt": e.toString()}};
            }
        }
        else {
            response = {"samp.status": "samp.warning",
                        "samp.result": {},
                        "samp.error": {"samp.errortxt": "no action"}};
        }
        this.connection.reply([msgId, response]);
        return handled;
    };
    CallableClient.prototype.receiveResponse = function(responderId, msgTag,
                                                        response) {
        var handled = false;
        var e;
        if (msgTag in this.replyHandler) {
            try {
                this.replyHandler[msgTag](responderId, msgTag, response);
                handled = true;
            }
            catch (e) {
            }
        }
        return handled;
    };
    CallableClient.prototype.calculateSubscriptions = function() {
        var subs = {};
        var mt;
        for (mt in this.callHandler) {
            subs[mt] = {};
        }
        return subs;
    };

    // ClientTracker is a CallableClient which also provides tracking of
    // registered clients.
    //
    // Its onchange member, if defined, will be called with arguments
    // (client-id, change-type, associated-data) whenever the list or
    // characteristics of registered clients has changed.
    var ClientTracker = function() {
        var tracker = this;
        this.ids = {};
        this.metas = {};
        this.subs = {};
        this.replyHandler = {};
        this.callHandler = {
            "samp.hub.event.shutdown": function(senderId, message) {
                tracker.connection.close();
            },
            "samp.hub.disconnect": function(senderId, message) {
                tracker.connection.close();
            },
            "samp.hub.event.register": function(senderId, message) {
                var id = message["samp.params"]["id"];
                tracker.ids[id] = true;
                tracker.changed(id, "register", null);
            },
            "samp.hub.event.unregister": function(senderId, message) {
                var id = message["samp.params"]["id"];
                delete tracker.ids[id];
                delete tracker.metas[id];
                delete tracker.subs[id];
                tracker.changed(id, "unregister", null);
            },
            "samp.hub.event.metadata": function(senderId, message) {
                var id = message["samp.params"]["id"];
                var meta = message["samp.params"]["metadata"];
                tracker.metas[id] = meta;
                tracker.changed(id, "meta", meta);
            },
            "samp.hub.event.subscriptions": function(senderId, message) {
                var id = message["samp.params"]["id"];
                var subs = message["samp.params"]["subscriptions"];
                tracker.subs[id] = subs;
                tracker.changed(id, "subs", subs);
            }
        };
    };
    ClientTracker.prototype = heir(CallableClient.prototype);
    ClientTracker.prototype.changed = function(id, type, data) {
        if (this.onchange) {
            this.onchange(id, type, data);
        }
    };
    ClientTracker.prototype.init = function(connection) {
        var tracker = this;
        this.connection = connection;
        var retrieveInfo = function(id, type, infoFuncName, infoArray) {
            connection[infoFuncName]([id], function(info) {
                infoArray[id] = info;
                tracker.changed(id, type, info);
            });
        };
        connection.getRegisteredClients([], function(idlist) {
            var i;
            var id;
            tracker.ids = {};
            for (i = 0; i < idlist.length; i++) {
                id = idlist[i];
                tracker.ids[id] = true;
                retrieveInfo(id, "meta", "getMetadata", tracker.metas);
                retrieveInfo(id, "subs", "getSubscriptions", tracker.subs);
            }
            tracker.changed(null, "ids", null);
        });
    };
    ClientTracker.prototype.getName = function(id) {
        var meta = this.metas[id];
        return (meta && meta["samp.name"]) ? meta["samp.name"] : "[" + id + "]";
    };

    // Connector class:
    // A higher level class which can manage transparent hub
    // registration/unregistration and client tracking.
    //
    // On construction, the name argument is mandatory, and corresponds
    // to the samp.name item submitted at registration time.
    // The other arguments are optional.
    // meta is a metadata map (if absent, no metadata is declared)
    // callableClient is a callable client object for receiving callbacks
    // (if absent, the client is not callable).
    // subs is a subscriptions map (if absent, no subscriptions are declared)
    var Connector = function(name, meta, callableClient, subs) {
        this.name = name;
        this.meta = meta;
        this.callableClient = callableClient;
        this.subs = subs;
        this.regTextNodes = [];
        this.whenRegs = [];
        this.whenUnregs = [];
        this.connection = undefined;
        this.onreg = undefined;
        this.onunreg = undefined;
    };
    var setRegText = function(connector, txt) {
        var i;
        var nodes = connector.regTextNodes;
        var node;
        for (i = 0; i < nodes.length; i++) {
            node = nodes[i];
            node.innerHTML = "";
            node.appendChild(document.createTextNode(txt));
        }
    };
    Connector.prototype.setConnection = function(conn) {
        var connector = this;
        var e;
        if (this.connection) {
            this.connection.close();
            if (this.onunreg) {
                try {
                    this.onunreg();
                }
                catch (e) {
                }
            }
        }
        this.connection = conn;
        if (conn) {
            conn.onclose = function() {
                connector.connection = null;
                if (connector.onunreg) {
                    try {
                        connector.onunreg();
                    }
                    catch (e) {
                    }
                }
                connector.update();
            };
            if (this.meta) {
                conn.declareMetadata([this.meta]);
            }
            if (this.callableClient) {
                if (this.callableClient.init) {
                    this.callableClient.init(conn);
                }
                conn.setCallable(this.callableClient, function() {
                    conn.declareSubscriptions([connector.subs]);
                });
            }
            if (this.onreg) {
                try {
                    this.onreg(conn);
                }
                catch (e) {
                }
            }
        }
        this.update();
    };
    Connector.prototype.register = function() {
        var connector = this;
        var regErrHandler = function(err) {
            setRegText(connector, "no (" + err.toString() + ")");
        };
        var regSuccessHandler = function(conn) {
            connector.setConnection(conn);
            setRegText(connector, conn ? "Yes" : "No");
        };
        register(this.name, regSuccessHandler, regErrHandler);
    };
    Connector.prototype.unregister = function() {
        if (this.connection) {
            this.connection.unregister([]);
            this.setConnection(null);
        }
    };

    // Returns a document fragment which contains Register/Unregister
    // buttons for use by the user to attempt to connect/disconnect
    // with the hub.  This is useful for models where explicit
    // user registration is encouraged or required, but when using
    // the register-on-demand model such buttons are not necessary.
    Connector.prototype.createRegButtons = function() {
        var connector = this;
        var regButt = document.createElement("button");
        regButt.setAttribute("type", "button");
        regButt.appendChild(document.createTextNode("Register"));
        regButt.onclick = function() {connector.register();};
        this.whenUnregs.push(regButt);
        var unregButt = document.createElement("button");
        unregButt.setAttribute("type", "button");
        unregButt.appendChild(document.createTextNode("Unregister"));
        unregButt.onclick = function() {connector.unregister();};
        this.whenRegs.push(unregButt);
        var regText = document.createElement("span");
        this.regTextNodes.push(regText);
        var node = document.createDocumentFragment();
        node.appendChild(regButt);
        node.appendChild(document.createTextNode(" "));
        node.appendChild(unregButt);
        var label = document.createElement("span");
        label.innerHTML = " <strong>Registered: </strong>";
        node.appendChild(label);
        node.appendChild(regText);
        this.update();
        return node;
    };

    Connector.prototype.update = function() {
        var i;
        var isConnected = !! this.connection;
        var enableds = isConnected ? this.whenRegs : this.whenUnregs;
        var disableds = isConnected ? this.whenUnregs : this.whenRegs;
        for (i = 0; i < enableds.length; i++) {
            enableds[i].removeAttribute("disabled");
        }
        for (i = 0; i < disableds.length; i++) {
            disableds[i].setAttribute("disabled", "disabled");
        }
        setRegText(this, "No");
    };

    // Provides execution of a SAMP operation with register-on-demand.
    // You can use this method to provide lightweight registration/use
    // of web SAMP.  Simply provide a connHandler function which
    // does something with a connection (e.g. sends a message) and
    // Connector.runWithConnection on it.  This will connect if not
    // already connected, and call the connHandler on with the connection.
    // No explicit registration action is then required from the user.
    //
    // If the regErrorHandler argument is supplied, it is a function of
    // one (error) argument called in the case that registration-on-demand
    // fails.
    //
    // This is a more-or-less complete sampjs page:
    //   <script>
    //     var connector = new samp.Connector("pinger", {"samp.name": "Pinger"})
    //     var pingFunc = function(connection) {
    //       connection.notifyAll([new samp.Message("samp.app.ping", {})])
    //     }
    //   </script>
    //   <button onclick="connector.runWithConnection(pingFunc)">Ping</button>
    Connector.prototype.runWithConnection =
            function(connHandler, regErrorHandler) {
        var connector = this;
        var regSuccessHandler = function(conn) {
            connector.setConnection(conn);
            connHandler(conn);
        };
        var regFailureHandler = function(e) {
            connector.setConnection(undefined);
            regErrorHandler(e);
        };
        var pingResultHandler = function(result) {
            connHandler(connector.connection);
        };
        var pingErrorHandler = function(err) {
            register(this.name, regSuccessHandler, regFailureHandler);
        };
        if (this.connection) {
            // Use getRegisteredClients as the most lightweight check
            // I can think of that this connection is still OK.
            // Ping doesn't work because the server replies even if the
            // private-key is incorrect/invalid.  Is that a bug or not?
            this.connection.
                 getRegisteredClients([], pingResultHandler, pingErrorHandler);
        }
        else {
            register(this.name, regSuccessHandler, regFailureHandler);
        }
    };

    // Sets up an interval timer to run at intervals and notify a callback
    // about whether a hub is currently running.
    // Every millis milliseconds, the supplied availHandler function is
    // called with a boolean argument: true if a (web profile) hub is
    // running, false if not.
    // Returns the interval timer (can be passed to clearInterval()).
    Connector.prototype.onHubAvailability = function(availHandler, millis) {
        samp.ping(availHandler);

        // Could use the W3C Page Visibility API to avoid making these
        // checks when the page is not visible.
        return setInterval(function() {samp.ping(availHandler);}, millis);
    };

    // Determines whether a given subscriptions map indicates subscription
    // to a given mtype.
    var isSubscribed = function(subs, mtype) {
        var matching = function(pattern, mtype) {
            if (pattern == mtype) {
                return true;
            }
            else if (pattern === "*") {
                return true;
            }
            else {
                var prefix;
                var split = /^(.*)\.\*$/.exec(pat);
                if (split) {
                    prefix = split[1];
                    if (prefix === mtype.substring(0, prefix.length)) {
                        return true;
                    }
                }
            }
            return false;
        };
        var pat;
        for (pat in subs) {
            if (matching(pat, mtype)) {
                return true;
            }
        }
        return false;
    }

    // Attempts registration with a SAMP hub.
    // On success the supplied connectionHandler function is called
    // with the connection as an argument, on failure the supplied
    // errorHandler is called with an argument that may be an Error
    // or an XmlRpc.Fault.
    var register = function(appName, connectionHandler, errorHandler) {
        var xClient = new XmlRpcClient();
        var regRequest = new XmlRpcRequest(WEBSAMP_PREFIX + "register");
        var securityInfo = {"samp.name": appName};
        regRequest.addParam(securityInfo);
        regRequest.checkParams([TYPE_MAP]);
        var resultHandler = function(result) {
            var conn;
            var e;
            try {
                conn = new Connection(result);
            }
            catch (e) {
                errorHandler(e);
                return;
            }
            connectionHandler(conn);
        };
        xClient.execute(regRequest, resultHandler, errorHandler);
    };

    // Calls the hub ping method once.  It is not necessary to be
    // registered to do this.
    // The supplied pingHandler function is called with a boolean argument:
    // true if a (web profile) hub is running, false if not.
    var ping = function(pingHandler) {
        var xClient = new XmlRpcClient();
        var pingRequest = new XmlRpcRequest(WEBSAMP_PREFIX + "ping");
        var resultHandler = function(result) {
            pingHandler(true);
        };
        var errorHandler = function(error) {
            pingHandler(false);
        };
        xClient.execute(pingRequest, resultHandler, errorHandler);
    };


    /* Exports. */
    var jss = {};
    jss.XmlRpcRequest = XmlRpcRequest;
    jss.XmlRpcClient = XmlRpcClient;
    jss.Message = Message;
    jss.TYPE_STRING = TYPE_STRING;
    jss.TYPE_LIST = TYPE_LIST;
    jss.TYPE_MAP = TYPE_MAP;
    jss.register = register;
    jss.ping = ping;
    jss.isSubscribed = isSubscribed;
    jss.Connector = Connector;
    jss.CallableClient = CallableClient;
    jss.ClientTracker = ClientTracker;

    return jss;
})();

define("samp", function(){});

/*! jQuery UI - v1.11.0 - 2014-06-26
* http://jqueryui.com
* Includes: core.js, widget.js, mouse.js, position.js, draggable.js, droppable.js, resizable.js, selectable.js, sortable.js, accordion.js, autocomplete.js, button.js, datepicker.js, dialog.js, menu.js, progressbar.js, selectmenu.js, slider.js, spinner.js, tabs.js, tooltip.js, effect.js, effect-blind.js, effect-bounce.js, effect-clip.js, effect-drop.js, effect-explode.js, effect-fade.js, effect-fold.js, effect-highlight.js, effect-puff.js, effect-pulsate.js, effect-scale.js, effect-shake.js, effect-size.js, effect-slide.js, effect-transfer.js
* Copyright 2014 jQuery Foundation and other contributors; Licensed MIT */

(function(e){"function"==typeof define&&define.amd?define('jquery.ui',["jquery"],e):e(jQuery)})(function(e){function t(t,s){var a,n,r,o=t.nodeName.toLowerCase();return"area"===o?(a=t.parentNode,n=a.name,t.href&&n&&"map"===a.nodeName.toLowerCase()?(r=e("img[usemap=#"+n+"]")[0],!!r&&i(r)):!1):(/input|select|textarea|button|object/.test(o)?!t.disabled:"a"===o?t.href||s:s)&&i(t)}function i(t){return e.expr.filters.visible(t)&&!e(t).parents().addBack().filter(function(){return"hidden"===e.css(this,"visibility")}).length}function s(e){for(var t,i;e.length&&e[0]!==document;){if(t=e.css("position"),("absolute"===t||"relative"===t||"fixed"===t)&&(i=parseInt(e.css("zIndex"),10),!isNaN(i)&&0!==i))return i;e=e.parent()}return 0}function a(){this._curInst=null,this._keyEvent=!1,this._disabledInputs=[],this._datepickerShowing=!1,this._inDialog=!1,this._mainDivId="ui-datepicker-div",this._inlineClass="ui-datepicker-inline",this._appendClass="ui-datepicker-append",this._triggerClass="ui-datepicker-trigger",this._dialogClass="ui-datepicker-dialog",this._disableClass="ui-datepicker-disabled",this._unselectableClass="ui-datepicker-unselectable",this._currentClass="ui-datepicker-current-day",this._dayOverClass="ui-datepicker-days-cell-over",this.regional=[],this.regional[""]={closeText:"Done",prevText:"Prev",nextText:"Next",currentText:"Today",monthNames:["January","February","March","April","May","June","July","August","September","October","November","December"],monthNamesShort:["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],dayNames:["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],dayNamesShort:["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],dayNamesMin:["Su","Mo","Tu","We","Th","Fr","Sa"],weekHeader:"Wk",dateFormat:"mm/dd/yy",firstDay:0,isRTL:!1,showMonthAfterYear:!1,yearSuffix:""},this._defaults={showOn:"focus",showAnim:"fadeIn",showOptions:{},defaultDate:null,appendText:"",buttonText:"...",buttonImage:"",buttonImageOnly:!1,hideIfNoPrevNext:!1,navigationAsDateFormat:!1,gotoCurrent:!1,changeMonth:!1,changeYear:!1,yearRange:"c-10:c+10",showOtherMonths:!1,selectOtherMonths:!1,showWeek:!1,calculateWeek:this.iso8601Week,shortYearCutoff:"+10",minDate:null,maxDate:null,duration:"fast",beforeShowDay:null,beforeShow:null,onSelect:null,onChangeMonthYear:null,onClose:null,numberOfMonths:1,showCurrentAtPos:0,stepMonths:1,stepBigMonths:12,altField:"",altFormat:"",constrainInput:!0,showButtonPanel:!1,autoSize:!1,disabled:!1},e.extend(this._defaults,this.regional[""]),this.regional.en=e.extend(!0,{},this.regional[""]),this.regional["en-US"]=e.extend(!0,{},this.regional.en),this.dpDiv=n(e("<div id='"+this._mainDivId+"' class='ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all'></div>"))}function n(t){var i="button, .ui-datepicker-prev, .ui-datepicker-next, .ui-datepicker-calendar td a";return t.delegate(i,"mouseout",function(){e(this).removeClass("ui-state-hover"),-1!==this.className.indexOf("ui-datepicker-prev")&&e(this).removeClass("ui-datepicker-prev-hover"),-1!==this.className.indexOf("ui-datepicker-next")&&e(this).removeClass("ui-datepicker-next-hover")}).delegate(i,"mouseover",function(){e.datepicker._isDisabledDatepicker(g.inline?t.parent()[0]:g.input[0])||(e(this).parents(".ui-datepicker-calendar").find("a").removeClass("ui-state-hover"),e(this).addClass("ui-state-hover"),-1!==this.className.indexOf("ui-datepicker-prev")&&e(this).addClass("ui-datepicker-prev-hover"),-1!==this.className.indexOf("ui-datepicker-next")&&e(this).addClass("ui-datepicker-next-hover"))})}function r(t,i){e.extend(t,i);for(var s in i)null==i[s]&&(t[s]=i[s]);return t}function o(e){return function(){var t=this.element.val();e.apply(this,arguments),this._refresh(),t!==this.element.val()&&this._trigger("change")}}e.ui=e.ui||{},e.extend(e.ui,{version:"1.11.0",keyCode:{BACKSPACE:8,COMMA:188,DELETE:46,DOWN:40,END:35,ENTER:13,ESCAPE:27,HOME:36,LEFT:37,PAGE_DOWN:34,PAGE_UP:33,PERIOD:190,RIGHT:39,SPACE:32,TAB:9,UP:38}}),e.fn.extend({scrollParent:function(){var t=this.css("position"),i="absolute"===t,s=this.parents().filter(function(){var t=e(this);return i&&"static"===t.css("position")?!1:/(auto|scroll)/.test(t.css("overflow")+t.css("overflow-y")+t.css("overflow-x"))}).eq(0);return"fixed"!==t&&s.length?s:e(this[0].ownerDocument||document)},uniqueId:function(){var e=0;return function(){return this.each(function(){this.id||(this.id="ui-id-"+ ++e)})}}(),removeUniqueId:function(){return this.each(function(){/^ui-id-\d+$/.test(this.id)&&e(this).removeAttr("id")})}}),e.extend(e.expr[":"],{data:e.expr.createPseudo?e.expr.createPseudo(function(t){return function(i){return!!e.data(i,t)}}):function(t,i,s){return!!e.data(t,s[3])},focusable:function(i){return t(i,!isNaN(e.attr(i,"tabindex")))},tabbable:function(i){var s=e.attr(i,"tabindex"),a=isNaN(s);return(a||s>=0)&&t(i,!a)}}),e("<a>").outerWidth(1).jquery||e.each(["Width","Height"],function(t,i){function s(t,i,s,n){return e.each(a,function(){i-=parseFloat(e.css(t,"padding"+this))||0,s&&(i-=parseFloat(e.css(t,"border"+this+"Width"))||0),n&&(i-=parseFloat(e.css(t,"margin"+this))||0)}),i}var a="Width"===i?["Left","Right"]:["Top","Bottom"],n=i.toLowerCase(),r={innerWidth:e.fn.innerWidth,innerHeight:e.fn.innerHeight,outerWidth:e.fn.outerWidth,outerHeight:e.fn.outerHeight};e.fn["inner"+i]=function(t){return void 0===t?r["inner"+i].call(this):this.each(function(){e(this).css(n,s(this,t)+"px")})},e.fn["outer"+i]=function(t,a){return"number"!=typeof t?r["outer"+i].call(this,t):this.each(function(){e(this).css(n,s(this,t,!0,a)+"px")})}}),e.fn.addBack||(e.fn.addBack=function(e){return this.add(null==e?this.prevObject:this.prevObject.filter(e))}),e("<a>").data("a-b","a").removeData("a-b").data("a-b")&&(e.fn.removeData=function(t){return function(i){return arguments.length?t.call(this,e.camelCase(i)):t.call(this)}}(e.fn.removeData)),e.ui.ie=!!/msie [\w.]+/.exec(navigator.userAgent.toLowerCase()),e.fn.extend({focus:function(t){return function(i,s){return"number"==typeof i?this.each(function(){var t=this;setTimeout(function(){e(t).focus(),s&&s.call(t)},i)}):t.apply(this,arguments)}}(e.fn.focus),disableSelection:function(){var e="onselectstart"in document.createElement("div")?"selectstart":"mousedown";return function(){return this.bind(e+".ui-disableSelection",function(e){e.preventDefault()})}}(),enableSelection:function(){return this.unbind(".ui-disableSelection")},zIndex:function(t){if(void 0!==t)return this.css("zIndex",t);if(this.length)for(var i,s,a=e(this[0]);a.length&&a[0]!==document;){if(i=a.css("position"),("absolute"===i||"relative"===i||"fixed"===i)&&(s=parseInt(a.css("zIndex"),10),!isNaN(s)&&0!==s))return s;a=a.parent()}return 0}}),e.ui.plugin={add:function(t,i,s){var a,n=e.ui[t].prototype;for(a in s)n.plugins[a]=n.plugins[a]||[],n.plugins[a].push([i,s[a]])},call:function(e,t,i,s){var a,n=e.plugins[t];if(n&&(s||e.element[0].parentNode&&11!==e.element[0].parentNode.nodeType))for(a=0;n.length>a;a++)e.options[n[a][0]]&&n[a][1].apply(e.element,i)}};var h=0,l=Array.prototype.slice;e.cleanData=function(t){return function(i){for(var s,a=0;null!=(s=i[a]);a++)try{e(s).triggerHandler("remove")}catch(n){}t(i)}}(e.cleanData),e.widget=function(t,i,s){var a,n,r,o,h={},l=t.split(".")[0];return t=t.split(".")[1],a=l+"-"+t,s||(s=i,i=e.Widget),e.expr[":"][a.toLowerCase()]=function(t){return!!e.data(t,a)},e[l]=e[l]||{},n=e[l][t],r=e[l][t]=function(e,t){return this._createWidget?(arguments.length&&this._createWidget(e,t),void 0):new r(e,t)},e.extend(r,n,{version:s.version,_proto:e.extend({},s),_childConstructors:[]}),o=new i,o.options=e.widget.extend({},o.options),e.each(s,function(t,s){return e.isFunction(s)?(h[t]=function(){var e=function(){return i.prototype[t].apply(this,arguments)},a=function(e){return i.prototype[t].apply(this,e)};return function(){var t,i=this._super,n=this._superApply;return this._super=e,this._superApply=a,t=s.apply(this,arguments),this._super=i,this._superApply=n,t}}(),void 0):(h[t]=s,void 0)}),r.prototype=e.widget.extend(o,{widgetEventPrefix:n?o.widgetEventPrefix||t:t},h,{constructor:r,namespace:l,widgetName:t,widgetFullName:a}),n?(e.each(n._childConstructors,function(t,i){var s=i.prototype;e.widget(s.namespace+"."+s.widgetName,r,i._proto)}),delete n._childConstructors):i._childConstructors.push(r),e.widget.bridge(t,r),r},e.widget.extend=function(t){for(var i,s,a=l.call(arguments,1),n=0,r=a.length;r>n;n++)for(i in a[n])s=a[n][i],a[n].hasOwnProperty(i)&&void 0!==s&&(t[i]=e.isPlainObject(s)?e.isPlainObject(t[i])?e.widget.extend({},t[i],s):e.widget.extend({},s):s);return t},e.widget.bridge=function(t,i){var s=i.prototype.widgetFullName||t;e.fn[t]=function(a){var n="string"==typeof a,r=l.call(arguments,1),o=this;return a=!n&&r.length?e.widget.extend.apply(null,[a].concat(r)):a,n?this.each(function(){var i,n=e.data(this,s);return"instance"===a?(o=n,!1):n?e.isFunction(n[a])&&"_"!==a.charAt(0)?(i=n[a].apply(n,r),i!==n&&void 0!==i?(o=i&&i.jquery?o.pushStack(i.get()):i,!1):void 0):e.error("no such method '"+a+"' for "+t+" widget instance"):e.error("cannot call methods on "+t+" prior to initialization; "+"attempted to call method '"+a+"'")}):this.each(function(){var t=e.data(this,s);t?(t.option(a||{}),t._init&&t._init()):e.data(this,s,new i(a,this))}),o}},e.Widget=function(){},e.Widget._childConstructors=[],e.Widget.prototype={widgetName:"widget",widgetEventPrefix:"",defaultElement:"<div>",options:{disabled:!1,create:null},_createWidget:function(t,i){i=e(i||this.defaultElement||this)[0],this.element=e(i),this.uuid=h++,this.eventNamespace="."+this.widgetName+this.uuid,this.options=e.widget.extend({},this.options,this._getCreateOptions(),t),this.bindings=e(),this.hoverable=e(),this.focusable=e(),i!==this&&(e.data(i,this.widgetFullName,this),this._on(!0,this.element,{remove:function(e){e.target===i&&this.destroy()}}),this.document=e(i.style?i.ownerDocument:i.document||i),this.window=e(this.document[0].defaultView||this.document[0].parentWindow)),this._create(),this._trigger("create",null,this._getCreateEventData()),this._init()},_getCreateOptions:e.noop,_getCreateEventData:e.noop,_create:e.noop,_init:e.noop,destroy:function(){this._destroy(),this.element.unbind(this.eventNamespace).removeData(this.widgetFullName).removeData(e.camelCase(this.widgetFullName)),this.widget().unbind(this.eventNamespace).removeAttr("aria-disabled").removeClass(this.widgetFullName+"-disabled "+"ui-state-disabled"),this.bindings.unbind(this.eventNamespace),this.hoverable.removeClass("ui-state-hover"),this.focusable.removeClass("ui-state-focus")},_destroy:e.noop,widget:function(){return this.element},option:function(t,i){var s,a,n,r=t;if(0===arguments.length)return e.widget.extend({},this.options);if("string"==typeof t)if(r={},s=t.split("."),t=s.shift(),s.length){for(a=r[t]=e.widget.extend({},this.options[t]),n=0;s.length-1>n;n++)a[s[n]]=a[s[n]]||{},a=a[s[n]];if(t=s.pop(),1===arguments.length)return void 0===a[t]?null:a[t];a[t]=i}else{if(1===arguments.length)return void 0===this.options[t]?null:this.options[t];r[t]=i}return this._setOptions(r),this},_setOptions:function(e){var t;for(t in e)this._setOption(t,e[t]);return this},_setOption:function(e,t){return this.options[e]=t,"disabled"===e&&(this.widget().toggleClass(this.widgetFullName+"-disabled",!!t),t&&(this.hoverable.removeClass("ui-state-hover"),this.focusable.removeClass("ui-state-focus"))),this},enable:function(){return this._setOptions({disabled:!1})},disable:function(){return this._setOptions({disabled:!0})},_on:function(t,i,s){var a,n=this;"boolean"!=typeof t&&(s=i,i=t,t=!1),s?(i=a=e(i),this.bindings=this.bindings.add(i)):(s=i,i=this.element,a=this.widget()),e.each(s,function(s,r){function o(){return t||n.options.disabled!==!0&&!e(this).hasClass("ui-state-disabled")?("string"==typeof r?n[r]:r).apply(n,arguments):void 0}"string"!=typeof r&&(o.guid=r.guid=r.guid||o.guid||e.guid++);var h=s.match(/^([\w:-]*)\s*(.*)$/),l=h[1]+n.eventNamespace,u=h[2];u?a.delegate(u,l,o):i.bind(l,o)})},_off:function(e,t){t=(t||"").split(" ").join(this.eventNamespace+" ")+this.eventNamespace,e.unbind(t).undelegate(t)},_delay:function(e,t){function i(){return("string"==typeof e?s[e]:e).apply(s,arguments)}var s=this;return setTimeout(i,t||0)},_hoverable:function(t){this.hoverable=this.hoverable.add(t),this._on(t,{mouseenter:function(t){e(t.currentTarget).addClass("ui-state-hover")},mouseleave:function(t){e(t.currentTarget).removeClass("ui-state-hover")}})},_focusable:function(t){this.focusable=this.focusable.add(t),this._on(t,{focusin:function(t){e(t.currentTarget).addClass("ui-state-focus")},focusout:function(t){e(t.currentTarget).removeClass("ui-state-focus")}})},_trigger:function(t,i,s){var a,n,r=this.options[t];if(s=s||{},i=e.Event(i),i.type=(t===this.widgetEventPrefix?t:this.widgetEventPrefix+t).toLowerCase(),i.target=this.element[0],n=i.originalEvent)for(a in n)a in i||(i[a]=n[a]);return this.element.trigger(i,s),!(e.isFunction(r)&&r.apply(this.element[0],[i].concat(s))===!1||i.isDefaultPrevented())}},e.each({show:"fadeIn",hide:"fadeOut"},function(t,i){e.Widget.prototype["_"+t]=function(s,a,n){"string"==typeof a&&(a={effect:a});var r,o=a?a===!0||"number"==typeof a?i:a.effect||i:t;a=a||{},"number"==typeof a&&(a={duration:a}),r=!e.isEmptyObject(a),a.complete=n,a.delay&&s.delay(a.delay),r&&e.effects&&e.effects.effect[o]?s[t](a):o!==t&&s[o]?s[o](a.duration,a.easing,n):s.queue(function(i){e(this)[t](),n&&n.call(s[0]),i()})}}),e.widget;var u=!1;e(document).mouseup(function(){u=!1}),e.widget("ui.mouse",{version:"1.11.0",options:{cancel:"input,textarea,button,select,option",distance:1,delay:0},_mouseInit:function(){var t=this;this.element.bind("mousedown."+this.widgetName,function(e){return t._mouseDown(e)}).bind("click."+this.widgetName,function(i){return!0===e.data(i.target,t.widgetName+".preventClickEvent")?(e.removeData(i.target,t.widgetName+".preventClickEvent"),i.stopImmediatePropagation(),!1):void 0}),this.started=!1},_mouseDestroy:function(){this.element.unbind("."+this.widgetName),this._mouseMoveDelegate&&this.document.unbind("mousemove."+this.widgetName,this._mouseMoveDelegate).unbind("mouseup."+this.widgetName,this._mouseUpDelegate)},_mouseDown:function(t){if(!u){this._mouseStarted&&this._mouseUp(t),this._mouseDownEvent=t;var i=this,s=1===t.which,a="string"==typeof this.options.cancel&&t.target.nodeName?e(t.target).closest(this.options.cancel).length:!1;return s&&!a&&this._mouseCapture(t)?(this.mouseDelayMet=!this.options.delay,this.mouseDelayMet||(this._mouseDelayTimer=setTimeout(function(){i.mouseDelayMet=!0},this.options.delay)),this._mouseDistanceMet(t)&&this._mouseDelayMet(t)&&(this._mouseStarted=this._mouseStart(t)!==!1,!this._mouseStarted)?(t.preventDefault(),!0):(!0===e.data(t.target,this.widgetName+".preventClickEvent")&&e.removeData(t.target,this.widgetName+".preventClickEvent"),this._mouseMoveDelegate=function(e){return i._mouseMove(e)},this._mouseUpDelegate=function(e){return i._mouseUp(e)},this.document.bind("mousemove."+this.widgetName,this._mouseMoveDelegate).bind("mouseup."+this.widgetName,this._mouseUpDelegate),t.preventDefault(),u=!0,!0)):!0}},_mouseMove:function(t){return e.ui.ie&&(!document.documentMode||9>document.documentMode)&&!t.button?this._mouseUp(t):t.which?this._mouseStarted?(this._mouseDrag(t),t.preventDefault()):(this._mouseDistanceMet(t)&&this._mouseDelayMet(t)&&(this._mouseStarted=this._mouseStart(this._mouseDownEvent,t)!==!1,this._mouseStarted?this._mouseDrag(t):this._mouseUp(t)),!this._mouseStarted):this._mouseUp(t)},_mouseUp:function(t){return this.document.unbind("mousemove."+this.widgetName,this._mouseMoveDelegate).unbind("mouseup."+this.widgetName,this._mouseUpDelegate),this._mouseStarted&&(this._mouseStarted=!1,t.target===this._mouseDownEvent.target&&e.data(t.target,this.widgetName+".preventClickEvent",!0),this._mouseStop(t)),u=!1,!1},_mouseDistanceMet:function(e){return Math.max(Math.abs(this._mouseDownEvent.pageX-e.pageX),Math.abs(this._mouseDownEvent.pageY-e.pageY))>=this.options.distance},_mouseDelayMet:function(){return this.mouseDelayMet},_mouseStart:function(){},_mouseDrag:function(){},_mouseStop:function(){},_mouseCapture:function(){return!0}}),function(){function t(e,t,i){return[parseFloat(e[0])*(p.test(e[0])?t/100:1),parseFloat(e[1])*(p.test(e[1])?i/100:1)]}function i(t,i){return parseInt(e.css(t,i),10)||0}function s(t){var i=t[0];return 9===i.nodeType?{width:t.width(),height:t.height(),offset:{top:0,left:0}}:e.isWindow(i)?{width:t.width(),height:t.height(),offset:{top:t.scrollTop(),left:t.scrollLeft()}}:i.preventDefault?{width:0,height:0,offset:{top:i.pageY,left:i.pageX}}:{width:t.outerWidth(),height:t.outerHeight(),offset:t.offset()}}e.ui=e.ui||{};var a,n,r=Math.max,o=Math.abs,h=Math.round,l=/left|center|right/,u=/top|center|bottom/,d=/[\+\-]\d+(\.[\d]+)?%?/,c=/^\w+/,p=/%$/,f=e.fn.position;e.position={scrollbarWidth:function(){if(void 0!==a)return a;var t,i,s=e("<div style='display:block;position:absolute;width:50px;height:50px;overflow:hidden;'><div style='height:100px;width:auto;'></div></div>"),n=s.children()[0];return e("body").append(s),t=n.offsetWidth,s.css("overflow","scroll"),i=n.offsetWidth,t===i&&(i=s[0].clientWidth),s.remove(),a=t-i},getScrollInfo:function(t){var i=t.isWindow||t.isDocument?"":t.element.css("overflow-x"),s=t.isWindow||t.isDocument?"":t.element.css("overflow-y"),a="scroll"===i||"auto"===i&&t.width<t.element[0].scrollWidth,n="scroll"===s||"auto"===s&&t.height<t.element[0].scrollHeight;return{width:n?e.position.scrollbarWidth():0,height:a?e.position.scrollbarWidth():0}},getWithinInfo:function(t){var i=e(t||window),s=e.isWindow(i[0]),a=!!i[0]&&9===i[0].nodeType;return{element:i,isWindow:s,isDocument:a,offset:i.offset()||{left:0,top:0},scrollLeft:i.scrollLeft(),scrollTop:i.scrollTop(),width:s?i.width():i.outerWidth(),height:s?i.height():i.outerHeight()}}},e.fn.position=function(a){if(!a||!a.of)return f.apply(this,arguments);a=e.extend({},a);var p,m,g,v,y,b,_=e(a.of),x=e.position.getWithinInfo(a.within),k=e.position.getScrollInfo(x),w=(a.collision||"flip").split(" "),D={};return b=s(_),_[0].preventDefault&&(a.at="left top"),m=b.width,g=b.height,v=b.offset,y=e.extend({},v),e.each(["my","at"],function(){var e,t,i=(a[this]||"").split(" ");1===i.length&&(i=l.test(i[0])?i.concat(["center"]):u.test(i[0])?["center"].concat(i):["center","center"]),i[0]=l.test(i[0])?i[0]:"center",i[1]=u.test(i[1])?i[1]:"center",e=d.exec(i[0]),t=d.exec(i[1]),D[this]=[e?e[0]:0,t?t[0]:0],a[this]=[c.exec(i[0])[0],c.exec(i[1])[0]]}),1===w.length&&(w[1]=w[0]),"right"===a.at[0]?y.left+=m:"center"===a.at[0]&&(y.left+=m/2),"bottom"===a.at[1]?y.top+=g:"center"===a.at[1]&&(y.top+=g/2),p=t(D.at,m,g),y.left+=p[0],y.top+=p[1],this.each(function(){var s,l,u=e(this),d=u.outerWidth(),c=u.outerHeight(),f=i(this,"marginLeft"),b=i(this,"marginTop"),T=d+f+i(this,"marginRight")+k.width,S=c+b+i(this,"marginBottom")+k.height,M=e.extend({},y),N=t(D.my,u.outerWidth(),u.outerHeight());"right"===a.my[0]?M.left-=d:"center"===a.my[0]&&(M.left-=d/2),"bottom"===a.my[1]?M.top-=c:"center"===a.my[1]&&(M.top-=c/2),M.left+=N[0],M.top+=N[1],n||(M.left=h(M.left),M.top=h(M.top)),s={marginLeft:f,marginTop:b},e.each(["left","top"],function(t,i){e.ui.position[w[t]]&&e.ui.position[w[t]][i](M,{targetWidth:m,targetHeight:g,elemWidth:d,elemHeight:c,collisionPosition:s,collisionWidth:T,collisionHeight:S,offset:[p[0]+N[0],p[1]+N[1]],my:a.my,at:a.at,within:x,elem:u})}),a.using&&(l=function(e){var t=v.left-M.left,i=t+m-d,s=v.top-M.top,n=s+g-c,h={target:{element:_,left:v.left,top:v.top,width:m,height:g},element:{element:u,left:M.left,top:M.top,width:d,height:c},horizontal:0>i?"left":t>0?"right":"center",vertical:0>n?"top":s>0?"bottom":"middle"};d>m&&m>o(t+i)&&(h.horizontal="center"),c>g&&g>o(s+n)&&(h.vertical="middle"),h.important=r(o(t),o(i))>r(o(s),o(n))?"horizontal":"vertical",a.using.call(this,e,h)}),u.offset(e.extend(M,{using:l}))})},e.ui.position={fit:{left:function(e,t){var i,s=t.within,a=s.isWindow?s.scrollLeft:s.offset.left,n=s.width,o=e.left-t.collisionPosition.marginLeft,h=a-o,l=o+t.collisionWidth-n-a;t.collisionWidth>n?h>0&&0>=l?(i=e.left+h+t.collisionWidth-n-a,e.left+=h-i):e.left=l>0&&0>=h?a:h>l?a+n-t.collisionWidth:a:h>0?e.left+=h:l>0?e.left-=l:e.left=r(e.left-o,e.left)},top:function(e,t){var i,s=t.within,a=s.isWindow?s.scrollTop:s.offset.top,n=t.within.height,o=e.top-t.collisionPosition.marginTop,h=a-o,l=o+t.collisionHeight-n-a;t.collisionHeight>n?h>0&&0>=l?(i=e.top+h+t.collisionHeight-n-a,e.top+=h-i):e.top=l>0&&0>=h?a:h>l?a+n-t.collisionHeight:a:h>0?e.top+=h:l>0?e.top-=l:e.top=r(e.top-o,e.top)}},flip:{left:function(e,t){var i,s,a=t.within,n=a.offset.left+a.scrollLeft,r=a.width,h=a.isWindow?a.scrollLeft:a.offset.left,l=e.left-t.collisionPosition.marginLeft,u=l-h,d=l+t.collisionWidth-r-h,c="left"===t.my[0]?-t.elemWidth:"right"===t.my[0]?t.elemWidth:0,p="left"===t.at[0]?t.targetWidth:"right"===t.at[0]?-t.targetWidth:0,f=-2*t.offset[0];0>u?(i=e.left+c+p+f+t.collisionWidth-r-n,(0>i||o(u)>i)&&(e.left+=c+p+f)):d>0&&(s=e.left-t.collisionPosition.marginLeft+c+p+f-h,(s>0||d>o(s))&&(e.left+=c+p+f))},top:function(e,t){var i,s,a=t.within,n=a.offset.top+a.scrollTop,r=a.height,h=a.isWindow?a.scrollTop:a.offset.top,l=e.top-t.collisionPosition.marginTop,u=l-h,d=l+t.collisionHeight-r-h,c="top"===t.my[1],p=c?-t.elemHeight:"bottom"===t.my[1]?t.elemHeight:0,f="top"===t.at[1]?t.targetHeight:"bottom"===t.at[1]?-t.targetHeight:0,m=-2*t.offset[1];0>u?(s=e.top+p+f+m+t.collisionHeight-r-n,e.top+p+f+m>u&&(0>s||o(u)>s)&&(e.top+=p+f+m)):d>0&&(i=e.top-t.collisionPosition.marginTop+p+f+m-h,e.top+p+f+m>d&&(i>0||d>o(i))&&(e.top+=p+f+m))}},flipfit:{left:function(){e.ui.position.flip.left.apply(this,arguments),e.ui.position.fit.left.apply(this,arguments)},top:function(){e.ui.position.flip.top.apply(this,arguments),e.ui.position.fit.top.apply(this,arguments)}}},function(){var t,i,s,a,r,o=document.getElementsByTagName("body")[0],h=document.createElement("div");t=document.createElement(o?"div":"body"),s={visibility:"hidden",width:0,height:0,border:0,margin:0,background:"none"},o&&e.extend(s,{position:"absolute",left:"-1000px",top:"-1000px"});for(r in s)t.style[r]=s[r];t.appendChild(h),i=o||document.documentElement,i.insertBefore(t,i.firstChild),h.style.cssText="position: absolute; left: 10.7432222px;",a=e(h).offset().left,n=a>10&&11>a,t.innerHTML="",i.removeChild(t)}()}(),e.ui.position,e.widget("ui.draggable",e.ui.mouse,{version:"1.11.0",widgetEventPrefix:"drag",options:{addClasses:!0,appendTo:"parent",axis:!1,connectToSortable:!1,containment:!1,cursor:"auto",cursorAt:!1,grid:!1,handle:!1,helper:"original",iframeFix:!1,opacity:!1,refreshPositions:!1,revert:!1,revertDuration:500,scope:"default",scroll:!0,scrollSensitivity:20,scrollSpeed:20,snap:!1,snapMode:"both",snapTolerance:20,stack:!1,zIndex:!1,drag:null,start:null,stop:null},_create:function(){"original"!==this.options.helper||/^(?:r|a|f)/.test(this.element.css("position"))||(this.element[0].style.position="relative"),this.options.addClasses&&this.element.addClass("ui-draggable"),this.options.disabled&&this.element.addClass("ui-draggable-disabled"),this._setHandleClassName(),this._mouseInit()},_setOption:function(e,t){this._super(e,t),"handle"===e&&this._setHandleClassName()},_destroy:function(){return(this.helper||this.element).is(".ui-draggable-dragging")?(this.destroyOnClear=!0,void 0):(this.element.removeClass("ui-draggable ui-draggable-dragging ui-draggable-disabled"),this._removeHandleClassName(),this._mouseDestroy(),void 0)},_mouseCapture:function(t){var i=this.document[0],s=this.options;try{i.activeElement&&"body"!==i.activeElement.nodeName.toLowerCase()&&e(i.activeElement).blur()}catch(a){}return this.helper||s.disabled||e(t.target).closest(".ui-resizable-handle").length>0?!1:(this.handle=this._getHandle(t),this.handle?(e(s.iframeFix===!0?"iframe":s.iframeFix).each(function(){e("<div class='ui-draggable-iframeFix' style='background: #fff;'></div>").css({width:this.offsetWidth+"px",height:this.offsetHeight+"px",position:"absolute",opacity:"0.001",zIndex:1e3}).css(e(this).offset()).appendTo("body")}),!0):!1)},_mouseStart:function(t){var i=this.options;return this.helper=this._createHelper(t),this.helper.addClass("ui-draggable-dragging"),this._cacheHelperProportions(),e.ui.ddmanager&&(e.ui.ddmanager.current=this),this._cacheMargins(),this.cssPosition=this.helper.css("position"),this.scrollParent=this.helper.scrollParent(),this.offsetParent=this.helper.offsetParent(),this.offsetParentCssPosition=this.offsetParent.css("position"),this.offset=this.positionAbs=this.element.offset(),this.offset={top:this.offset.top-this.margins.top,left:this.offset.left-this.margins.left},this.offset.scroll=!1,e.extend(this.offset,{click:{left:t.pageX-this.offset.left,top:t.pageY-this.offset.top},parent:this._getParentOffset(),relative:this._getRelativeOffset()}),this.originalPosition=this.position=this._generatePosition(t,!1),this.originalPageX=t.pageX,this.originalPageY=t.pageY,i.cursorAt&&this._adjustOffsetFromHelper(i.cursorAt),this._setContainment(),this._trigger("start",t)===!1?(this._clear(),!1):(this._cacheHelperProportions(),e.ui.ddmanager&&!i.dropBehaviour&&e.ui.ddmanager.prepareOffsets(this,t),this._mouseDrag(t,!0),e.ui.ddmanager&&e.ui.ddmanager.dragStart(this,t),!0)},_mouseDrag:function(t,i){if("fixed"===this.offsetParentCssPosition&&(this.offset.parent=this._getParentOffset()),this.position=this._generatePosition(t,!0),this.positionAbs=this._convertPositionTo("absolute"),!i){var s=this._uiHash();if(this._trigger("drag",t,s)===!1)return this._mouseUp({}),!1;this.position=s.position}return this.helper[0].style.left=this.position.left+"px",this.helper[0].style.top=this.position.top+"px",e.ui.ddmanager&&e.ui.ddmanager.drag(this,t),!1},_mouseStop:function(t){var i=this,s=!1;return e.ui.ddmanager&&!this.options.dropBehaviour&&(s=e.ui.ddmanager.drop(this,t)),this.dropped&&(s=this.dropped,this.dropped=!1),"invalid"===this.options.revert&&!s||"valid"===this.options.revert&&s||this.options.revert===!0||e.isFunction(this.options.revert)&&this.options.revert.call(this.element,s)?e(this.helper).animate(this.originalPosition,parseInt(this.options.revertDuration,10),function(){i._trigger("stop",t)!==!1&&i._clear()}):this._trigger("stop",t)!==!1&&this._clear(),!1},_mouseUp:function(t){return e("div.ui-draggable-iframeFix").each(function(){this.parentNode.removeChild(this)}),e.ui.ddmanager&&e.ui.ddmanager.dragStop(this,t),this.element.focus(),e.ui.mouse.prototype._mouseUp.call(this,t)},cancel:function(){return this.helper.is(".ui-draggable-dragging")?this._mouseUp({}):this._clear(),this},_getHandle:function(t){return this.options.handle?!!e(t.target).closest(this.element.find(this.options.handle)).length:!0},_setHandleClassName:function(){this._removeHandleClassName(),e(this.options.handle||this.element).addClass("ui-draggable-handle")},_removeHandleClassName:function(){this.element.find(".ui-draggable-handle").addBack().removeClass("ui-draggable-handle")},_createHelper:function(t){var i=this.options,s=e.isFunction(i.helper)?e(i.helper.apply(this.element[0],[t])):"clone"===i.helper?this.element.clone().removeAttr("id"):this.element;return s.parents("body").length||s.appendTo("parent"===i.appendTo?this.element[0].parentNode:i.appendTo),s[0]===this.element[0]||/(fixed|absolute)/.test(s.css("position"))||s.css("position","absolute"),s},_adjustOffsetFromHelper:function(t){"string"==typeof t&&(t=t.split(" ")),e.isArray(t)&&(t={left:+t[0],top:+t[1]||0}),"left"in t&&(this.offset.click.left=t.left+this.margins.left),"right"in t&&(this.offset.click.left=this.helperProportions.width-t.right+this.margins.left),"top"in t&&(this.offset.click.top=t.top+this.margins.top),"bottom"in t&&(this.offset.click.top=this.helperProportions.height-t.bottom+this.margins.top)},_isRootNode:function(e){return/(html|body)/i.test(e.tagName)||e===this.document[0]},_getParentOffset:function(){var t=this.offsetParent.offset(),i=this.document[0];return"absolute"===this.cssPosition&&this.scrollParent[0]!==i&&e.contains(this.scrollParent[0],this.offsetParent[0])&&(t.left+=this.scrollParent.scrollLeft(),t.top+=this.scrollParent.scrollTop()),this._isRootNode(this.offsetParent[0])&&(t={top:0,left:0}),{top:t.top+(parseInt(this.offsetParent.css("borderTopWidth"),10)||0),left:t.left+(parseInt(this.offsetParent.css("borderLeftWidth"),10)||0)}},_getRelativeOffset:function(){if("relative"!==this.cssPosition)return{top:0,left:0};var e=this.element.position(),t=this._isRootNode(this.scrollParent[0]);return{top:e.top-(parseInt(this.helper.css("top"),10)||0)+(t?0:this.scrollParent.scrollTop()),left:e.left-(parseInt(this.helper.css("left"),10)||0)+(t?0:this.scrollParent.scrollLeft())}},_cacheMargins:function(){this.margins={left:parseInt(this.element.css("marginLeft"),10)||0,top:parseInt(this.element.css("marginTop"),10)||0,right:parseInt(this.element.css("marginRight"),10)||0,bottom:parseInt(this.element.css("marginBottom"),10)||0}},_cacheHelperProportions:function(){this.helperProportions={width:this.helper.outerWidth(),height:this.helper.outerHeight()}},_setContainment:function(){var t,i,s,a=this.options,n=this.document[0];return this.relative_container=null,a.containment?"window"===a.containment?(this.containment=[e(window).scrollLeft()-this.offset.relative.left-this.offset.parent.left,e(window).scrollTop()-this.offset.relative.top-this.offset.parent.top,e(window).scrollLeft()+e(window).width()-this.helperProportions.width-this.margins.left,e(window).scrollTop()+(e(window).height()||n.body.parentNode.scrollHeight)-this.helperProportions.height-this.margins.top],void 0):"document"===a.containment?(this.containment=[0,0,e(n).width()-this.helperProportions.width-this.margins.left,(e(n).height()||n.body.parentNode.scrollHeight)-this.helperProportions.height-this.margins.top],void 0):a.containment.constructor===Array?(this.containment=a.containment,void 0):("parent"===a.containment&&(a.containment=this.helper[0].parentNode),i=e(a.containment),s=i[0],s&&(t="hidden"!==i.css("overflow"),this.containment=[(parseInt(i.css("borderLeftWidth"),10)||0)+(parseInt(i.css("paddingLeft"),10)||0),(parseInt(i.css("borderTopWidth"),10)||0)+(parseInt(i.css("paddingTop"),10)||0),(t?Math.max(s.scrollWidth,s.offsetWidth):s.offsetWidth)-(parseInt(i.css("borderRightWidth"),10)||0)-(parseInt(i.css("paddingRight"),10)||0)-this.helperProportions.width-this.margins.left-this.margins.right,(t?Math.max(s.scrollHeight,s.offsetHeight):s.offsetHeight)-(parseInt(i.css("borderBottomWidth"),10)||0)-(parseInt(i.css("paddingBottom"),10)||0)-this.helperProportions.height-this.margins.top-this.margins.bottom],this.relative_container=i),void 0):(this.containment=null,void 0)},_convertPositionTo:function(e,t){t||(t=this.position);var i="absolute"===e?1:-1,s=this._isRootNode(this.scrollParent[0]);return{top:t.top+this.offset.relative.top*i+this.offset.parent.top*i-("fixed"===this.cssPosition?-this.offset.scroll.top:s?0:this.offset.scroll.top)*i,left:t.left+this.offset.relative.left*i+this.offset.parent.left*i-("fixed"===this.cssPosition?-this.offset.scroll.left:s?0:this.offset.scroll.left)*i}},_generatePosition:function(e,t){var i,s,a,n,r=this.options,o=this._isRootNode(this.scrollParent[0]),h=e.pageX,l=e.pageY;return o&&this.offset.scroll||(this.offset.scroll={top:this.scrollParent.scrollTop(),left:this.scrollParent.scrollLeft()}),t&&(this.containment&&(this.relative_container?(s=this.relative_container.offset(),i=[this.containment[0]+s.left,this.containment[1]+s.top,this.containment[2]+s.left,this.containment[3]+s.top]):i=this.containment,e.pageX-this.offset.click.left<i[0]&&(h=i[0]+this.offset.click.left),e.pageY-this.offset.click.top<i[1]&&(l=i[1]+this.offset.click.top),e.pageX-this.offset.click.left>i[2]&&(h=i[2]+this.offset.click.left),e.pageY-this.offset.click.top>i[3]&&(l=i[3]+this.offset.click.top)),r.grid&&(a=r.grid[1]?this.originalPageY+Math.round((l-this.originalPageY)/r.grid[1])*r.grid[1]:this.originalPageY,l=i?a-this.offset.click.top>=i[1]||a-this.offset.click.top>i[3]?a:a-this.offset.click.top>=i[1]?a-r.grid[1]:a+r.grid[1]:a,n=r.grid[0]?this.originalPageX+Math.round((h-this.originalPageX)/r.grid[0])*r.grid[0]:this.originalPageX,h=i?n-this.offset.click.left>=i[0]||n-this.offset.click.left>i[2]?n:n-this.offset.click.left>=i[0]?n-r.grid[0]:n+r.grid[0]:n),"y"===r.axis&&(h=this.originalPageX),"x"===r.axis&&(l=this.originalPageY)),{top:l-this.offset.click.top-this.offset.relative.top-this.offset.parent.top+("fixed"===this.cssPosition?-this.offset.scroll.top:o?0:this.offset.scroll.top),left:h-this.offset.click.left-this.offset.relative.left-this.offset.parent.left+("fixed"===this.cssPosition?-this.offset.scroll.left:o?0:this.offset.scroll.left)}
},_clear:function(){this.helper.removeClass("ui-draggable-dragging"),this.helper[0]===this.element[0]||this.cancelHelperRemoval||this.helper.remove(),this.helper=null,this.cancelHelperRemoval=!1,this.destroyOnClear&&this.destroy()},_trigger:function(t,i,s){return s=s||this._uiHash(),e.ui.plugin.call(this,t,[i,s,this],!0),"drag"===t&&(this.positionAbs=this._convertPositionTo("absolute")),e.Widget.prototype._trigger.call(this,t,i,s)},plugins:{},_uiHash:function(){return{helper:this.helper,position:this.position,originalPosition:this.originalPosition,offset:this.positionAbs}}}),e.ui.plugin.add("draggable","connectToSortable",{start:function(t,i,s){var a=s.options,n=e.extend({},i,{item:s.element});s.sortables=[],e(a.connectToSortable).each(function(){var i=e(this).sortable("instance");i&&!i.options.disabled&&(s.sortables.push({instance:i,shouldRevert:i.options.revert}),i.refreshPositions(),i._trigger("activate",t,n))})},stop:function(t,i,s){var a=e.extend({},i,{item:s.element});e.each(s.sortables,function(){this.instance.isOver?(this.instance.isOver=0,s.cancelHelperRemoval=!0,this.instance.cancelHelperRemoval=!1,this.shouldRevert&&(this.instance.options.revert=this.shouldRevert),this.instance._mouseStop(t),this.instance.options.helper=this.instance.options._helper,"original"===s.options.helper&&this.instance.currentItem.css({top:"auto",left:"auto"})):(this.instance.cancelHelperRemoval=!1,this.instance._trigger("deactivate",t,a))})},drag:function(t,i,s){var a=this;e.each(s.sortables,function(){var n=!1,r=this;this.instance.positionAbs=s.positionAbs,this.instance.helperProportions=s.helperProportions,this.instance.offset.click=s.offset.click,this.instance._intersectsWith(this.instance.containerCache)&&(n=!0,e.each(s.sortables,function(){return this.instance.positionAbs=s.positionAbs,this.instance.helperProportions=s.helperProportions,this.instance.offset.click=s.offset.click,this!==r&&this.instance._intersectsWith(this.instance.containerCache)&&e.contains(r.instance.element[0],this.instance.element[0])&&(n=!1),n})),n?(this.instance.isOver||(this.instance.isOver=1,this.instance.currentItem=e(a).clone().removeAttr("id").appendTo(this.instance.element).data("ui-sortable-item",!0),this.instance.options._helper=this.instance.options.helper,this.instance.options.helper=function(){return i.helper[0]},t.target=this.instance.currentItem[0],this.instance._mouseCapture(t,!0),this.instance._mouseStart(t,!0,!0),this.instance.offset.click.top=s.offset.click.top,this.instance.offset.click.left=s.offset.click.left,this.instance.offset.parent.left-=s.offset.parent.left-this.instance.offset.parent.left,this.instance.offset.parent.top-=s.offset.parent.top-this.instance.offset.parent.top,s._trigger("toSortable",t),s.dropped=this.instance.element,s.currentItem=s.element,this.instance.fromOutside=s),this.instance.currentItem&&this.instance._mouseDrag(t)):this.instance.isOver&&(this.instance.isOver=0,this.instance.cancelHelperRemoval=!0,this.instance.options.revert=!1,this.instance._trigger("out",t,this.instance._uiHash(this.instance)),this.instance._mouseStop(t,!0),this.instance.options.helper=this.instance.options._helper,this.instance.currentItem.remove(),this.instance.placeholder&&this.instance.placeholder.remove(),s._trigger("fromSortable",t),s.dropped=!1)})}}),e.ui.plugin.add("draggable","cursor",{start:function(t,i,s){var a=e("body"),n=s.options;a.css("cursor")&&(n._cursor=a.css("cursor")),a.css("cursor",n.cursor)},stop:function(t,i,s){var a=s.options;a._cursor&&e("body").css("cursor",a._cursor)}}),e.ui.plugin.add("draggable","opacity",{start:function(t,i,s){var a=e(i.helper),n=s.options;a.css("opacity")&&(n._opacity=a.css("opacity")),a.css("opacity",n.opacity)},stop:function(t,i,s){var a=s.options;a._opacity&&e(i.helper).css("opacity",a._opacity)}}),e.ui.plugin.add("draggable","scroll",{start:function(e,t,i){i.scrollParent[0]!==i.document[0]&&"HTML"!==i.scrollParent[0].tagName&&(i.overflowOffset=i.scrollParent.offset())},drag:function(t,i,s){var a=s.options,n=!1,r=s.document[0];s.scrollParent[0]!==r&&"HTML"!==s.scrollParent[0].tagName?(a.axis&&"x"===a.axis||(s.overflowOffset.top+s.scrollParent[0].offsetHeight-t.pageY<a.scrollSensitivity?s.scrollParent[0].scrollTop=n=s.scrollParent[0].scrollTop+a.scrollSpeed:t.pageY-s.overflowOffset.top<a.scrollSensitivity&&(s.scrollParent[0].scrollTop=n=s.scrollParent[0].scrollTop-a.scrollSpeed)),a.axis&&"y"===a.axis||(s.overflowOffset.left+s.scrollParent[0].offsetWidth-t.pageX<a.scrollSensitivity?s.scrollParent[0].scrollLeft=n=s.scrollParent[0].scrollLeft+a.scrollSpeed:t.pageX-s.overflowOffset.left<a.scrollSensitivity&&(s.scrollParent[0].scrollLeft=n=s.scrollParent[0].scrollLeft-a.scrollSpeed))):(a.axis&&"x"===a.axis||(t.pageY-e(r).scrollTop()<a.scrollSensitivity?n=e(r).scrollTop(e(r).scrollTop()-a.scrollSpeed):e(window).height()-(t.pageY-e(r).scrollTop())<a.scrollSensitivity&&(n=e(r).scrollTop(e(r).scrollTop()+a.scrollSpeed))),a.axis&&"y"===a.axis||(t.pageX-e(r).scrollLeft()<a.scrollSensitivity?n=e(r).scrollLeft(e(r).scrollLeft()-a.scrollSpeed):e(window).width()-(t.pageX-e(r).scrollLeft())<a.scrollSensitivity&&(n=e(r).scrollLeft(e(r).scrollLeft()+a.scrollSpeed)))),n!==!1&&e.ui.ddmanager&&!a.dropBehaviour&&e.ui.ddmanager.prepareOffsets(s,t)}}),e.ui.plugin.add("draggable","snap",{start:function(t,i,s){var a=s.options;s.snapElements=[],e(a.snap.constructor!==String?a.snap.items||":data(ui-draggable)":a.snap).each(function(){var t=e(this),i=t.offset();this!==s.element[0]&&s.snapElements.push({item:this,width:t.outerWidth(),height:t.outerHeight(),top:i.top,left:i.left})})},drag:function(t,i,s){var a,n,r,o,h,l,u,d,c,p,f=s.options,m=f.snapTolerance,g=i.offset.left,v=g+s.helperProportions.width,y=i.offset.top,b=y+s.helperProportions.height;for(c=s.snapElements.length-1;c>=0;c--)h=s.snapElements[c].left,l=h+s.snapElements[c].width,u=s.snapElements[c].top,d=u+s.snapElements[c].height,h-m>v||g>l+m||u-m>b||y>d+m||!e.contains(s.snapElements[c].item.ownerDocument,s.snapElements[c].item)?(s.snapElements[c].snapping&&s.options.snap.release&&s.options.snap.release.call(s.element,t,e.extend(s._uiHash(),{snapItem:s.snapElements[c].item})),s.snapElements[c].snapping=!1):("inner"!==f.snapMode&&(a=m>=Math.abs(u-b),n=m>=Math.abs(d-y),r=m>=Math.abs(h-v),o=m>=Math.abs(l-g),a&&(i.position.top=s._convertPositionTo("relative",{top:u-s.helperProportions.height,left:0}).top-s.margins.top),n&&(i.position.top=s._convertPositionTo("relative",{top:d,left:0}).top-s.margins.top),r&&(i.position.left=s._convertPositionTo("relative",{top:0,left:h-s.helperProportions.width}).left-s.margins.left),o&&(i.position.left=s._convertPositionTo("relative",{top:0,left:l}).left-s.margins.left)),p=a||n||r||o,"outer"!==f.snapMode&&(a=m>=Math.abs(u-y),n=m>=Math.abs(d-b),r=m>=Math.abs(h-g),o=m>=Math.abs(l-v),a&&(i.position.top=s._convertPositionTo("relative",{top:u,left:0}).top-s.margins.top),n&&(i.position.top=s._convertPositionTo("relative",{top:d-s.helperProportions.height,left:0}).top-s.margins.top),r&&(i.position.left=s._convertPositionTo("relative",{top:0,left:h}).left-s.margins.left),o&&(i.position.left=s._convertPositionTo("relative",{top:0,left:l-s.helperProportions.width}).left-s.margins.left)),!s.snapElements[c].snapping&&(a||n||r||o||p)&&s.options.snap.snap&&s.options.snap.snap.call(s.element,t,e.extend(s._uiHash(),{snapItem:s.snapElements[c].item})),s.snapElements[c].snapping=a||n||r||o||p)}}),e.ui.plugin.add("draggable","stack",{start:function(t,i,s){var a,n=s.options,r=e.makeArray(e(n.stack)).sort(function(t,i){return(parseInt(e(t).css("zIndex"),10)||0)-(parseInt(e(i).css("zIndex"),10)||0)});r.length&&(a=parseInt(e(r[0]).css("zIndex"),10)||0,e(r).each(function(t){e(this).css("zIndex",a+t)}),this.css("zIndex",a+r.length))}}),e.ui.plugin.add("draggable","zIndex",{start:function(t,i,s){var a=e(i.helper),n=s.options;a.css("zIndex")&&(n._zIndex=a.css("zIndex")),a.css("zIndex",n.zIndex)},stop:function(t,i,s){var a=s.options;a._zIndex&&e(i.helper).css("zIndex",a._zIndex)}}),e.ui.draggable,e.widget("ui.droppable",{version:"1.11.0",widgetEventPrefix:"drop",options:{accept:"*",activeClass:!1,addClasses:!0,greedy:!1,hoverClass:!1,scope:"default",tolerance:"intersect",activate:null,deactivate:null,drop:null,out:null,over:null},_create:function(){var t,i=this.options,s=i.accept;this.isover=!1,this.isout=!0,this.accept=e.isFunction(s)?s:function(e){return e.is(s)},this.proportions=function(){return arguments.length?(t=arguments[0],void 0):t?t:t={width:this.element[0].offsetWidth,height:this.element[0].offsetHeight}},this._addToManager(i.scope),i.addClasses&&this.element.addClass("ui-droppable")},_addToManager:function(t){e.ui.ddmanager.droppables[t]=e.ui.ddmanager.droppables[t]||[],e.ui.ddmanager.droppables[t].push(this)},_splice:function(e){for(var t=0;e.length>t;t++)e[t]===this&&e.splice(t,1)},_destroy:function(){var t=e.ui.ddmanager.droppables[this.options.scope];this._splice(t),this.element.removeClass("ui-droppable ui-droppable-disabled")},_setOption:function(t,i){if("accept"===t)this.accept=e.isFunction(i)?i:function(e){return e.is(i)};else if("scope"===t){var s=e.ui.ddmanager.droppables[this.options.scope];this._splice(s),this._addToManager(i)}this._super(t,i)},_activate:function(t){var i=e.ui.ddmanager.current;this.options.activeClass&&this.element.addClass(this.options.activeClass),i&&this._trigger("activate",t,this.ui(i))},_deactivate:function(t){var i=e.ui.ddmanager.current;this.options.activeClass&&this.element.removeClass(this.options.activeClass),i&&this._trigger("deactivate",t,this.ui(i))},_over:function(t){var i=e.ui.ddmanager.current;i&&(i.currentItem||i.element)[0]!==this.element[0]&&this.accept.call(this.element[0],i.currentItem||i.element)&&(this.options.hoverClass&&this.element.addClass(this.options.hoverClass),this._trigger("over",t,this.ui(i)))},_out:function(t){var i=e.ui.ddmanager.current;i&&(i.currentItem||i.element)[0]!==this.element[0]&&this.accept.call(this.element[0],i.currentItem||i.element)&&(this.options.hoverClass&&this.element.removeClass(this.options.hoverClass),this._trigger("out",t,this.ui(i)))},_drop:function(t,i){var s=i||e.ui.ddmanager.current,a=!1;return s&&(s.currentItem||s.element)[0]!==this.element[0]?(this.element.find(":data(ui-droppable)").not(".ui-draggable-dragging").each(function(){var t=e(this).droppable("instance");return t.options.greedy&&!t.options.disabled&&t.options.scope===s.options.scope&&t.accept.call(t.element[0],s.currentItem||s.element)&&e.ui.intersect(s,e.extend(t,{offset:t.element.offset()}),t.options.tolerance)?(a=!0,!1):void 0}),a?!1:this.accept.call(this.element[0],s.currentItem||s.element)?(this.options.activeClass&&this.element.removeClass(this.options.activeClass),this.options.hoverClass&&this.element.removeClass(this.options.hoverClass),this._trigger("drop",t,this.ui(s)),this.element):!1):!1},ui:function(e){return{draggable:e.currentItem||e.element,helper:e.helper,position:e.position,offset:e.positionAbs}}}),e.ui.intersect=function(){function e(e,t,i){return e>=t&&t+i>e}return function(t,i,s){if(!i.offset)return!1;var a,n,r=(t.positionAbs||t.position.absolute).left,o=(t.positionAbs||t.position.absolute).top,h=r+t.helperProportions.width,l=o+t.helperProportions.height,u=i.offset.left,d=i.offset.top,c=u+i.proportions().width,p=d+i.proportions().height;switch(s){case"fit":return r>=u&&c>=h&&o>=d&&p>=l;case"intersect":return r+t.helperProportions.width/2>u&&c>h-t.helperProportions.width/2&&o+t.helperProportions.height/2>d&&p>l-t.helperProportions.height/2;case"pointer":return a=(t.positionAbs||t.position.absolute).left+(t.clickOffset||t.offset.click).left,n=(t.positionAbs||t.position.absolute).top+(t.clickOffset||t.offset.click).top,e(n,d,i.proportions().height)&&e(a,u,i.proportions().width);case"touch":return(o>=d&&p>=o||l>=d&&p>=l||d>o&&l>p)&&(r>=u&&c>=r||h>=u&&c>=h||u>r&&h>c);default:return!1}}}(),e.ui.ddmanager={current:null,droppables:{"default":[]},prepareOffsets:function(t,i){var s,a,n=e.ui.ddmanager.droppables[t.options.scope]||[],r=i?i.type:null,o=(t.currentItem||t.element).find(":data(ui-droppable)").addBack();e:for(s=0;n.length>s;s++)if(!(n[s].options.disabled||t&&!n[s].accept.call(n[s].element[0],t.currentItem||t.element))){for(a=0;o.length>a;a++)if(o[a]===n[s].element[0]){n[s].proportions().height=0;continue e}n[s].visible="none"!==n[s].element.css("display"),n[s].visible&&("mousedown"===r&&n[s]._activate.call(n[s],i),n[s].offset=n[s].element.offset(),n[s].proportions({width:n[s].element[0].offsetWidth,height:n[s].element[0].offsetHeight}))}},drop:function(t,i){var s=!1;return e.each((e.ui.ddmanager.droppables[t.options.scope]||[]).slice(),function(){this.options&&(!this.options.disabled&&this.visible&&e.ui.intersect(t,this,this.options.tolerance)&&(s=this._drop.call(this,i)||s),!this.options.disabled&&this.visible&&this.accept.call(this.element[0],t.currentItem||t.element)&&(this.isout=!0,this.isover=!1,this._deactivate.call(this,i)))}),s},dragStart:function(t,i){t.element.parentsUntil("body").bind("scroll.droppable",function(){t.options.refreshPositions||e.ui.ddmanager.prepareOffsets(t,i)})},drag:function(t,i){t.options.refreshPositions&&e.ui.ddmanager.prepareOffsets(t,i),e.each(e.ui.ddmanager.droppables[t.options.scope]||[],function(){if(!this.options.disabled&&!this.greedyChild&&this.visible){var s,a,n,r=e.ui.intersect(t,this,this.options.tolerance),o=!r&&this.isover?"isout":r&&!this.isover?"isover":null;o&&(this.options.greedy&&(a=this.options.scope,n=this.element.parents(":data(ui-droppable)").filter(function(){return e(this).droppable("instance").options.scope===a}),n.length&&(s=e(n[0]).droppable("instance"),s.greedyChild="isover"===o)),s&&"isover"===o&&(s.isover=!1,s.isout=!0,s._out.call(s,i)),this[o]=!0,this["isout"===o?"isover":"isout"]=!1,this["isover"===o?"_over":"_out"].call(this,i),s&&"isout"===o&&(s.isout=!1,s.isover=!0,s._over.call(s,i)))}})},dragStop:function(t,i){t.element.parentsUntil("body").unbind("scroll.droppable"),t.options.refreshPositions||e.ui.ddmanager.prepareOffsets(t,i)}},e.ui.droppable,e.widget("ui.resizable",e.ui.mouse,{version:"1.11.0",widgetEventPrefix:"resize",options:{alsoResize:!1,animate:!1,animateDuration:"slow",animateEasing:"swing",aspectRatio:!1,autoHide:!1,containment:!1,ghost:!1,grid:!1,handles:"e,s,se",helper:!1,maxHeight:null,maxWidth:null,minHeight:10,minWidth:10,zIndex:90,resize:null,start:null,stop:null},_num:function(e){return parseInt(e,10)||0},_isNumber:function(e){return!isNaN(parseInt(e,10))},_hasScroll:function(t,i){if("hidden"===e(t).css("overflow"))return!1;var s=i&&"left"===i?"scrollLeft":"scrollTop",a=!1;return t[s]>0?!0:(t[s]=1,a=t[s]>0,t[s]=0,a)},_create:function(){var t,i,s,a,n,r=this,o=this.options;if(this.element.addClass("ui-resizable"),e.extend(this,{_aspectRatio:!!o.aspectRatio,aspectRatio:o.aspectRatio,originalElement:this.element,_proportionallyResizeElements:[],_helper:o.helper||o.ghost||o.animate?o.helper||"ui-resizable-helper":null}),this.element[0].nodeName.match(/canvas|textarea|input|select|button|img/i)&&(this.element.wrap(e("<div class='ui-wrapper' style='overflow: hidden;'></div>").css({position:this.element.css("position"),width:this.element.outerWidth(),height:this.element.outerHeight(),top:this.element.css("top"),left:this.element.css("left")})),this.element=this.element.parent().data("ui-resizable",this.element.resizable("instance")),this.elementIsWrapper=!0,this.element.css({marginLeft:this.originalElement.css("marginLeft"),marginTop:this.originalElement.css("marginTop"),marginRight:this.originalElement.css("marginRight"),marginBottom:this.originalElement.css("marginBottom")}),this.originalElement.css({marginLeft:0,marginTop:0,marginRight:0,marginBottom:0}),this.originalResizeStyle=this.originalElement.css("resize"),this.originalElement.css("resize","none"),this._proportionallyResizeElements.push(this.originalElement.css({position:"static",zoom:1,display:"block"})),this.originalElement.css({margin:this.originalElement.css("margin")}),this._proportionallyResize()),this.handles=o.handles||(e(".ui-resizable-handle",this.element).length?{n:".ui-resizable-n",e:".ui-resizable-e",s:".ui-resizable-s",w:".ui-resizable-w",se:".ui-resizable-se",sw:".ui-resizable-sw",ne:".ui-resizable-ne",nw:".ui-resizable-nw"}:"e,s,se"),this.handles.constructor===String)for("all"===this.handles&&(this.handles="n,e,s,w,se,sw,ne,nw"),t=this.handles.split(","),this.handles={},i=0;t.length>i;i++)s=e.trim(t[i]),n="ui-resizable-"+s,a=e("<div class='ui-resizable-handle "+n+"'></div>"),a.css({zIndex:o.zIndex}),"se"===s&&a.addClass("ui-icon ui-icon-gripsmall-diagonal-se"),this.handles[s]=".ui-resizable-"+s,this.element.append(a);this._renderAxis=function(t){var i,s,a,n;t=t||this.element;for(i in this.handles)this.handles[i].constructor===String&&(this.handles[i]=this.element.children(this.handles[i]).first().show()),this.elementIsWrapper&&this.originalElement[0].nodeName.match(/textarea|input|select|button/i)&&(s=e(this.handles[i],this.element),n=/sw|ne|nw|se|n|s/.test(i)?s.outerHeight():s.outerWidth(),a=["padding",/ne|nw|n/.test(i)?"Top":/se|sw|s/.test(i)?"Bottom":/^e$/.test(i)?"Right":"Left"].join(""),t.css(a,n),this._proportionallyResize()),e(this.handles[i]).length},this._renderAxis(this.element),this._handles=e(".ui-resizable-handle",this.element).disableSelection(),this._handles.mouseover(function(){r.resizing||(this.className&&(a=this.className.match(/ui-resizable-(se|sw|ne|nw|n|e|s|w)/i)),r.axis=a&&a[1]?a[1]:"se")}),o.autoHide&&(this._handles.hide(),e(this.element).addClass("ui-resizable-autohide").mouseenter(function(){o.disabled||(e(this).removeClass("ui-resizable-autohide"),r._handles.show())}).mouseleave(function(){o.disabled||r.resizing||(e(this).addClass("ui-resizable-autohide"),r._handles.hide())})),this._mouseInit()},_destroy:function(){this._mouseDestroy();var t,i=function(t){e(t).removeClass("ui-resizable ui-resizable-disabled ui-resizable-resizing").removeData("resizable").removeData("ui-resizable").unbind(".resizable").find(".ui-resizable-handle").remove()};return this.elementIsWrapper&&(i(this.element),t=this.element,this.originalElement.css({position:t.css("position"),width:t.outerWidth(),height:t.outerHeight(),top:t.css("top"),left:t.css("left")}).insertAfter(t),t.remove()),this.originalElement.css("resize",this.originalResizeStyle),i(this.originalElement),this},_mouseCapture:function(t){var i,s,a=!1;for(i in this.handles)s=e(this.handles[i])[0],(s===t.target||e.contains(s,t.target))&&(a=!0);return!this.options.disabled&&a},_mouseStart:function(t){var i,s,a,n=this.options,r=this.element;return this.resizing=!0,this._renderProxy(),i=this._num(this.helper.css("left")),s=this._num(this.helper.css("top")),n.containment&&(i+=e(n.containment).scrollLeft()||0,s+=e(n.containment).scrollTop()||0),this.offset=this.helper.offset(),this.position={left:i,top:s},this.size=this._helper?{width:this.helper.width(),height:this.helper.height()}:{width:r.width(),height:r.height()},this.originalSize=this._helper?{width:r.outerWidth(),height:r.outerHeight()}:{width:r.width(),height:r.height()},this.originalPosition={left:i,top:s},this.sizeDiff={width:r.outerWidth()-r.width(),height:r.outerHeight()-r.height()},this.originalMousePosition={left:t.pageX,top:t.pageY},this.aspectRatio="number"==typeof n.aspectRatio?n.aspectRatio:this.originalSize.width/this.originalSize.height||1,a=e(".ui-resizable-"+this.axis).css("cursor"),e("body").css("cursor","auto"===a?this.axis+"-resize":a),r.addClass("ui-resizable-resizing"),this._propagate("start",t),!0},_mouseDrag:function(t){var i,s=this.helper,a={},n=this.originalMousePosition,r=this.axis,o=t.pageX-n.left||0,h=t.pageY-n.top||0,l=this._change[r];return this.prevPosition={top:this.position.top,left:this.position.left},this.prevSize={width:this.size.width,height:this.size.height},l?(i=l.apply(this,[t,o,h]),this._updateVirtualBoundaries(t.shiftKey),(this._aspectRatio||t.shiftKey)&&(i=this._updateRatio(i,t)),i=this._respectSize(i,t),this._updateCache(i),this._propagate("resize",t),this.position.top!==this.prevPosition.top&&(a.top=this.position.top+"px"),this.position.left!==this.prevPosition.left&&(a.left=this.position.left+"px"),this.size.width!==this.prevSize.width&&(a.width=this.size.width+"px"),this.size.height!==this.prevSize.height&&(a.height=this.size.height+"px"),s.css(a),!this._helper&&this._proportionallyResizeElements.length&&this._proportionallyResize(),e.isEmptyObject(a)||this._trigger("resize",t,this.ui()),!1):!1},_mouseStop:function(t){this.resizing=!1;var i,s,a,n,r,o,h,l=this.options,u=this;return this._helper&&(i=this._proportionallyResizeElements,s=i.length&&/textarea/i.test(i[0].nodeName),a=s&&this._hasScroll(i[0],"left")?0:u.sizeDiff.height,n=s?0:u.sizeDiff.width,r={width:u.helper.width()-n,height:u.helper.height()-a},o=parseInt(u.element.css("left"),10)+(u.position.left-u.originalPosition.left)||null,h=parseInt(u.element.css("top"),10)+(u.position.top-u.originalPosition.top)||null,l.animate||this.element.css(e.extend(r,{top:h,left:o})),u.helper.height(u.size.height),u.helper.width(u.size.width),this._helper&&!l.animate&&this._proportionallyResize()),e("body").css("cursor","auto"),this.element.removeClass("ui-resizable-resizing"),this._propagate("stop",t),this._helper&&this.helper.remove(),!1},_updateVirtualBoundaries:function(e){var t,i,s,a,n,r=this.options;n={minWidth:this._isNumber(r.minWidth)?r.minWidth:0,maxWidth:this._isNumber(r.maxWidth)?r.maxWidth:1/0,minHeight:this._isNumber(r.minHeight)?r.minHeight:0,maxHeight:this._isNumber(r.maxHeight)?r.maxHeight:1/0},(this._aspectRatio||e)&&(t=n.minHeight*this.aspectRatio,s=n.minWidth/this.aspectRatio,i=n.maxHeight*this.aspectRatio,a=n.maxWidth/this.aspectRatio,t>n.minWidth&&(n.minWidth=t),s>n.minHeight&&(n.minHeight=s),n.maxWidth>i&&(n.maxWidth=i),n.maxHeight>a&&(n.maxHeight=a)),this._vBoundaries=n},_updateCache:function(e){this.offset=this.helper.offset(),this._isNumber(e.left)&&(this.position.left=e.left),this._isNumber(e.top)&&(this.position.top=e.top),this._isNumber(e.height)&&(this.size.height=e.height),this._isNumber(e.width)&&(this.size.width=e.width)},_updateRatio:function(e){var t=this.position,i=this.size,s=this.axis;return this._isNumber(e.height)?e.width=e.height*this.aspectRatio:this._isNumber(e.width)&&(e.height=e.width/this.aspectRatio),"sw"===s&&(e.left=t.left+(i.width-e.width),e.top=null),"nw"===s&&(e.top=t.top+(i.height-e.height),e.left=t.left+(i.width-e.width)),e},_respectSize:function(e){var t=this._vBoundaries,i=this.axis,s=this._isNumber(e.width)&&t.maxWidth&&t.maxWidth<e.width,a=this._isNumber(e.height)&&t.maxHeight&&t.maxHeight<e.height,n=this._isNumber(e.width)&&t.minWidth&&t.minWidth>e.width,r=this._isNumber(e.height)&&t.minHeight&&t.minHeight>e.height,o=this.originalPosition.left+this.originalSize.width,h=this.position.top+this.size.height,l=/sw|nw|w/.test(i),u=/nw|ne|n/.test(i);return n&&(e.width=t.minWidth),r&&(e.height=t.minHeight),s&&(e.width=t.maxWidth),a&&(e.height=t.maxHeight),n&&l&&(e.left=o-t.minWidth),s&&l&&(e.left=o-t.maxWidth),r&&u&&(e.top=h-t.minHeight),a&&u&&(e.top=h-t.maxHeight),e.width||e.height||e.left||!e.top?e.width||e.height||e.top||!e.left||(e.left=null):e.top=null,e},_proportionallyResize:function(){if(this._proportionallyResizeElements.length){var e,t,i,s,a,n=this.helper||this.element;for(e=0;this._proportionallyResizeElements.length>e;e++){if(a=this._proportionallyResizeElements[e],!this.borderDif)for(this.borderDif=[],i=[a.css("borderTopWidth"),a.css("borderRightWidth"),a.css("borderBottomWidth"),a.css("borderLeftWidth")],s=[a.css("paddingTop"),a.css("paddingRight"),a.css("paddingBottom"),a.css("paddingLeft")],t=0;i.length>t;t++)this.borderDif[t]=(parseInt(i[t],10)||0)+(parseInt(s[t],10)||0);a.css({height:n.height()-this.borderDif[0]-this.borderDif[2]||0,width:n.width()-this.borderDif[1]-this.borderDif[3]||0})}}},_renderProxy:function(){var t=this.element,i=this.options;this.elementOffset=t.offset(),this._helper?(this.helper=this.helper||e("<div style='overflow:hidden;'></div>"),this.helper.addClass(this._helper).css({width:this.element.outerWidth()-1,height:this.element.outerHeight()-1,position:"absolute",left:this.elementOffset.left+"px",top:this.elementOffset.top+"px",zIndex:++i.zIndex}),this.helper.appendTo("body").disableSelection()):this.helper=this.element},_change:{e:function(e,t){return{width:this.originalSize.width+t}},w:function(e,t){var i=this.originalSize,s=this.originalPosition;return{left:s.left+t,width:i.width-t}},n:function(e,t,i){var s=this.originalSize,a=this.originalPosition;return{top:a.top+i,height:s.height-i}},s:function(e,t,i){return{height:this.originalSize.height+i}},se:function(t,i,s){return e.extend(this._change.s.apply(this,arguments),this._change.e.apply(this,[t,i,s]))},sw:function(t,i,s){return e.extend(this._change.s.apply(this,arguments),this._change.w.apply(this,[t,i,s]))},ne:function(t,i,s){return e.extend(this._change.n.apply(this,arguments),this._change.e.apply(this,[t,i,s]))},nw:function(t,i,s){return e.extend(this._change.n.apply(this,arguments),this._change.w.apply(this,[t,i,s]))}},_propagate:function(t,i){e.ui.plugin.call(this,t,[i,this.ui()]),"resize"!==t&&this._trigger(t,i,this.ui())},plugins:{},ui:function(){return{originalElement:this.originalElement,element:this.element,helper:this.helper,position:this.position,size:this.size,originalSize:this.originalSize,originalPosition:this.originalPosition,prevSize:this.prevSize,prevPosition:this.prevPosition}}}),e.ui.plugin.add("resizable","animate",{stop:function(t){var i=e(this).resizable("instance"),s=i.options,a=i._proportionallyResizeElements,n=a.length&&/textarea/i.test(a[0].nodeName),r=n&&i._hasScroll(a[0],"left")?0:i.sizeDiff.height,o=n?0:i.sizeDiff.width,h={width:i.size.width-o,height:i.size.height-r},l=parseInt(i.element.css("left"),10)+(i.position.left-i.originalPosition.left)||null,u=parseInt(i.element.css("top"),10)+(i.position.top-i.originalPosition.top)||null;i.element.animate(e.extend(h,u&&l?{top:u,left:l}:{}),{duration:s.animateDuration,easing:s.animateEasing,step:function(){var s={width:parseInt(i.element.css("width"),10),height:parseInt(i.element.css("height"),10),top:parseInt(i.element.css("top"),10),left:parseInt(i.element.css("left"),10)};a&&a.length&&e(a[0]).css({width:s.width,height:s.height}),i._updateCache(s),i._propagate("resize",t)}})}}),e.ui.plugin.add("resizable","containment",{start:function(){var t,i,s,a,n,r,o,h=e(this).resizable("instance"),l=h.options,u=h.element,d=l.containment,c=d instanceof e?d.get(0):/parent/.test(d)?u.parent().get(0):d;c&&(h.containerElement=e(c),/document/.test(d)||d===document?(h.containerOffset={left:0,top:0},h.containerPosition={left:0,top:0},h.parentData={element:e(document),left:0,top:0,width:e(document).width(),height:e(document).height()||document.body.parentNode.scrollHeight}):(t=e(c),i=[],e(["Top","Right","Left","Bottom"]).each(function(e,s){i[e]=h._num(t.css("padding"+s))}),h.containerOffset=t.offset(),h.containerPosition=t.position(),h.containerSize={height:t.innerHeight()-i[3],width:t.innerWidth()-i[1]},s=h.containerOffset,a=h.containerSize.height,n=h.containerSize.width,r=h._hasScroll(c,"left")?c.scrollWidth:n,o=h._hasScroll(c)?c.scrollHeight:a,h.parentData={element:c,left:s.left,top:s.top,width:r,height:o}))},resize:function(t,i){var s,a,n,r,o=e(this).resizable("instance"),h=o.options,l=o.containerOffset,u=o.position,d=o._aspectRatio||t.shiftKey,c={top:0,left:0},p=o.containerElement,f=!0;p[0]!==document&&/static/.test(p.css("position"))&&(c=l),u.left<(o._helper?l.left:0)&&(o.size.width=o.size.width+(o._helper?o.position.left-l.left:o.position.left-c.left),d&&(o.size.height=o.size.width/o.aspectRatio,f=!1),o.position.left=h.helper?l.left:0),u.top<(o._helper?l.top:0)&&(o.size.height=o.size.height+(o._helper?o.position.top-l.top:o.position.top),d&&(o.size.width=o.size.height*o.aspectRatio,f=!1),o.position.top=o._helper?l.top:0),o.offset.left=o.parentData.left+o.position.left,o.offset.top=o.parentData.top+o.position.top,s=Math.abs((o._helper?o.offset.left-c.left:o.offset.left-l.left)+o.sizeDiff.width),a=Math.abs((o._helper?o.offset.top-c.top:o.offset.top-l.top)+o.sizeDiff.height),n=o.containerElement.get(0)===o.element.parent().get(0),r=/relative|absolute/.test(o.containerElement.css("position")),n&&r&&(s-=Math.abs(o.parentData.left)),s+o.size.width>=o.parentData.width&&(o.size.width=o.parentData.width-s,d&&(o.size.height=o.size.width/o.aspectRatio,f=!1)),a+o.size.height>=o.parentData.height&&(o.size.height=o.parentData.height-a,d&&(o.size.width=o.size.height*o.aspectRatio,f=!1)),f||(o.position.left=i.prevPosition.left,o.position.top=i.prevPosition.top,o.size.width=i.prevSize.width,o.size.height=i.prevSize.height)},stop:function(){var t=e(this).resizable("instance"),i=t.options,s=t.containerOffset,a=t.containerPosition,n=t.containerElement,r=e(t.helper),o=r.offset(),h=r.outerWidth()-t.sizeDiff.width,l=r.outerHeight()-t.sizeDiff.height;t._helper&&!i.animate&&/relative/.test(n.css("position"))&&e(this).css({left:o.left-a.left-s.left,width:h,height:l}),t._helper&&!i.animate&&/static/.test(n.css("position"))&&e(this).css({left:o.left-a.left-s.left,width:h,height:l})}}),e.ui.plugin.add("resizable","alsoResize",{start:function(){var t=e(this).resizable("instance"),i=t.options,s=function(t){e(t).each(function(){var t=e(this);t.data("ui-resizable-alsoresize",{width:parseInt(t.width(),10),height:parseInt(t.height(),10),left:parseInt(t.css("left"),10),top:parseInt(t.css("top"),10)})})};"object"!=typeof i.alsoResize||i.alsoResize.parentNode?s(i.alsoResize):i.alsoResize.length?(i.alsoResize=i.alsoResize[0],s(i.alsoResize)):e.each(i.alsoResize,function(e){s(e)})},resize:function(t,i){var s=e(this).resizable("instance"),a=s.options,n=s.originalSize,r=s.originalPosition,o={height:s.size.height-n.height||0,width:s.size.width-n.width||0,top:s.position.top-r.top||0,left:s.position.left-r.left||0},h=function(t,s){e(t).each(function(){var t=e(this),a=e(this).data("ui-resizable-alsoresize"),n={},r=s&&s.length?s:t.parents(i.originalElement[0]).length?["width","height"]:["width","height","top","left"];e.each(r,function(e,t){var i=(a[t]||0)+(o[t]||0);i&&i>=0&&(n[t]=i||null)}),t.css(n)})};"object"!=typeof a.alsoResize||a.alsoResize.nodeType?h(a.alsoResize):e.each(a.alsoResize,function(e,t){h(e,t)})},stop:function(){e(this).removeData("resizable-alsoresize")}}),e.ui.plugin.add("resizable","ghost",{start:function(){var t=e(this).resizable("instance"),i=t.options,s=t.size;t.ghost=t.originalElement.clone(),t.ghost.css({opacity:.25,display:"block",position:"relative",height:s.height,width:s.width,margin:0,left:0,top:0}).addClass("ui-resizable-ghost").addClass("string"==typeof i.ghost?i.ghost:""),t.ghost.appendTo(t.helper)},resize:function(){var t=e(this).resizable("instance");t.ghost&&t.ghost.css({position:"relative",height:t.size.height,width:t.size.width})},stop:function(){var t=e(this).resizable("instance");t.ghost&&t.helper&&t.helper.get(0).removeChild(t.ghost.get(0))}}),e.ui.plugin.add("resizable","grid",{resize:function(){var t=e(this).resizable("instance"),i=t.options,s=t.size,a=t.originalSize,n=t.originalPosition,r=t.axis,o="number"==typeof i.grid?[i.grid,i.grid]:i.grid,h=o[0]||1,l=o[1]||1,u=Math.round((s.width-a.width)/h)*h,d=Math.round((s.height-a.height)/l)*l,c=a.width+u,p=a.height+d,f=i.maxWidth&&c>i.maxWidth,m=i.maxHeight&&p>i.maxHeight,g=i.minWidth&&i.minWidth>c,v=i.minHeight&&i.minHeight>p;i.grid=o,g&&(c+=h),v&&(p+=l),f&&(c-=h),m&&(p-=l),/^(se|s|e)$/.test(r)?(t.size.width=c,t.size.height=p):/^(ne)$/.test(r)?(t.size.width=c,t.size.height=p,t.position.top=n.top-d):/^(sw)$/.test(r)?(t.size.width=c,t.size.height=p,t.position.left=n.left-u):(p-l>0?(t.size.height=p,t.position.top=n.top-d):(t.size.height=l,t.position.top=n.top+a.height-l),c-h>0?(t.size.width=c,t.position.left=n.left-u):(t.size.width=h,t.position.left=n.left+a.width-h))}}),e.ui.resizable,e.widget("ui.selectable",e.ui.mouse,{version:"1.11.0",options:{appendTo:"body",autoRefresh:!0,distance:0,filter:"*",tolerance:"touch",selected:null,selecting:null,start:null,stop:null,unselected:null,unselecting:null},_create:function(){var t,i=this;
this.element.addClass("ui-selectable"),this.dragged=!1,this.refresh=function(){t=e(i.options.filter,i.element[0]),t.addClass("ui-selectee"),t.each(function(){var t=e(this),i=t.offset();e.data(this,"selectable-item",{element:this,$element:t,left:i.left,top:i.top,right:i.left+t.outerWidth(),bottom:i.top+t.outerHeight(),startselected:!1,selected:t.hasClass("ui-selected"),selecting:t.hasClass("ui-selecting"),unselecting:t.hasClass("ui-unselecting")})})},this.refresh(),this.selectees=t.addClass("ui-selectee"),this._mouseInit(),this.helper=e("<div class='ui-selectable-helper'></div>")},_destroy:function(){this.selectees.removeClass("ui-selectee").removeData("selectable-item"),this.element.removeClass("ui-selectable ui-selectable-disabled"),this._mouseDestroy()},_mouseStart:function(t){var i=this,s=this.options;this.opos=[t.pageX,t.pageY],this.options.disabled||(this.selectees=e(s.filter,this.element[0]),this._trigger("start",t),e(s.appendTo).append(this.helper),this.helper.css({left:t.pageX,top:t.pageY,width:0,height:0}),s.autoRefresh&&this.refresh(),this.selectees.filter(".ui-selected").each(function(){var s=e.data(this,"selectable-item");s.startselected=!0,t.metaKey||t.ctrlKey||(s.$element.removeClass("ui-selected"),s.selected=!1,s.$element.addClass("ui-unselecting"),s.unselecting=!0,i._trigger("unselecting",t,{unselecting:s.element}))}),e(t.target).parents().addBack().each(function(){var s,a=e.data(this,"selectable-item");return a?(s=!t.metaKey&&!t.ctrlKey||!a.$element.hasClass("ui-selected"),a.$element.removeClass(s?"ui-unselecting":"ui-selected").addClass(s?"ui-selecting":"ui-unselecting"),a.unselecting=!s,a.selecting=s,a.selected=s,s?i._trigger("selecting",t,{selecting:a.element}):i._trigger("unselecting",t,{unselecting:a.element}),!1):void 0}))},_mouseDrag:function(t){if(this.dragged=!0,!this.options.disabled){var i,s=this,a=this.options,n=this.opos[0],r=this.opos[1],o=t.pageX,h=t.pageY;return n>o&&(i=o,o=n,n=i),r>h&&(i=h,h=r,r=i),this.helper.css({left:n,top:r,width:o-n,height:h-r}),this.selectees.each(function(){var i=e.data(this,"selectable-item"),l=!1;i&&i.element!==s.element[0]&&("touch"===a.tolerance?l=!(i.left>o||n>i.right||i.top>h||r>i.bottom):"fit"===a.tolerance&&(l=i.left>n&&o>i.right&&i.top>r&&h>i.bottom),l?(i.selected&&(i.$element.removeClass("ui-selected"),i.selected=!1),i.unselecting&&(i.$element.removeClass("ui-unselecting"),i.unselecting=!1),i.selecting||(i.$element.addClass("ui-selecting"),i.selecting=!0,s._trigger("selecting",t,{selecting:i.element}))):(i.selecting&&((t.metaKey||t.ctrlKey)&&i.startselected?(i.$element.removeClass("ui-selecting"),i.selecting=!1,i.$element.addClass("ui-selected"),i.selected=!0):(i.$element.removeClass("ui-selecting"),i.selecting=!1,i.startselected&&(i.$element.addClass("ui-unselecting"),i.unselecting=!0),s._trigger("unselecting",t,{unselecting:i.element}))),i.selected&&(t.metaKey||t.ctrlKey||i.startselected||(i.$element.removeClass("ui-selected"),i.selected=!1,i.$element.addClass("ui-unselecting"),i.unselecting=!0,s._trigger("unselecting",t,{unselecting:i.element})))))}),!1}},_mouseStop:function(t){var i=this;return this.dragged=!1,e(".ui-unselecting",this.element[0]).each(function(){var s=e.data(this,"selectable-item");s.$element.removeClass("ui-unselecting"),s.unselecting=!1,s.startselected=!1,i._trigger("unselected",t,{unselected:s.element})}),e(".ui-selecting",this.element[0]).each(function(){var s=e.data(this,"selectable-item");s.$element.removeClass("ui-selecting").addClass("ui-selected"),s.selecting=!1,s.selected=!0,s.startselected=!0,i._trigger("selected",t,{selected:s.element})}),this._trigger("stop",t),this.helper.remove(),!1}}),e.widget("ui.sortable",e.ui.mouse,{version:"1.11.0",widgetEventPrefix:"sort",ready:!1,options:{appendTo:"parent",axis:!1,connectWith:!1,containment:!1,cursor:"auto",cursorAt:!1,dropOnEmpty:!0,forcePlaceholderSize:!1,forceHelperSize:!1,grid:!1,handle:!1,helper:"original",items:"> *",opacity:!1,placeholder:!1,revert:!1,scroll:!0,scrollSensitivity:20,scrollSpeed:20,scope:"default",tolerance:"intersect",zIndex:1e3,activate:null,beforeStop:null,change:null,deactivate:null,out:null,over:null,receive:null,remove:null,sort:null,start:null,stop:null,update:null},_isOverAxis:function(e,t,i){return e>=t&&t+i>e},_isFloating:function(e){return/left|right/.test(e.css("float"))||/inline|table-cell/.test(e.css("display"))},_create:function(){var e=this.options;this.containerCache={},this.element.addClass("ui-sortable"),this.refresh(),this.floating=this.items.length?"x"===e.axis||this._isFloating(this.items[0].item):!1,this.offset=this.element.offset(),this._mouseInit(),this._setHandleClassName(),this.ready=!0},_setOption:function(e,t){this._super(e,t),"handle"===e&&this._setHandleClassName()},_setHandleClassName:function(){this.element.find(".ui-sortable-handle").removeClass("ui-sortable-handle"),e.each(this.items,function(){(this.instance.options.handle?this.item.find(this.instance.options.handle):this.item).addClass("ui-sortable-handle")})},_destroy:function(){this.element.removeClass("ui-sortable ui-sortable-disabled").find(".ui-sortable-handle").removeClass("ui-sortable-handle"),this._mouseDestroy();for(var e=this.items.length-1;e>=0;e--)this.items[e].item.removeData(this.widgetName+"-item");return this},_mouseCapture:function(t,i){var s=null,a=!1,n=this;return this.reverting?!1:this.options.disabled||"static"===this.options.type?!1:(this._refreshItems(t),e(t.target).parents().each(function(){return e.data(this,n.widgetName+"-item")===n?(s=e(this),!1):void 0}),e.data(t.target,n.widgetName+"-item")===n&&(s=e(t.target)),s?!this.options.handle||i||(e(this.options.handle,s).find("*").addBack().each(function(){this===t.target&&(a=!0)}),a)?(this.currentItem=s,this._removeCurrentsFromItems(),!0):!1:!1)},_mouseStart:function(t,i,s){var a,n,r=this.options;if(this.currentContainer=this,this.refreshPositions(),this.helper=this._createHelper(t),this._cacheHelperProportions(),this._cacheMargins(),this.scrollParent=this.helper.scrollParent(),this.offset=this.currentItem.offset(),this.offset={top:this.offset.top-this.margins.top,left:this.offset.left-this.margins.left},e.extend(this.offset,{click:{left:t.pageX-this.offset.left,top:t.pageY-this.offset.top},parent:this._getParentOffset(),relative:this._getRelativeOffset()}),this.helper.css("position","absolute"),this.cssPosition=this.helper.css("position"),this.originalPosition=this._generatePosition(t),this.originalPageX=t.pageX,this.originalPageY=t.pageY,r.cursorAt&&this._adjustOffsetFromHelper(r.cursorAt),this.domPosition={prev:this.currentItem.prev()[0],parent:this.currentItem.parent()[0]},this.helper[0]!==this.currentItem[0]&&this.currentItem.hide(),this._createPlaceholder(),r.containment&&this._setContainment(),r.cursor&&"auto"!==r.cursor&&(n=this.document.find("body"),this.storedCursor=n.css("cursor"),n.css("cursor",r.cursor),this.storedStylesheet=e("<style>*{ cursor: "+r.cursor+" !important; }</style>").appendTo(n)),r.opacity&&(this.helper.css("opacity")&&(this._storedOpacity=this.helper.css("opacity")),this.helper.css("opacity",r.opacity)),r.zIndex&&(this.helper.css("zIndex")&&(this._storedZIndex=this.helper.css("zIndex")),this.helper.css("zIndex",r.zIndex)),this.scrollParent[0]!==document&&"HTML"!==this.scrollParent[0].tagName&&(this.overflowOffset=this.scrollParent.offset()),this._trigger("start",t,this._uiHash()),this._preserveHelperProportions||this._cacheHelperProportions(),!s)for(a=this.containers.length-1;a>=0;a--)this.containers[a]._trigger("activate",t,this._uiHash(this));return e.ui.ddmanager&&(e.ui.ddmanager.current=this),e.ui.ddmanager&&!r.dropBehaviour&&e.ui.ddmanager.prepareOffsets(this,t),this.dragging=!0,this.helper.addClass("ui-sortable-helper"),this._mouseDrag(t),!0},_mouseDrag:function(t){var i,s,a,n,r=this.options,o=!1;for(this.position=this._generatePosition(t),this.positionAbs=this._convertPositionTo("absolute"),this.lastPositionAbs||(this.lastPositionAbs=this.positionAbs),this.options.scroll&&(this.scrollParent[0]!==document&&"HTML"!==this.scrollParent[0].tagName?(this.overflowOffset.top+this.scrollParent[0].offsetHeight-t.pageY<r.scrollSensitivity?this.scrollParent[0].scrollTop=o=this.scrollParent[0].scrollTop+r.scrollSpeed:t.pageY-this.overflowOffset.top<r.scrollSensitivity&&(this.scrollParent[0].scrollTop=o=this.scrollParent[0].scrollTop-r.scrollSpeed),this.overflowOffset.left+this.scrollParent[0].offsetWidth-t.pageX<r.scrollSensitivity?this.scrollParent[0].scrollLeft=o=this.scrollParent[0].scrollLeft+r.scrollSpeed:t.pageX-this.overflowOffset.left<r.scrollSensitivity&&(this.scrollParent[0].scrollLeft=o=this.scrollParent[0].scrollLeft-r.scrollSpeed)):(t.pageY-e(document).scrollTop()<r.scrollSensitivity?o=e(document).scrollTop(e(document).scrollTop()-r.scrollSpeed):e(window).height()-(t.pageY-e(document).scrollTop())<r.scrollSensitivity&&(o=e(document).scrollTop(e(document).scrollTop()+r.scrollSpeed)),t.pageX-e(document).scrollLeft()<r.scrollSensitivity?o=e(document).scrollLeft(e(document).scrollLeft()-r.scrollSpeed):e(window).width()-(t.pageX-e(document).scrollLeft())<r.scrollSensitivity&&(o=e(document).scrollLeft(e(document).scrollLeft()+r.scrollSpeed))),o!==!1&&e.ui.ddmanager&&!r.dropBehaviour&&e.ui.ddmanager.prepareOffsets(this,t)),this.positionAbs=this._convertPositionTo("absolute"),this.options.axis&&"y"===this.options.axis||(this.helper[0].style.left=this.position.left+"px"),this.options.axis&&"x"===this.options.axis||(this.helper[0].style.top=this.position.top+"px"),i=this.items.length-1;i>=0;i--)if(s=this.items[i],a=s.item[0],n=this._intersectsWithPointer(s),n&&s.instance===this.currentContainer&&a!==this.currentItem[0]&&this.placeholder[1===n?"next":"prev"]()[0]!==a&&!e.contains(this.placeholder[0],a)&&("semi-dynamic"===this.options.type?!e.contains(this.element[0],a):!0)){if(this.direction=1===n?"down":"up","pointer"!==this.options.tolerance&&!this._intersectsWithSides(s))break;this._rearrange(t,s),this._trigger("change",t,this._uiHash());break}return this._contactContainers(t),e.ui.ddmanager&&e.ui.ddmanager.drag(this,t),this._trigger("sort",t,this._uiHash()),this.lastPositionAbs=this.positionAbs,!1},_mouseStop:function(t,i){if(t){if(e.ui.ddmanager&&!this.options.dropBehaviour&&e.ui.ddmanager.drop(this,t),this.options.revert){var s=this,a=this.placeholder.offset(),n=this.options.axis,r={};n&&"x"!==n||(r.left=a.left-this.offset.parent.left-this.margins.left+(this.offsetParent[0]===document.body?0:this.offsetParent[0].scrollLeft)),n&&"y"!==n||(r.top=a.top-this.offset.parent.top-this.margins.top+(this.offsetParent[0]===document.body?0:this.offsetParent[0].scrollTop)),this.reverting=!0,e(this.helper).animate(r,parseInt(this.options.revert,10)||500,function(){s._clear(t)})}else this._clear(t,i);return!1}},cancel:function(){if(this.dragging){this._mouseUp({target:null}),"original"===this.options.helper?this.currentItem.css(this._storedCSS).removeClass("ui-sortable-helper"):this.currentItem.show();for(var t=this.containers.length-1;t>=0;t--)this.containers[t]._trigger("deactivate",null,this._uiHash(this)),this.containers[t].containerCache.over&&(this.containers[t]._trigger("out",null,this._uiHash(this)),this.containers[t].containerCache.over=0)}return this.placeholder&&(this.placeholder[0].parentNode&&this.placeholder[0].parentNode.removeChild(this.placeholder[0]),"original"!==this.options.helper&&this.helper&&this.helper[0].parentNode&&this.helper.remove(),e.extend(this,{helper:null,dragging:!1,reverting:!1,_noFinalSort:null}),this.domPosition.prev?e(this.domPosition.prev).after(this.currentItem):e(this.domPosition.parent).prepend(this.currentItem)),this},serialize:function(t){var i=this._getItemsAsjQuery(t&&t.connected),s=[];return t=t||{},e(i).each(function(){var i=(e(t.item||this).attr(t.attribute||"id")||"").match(t.expression||/(.+)[\-=_](.+)/);i&&s.push((t.key||i[1]+"[]")+"="+(t.key&&t.expression?i[1]:i[2]))}),!s.length&&t.key&&s.push(t.key+"="),s.join("&")},toArray:function(t){var i=this._getItemsAsjQuery(t&&t.connected),s=[];return t=t||{},i.each(function(){s.push(e(t.item||this).attr(t.attribute||"id")||"")}),s},_intersectsWith:function(e){var t=this.positionAbs.left,i=t+this.helperProportions.width,s=this.positionAbs.top,a=s+this.helperProportions.height,n=e.left,r=n+e.width,o=e.top,h=o+e.height,l=this.offset.click.top,u=this.offset.click.left,d="x"===this.options.axis||s+l>o&&h>s+l,c="y"===this.options.axis||t+u>n&&r>t+u,p=d&&c;return"pointer"===this.options.tolerance||this.options.forcePointerForContainers||"pointer"!==this.options.tolerance&&this.helperProportions[this.floating?"width":"height"]>e[this.floating?"width":"height"]?p:t+this.helperProportions.width/2>n&&r>i-this.helperProportions.width/2&&s+this.helperProportions.height/2>o&&h>a-this.helperProportions.height/2},_intersectsWithPointer:function(e){var t="x"===this.options.axis||this._isOverAxis(this.positionAbs.top+this.offset.click.top,e.top,e.height),i="y"===this.options.axis||this._isOverAxis(this.positionAbs.left+this.offset.click.left,e.left,e.width),s=t&&i,a=this._getDragVerticalDirection(),n=this._getDragHorizontalDirection();return s?this.floating?n&&"right"===n||"down"===a?2:1:a&&("down"===a?2:1):!1},_intersectsWithSides:function(e){var t=this._isOverAxis(this.positionAbs.top+this.offset.click.top,e.top+e.height/2,e.height),i=this._isOverAxis(this.positionAbs.left+this.offset.click.left,e.left+e.width/2,e.width),s=this._getDragVerticalDirection(),a=this._getDragHorizontalDirection();return this.floating&&a?"right"===a&&i||"left"===a&&!i:s&&("down"===s&&t||"up"===s&&!t)},_getDragVerticalDirection:function(){var e=this.positionAbs.top-this.lastPositionAbs.top;return 0!==e&&(e>0?"down":"up")},_getDragHorizontalDirection:function(){var e=this.positionAbs.left-this.lastPositionAbs.left;return 0!==e&&(e>0?"right":"left")},refresh:function(e){return this._refreshItems(e),this._setHandleClassName(),this.refreshPositions(),this},_connectWith:function(){var e=this.options;return e.connectWith.constructor===String?[e.connectWith]:e.connectWith},_getItemsAsjQuery:function(t){function i(){o.push(this)}var s,a,n,r,o=[],h=[],l=this._connectWith();if(l&&t)for(s=l.length-1;s>=0;s--)for(n=e(l[s]),a=n.length-1;a>=0;a--)r=e.data(n[a],this.widgetFullName),r&&r!==this&&!r.options.disabled&&h.push([e.isFunction(r.options.items)?r.options.items.call(r.element):e(r.options.items,r.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"),r]);for(h.push([e.isFunction(this.options.items)?this.options.items.call(this.element,null,{options:this.options,item:this.currentItem}):e(this.options.items,this.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"),this]),s=h.length-1;s>=0;s--)h[s][0].each(i);return e(o)},_removeCurrentsFromItems:function(){var t=this.currentItem.find(":data("+this.widgetName+"-item)");this.items=e.grep(this.items,function(e){for(var i=0;t.length>i;i++)if(t[i]===e.item[0])return!1;return!0})},_refreshItems:function(t){this.items=[],this.containers=[this];var i,s,a,n,r,o,h,l,u=this.items,d=[[e.isFunction(this.options.items)?this.options.items.call(this.element[0],t,{item:this.currentItem}):e(this.options.items,this.element),this]],c=this._connectWith();if(c&&this.ready)for(i=c.length-1;i>=0;i--)for(a=e(c[i]),s=a.length-1;s>=0;s--)n=e.data(a[s],this.widgetFullName),n&&n!==this&&!n.options.disabled&&(d.push([e.isFunction(n.options.items)?n.options.items.call(n.element[0],t,{item:this.currentItem}):e(n.options.items,n.element),n]),this.containers.push(n));for(i=d.length-1;i>=0;i--)for(r=d[i][1],o=d[i][0],s=0,l=o.length;l>s;s++)h=e(o[s]),h.data(this.widgetName+"-item",r),u.push({item:h,instance:r,width:0,height:0,left:0,top:0})},refreshPositions:function(t){this.offsetParent&&this.helper&&(this.offset.parent=this._getParentOffset());var i,s,a,n;for(i=this.items.length-1;i>=0;i--)s=this.items[i],s.instance!==this.currentContainer&&this.currentContainer&&s.item[0]!==this.currentItem[0]||(a=this.options.toleranceElement?e(this.options.toleranceElement,s.item):s.item,t||(s.width=a.outerWidth(),s.height=a.outerHeight()),n=a.offset(),s.left=n.left,s.top=n.top);if(this.options.custom&&this.options.custom.refreshContainers)this.options.custom.refreshContainers.call(this);else for(i=this.containers.length-1;i>=0;i--)n=this.containers[i].element.offset(),this.containers[i].containerCache.left=n.left,this.containers[i].containerCache.top=n.top,this.containers[i].containerCache.width=this.containers[i].element.outerWidth(),this.containers[i].containerCache.height=this.containers[i].element.outerHeight();return this},_createPlaceholder:function(t){t=t||this;var i,s=t.options;s.placeholder&&s.placeholder.constructor!==String||(i=s.placeholder,s.placeholder={element:function(){var s=t.currentItem[0].nodeName.toLowerCase(),a=e("<"+s+">",t.document[0]).addClass(i||t.currentItem[0].className+" ui-sortable-placeholder").removeClass("ui-sortable-helper");return"tr"===s?t.currentItem.children().each(function(){e("<td>&#160;</td>",t.document[0]).attr("colspan",e(this).attr("colspan")||1).appendTo(a)}):"img"===s&&a.attr("src",t.currentItem.attr("src")),i||a.css("visibility","hidden"),a},update:function(e,a){(!i||s.forcePlaceholderSize)&&(a.height()||a.height(t.currentItem.innerHeight()-parseInt(t.currentItem.css("paddingTop")||0,10)-parseInt(t.currentItem.css("paddingBottom")||0,10)),a.width()||a.width(t.currentItem.innerWidth()-parseInt(t.currentItem.css("paddingLeft")||0,10)-parseInt(t.currentItem.css("paddingRight")||0,10)))}}),t.placeholder=e(s.placeholder.element.call(t.element,t.currentItem)),t.currentItem.after(t.placeholder),s.placeholder.update(t,t.placeholder)},_contactContainers:function(t){var i,s,a,n,r,o,h,l,u,d,c=null,p=null;for(i=this.containers.length-1;i>=0;i--)if(!e.contains(this.currentItem[0],this.containers[i].element[0]))if(this._intersectsWith(this.containers[i].containerCache)){if(c&&e.contains(this.containers[i].element[0],c.element[0]))continue;c=this.containers[i],p=i}else this.containers[i].containerCache.over&&(this.containers[i]._trigger("out",t,this._uiHash(this)),this.containers[i].containerCache.over=0);if(c)if(1===this.containers.length)this.containers[p].containerCache.over||(this.containers[p]._trigger("over",t,this._uiHash(this)),this.containers[p].containerCache.over=1);else{for(a=1e4,n=null,u=c.floating||this._isFloating(this.currentItem),r=u?"left":"top",o=u?"width":"height",d=u?"clientX":"clientY",s=this.items.length-1;s>=0;s--)e.contains(this.containers[p].element[0],this.items[s].item[0])&&this.items[s].item[0]!==this.currentItem[0]&&(h=this.items[s].item.offset()[r],l=!1,t[d]-h>this.items[s][o]/2&&(l=!0),a>Math.abs(t[d]-h)&&(a=Math.abs(t[d]-h),n=this.items[s],this.direction=l?"up":"down"));if(!n&&!this.options.dropOnEmpty)return;if(this.currentContainer===this.containers[p])return;n?this._rearrange(t,n,null,!0):this._rearrange(t,null,this.containers[p].element,!0),this._trigger("change",t,this._uiHash()),this.containers[p]._trigger("change",t,this._uiHash(this)),this.currentContainer=this.containers[p],this.options.placeholder.update(this.currentContainer,this.placeholder),this.containers[p]._trigger("over",t,this._uiHash(this)),this.containers[p].containerCache.over=1}},_createHelper:function(t){var i=this.options,s=e.isFunction(i.helper)?e(i.helper.apply(this.element[0],[t,this.currentItem])):"clone"===i.helper?this.currentItem.clone():this.currentItem;return s.parents("body").length||e("parent"!==i.appendTo?i.appendTo:this.currentItem[0].parentNode)[0].appendChild(s[0]),s[0]===this.currentItem[0]&&(this._storedCSS={width:this.currentItem[0].style.width,height:this.currentItem[0].style.height,position:this.currentItem.css("position"),top:this.currentItem.css("top"),left:this.currentItem.css("left")}),(!s[0].style.width||i.forceHelperSize)&&s.width(this.currentItem.width()),(!s[0].style.height||i.forceHelperSize)&&s.height(this.currentItem.height()),s},_adjustOffsetFromHelper:function(t){"string"==typeof t&&(t=t.split(" ")),e.isArray(t)&&(t={left:+t[0],top:+t[1]||0}),"left"in t&&(this.offset.click.left=t.left+this.margins.left),"right"in t&&(this.offset.click.left=this.helperProportions.width-t.right+this.margins.left),"top"in t&&(this.offset.click.top=t.top+this.margins.top),"bottom"in t&&(this.offset.click.top=this.helperProportions.height-t.bottom+this.margins.top)},_getParentOffset:function(){this.offsetParent=this.helper.offsetParent();var t=this.offsetParent.offset();return"absolute"===this.cssPosition&&this.scrollParent[0]!==document&&e.contains(this.scrollParent[0],this.offsetParent[0])&&(t.left+=this.scrollParent.scrollLeft(),t.top+=this.scrollParent.scrollTop()),(this.offsetParent[0]===document.body||this.offsetParent[0].tagName&&"html"===this.offsetParent[0].tagName.toLowerCase()&&e.ui.ie)&&(t={top:0,left:0}),{top:t.top+(parseInt(this.offsetParent.css("borderTopWidth"),10)||0),left:t.left+(parseInt(this.offsetParent.css("borderLeftWidth"),10)||0)}},_getRelativeOffset:function(){if("relative"===this.cssPosition){var e=this.currentItem.position();return{top:e.top-(parseInt(this.helper.css("top"),10)||0)+this.scrollParent.scrollTop(),left:e.left-(parseInt(this.helper.css("left"),10)||0)+this.scrollParent.scrollLeft()}}return{top:0,left:0}},_cacheMargins:function(){this.margins={left:parseInt(this.currentItem.css("marginLeft"),10)||0,top:parseInt(this.currentItem.css("marginTop"),10)||0}},_cacheHelperProportions:function(){this.helperProportions={width:this.helper.outerWidth(),height:this.helper.outerHeight()}},_setContainment:function(){var t,i,s,a=this.options;"parent"===a.containment&&(a.containment=this.helper[0].parentNode),("document"===a.containment||"window"===a.containment)&&(this.containment=[0-this.offset.relative.left-this.offset.parent.left,0-this.offset.relative.top-this.offset.parent.top,e("document"===a.containment?document:window).width()-this.helperProportions.width-this.margins.left,(e("document"===a.containment?document:window).height()||document.body.parentNode.scrollHeight)-this.helperProportions.height-this.margins.top]),/^(document|window|parent)$/.test(a.containment)||(t=e(a.containment)[0],i=e(a.containment).offset(),s="hidden"!==e(t).css("overflow"),this.containment=[i.left+(parseInt(e(t).css("borderLeftWidth"),10)||0)+(parseInt(e(t).css("paddingLeft"),10)||0)-this.margins.left,i.top+(parseInt(e(t).css("borderTopWidth"),10)||0)+(parseInt(e(t).css("paddingTop"),10)||0)-this.margins.top,i.left+(s?Math.max(t.scrollWidth,t.offsetWidth):t.offsetWidth)-(parseInt(e(t).css("borderLeftWidth"),10)||0)-(parseInt(e(t).css("paddingRight"),10)||0)-this.helperProportions.width-this.margins.left,i.top+(s?Math.max(t.scrollHeight,t.offsetHeight):t.offsetHeight)-(parseInt(e(t).css("borderTopWidth"),10)||0)-(parseInt(e(t).css("paddingBottom"),10)||0)-this.helperProportions.height-this.margins.top])},_convertPositionTo:function(t,i){i||(i=this.position);var s="absolute"===t?1:-1,a="absolute"!==this.cssPosition||this.scrollParent[0]!==document&&e.contains(this.scrollParent[0],this.offsetParent[0])?this.scrollParent:this.offsetParent,n=/(html|body)/i.test(a[0].tagName);return{top:i.top+this.offset.relative.top*s+this.offset.parent.top*s-("fixed"===this.cssPosition?-this.scrollParent.scrollTop():n?0:a.scrollTop())*s,left:i.left+this.offset.relative.left*s+this.offset.parent.left*s-("fixed"===this.cssPosition?-this.scrollParent.scrollLeft():n?0:a.scrollLeft())*s}},_generatePosition:function(t){var i,s,a=this.options,n=t.pageX,r=t.pageY,o="absolute"!==this.cssPosition||this.scrollParent[0]!==document&&e.contains(this.scrollParent[0],this.offsetParent[0])?this.scrollParent:this.offsetParent,h=/(html|body)/i.test(o[0].tagName);return"relative"!==this.cssPosition||this.scrollParent[0]!==document&&this.scrollParent[0]!==this.offsetParent[0]||(this.offset.relative=this._getRelativeOffset()),this.originalPosition&&(this.containment&&(t.pageX-this.offset.click.left<this.containment[0]&&(n=this.containment[0]+this.offset.click.left),t.pageY-this.offset.click.top<this.containment[1]&&(r=this.containment[1]+this.offset.click.top),t.pageX-this.offset.click.left>this.containment[2]&&(n=this.containment[2]+this.offset.click.left),t.pageY-this.offset.click.top>this.containment[3]&&(r=this.containment[3]+this.offset.click.top)),a.grid&&(i=this.originalPageY+Math.round((r-this.originalPageY)/a.grid[1])*a.grid[1],r=this.containment?i-this.offset.click.top>=this.containment[1]&&i-this.offset.click.top<=this.containment[3]?i:i-this.offset.click.top>=this.containment[1]?i-a.grid[1]:i+a.grid[1]:i,s=this.originalPageX+Math.round((n-this.originalPageX)/a.grid[0])*a.grid[0],n=this.containment?s-this.offset.click.left>=this.containment[0]&&s-this.offset.click.left<=this.containment[2]?s:s-this.offset.click.left>=this.containment[0]?s-a.grid[0]:s+a.grid[0]:s)),{top:r-this.offset.click.top-this.offset.relative.top-this.offset.parent.top+("fixed"===this.cssPosition?-this.scrollParent.scrollTop():h?0:o.scrollTop()),left:n-this.offset.click.left-this.offset.relative.left-this.offset.parent.left+("fixed"===this.cssPosition?-this.scrollParent.scrollLeft():h?0:o.scrollLeft())}},_rearrange:function(e,t,i,s){i?i[0].appendChild(this.placeholder[0]):t.item[0].parentNode.insertBefore(this.placeholder[0],"down"===this.direction?t.item[0]:t.item[0].nextSibling),this.counter=this.counter?++this.counter:1;var a=this.counter;this._delay(function(){a===this.counter&&this.refreshPositions(!s)})},_clear:function(e,t){function i(e,t,i){return function(s){i._trigger(e,s,t._uiHash(t))}}this.reverting=!1;var s,a=[];if(!this._noFinalSort&&this.currentItem.parent().length&&this.placeholder.before(this.currentItem),this._noFinalSort=null,this.helper[0]===this.currentItem[0]){for(s in this._storedCSS)("auto"===this._storedCSS[s]||"static"===this._storedCSS[s])&&(this._storedCSS[s]="");this.currentItem.css(this._storedCSS).removeClass("ui-sortable-helper")}else this.currentItem.show();for(this.fromOutside&&!t&&a.push(function(e){this._trigger("receive",e,this._uiHash(this.fromOutside))}),!this.fromOutside&&this.domPosition.prev===this.currentItem.prev().not(".ui-sortable-helper")[0]&&this.domPosition.parent===this.currentItem.parent()[0]||t||a.push(function(e){this._trigger("update",e,this._uiHash())}),this!==this.currentContainer&&(t||(a.push(function(e){this._trigger("remove",e,this._uiHash())}),a.push(function(e){return function(t){e._trigger("receive",t,this._uiHash(this))}}.call(this,this.currentContainer)),a.push(function(e){return function(t){e._trigger("update",t,this._uiHash(this))}}.call(this,this.currentContainer)))),s=this.containers.length-1;s>=0;s--)t||a.push(i("deactivate",this,this.containers[s])),this.containers[s].containerCache.over&&(a.push(i("out",this,this.containers[s])),this.containers[s].containerCache.over=0);if(this.storedCursor&&(this.document.find("body").css("cursor",this.storedCursor),this.storedStylesheet.remove()),this._storedOpacity&&this.helper.css("opacity",this._storedOpacity),this._storedZIndex&&this.helper.css("zIndex","auto"===this._storedZIndex?"":this._storedZIndex),this.dragging=!1,this.cancelHelperRemoval){if(!t){for(this._trigger("beforeStop",e,this._uiHash()),s=0;a.length>s;s++)a[s].call(this,e);this._trigger("stop",e,this._uiHash())}return this.fromOutside=!1,!1}if(t||this._trigger("beforeStop",e,this._uiHash()),this.placeholder[0].parentNode.removeChild(this.placeholder[0]),this.helper[0]!==this.currentItem[0]&&this.helper.remove(),this.helper=null,!t){for(s=0;a.length>s;s++)a[s].call(this,e);this._trigger("stop",e,this._uiHash())}return this.fromOutside=!1,!0},_trigger:function(){e.Widget.prototype._trigger.apply(this,arguments)===!1&&this.cancel()},_uiHash:function(t){var i=t||this;return{helper:i.helper,placeholder:i.placeholder||e([]),position:i.position,originalPosition:i.originalPosition,offset:i.positionAbs,item:i.currentItem,sender:t?t.element:null}}}),e.widget("ui.accordion",{version:"1.11.0",options:{active:0,animate:{},collapsible:!1,event:"click",header:"> li > :first-child,> :not(li):even",heightStyle:"auto",icons:{activeHeader:"ui-icon-triangle-1-s",header:"ui-icon-triangle-1-e"},activate:null,beforeActivate:null},hideProps:{borderTopWidth:"hide",borderBottomWidth:"hide",paddingTop:"hide",paddingBottom:"hide",height:"hide"},showProps:{borderTopWidth:"show",borderBottomWidth:"show",paddingTop:"show",paddingBottom:"show",height:"show"},_create:function(){var t=this.options;this.prevShow=this.prevHide=e(),this.element.addClass("ui-accordion ui-widget ui-helper-reset").attr("role","tablist"),t.collapsible||t.active!==!1&&null!=t.active||(t.active=0),this._processPanels(),0>t.active&&(t.active+=this.headers.length),this._refresh()},_getCreateEventData:function(){return{header:this.active,panel:this.active.length?this.active.next():e()}},_createIcons:function(){var t=this.options.icons;t&&(e("<span>").addClass("ui-accordion-header-icon ui-icon "+t.header).prependTo(this.headers),this.active.children(".ui-accordion-header-icon").removeClass(t.header).addClass(t.activeHeader),this.headers.addClass("ui-accordion-icons"))},_destroyIcons:function(){this.headers.removeClass("ui-accordion-icons").children(".ui-accordion-header-icon").remove()},_destroy:function(){var e;this.element.removeClass("ui-accordion ui-widget ui-helper-reset").removeAttr("role"),this.headers.removeClass("ui-accordion-header ui-accordion-header-active ui-state-default ui-corner-all ui-state-active ui-state-disabled ui-corner-top").removeAttr("role").removeAttr("aria-expanded").removeAttr("aria-selected").removeAttr("aria-controls").removeAttr("tabIndex").removeUniqueId(),this._destroyIcons(),e=this.headers.next().removeClass("ui-helper-reset ui-widget-content ui-corner-bottom ui-accordion-content ui-accordion-content-active ui-state-disabled").css("display","").removeAttr("role").removeAttr("aria-hidden").removeAttr("aria-labelledby").removeUniqueId(),"content"!==this.options.heightStyle&&e.css("height","")},_setOption:function(e,t){return"active"===e?(this._activate(t),void 0):("event"===e&&(this.options.event&&this._off(this.headers,this.options.event),this._setupEvents(t)),this._super(e,t),"collapsible"!==e||t||this.options.active!==!1||this._activate(0),"icons"===e&&(this._destroyIcons(),t&&this._createIcons()),"disabled"===e&&(this.element.toggleClass("ui-state-disabled",!!t).attr("aria-disabled",t),this.headers.add(this.headers.next()).toggleClass("ui-state-disabled",!!t)),void 0)},_keydown:function(t){if(!t.altKey&&!t.ctrlKey){var i=e.ui.keyCode,s=this.headers.length,a=this.headers.index(t.target),n=!1;switch(t.keyCode){case i.RIGHT:case i.DOWN:n=this.headers[(a+1)%s];break;case i.LEFT:case i.UP:n=this.headers[(a-1+s)%s];break;case i.SPACE:case i.ENTER:this._eventHandler(t);break;case i.HOME:n=this.headers[0];break;case i.END:n=this.headers[s-1]}n&&(e(t.target).attr("tabIndex",-1),e(n).attr("tabIndex",0),n.focus(),t.preventDefault())}},_panelKeyDown:function(t){t.keyCode===e.ui.keyCode.UP&&t.ctrlKey&&e(t.currentTarget).prev().focus()},refresh:function(){var t=this.options;this._processPanels(),t.active===!1&&t.collapsible===!0||!this.headers.length?(t.active=!1,this.active=e()):t.active===!1?this._activate(0):this.active.length&&!e.contains(this.element[0],this.active[0])?this.headers.length===this.headers.find(".ui-state-disabled").length?(t.active=!1,this.active=e()):this._activate(Math.max(0,t.active-1)):t.active=this.headers.index(this.active),this._destroyIcons(),this._refresh()},_processPanels:function(){this.headers=this.element.find(this.options.header).addClass("ui-accordion-header ui-state-default ui-corner-all"),this.headers.next().addClass("ui-accordion-content ui-helper-reset ui-widget-content ui-corner-bottom").filter(":not(.ui-accordion-content-active)").hide()},_refresh:function(){var t,i=this.options,s=i.heightStyle,a=this.element.parent();this.active=this._findActive(i.active).addClass("ui-accordion-header-active ui-state-active ui-corner-top").removeClass("ui-corner-all"),this.active.next().addClass("ui-accordion-content-active").show(),this.headers.attr("role","tab").each(function(){var t=e(this),i=t.uniqueId().attr("id"),s=t.next(),a=s.uniqueId().attr("id");
t.attr("aria-controls",a),s.attr("aria-labelledby",i)}).next().attr("role","tabpanel"),this.headers.not(this.active).attr({"aria-selected":"false","aria-expanded":"false",tabIndex:-1}).next().attr({"aria-hidden":"true"}).hide(),this.active.length?this.active.attr({"aria-selected":"true","aria-expanded":"true",tabIndex:0}).next().attr({"aria-hidden":"false"}):this.headers.eq(0).attr("tabIndex",0),this._createIcons(),this._setupEvents(i.event),"fill"===s?(t=a.height(),this.element.siblings(":visible").each(function(){var i=e(this),s=i.css("position");"absolute"!==s&&"fixed"!==s&&(t-=i.outerHeight(!0))}),this.headers.each(function(){t-=e(this).outerHeight(!0)}),this.headers.next().each(function(){e(this).height(Math.max(0,t-e(this).innerHeight()+e(this).height()))}).css("overflow","auto")):"auto"===s&&(t=0,this.headers.next().each(function(){t=Math.max(t,e(this).css("height","").height())}).height(t))},_activate:function(t){var i=this._findActive(t)[0];i!==this.active[0]&&(i=i||this.active[0],this._eventHandler({target:i,currentTarget:i,preventDefault:e.noop}))},_findActive:function(t){return"number"==typeof t?this.headers.eq(t):e()},_setupEvents:function(t){var i={keydown:"_keydown"};t&&e.each(t.split(" "),function(e,t){i[t]="_eventHandler"}),this._off(this.headers.add(this.headers.next())),this._on(this.headers,i),this._on(this.headers.next(),{keydown:"_panelKeyDown"}),this._hoverable(this.headers),this._focusable(this.headers)},_eventHandler:function(t){var i=this.options,s=this.active,a=e(t.currentTarget),n=a[0]===s[0],r=n&&i.collapsible,o=r?e():a.next(),h=s.next(),l={oldHeader:s,oldPanel:h,newHeader:r?e():a,newPanel:o};t.preventDefault(),n&&!i.collapsible||this._trigger("beforeActivate",t,l)===!1||(i.active=r?!1:this.headers.index(a),this.active=n?e():a,this._toggle(l),s.removeClass("ui-accordion-header-active ui-state-active"),i.icons&&s.children(".ui-accordion-header-icon").removeClass(i.icons.activeHeader).addClass(i.icons.header),n||(a.removeClass("ui-corner-all").addClass("ui-accordion-header-active ui-state-active ui-corner-top"),i.icons&&a.children(".ui-accordion-header-icon").removeClass(i.icons.header).addClass(i.icons.activeHeader),a.next().addClass("ui-accordion-content-active")))},_toggle:function(t){var i=t.newPanel,s=this.prevShow.length?this.prevShow:t.oldPanel;this.prevShow.add(this.prevHide).stop(!0,!0),this.prevShow=i,this.prevHide=s,this.options.animate?this._animate(i,s,t):(s.hide(),i.show(),this._toggleComplete(t)),s.attr({"aria-hidden":"true"}),s.prev().attr("aria-selected","false"),i.length&&s.length?s.prev().attr({tabIndex:-1,"aria-expanded":"false"}):i.length&&this.headers.filter(function(){return 0===e(this).attr("tabIndex")}).attr("tabIndex",-1),i.attr("aria-hidden","false").prev().attr({"aria-selected":"true",tabIndex:0,"aria-expanded":"true"})},_animate:function(e,t,i){var s,a,n,r=this,o=0,h=e.length&&(!t.length||e.index()<t.index()),l=this.options.animate||{},u=h&&l.down||l,d=function(){r._toggleComplete(i)};return"number"==typeof u&&(n=u),"string"==typeof u&&(a=u),a=a||u.easing||l.easing,n=n||u.duration||l.duration,t.length?e.length?(s=e.show().outerHeight(),t.animate(this.hideProps,{duration:n,easing:a,step:function(e,t){t.now=Math.round(e)}}),e.hide().animate(this.showProps,{duration:n,easing:a,complete:d,step:function(e,i){i.now=Math.round(e),"height"!==i.prop?o+=i.now:"content"!==r.options.heightStyle&&(i.now=Math.round(s-t.outerHeight()-o),o=0)}}),void 0):t.animate(this.hideProps,n,a,d):e.animate(this.showProps,n,a,d)},_toggleComplete:function(e){var t=e.oldPanel;t.removeClass("ui-accordion-content-active").prev().removeClass("ui-corner-top").addClass("ui-corner-all"),t.length&&(t.parent()[0].className=t.parent()[0].className),this._trigger("activate",null,e)}}),e.widget("ui.menu",{version:"1.11.0",defaultElement:"<ul>",delay:300,options:{icons:{submenu:"ui-icon-carat-1-e"},items:"> *",menus:"ul",position:{my:"left-1 top",at:"right top"},role:"menu",blur:null,focus:null,select:null},_create:function(){this.activeMenu=this.element,this.mouseHandled=!1,this.element.uniqueId().addClass("ui-menu ui-widget ui-widget-content").toggleClass("ui-menu-icons",!!this.element.find(".ui-icon").length).attr({role:this.options.role,tabIndex:0}),this.options.disabled&&this.element.addClass("ui-state-disabled").attr("aria-disabled","true"),this._on({"mousedown .ui-menu-item":function(e){e.preventDefault()},"click .ui-menu-item":function(t){var i=e(t.target);!this.mouseHandled&&i.not(".ui-state-disabled").length&&(this.select(t),t.isPropagationStopped()||(this.mouseHandled=!0),i.has(".ui-menu").length?this.expand(t):!this.element.is(":focus")&&e(this.document[0].activeElement).closest(".ui-menu").length&&(this.element.trigger("focus",[!0]),this.active&&1===this.active.parents(".ui-menu").length&&clearTimeout(this.timer)))},"mouseenter .ui-menu-item":function(t){var i=e(t.currentTarget);i.siblings(".ui-state-active").removeClass("ui-state-active"),this.focus(t,i)},mouseleave:"collapseAll","mouseleave .ui-menu":"collapseAll",focus:function(e,t){var i=this.active||this.element.find(this.options.items).eq(0);t||this.focus(e,i)},blur:function(t){this._delay(function(){e.contains(this.element[0],this.document[0].activeElement)||this.collapseAll(t)})},keydown:"_keydown"}),this.refresh(),this._on(this.document,{click:function(e){this._closeOnDocumentClick(e)&&this.collapseAll(e),this.mouseHandled=!1}})},_destroy:function(){this.element.removeAttr("aria-activedescendant").find(".ui-menu").addBack().removeClass("ui-menu ui-widget ui-widget-content ui-menu-icons ui-front").removeAttr("role").removeAttr("tabIndex").removeAttr("aria-labelledby").removeAttr("aria-expanded").removeAttr("aria-hidden").removeAttr("aria-disabled").removeUniqueId().show(),this.element.find(".ui-menu-item").removeClass("ui-menu-item").removeAttr("role").removeAttr("aria-disabled").removeUniqueId().removeClass("ui-state-hover").removeAttr("tabIndex").removeAttr("role").removeAttr("aria-haspopup").children().each(function(){var t=e(this);t.data("ui-menu-submenu-carat")&&t.remove()}),this.element.find(".ui-menu-divider").removeClass("ui-menu-divider ui-widget-content")},_keydown:function(t){function i(e){return e.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g,"\\$&")}var s,a,n,r,o,h=!0;switch(t.keyCode){case e.ui.keyCode.PAGE_UP:this.previousPage(t);break;case e.ui.keyCode.PAGE_DOWN:this.nextPage(t);break;case e.ui.keyCode.HOME:this._move("first","first",t);break;case e.ui.keyCode.END:this._move("last","last",t);break;case e.ui.keyCode.UP:this.previous(t);break;case e.ui.keyCode.DOWN:this.next(t);break;case e.ui.keyCode.LEFT:this.collapse(t);break;case e.ui.keyCode.RIGHT:this.active&&!this.active.is(".ui-state-disabled")&&this.expand(t);break;case e.ui.keyCode.ENTER:case e.ui.keyCode.SPACE:this._activate(t);break;case e.ui.keyCode.ESCAPE:this.collapse(t);break;default:h=!1,a=this.previousFilter||"",n=String.fromCharCode(t.keyCode),r=!1,clearTimeout(this.filterTimer),n===a?r=!0:n=a+n,o=RegExp("^"+i(n),"i"),s=this.activeMenu.find(this.options.items).filter(function(){return o.test(e(this).text())}),s=r&&-1!==s.index(this.active.next())?this.active.nextAll(".ui-menu-item"):s,s.length||(n=String.fromCharCode(t.keyCode),o=RegExp("^"+i(n),"i"),s=this.activeMenu.find(this.options.items).filter(function(){return o.test(e(this).text())})),s.length?(this.focus(t,s),s.length>1?(this.previousFilter=n,this.filterTimer=this._delay(function(){delete this.previousFilter},1e3)):delete this.previousFilter):delete this.previousFilter}h&&t.preventDefault()},_activate:function(e){this.active.is(".ui-state-disabled")||(this.active.is("[aria-haspopup='true']")?this.expand(e):this.select(e))},refresh:function(){var t,i,s=this,a=this.options.icons.submenu,n=this.element.find(this.options.menus);this.element.toggleClass("ui-menu-icons",!!this.element.find(".ui-icon").length),n.filter(":not(.ui-menu)").addClass("ui-menu ui-widget ui-widget-content ui-front").hide().attr({role:this.options.role,"aria-hidden":"true","aria-expanded":"false"}).each(function(){var t=e(this),i=t.parent(),s=e("<span>").addClass("ui-menu-icon ui-icon "+a).data("ui-menu-submenu-carat",!0);i.attr("aria-haspopup","true").prepend(s),t.attr("aria-labelledby",i.attr("id"))}),t=n.add(this.element),i=t.find(this.options.items),i.not(".ui-menu-item").each(function(){var t=e(this);s._isDivider(t)&&t.addClass("ui-widget-content ui-menu-divider")}),i.not(".ui-menu-item, .ui-menu-divider").addClass("ui-menu-item").uniqueId().attr({tabIndex:-1,role:this._itemRole()}),i.filter(".ui-state-disabled").attr("aria-disabled","true"),this.active&&!e.contains(this.element[0],this.active[0])&&this.blur()},_itemRole:function(){return{menu:"menuitem",listbox:"option"}[this.options.role]},_setOption:function(e,t){"icons"===e&&this.element.find(".ui-menu-icon").removeClass(this.options.icons.submenu).addClass(t.submenu),"disabled"===e&&this.element.toggleClass("ui-state-disabled",!!t).attr("aria-disabled",t),this._super(e,t)},focus:function(e,t){var i,s;this.blur(e,e&&"focus"===e.type),this._scrollIntoView(t),this.active=t.first(),s=this.active.addClass("ui-state-focus").removeClass("ui-state-active"),this.options.role&&this.element.attr("aria-activedescendant",s.attr("id")),this.active.parent().closest(".ui-menu-item").addClass("ui-state-active"),e&&"keydown"===e.type?this._close():this.timer=this._delay(function(){this._close()},this.delay),i=t.children(".ui-menu"),i.length&&e&&/^mouse/.test(e.type)&&this._startOpening(i),this.activeMenu=t.parent(),this._trigger("focus",e,{item:t})},_scrollIntoView:function(t){var i,s,a,n,r,o;this._hasScroll()&&(i=parseFloat(e.css(this.activeMenu[0],"borderTopWidth"))||0,s=parseFloat(e.css(this.activeMenu[0],"paddingTop"))||0,a=t.offset().top-this.activeMenu.offset().top-i-s,n=this.activeMenu.scrollTop(),r=this.activeMenu.height(),o=t.outerHeight(),0>a?this.activeMenu.scrollTop(n+a):a+o>r&&this.activeMenu.scrollTop(n+a-r+o))},blur:function(e,t){t||clearTimeout(this.timer),this.active&&(this.active.removeClass("ui-state-focus"),this.active=null,this._trigger("blur",e,{item:this.active}))},_startOpening:function(e){clearTimeout(this.timer),"true"===e.attr("aria-hidden")&&(this.timer=this._delay(function(){this._close(),this._open(e)},this.delay))},_open:function(t){var i=e.extend({of:this.active},this.options.position);clearTimeout(this.timer),this.element.find(".ui-menu").not(t.parents(".ui-menu")).hide().attr("aria-hidden","true"),t.show().removeAttr("aria-hidden").attr("aria-expanded","true").position(i)},collapseAll:function(t,i){clearTimeout(this.timer),this.timer=this._delay(function(){var s=i?this.element:e(t&&t.target).closest(this.element.find(".ui-menu"));s.length||(s=this.element),this._close(s),this.blur(t),this.activeMenu=s},this.delay)},_close:function(e){e||(e=this.active?this.active.parent():this.element),e.find(".ui-menu").hide().attr("aria-hidden","true").attr("aria-expanded","false").end().find(".ui-state-active").not(".ui-state-focus").removeClass("ui-state-active")},_closeOnDocumentClick:function(t){return!e(t.target).closest(".ui-menu").length},_isDivider:function(e){return!/[^\-\u2014\u2013\s]/.test(e.text())},collapse:function(e){var t=this.active&&this.active.parent().closest(".ui-menu-item",this.element);t&&t.length&&(this._close(),this.focus(e,t))},expand:function(e){var t=this.active&&this.active.children(".ui-menu ").find(this.options.items).first();t&&t.length&&(this._open(t.parent()),this._delay(function(){this.focus(e,t)}))},next:function(e){this._move("next","first",e)},previous:function(e){this._move("prev","last",e)},isFirstItem:function(){return this.active&&!this.active.prevAll(".ui-menu-item").length},isLastItem:function(){return this.active&&!this.active.nextAll(".ui-menu-item").length},_move:function(e,t,i){var s;this.active&&(s="first"===e||"last"===e?this.active["first"===e?"prevAll":"nextAll"](".ui-menu-item").eq(-1):this.active[e+"All"](".ui-menu-item").eq(0)),s&&s.length&&this.active||(s=this.activeMenu.find(this.options.items)[t]()),this.focus(i,s)},nextPage:function(t){var i,s,a;return this.active?(this.isLastItem()||(this._hasScroll()?(s=this.active.offset().top,a=this.element.height(),this.active.nextAll(".ui-menu-item").each(function(){return i=e(this),0>i.offset().top-s-a}),this.focus(t,i)):this.focus(t,this.activeMenu.find(this.options.items)[this.active?"last":"first"]())),void 0):(this.next(t),void 0)},previousPage:function(t){var i,s,a;return this.active?(this.isFirstItem()||(this._hasScroll()?(s=this.active.offset().top,a=this.element.height(),this.active.prevAll(".ui-menu-item").each(function(){return i=e(this),i.offset().top-s+a>0}),this.focus(t,i)):this.focus(t,this.activeMenu.find(this.options.items).first())),void 0):(this.next(t),void 0)},_hasScroll:function(){return this.element.outerHeight()<this.element.prop("scrollHeight")},select:function(t){this.active=this.active||e(t.target).closest(".ui-menu-item");var i={item:this.active};this.active.has(".ui-menu").length||this.collapseAll(t,!0),this._trigger("select",t,i)}}),e.widget("ui.autocomplete",{version:"1.11.0",defaultElement:"<input>",options:{appendTo:null,autoFocus:!1,delay:300,minLength:1,position:{my:"left top",at:"left bottom",collision:"none"},source:null,change:null,close:null,focus:null,open:null,response:null,search:null,select:null},requestIndex:0,pending:0,_create:function(){var t,i,s,a=this.element[0].nodeName.toLowerCase(),n="textarea"===a,r="input"===a;this.isMultiLine=n?!0:r?!1:this.element.prop("isContentEditable"),this.valueMethod=this.element[n||r?"val":"text"],this.isNewMenu=!0,this.element.addClass("ui-autocomplete-input").attr("autocomplete","off"),this._on(this.element,{keydown:function(a){if(this.element.prop("readOnly"))return t=!0,s=!0,i=!0,void 0;t=!1,s=!1,i=!1;var n=e.ui.keyCode;switch(a.keyCode){case n.PAGE_UP:t=!0,this._move("previousPage",a);break;case n.PAGE_DOWN:t=!0,this._move("nextPage",a);break;case n.UP:t=!0,this._keyEvent("previous",a);break;case n.DOWN:t=!0,this._keyEvent("next",a);break;case n.ENTER:this.menu.active&&(t=!0,a.preventDefault(),this.menu.select(a));break;case n.TAB:this.menu.active&&this.menu.select(a);break;case n.ESCAPE:this.menu.element.is(":visible")&&(this._value(this.term),this.close(a),a.preventDefault());break;default:i=!0,this._searchTimeout(a)}},keypress:function(s){if(t)return t=!1,(!this.isMultiLine||this.menu.element.is(":visible"))&&s.preventDefault(),void 0;if(!i){var a=e.ui.keyCode;switch(s.keyCode){case a.PAGE_UP:this._move("previousPage",s);break;case a.PAGE_DOWN:this._move("nextPage",s);break;case a.UP:this._keyEvent("previous",s);break;case a.DOWN:this._keyEvent("next",s)}}},input:function(e){return s?(s=!1,e.preventDefault(),void 0):(this._searchTimeout(e),void 0)},focus:function(){this.selectedItem=null,this.previous=this._value()},blur:function(e){return this.cancelBlur?(delete this.cancelBlur,void 0):(clearTimeout(this.searching),this.close(e),this._change(e),void 0)}}),this._initSource(),this.menu=e("<ul>").addClass("ui-autocomplete ui-front").appendTo(this._appendTo()).menu({role:null}).hide().menu("instance"),this._on(this.menu.element,{mousedown:function(t){t.preventDefault(),this.cancelBlur=!0,this._delay(function(){delete this.cancelBlur});var i=this.menu.element[0];e(t.target).closest(".ui-menu-item").length||this._delay(function(){var t=this;this.document.one("mousedown",function(s){s.target===t.element[0]||s.target===i||e.contains(i,s.target)||t.close()})})},menufocus:function(t,i){var s,a;return this.isNewMenu&&(this.isNewMenu=!1,t.originalEvent&&/^mouse/.test(t.originalEvent.type))?(this.menu.blur(),this.document.one("mousemove",function(){e(t.target).trigger(t.originalEvent)}),void 0):(a=i.item.data("ui-autocomplete-item"),!1!==this._trigger("focus",t,{item:a})&&t.originalEvent&&/^key/.test(t.originalEvent.type)&&this._value(a.value),s=i.item.attr("aria-label")||a.value,s&&jQuery.trim(s).length&&(this.liveRegion.children().hide(),e("<div>").text(s).appendTo(this.liveRegion)),void 0)},menuselect:function(e,t){var i=t.item.data("ui-autocomplete-item"),s=this.previous;this.element[0]!==this.document[0].activeElement&&(this.element.focus(),this.previous=s,this._delay(function(){this.previous=s,this.selectedItem=i})),!1!==this._trigger("select",e,{item:i})&&this._value(i.value),this.term=this._value(),this.close(e),this.selectedItem=i}}),this.liveRegion=e("<span>",{role:"status","aria-live":"assertive","aria-relevant":"additions"}).addClass("ui-helper-hidden-accessible").appendTo(this.document[0].body),this._on(this.window,{beforeunload:function(){this.element.removeAttr("autocomplete")}})},_destroy:function(){clearTimeout(this.searching),this.element.removeClass("ui-autocomplete-input").removeAttr("autocomplete"),this.menu.element.remove(),this.liveRegion.remove()},_setOption:function(e,t){this._super(e,t),"source"===e&&this._initSource(),"appendTo"===e&&this.menu.element.appendTo(this._appendTo()),"disabled"===e&&t&&this.xhr&&this.xhr.abort()},_appendTo:function(){var t=this.options.appendTo;return t&&(t=t.jquery||t.nodeType?e(t):this.document.find(t).eq(0)),t&&t[0]||(t=this.element.closest(".ui-front")),t.length||(t=this.document[0].body),t},_initSource:function(){var t,i,s=this;e.isArray(this.options.source)?(t=this.options.source,this.source=function(i,s){s(e.ui.autocomplete.filter(t,i.term))}):"string"==typeof this.options.source?(i=this.options.source,this.source=function(t,a){s.xhr&&s.xhr.abort(),s.xhr=e.ajax({url:i,data:t,dataType:"json",success:function(e){a(e)},error:function(){a([])}})}):this.source=this.options.source},_searchTimeout:function(e){clearTimeout(this.searching),this.searching=this._delay(function(){var t=this.term===this._value(),i=this.menu.element.is(":visible"),s=e.altKey||e.ctrlKey||e.metaKey||e.shiftKey;(!t||t&&!i&&!s)&&(this.selectedItem=null,this.search(null,e))},this.options.delay)},search:function(e,t){return e=null!=e?e:this._value(),this.term=this._value(),e.length<this.options.minLength?this.close(t):this._trigger("search",t)!==!1?this._search(e):void 0},_search:function(e){this.pending++,this.element.addClass("ui-autocomplete-loading"),this.cancelSearch=!1,this.source({term:e},this._response())},_response:function(){var t=++this.requestIndex;return e.proxy(function(e){t===this.requestIndex&&this.__response(e),this.pending--,this.pending||this.element.removeClass("ui-autocomplete-loading")},this)},__response:function(e){e&&(e=this._normalize(e)),this._trigger("response",null,{content:e}),!this.options.disabled&&e&&e.length&&!this.cancelSearch?(this._suggest(e),this._trigger("open")):this._close()},close:function(e){this.cancelSearch=!0,this._close(e)},_close:function(e){this.menu.element.is(":visible")&&(this.menu.element.hide(),this.menu.blur(),this.isNewMenu=!0,this._trigger("close",e))},_change:function(e){this.previous!==this._value()&&this._trigger("change",e,{item:this.selectedItem})},_normalize:function(t){return t.length&&t[0].label&&t[0].value?t:e.map(t,function(t){return"string"==typeof t?{label:t,value:t}:e.extend({},t,{label:t.label||t.value,value:t.value||t.label})})},_suggest:function(t){var i=this.menu.element.empty();this._renderMenu(i,t),this.isNewMenu=!0,this.menu.refresh(),i.show(),this._resizeMenu(),i.position(e.extend({of:this.element},this.options.position)),this.options.autoFocus&&this.menu.next()},_resizeMenu:function(){var e=this.menu.element;e.outerWidth(Math.max(e.width("").outerWidth()+1,this.element.outerWidth()))},_renderMenu:function(t,i){var s=this;e.each(i,function(e,i){s._renderItemData(t,i)})},_renderItemData:function(e,t){return this._renderItem(e,t).data("ui-autocomplete-item",t)},_renderItem:function(t,i){return e("<li>").text(i.label).appendTo(t)},_move:function(e,t){return this.menu.element.is(":visible")?this.menu.isFirstItem()&&/^previous/.test(e)||this.menu.isLastItem()&&/^next/.test(e)?(this.isMultiLine||this._value(this.term),this.menu.blur(),void 0):(this.menu[e](t),void 0):(this.search(null,t),void 0)},widget:function(){return this.menu.element},_value:function(){return this.valueMethod.apply(this.element,arguments)},_keyEvent:function(e,t){(!this.isMultiLine||this.menu.element.is(":visible"))&&(this._move(e,t),t.preventDefault())}}),e.extend(e.ui.autocomplete,{escapeRegex:function(e){return e.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g,"\\$&")},filter:function(t,i){var s=RegExp(e.ui.autocomplete.escapeRegex(i),"i");return e.grep(t,function(e){return s.test(e.label||e.value||e)})}}),e.widget("ui.autocomplete",e.ui.autocomplete,{options:{messages:{noResults:"No search results.",results:function(e){return e+(e>1?" results are":" result is")+" available, use up and down arrow keys to navigate."}}},__response:function(t){var i;this._superApply(arguments),this.options.disabled||this.cancelSearch||(i=t&&t.length?this.options.messages.results(t.length):this.options.messages.noResults,this.liveRegion.children().hide(),e("<div>").text(i).appendTo(this.liveRegion))}}),e.ui.autocomplete;var d,c="ui-button ui-widget ui-state-default ui-corner-all",p="ui-button-icons-only ui-button-icon-only ui-button-text-icons ui-button-text-icon-primary ui-button-text-icon-secondary ui-button-text-only",f=function(){var t=e(this);setTimeout(function(){t.find(":ui-button").button("refresh")},1)},m=function(t){var i=t.name,s=t.form,a=e([]);return i&&(i=i.replace(/'/g,"\\'"),a=s?e(s).find("[name='"+i+"'][type=radio]"):e("[name='"+i+"'][type=radio]",t.ownerDocument).filter(function(){return!this.form})),a};e.widget("ui.button",{version:"1.11.0",defaultElement:"<button>",options:{disabled:null,text:!0,label:null,icons:{primary:null,secondary:null}},_create:function(){this.element.closest("form").unbind("reset"+this.eventNamespace).bind("reset"+this.eventNamespace,f),"boolean"!=typeof this.options.disabled?this.options.disabled=!!this.element.prop("disabled"):this.element.prop("disabled",this.options.disabled),this._determineButtonType(),this.hasTitle=!!this.buttonElement.attr("title");var t=this,i=this.options,s="checkbox"===this.type||"radio"===this.type,a=s?"":"ui-state-active";null===i.label&&(i.label="input"===this.type?this.buttonElement.val():this.buttonElement.html()),this._hoverable(this.buttonElement),this.buttonElement.addClass(c).attr("role","button").bind("mouseenter"+this.eventNamespace,function(){i.disabled||this===d&&e(this).addClass("ui-state-active")}).bind("mouseleave"+this.eventNamespace,function(){i.disabled||e(this).removeClass(a)}).bind("click"+this.eventNamespace,function(e){i.disabled&&(e.preventDefault(),e.stopImmediatePropagation())}),this._on({focus:function(){this.buttonElement.addClass("ui-state-focus")},blur:function(){this.buttonElement.removeClass("ui-state-focus")}}),s&&this.element.bind("change"+this.eventNamespace,function(){t.refresh()}),"checkbox"===this.type?this.buttonElement.bind("click"+this.eventNamespace,function(){return i.disabled?!1:void 0}):"radio"===this.type?this.buttonElement.bind("click"+this.eventNamespace,function(){if(i.disabled)return!1;e(this).addClass("ui-state-active"),t.buttonElement.attr("aria-pressed","true");var s=t.element[0];m(s).not(s).map(function(){return e(this).button("widget")[0]}).removeClass("ui-state-active").attr("aria-pressed","false")}):(this.buttonElement.bind("mousedown"+this.eventNamespace,function(){return i.disabled?!1:(e(this).addClass("ui-state-active"),d=this,t.document.one("mouseup",function(){d=null}),void 0)}).bind("mouseup"+this.eventNamespace,function(){return i.disabled?!1:(e(this).removeClass("ui-state-active"),void 0)}).bind("keydown"+this.eventNamespace,function(t){return i.disabled?!1:((t.keyCode===e.ui.keyCode.SPACE||t.keyCode===e.ui.keyCode.ENTER)&&e(this).addClass("ui-state-active"),void 0)}).bind("keyup"+this.eventNamespace+" blur"+this.eventNamespace,function(){e(this).removeClass("ui-state-active")}),this.buttonElement.is("a")&&this.buttonElement.keyup(function(t){t.keyCode===e.ui.keyCode.SPACE&&e(this).click()})),this._setOption("disabled",i.disabled),this._resetButton()},_determineButtonType:function(){var e,t,i;this.type=this.element.is("[type=checkbox]")?"checkbox":this.element.is("[type=radio]")?"radio":this.element.is("input")?"input":"button","checkbox"===this.type||"radio"===this.type?(e=this.element.parents().last(),t="label[for='"+this.element.attr("id")+"']",this.buttonElement=e.find(t),this.buttonElement.length||(e=e.length?e.siblings():this.element.siblings(),this.buttonElement=e.filter(t),this.buttonElement.length||(this.buttonElement=e.find(t))),this.element.addClass("ui-helper-hidden-accessible"),i=this.element.is(":checked"),i&&this.buttonElement.addClass("ui-state-active"),this.buttonElement.prop("aria-pressed",i)):this.buttonElement=this.element},widget:function(){return this.buttonElement},_destroy:function(){this.element.removeClass("ui-helper-hidden-accessible"),this.buttonElement.removeClass(c+" ui-state-active "+p).removeAttr("role").removeAttr("aria-pressed").html(this.buttonElement.find(".ui-button-text").html()),this.hasTitle||this.buttonElement.removeAttr("title")},_setOption:function(e,t){return this._super(e,t),"disabled"===e?(this.widget().toggleClass("ui-state-disabled",!!t),this.element.prop("disabled",!!t),t&&("checkbox"===this.type||"radio"===this.type?this.buttonElement.removeClass("ui-state-focus"):this.buttonElement.removeClass("ui-state-focus ui-state-active")),void 0):(this._resetButton(),void 0)},refresh:function(){var t=this.element.is("input, button")?this.element.is(":disabled"):this.element.hasClass("ui-button-disabled");t!==this.options.disabled&&this._setOption("disabled",t),"radio"===this.type?m(this.element[0]).each(function(){e(this).is(":checked")?e(this).button("widget").addClass("ui-state-active").attr("aria-pressed","true"):e(this).button("widget").removeClass("ui-state-active").attr("aria-pressed","false")}):"checkbox"===this.type&&(this.element.is(":checked")?this.buttonElement.addClass("ui-state-active").attr("aria-pressed","true"):this.buttonElement.removeClass("ui-state-active").attr("aria-pressed","false"))},_resetButton:function(){if("input"===this.type)return this.options.label&&this.element.val(this.options.label),void 0;var t=this.buttonElement.removeClass(p),i=e("<span></span>",this.document[0]).addClass("ui-button-text").html(this.options.label).appendTo(t.empty()).text(),s=this.options.icons,a=s.primary&&s.secondary,n=[];s.primary||s.secondary?(this.options.text&&n.push("ui-button-text-icon"+(a?"s":s.primary?"-primary":"-secondary")),s.primary&&t.prepend("<span class='ui-button-icon-primary ui-icon "+s.primary+"'></span>"),s.secondary&&t.append("<span class='ui-button-icon-secondary ui-icon "+s.secondary+"'></span>"),this.options.text||(n.push(a?"ui-button-icons-only":"ui-button-icon-only"),this.hasTitle||t.attr("title",e.trim(i)))):n.push("ui-button-text-only"),t.addClass(n.join(" "))}}),e.widget("ui.buttonset",{version:"1.11.0",options:{items:"button, input[type=button], input[type=submit], input[type=reset], input[type=checkbox], input[type=radio], a, :data(ui-button)"},_create:function(){this.element.addClass("ui-buttonset")},_init:function(){this.refresh()},_setOption:function(e,t){"disabled"===e&&this.buttons.button("option",e,t),this._super(e,t)},refresh:function(){var t="rtl"===this.element.css("direction"),i=this.element.find(this.options.items),s=i.filter(":ui-button");i.not(":ui-button").button(),s.button("refresh"),this.buttons=i.map(function(){return e(this).button("widget")[0]}).removeClass("ui-corner-all ui-corner-left ui-corner-right").filter(":first").addClass(t?"ui-corner-right":"ui-corner-left").end().filter(":last").addClass(t?"ui-corner-left":"ui-corner-right").end().end()},_destroy:function(){this.element.removeClass("ui-buttonset"),this.buttons.map(function(){return e(this).button("widget")[0]}).removeClass("ui-corner-left ui-corner-right").end().button("destroy")}}),e.ui.button,e.extend(e.ui,{datepicker:{version:"1.11.0"}});var g;e.extend(a.prototype,{markerClassName:"hasDatepicker",maxRows:4,_widgetDatepicker:function(){return this.dpDiv},setDefaults:function(e){return r(this._defaults,e||{}),this},_attachDatepicker:function(t,i){var s,a,n;s=t.nodeName.toLowerCase(),a="div"===s||"span"===s,t.id||(this.uuid+=1,t.id="dp"+this.uuid),n=this._newInst(e(t),a),n.settings=e.extend({},i||{}),"input"===s?this._connectDatepicker(t,n):a&&this._inlineDatepicker(t,n)},_newInst:function(t,i){var s=t[0].id.replace(/([^A-Za-z0-9_\-])/g,"\\\\$1");return{id:s,input:t,selectedDay:0,selectedMonth:0,selectedYear:0,drawMonth:0,drawYear:0,inline:i,dpDiv:i?n(e("<div class='"+this._inlineClass+" ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all'></div>")):this.dpDiv}},_connectDatepicker:function(t,i){var s=e(t);i.append=e([]),i.trigger=e([]),s.hasClass(this.markerClassName)||(this._attachments(s,i),s.addClass(this.markerClassName).keydown(this._doKeyDown).keypress(this._doKeyPress).keyup(this._doKeyUp),this._autoSize(i),e.data(t,"datepicker",i),i.settings.disabled&&this._disableDatepicker(t))},_attachments:function(t,i){var s,a,n,r=this._get(i,"appendText"),o=this._get(i,"isRTL");i.append&&i.append.remove(),r&&(i.append=e("<span class='"+this._appendClass+"'>"+r+"</span>"),t[o?"before":"after"](i.append)),t.unbind("focus",this._showDatepicker),i.trigger&&i.trigger.remove(),s=this._get(i,"showOn"),("focus"===s||"both"===s)&&t.focus(this._showDatepicker),("button"===s||"both"===s)&&(a=this._get(i,"buttonText"),n=this._get(i,"buttonImage"),i.trigger=e(this._get(i,"buttonImageOnly")?e("<img/>").addClass(this._triggerClass).attr({src:n,alt:a,title:a}):e("<button type='button'></button>").addClass(this._triggerClass).html(n?e("<img/>").attr({src:n,alt:a,title:a}):a)),t[o?"before":"after"](i.trigger),i.trigger.click(function(){return e.datepicker._datepickerShowing&&e.datepicker._lastInput===t[0]?e.datepicker._hideDatepicker():e.datepicker._datepickerShowing&&e.datepicker._lastInput!==t[0]?(e.datepicker._hideDatepicker(),e.datepicker._showDatepicker(t[0])):e.datepicker._showDatepicker(t[0]),!1}))},_autoSize:function(e){if(this._get(e,"autoSize")&&!e.inline){var t,i,s,a,n=new Date(2009,11,20),r=this._get(e,"dateFormat");r.match(/[DM]/)&&(t=function(e){for(i=0,s=0,a=0;e.length>a;a++)e[a].length>i&&(i=e[a].length,s=a);return s},n.setMonth(t(this._get(e,r.match(/MM/)?"monthNames":"monthNamesShort"))),n.setDate(t(this._get(e,r.match(/DD/)?"dayNames":"dayNamesShort"))+20-n.getDay())),e.input.attr("size",this._formatDate(e,n).length)}},_inlineDatepicker:function(t,i){var s=e(t);s.hasClass(this.markerClassName)||(s.addClass(this.markerClassName).append(i.dpDiv),e.data(t,"datepicker",i),this._setDate(i,this._getDefaultDate(i),!0),this._updateDatepicker(i),this._updateAlternate(i),i.settings.disabled&&this._disableDatepicker(t),i.dpDiv.css("display","block"))},_dialogDatepicker:function(t,i,s,a,n){var o,h,l,u,d,c=this._dialogInst;return c||(this.uuid+=1,o="dp"+this.uuid,this._dialogInput=e("<input type='text' id='"+o+"' style='position: absolute; top: -100px; width: 0px;'/>"),this._dialogInput.keydown(this._doKeyDown),e("body").append(this._dialogInput),c=this._dialogInst=this._newInst(this._dialogInput,!1),c.settings={},e.data(this._dialogInput[0],"datepicker",c)),r(c.settings,a||{}),i=i&&i.constructor===Date?this._formatDate(c,i):i,this._dialogInput.val(i),this._pos=n?n.length?n:[n.pageX,n.pageY]:null,this._pos||(h=document.documentElement.clientWidth,l=document.documentElement.clientHeight,u=document.documentElement.scrollLeft||document.body.scrollLeft,d=document.documentElement.scrollTop||document.body.scrollTop,this._pos=[h/2-100+u,l/2-150+d]),this._dialogInput.css("left",this._pos[0]+20+"px").css("top",this._pos[1]+"px"),c.settings.onSelect=s,this._inDialog=!0,this.dpDiv.addClass(this._dialogClass),this._showDatepicker(this._dialogInput[0]),e.blockUI&&e.blockUI(this.dpDiv),e.data(this._dialogInput[0],"datepicker",c),this},_destroyDatepicker:function(t){var i,s=e(t),a=e.data(t,"datepicker");s.hasClass(this.markerClassName)&&(i=t.nodeName.toLowerCase(),e.removeData(t,"datepicker"),"input"===i?(a.append.remove(),a.trigger.remove(),s.removeClass(this.markerClassName).unbind("focus",this._showDatepicker).unbind("keydown",this._doKeyDown).unbind("keypress",this._doKeyPress).unbind("keyup",this._doKeyUp)):("div"===i||"span"===i)&&s.removeClass(this.markerClassName).empty())
},_enableDatepicker:function(t){var i,s,a=e(t),n=e.data(t,"datepicker");a.hasClass(this.markerClassName)&&(i=t.nodeName.toLowerCase(),"input"===i?(t.disabled=!1,n.trigger.filter("button").each(function(){this.disabled=!1}).end().filter("img").css({opacity:"1.0",cursor:""})):("div"===i||"span"===i)&&(s=a.children("."+this._inlineClass),s.children().removeClass("ui-state-disabled"),s.find("select.ui-datepicker-month, select.ui-datepicker-year").prop("disabled",!1)),this._disabledInputs=e.map(this._disabledInputs,function(e){return e===t?null:e}))},_disableDatepicker:function(t){var i,s,a=e(t),n=e.data(t,"datepicker");a.hasClass(this.markerClassName)&&(i=t.nodeName.toLowerCase(),"input"===i?(t.disabled=!0,n.trigger.filter("button").each(function(){this.disabled=!0}).end().filter("img").css({opacity:"0.5",cursor:"default"})):("div"===i||"span"===i)&&(s=a.children("."+this._inlineClass),s.children().addClass("ui-state-disabled"),s.find("select.ui-datepicker-month, select.ui-datepicker-year").prop("disabled",!0)),this._disabledInputs=e.map(this._disabledInputs,function(e){return e===t?null:e}),this._disabledInputs[this._disabledInputs.length]=t)},_isDisabledDatepicker:function(e){if(!e)return!1;for(var t=0;this._disabledInputs.length>t;t++)if(this._disabledInputs[t]===e)return!0;return!1},_getInst:function(t){try{return e.data(t,"datepicker")}catch(i){throw"Missing instance data for this datepicker"}},_optionDatepicker:function(t,i,s){var a,n,o,h,l=this._getInst(t);return 2===arguments.length&&"string"==typeof i?"defaults"===i?e.extend({},e.datepicker._defaults):l?"all"===i?e.extend({},l.settings):this._get(l,i):null:(a=i||{},"string"==typeof i&&(a={},a[i]=s),l&&(this._curInst===l&&this._hideDatepicker(),n=this._getDateDatepicker(t,!0),o=this._getMinMaxDate(l,"min"),h=this._getMinMaxDate(l,"max"),r(l.settings,a),null!==o&&void 0!==a.dateFormat&&void 0===a.minDate&&(l.settings.minDate=this._formatDate(l,o)),null!==h&&void 0!==a.dateFormat&&void 0===a.maxDate&&(l.settings.maxDate=this._formatDate(l,h)),"disabled"in a&&(a.disabled?this._disableDatepicker(t):this._enableDatepicker(t)),this._attachments(e(t),l),this._autoSize(l),this._setDate(l,n),this._updateAlternate(l),this._updateDatepicker(l)),void 0)},_changeDatepicker:function(e,t,i){this._optionDatepicker(e,t,i)},_refreshDatepicker:function(e){var t=this._getInst(e);t&&this._updateDatepicker(t)},_setDateDatepicker:function(e,t){var i=this._getInst(e);i&&(this._setDate(i,t),this._updateDatepicker(i),this._updateAlternate(i))},_getDateDatepicker:function(e,t){var i=this._getInst(e);return i&&!i.inline&&this._setDateFromField(i,t),i?this._getDate(i):null},_doKeyDown:function(t){var i,s,a,n=e.datepicker._getInst(t.target),r=!0,o=n.dpDiv.is(".ui-datepicker-rtl");if(n._keyEvent=!0,e.datepicker._datepickerShowing)switch(t.keyCode){case 9:e.datepicker._hideDatepicker(),r=!1;break;case 13:return a=e("td."+e.datepicker._dayOverClass+":not(."+e.datepicker._currentClass+")",n.dpDiv),a[0]&&e.datepicker._selectDay(t.target,n.selectedMonth,n.selectedYear,a[0]),i=e.datepicker._get(n,"onSelect"),i?(s=e.datepicker._formatDate(n),i.apply(n.input?n.input[0]:null,[s,n])):e.datepicker._hideDatepicker(),!1;case 27:e.datepicker._hideDatepicker();break;case 33:e.datepicker._adjustDate(t.target,t.ctrlKey?-e.datepicker._get(n,"stepBigMonths"):-e.datepicker._get(n,"stepMonths"),"M");break;case 34:e.datepicker._adjustDate(t.target,t.ctrlKey?+e.datepicker._get(n,"stepBigMonths"):+e.datepicker._get(n,"stepMonths"),"M");break;case 35:(t.ctrlKey||t.metaKey)&&e.datepicker._clearDate(t.target),r=t.ctrlKey||t.metaKey;break;case 36:(t.ctrlKey||t.metaKey)&&e.datepicker._gotoToday(t.target),r=t.ctrlKey||t.metaKey;break;case 37:(t.ctrlKey||t.metaKey)&&e.datepicker._adjustDate(t.target,o?1:-1,"D"),r=t.ctrlKey||t.metaKey,t.originalEvent.altKey&&e.datepicker._adjustDate(t.target,t.ctrlKey?-e.datepicker._get(n,"stepBigMonths"):-e.datepicker._get(n,"stepMonths"),"M");break;case 38:(t.ctrlKey||t.metaKey)&&e.datepicker._adjustDate(t.target,-7,"D"),r=t.ctrlKey||t.metaKey;break;case 39:(t.ctrlKey||t.metaKey)&&e.datepicker._adjustDate(t.target,o?-1:1,"D"),r=t.ctrlKey||t.metaKey,t.originalEvent.altKey&&e.datepicker._adjustDate(t.target,t.ctrlKey?+e.datepicker._get(n,"stepBigMonths"):+e.datepicker._get(n,"stepMonths"),"M");break;case 40:(t.ctrlKey||t.metaKey)&&e.datepicker._adjustDate(t.target,7,"D"),r=t.ctrlKey||t.metaKey;break;default:r=!1}else 36===t.keyCode&&t.ctrlKey?e.datepicker._showDatepicker(this):r=!1;r&&(t.preventDefault(),t.stopPropagation())},_doKeyPress:function(t){var i,s,a=e.datepicker._getInst(t.target);return e.datepicker._get(a,"constrainInput")?(i=e.datepicker._possibleChars(e.datepicker._get(a,"dateFormat")),s=String.fromCharCode(null==t.charCode?t.keyCode:t.charCode),t.ctrlKey||t.metaKey||" ">s||!i||i.indexOf(s)>-1):void 0},_doKeyUp:function(t){var i,s=e.datepicker._getInst(t.target);if(s.input.val()!==s.lastVal)try{i=e.datepicker.parseDate(e.datepicker._get(s,"dateFormat"),s.input?s.input.val():null,e.datepicker._getFormatConfig(s)),i&&(e.datepicker._setDateFromField(s),e.datepicker._updateAlternate(s),e.datepicker._updateDatepicker(s))}catch(a){}return!0},_showDatepicker:function(t){if(t=t.target||t,"input"!==t.nodeName.toLowerCase()&&(t=e("input",t.parentNode)[0]),!e.datepicker._isDisabledDatepicker(t)&&e.datepicker._lastInput!==t){var i,a,n,o,h,l,u;i=e.datepicker._getInst(t),e.datepicker._curInst&&e.datepicker._curInst!==i&&(e.datepicker._curInst.dpDiv.stop(!0,!0),i&&e.datepicker._datepickerShowing&&e.datepicker._hideDatepicker(e.datepicker._curInst.input[0])),a=e.datepicker._get(i,"beforeShow"),n=a?a.apply(t,[t,i]):{},n!==!1&&(r(i.settings,n),i.lastVal=null,e.datepicker._lastInput=t,e.datepicker._setDateFromField(i),e.datepicker._inDialog&&(t.value=""),e.datepicker._pos||(e.datepicker._pos=e.datepicker._findPos(t),e.datepicker._pos[1]+=t.offsetHeight),o=!1,e(t).parents().each(function(){return o|="fixed"===e(this).css("position"),!o}),h={left:e.datepicker._pos[0],top:e.datepicker._pos[1]},e.datepicker._pos=null,i.dpDiv.empty(),i.dpDiv.css({position:"absolute",display:"block",top:"-1000px"}),e.datepicker._updateDatepicker(i),h=e.datepicker._checkOffset(i,h,o),i.dpDiv.css({position:e.datepicker._inDialog&&e.blockUI?"static":o?"fixed":"absolute",display:"none",left:h.left+"px",top:h.top+"px"}),i.inline||(l=e.datepicker._get(i,"showAnim"),u=e.datepicker._get(i,"duration"),i.dpDiv.css("z-index",s(e(t))+1),e.datepicker._datepickerShowing=!0,e.effects&&e.effects.effect[l]?i.dpDiv.show(l,e.datepicker._get(i,"showOptions"),u):i.dpDiv[l||"show"](l?u:null),e.datepicker._shouldFocusInput(i)&&i.input.focus(),e.datepicker._curInst=i))}},_updateDatepicker:function(t){this.maxRows=4,g=t,t.dpDiv.empty().append(this._generateHTML(t)),this._attachHandlers(t),t.dpDiv.find("."+this._dayOverClass+" a");var i,s=this._getNumberOfMonths(t),a=s[1],n=17;t.dpDiv.removeClass("ui-datepicker-multi-2 ui-datepicker-multi-3 ui-datepicker-multi-4").width(""),a>1&&t.dpDiv.addClass("ui-datepicker-multi-"+a).css("width",n*a+"em"),t.dpDiv[(1!==s[0]||1!==s[1]?"add":"remove")+"Class"]("ui-datepicker-multi"),t.dpDiv[(this._get(t,"isRTL")?"add":"remove")+"Class"]("ui-datepicker-rtl"),t===e.datepicker._curInst&&e.datepicker._datepickerShowing&&e.datepicker._shouldFocusInput(t)&&t.input.focus(),t.yearshtml&&(i=t.yearshtml,setTimeout(function(){i===t.yearshtml&&t.yearshtml&&t.dpDiv.find("select.ui-datepicker-year:first").replaceWith(t.yearshtml),i=t.yearshtml=null},0))},_shouldFocusInput:function(e){return e.input&&e.input.is(":visible")&&!e.input.is(":disabled")&&!e.input.is(":focus")},_checkOffset:function(t,i,s){var a=t.dpDiv.outerWidth(),n=t.dpDiv.outerHeight(),r=t.input?t.input.outerWidth():0,o=t.input?t.input.outerHeight():0,h=document.documentElement.clientWidth+(s?0:e(document).scrollLeft()),l=document.documentElement.clientHeight+(s?0:e(document).scrollTop());return i.left-=this._get(t,"isRTL")?a-r:0,i.left-=s&&i.left===t.input.offset().left?e(document).scrollLeft():0,i.top-=s&&i.top===t.input.offset().top+o?e(document).scrollTop():0,i.left-=Math.min(i.left,i.left+a>h&&h>a?Math.abs(i.left+a-h):0),i.top-=Math.min(i.top,i.top+n>l&&l>n?Math.abs(n+o):0),i},_findPos:function(t){for(var i,s=this._getInst(t),a=this._get(s,"isRTL");t&&("hidden"===t.type||1!==t.nodeType||e.expr.filters.hidden(t));)t=t[a?"previousSibling":"nextSibling"];return i=e(t).offset(),[i.left,i.top]},_hideDatepicker:function(t){var i,s,a,n,r=this._curInst;!r||t&&r!==e.data(t,"datepicker")||this._datepickerShowing&&(i=this._get(r,"showAnim"),s=this._get(r,"duration"),a=function(){e.datepicker._tidyDialog(r)},e.effects&&(e.effects.effect[i]||e.effects[i])?r.dpDiv.hide(i,e.datepicker._get(r,"showOptions"),s,a):r.dpDiv["slideDown"===i?"slideUp":"fadeIn"===i?"fadeOut":"hide"](i?s:null,a),i||a(),this._datepickerShowing=!1,n=this._get(r,"onClose"),n&&n.apply(r.input?r.input[0]:null,[r.input?r.input.val():"",r]),this._lastInput=null,this._inDialog&&(this._dialogInput.css({position:"absolute",left:"0",top:"-100px"}),e.blockUI&&(e.unblockUI(),e("body").append(this.dpDiv))),this._inDialog=!1)},_tidyDialog:function(e){e.dpDiv.removeClass(this._dialogClass).unbind(".ui-datepicker-calendar")},_checkExternalClick:function(t){if(e.datepicker._curInst){var i=e(t.target),s=e.datepicker._getInst(i[0]);(i[0].id!==e.datepicker._mainDivId&&0===i.parents("#"+e.datepicker._mainDivId).length&&!i.hasClass(e.datepicker.markerClassName)&&!i.closest("."+e.datepicker._triggerClass).length&&e.datepicker._datepickerShowing&&(!e.datepicker._inDialog||!e.blockUI)||i.hasClass(e.datepicker.markerClassName)&&e.datepicker._curInst!==s)&&e.datepicker._hideDatepicker()}},_adjustDate:function(t,i,s){var a=e(t),n=this._getInst(a[0]);this._isDisabledDatepicker(a[0])||(this._adjustInstDate(n,i+("M"===s?this._get(n,"showCurrentAtPos"):0),s),this._updateDatepicker(n))},_gotoToday:function(t){var i,s=e(t),a=this._getInst(s[0]);this._get(a,"gotoCurrent")&&a.currentDay?(a.selectedDay=a.currentDay,a.drawMonth=a.selectedMonth=a.currentMonth,a.drawYear=a.selectedYear=a.currentYear):(i=new Date,a.selectedDay=i.getDate(),a.drawMonth=a.selectedMonth=i.getMonth(),a.drawYear=a.selectedYear=i.getFullYear()),this._notifyChange(a),this._adjustDate(s)},_selectMonthYear:function(t,i,s){var a=e(t),n=this._getInst(a[0]);n["selected"+("M"===s?"Month":"Year")]=n["draw"+("M"===s?"Month":"Year")]=parseInt(i.options[i.selectedIndex].value,10),this._notifyChange(n),this._adjustDate(a)},_selectDay:function(t,i,s,a){var n,r=e(t);e(a).hasClass(this._unselectableClass)||this._isDisabledDatepicker(r[0])||(n=this._getInst(r[0]),n.selectedDay=n.currentDay=e("a",a).html(),n.selectedMonth=n.currentMonth=i,n.selectedYear=n.currentYear=s,this._selectDate(t,this._formatDate(n,n.currentDay,n.currentMonth,n.currentYear)))},_clearDate:function(t){var i=e(t);this._selectDate(i,"")},_selectDate:function(t,i){var s,a=e(t),n=this._getInst(a[0]);i=null!=i?i:this._formatDate(n),n.input&&n.input.val(i),this._updateAlternate(n),s=this._get(n,"onSelect"),s?s.apply(n.input?n.input[0]:null,[i,n]):n.input&&n.input.trigger("change"),n.inline?this._updateDatepicker(n):(this._hideDatepicker(),this._lastInput=n.input[0],"object"!=typeof n.input[0]&&n.input.focus(),this._lastInput=null)},_updateAlternate:function(t){var i,s,a,n=this._get(t,"altField");n&&(i=this._get(t,"altFormat")||this._get(t,"dateFormat"),s=this._getDate(t),a=this.formatDate(i,s,this._getFormatConfig(t)),e(n).each(function(){e(this).val(a)}))},noWeekends:function(e){var t=e.getDay();return[t>0&&6>t,""]},iso8601Week:function(e){var t,i=new Date(e.getTime());return i.setDate(i.getDate()+4-(i.getDay()||7)),t=i.getTime(),i.setMonth(0),i.setDate(1),Math.floor(Math.round((t-i)/864e5)/7)+1},parseDate:function(t,i,s){if(null==t||null==i)throw"Invalid arguments";if(i="object"==typeof i?""+i:i+"",""===i)return null;var a,n,r,o,h=0,l=(s?s.shortYearCutoff:null)||this._defaults.shortYearCutoff,u="string"!=typeof l?l:(new Date).getFullYear()%100+parseInt(l,10),d=(s?s.dayNamesShort:null)||this._defaults.dayNamesShort,c=(s?s.dayNames:null)||this._defaults.dayNames,p=(s?s.monthNamesShort:null)||this._defaults.monthNamesShort,f=(s?s.monthNames:null)||this._defaults.monthNames,m=-1,g=-1,v=-1,y=-1,b=!1,_=function(e){var i=t.length>a+1&&t.charAt(a+1)===e;return i&&a++,i},x=function(e){var t=_(e),s="@"===e?14:"!"===e?20:"y"===e&&t?4:"o"===e?3:2,a=RegExp("^\\d{1,"+s+"}"),n=i.substring(h).match(a);if(!n)throw"Missing number at position "+h;return h+=n[0].length,parseInt(n[0],10)},k=function(t,s,a){var n=-1,r=e.map(_(t)?a:s,function(e,t){return[[t,e]]}).sort(function(e,t){return-(e[1].length-t[1].length)});if(e.each(r,function(e,t){var s=t[1];return i.substr(h,s.length).toLowerCase()===s.toLowerCase()?(n=t[0],h+=s.length,!1):void 0}),-1!==n)return n+1;throw"Unknown name at position "+h},w=function(){if(i.charAt(h)!==t.charAt(a))throw"Unexpected literal at position "+h;h++};for(a=0;t.length>a;a++)if(b)"'"!==t.charAt(a)||_("'")?w():b=!1;else switch(t.charAt(a)){case"d":v=x("d");break;case"D":k("D",d,c);break;case"o":y=x("o");break;case"m":g=x("m");break;case"M":g=k("M",p,f);break;case"y":m=x("y");break;case"@":o=new Date(x("@")),m=o.getFullYear(),g=o.getMonth()+1,v=o.getDate();break;case"!":o=new Date((x("!")-this._ticksTo1970)/1e4),m=o.getFullYear(),g=o.getMonth()+1,v=o.getDate();break;case"'":_("'")?w():b=!0;break;default:w()}if(i.length>h&&(r=i.substr(h),!/^\s+/.test(r)))throw"Extra/unparsed characters found in date: "+r;if(-1===m?m=(new Date).getFullYear():100>m&&(m+=(new Date).getFullYear()-(new Date).getFullYear()%100+(u>=m?0:-100)),y>-1)for(g=1,v=y;;){if(n=this._getDaysInMonth(m,g-1),n>=v)break;g++,v-=n}if(o=this._daylightSavingAdjust(new Date(m,g-1,v)),o.getFullYear()!==m||o.getMonth()+1!==g||o.getDate()!==v)throw"Invalid date";return o},ATOM:"yy-mm-dd",COOKIE:"D, dd M yy",ISO_8601:"yy-mm-dd",RFC_822:"D, d M y",RFC_850:"DD, dd-M-y",RFC_1036:"D, d M y",RFC_1123:"D, d M yy",RFC_2822:"D, d M yy",RSS:"D, d M y",TICKS:"!",TIMESTAMP:"@",W3C:"yy-mm-dd",_ticksTo1970:1e7*60*60*24*(718685+Math.floor(492.5)-Math.floor(19.7)+Math.floor(4.925)),formatDate:function(e,t,i){if(!t)return"";var s,a=(i?i.dayNamesShort:null)||this._defaults.dayNamesShort,n=(i?i.dayNames:null)||this._defaults.dayNames,r=(i?i.monthNamesShort:null)||this._defaults.monthNamesShort,o=(i?i.monthNames:null)||this._defaults.monthNames,h=function(t){var i=e.length>s+1&&e.charAt(s+1)===t;return i&&s++,i},l=function(e,t,i){var s=""+t;if(h(e))for(;i>s.length;)s="0"+s;return s},u=function(e,t,i,s){return h(e)?s[t]:i[t]},d="",c=!1;if(t)for(s=0;e.length>s;s++)if(c)"'"!==e.charAt(s)||h("'")?d+=e.charAt(s):c=!1;else switch(e.charAt(s)){case"d":d+=l("d",t.getDate(),2);break;case"D":d+=u("D",t.getDay(),a,n);break;case"o":d+=l("o",Math.round((new Date(t.getFullYear(),t.getMonth(),t.getDate()).getTime()-new Date(t.getFullYear(),0,0).getTime())/864e5),3);break;case"m":d+=l("m",t.getMonth()+1,2);break;case"M":d+=u("M",t.getMonth(),r,o);break;case"y":d+=h("y")?t.getFullYear():(10>t.getYear()%100?"0":"")+t.getYear()%100;break;case"@":d+=t.getTime();break;case"!":d+=1e4*t.getTime()+this._ticksTo1970;break;case"'":h("'")?d+="'":c=!0;break;default:d+=e.charAt(s)}return d},_possibleChars:function(e){var t,i="",s=!1,a=function(i){var s=e.length>t+1&&e.charAt(t+1)===i;return s&&t++,s};for(t=0;e.length>t;t++)if(s)"'"!==e.charAt(t)||a("'")?i+=e.charAt(t):s=!1;else switch(e.charAt(t)){case"d":case"m":case"y":case"@":i+="0123456789";break;case"D":case"M":return null;case"'":a("'")?i+="'":s=!0;break;default:i+=e.charAt(t)}return i},_get:function(e,t){return void 0!==e.settings[t]?e.settings[t]:this._defaults[t]},_setDateFromField:function(e,t){if(e.input.val()!==e.lastVal){var i=this._get(e,"dateFormat"),s=e.lastVal=e.input?e.input.val():null,a=this._getDefaultDate(e),n=a,r=this._getFormatConfig(e);try{n=this.parseDate(i,s,r)||a}catch(o){s=t?"":s}e.selectedDay=n.getDate(),e.drawMonth=e.selectedMonth=n.getMonth(),e.drawYear=e.selectedYear=n.getFullYear(),e.currentDay=s?n.getDate():0,e.currentMonth=s?n.getMonth():0,e.currentYear=s?n.getFullYear():0,this._adjustInstDate(e)}},_getDefaultDate:function(e){return this._restrictMinMax(e,this._determineDate(e,this._get(e,"defaultDate"),new Date))},_determineDate:function(t,i,s){var a=function(e){var t=new Date;return t.setDate(t.getDate()+e),t},n=function(i){try{return e.datepicker.parseDate(e.datepicker._get(t,"dateFormat"),i,e.datepicker._getFormatConfig(t))}catch(s){}for(var a=(i.toLowerCase().match(/^c/)?e.datepicker._getDate(t):null)||new Date,n=a.getFullYear(),r=a.getMonth(),o=a.getDate(),h=/([+\-]?[0-9]+)\s*(d|D|w|W|m|M|y|Y)?/g,l=h.exec(i);l;){switch(l[2]||"d"){case"d":case"D":o+=parseInt(l[1],10);break;case"w":case"W":o+=7*parseInt(l[1],10);break;case"m":case"M":r+=parseInt(l[1],10),o=Math.min(o,e.datepicker._getDaysInMonth(n,r));break;case"y":case"Y":n+=parseInt(l[1],10),o=Math.min(o,e.datepicker._getDaysInMonth(n,r))}l=h.exec(i)}return new Date(n,r,o)},r=null==i||""===i?s:"string"==typeof i?n(i):"number"==typeof i?isNaN(i)?s:a(i):new Date(i.getTime());return r=r&&"Invalid Date"==""+r?s:r,r&&(r.setHours(0),r.setMinutes(0),r.setSeconds(0),r.setMilliseconds(0)),this._daylightSavingAdjust(r)},_daylightSavingAdjust:function(e){return e?(e.setHours(e.getHours()>12?e.getHours()+2:0),e):null},_setDate:function(e,t,i){var s=!t,a=e.selectedMonth,n=e.selectedYear,r=this._restrictMinMax(e,this._determineDate(e,t,new Date));e.selectedDay=e.currentDay=r.getDate(),e.drawMonth=e.selectedMonth=e.currentMonth=r.getMonth(),e.drawYear=e.selectedYear=e.currentYear=r.getFullYear(),a===e.selectedMonth&&n===e.selectedYear||i||this._notifyChange(e),this._adjustInstDate(e),e.input&&e.input.val(s?"":this._formatDate(e))},_getDate:function(e){var t=!e.currentYear||e.input&&""===e.input.val()?null:this._daylightSavingAdjust(new Date(e.currentYear,e.currentMonth,e.currentDay));return t},_attachHandlers:function(t){var i=this._get(t,"stepMonths"),s="#"+t.id.replace(/\\\\/g,"\\");t.dpDiv.find("[data-handler]").map(function(){var t={prev:function(){e.datepicker._adjustDate(s,-i,"M")},next:function(){e.datepicker._adjustDate(s,+i,"M")},hide:function(){e.datepicker._hideDatepicker()},today:function(){e.datepicker._gotoToday(s)},selectDay:function(){return e.datepicker._selectDay(s,+this.getAttribute("data-month"),+this.getAttribute("data-year"),this),!1},selectMonth:function(){return e.datepicker._selectMonthYear(s,this,"M"),!1},selectYear:function(){return e.datepicker._selectMonthYear(s,this,"Y"),!1}};e(this).bind(this.getAttribute("data-event"),t[this.getAttribute("data-handler")])})},_generateHTML:function(e){var t,i,s,a,n,r,o,h,l,u,d,c,p,f,m,g,v,y,b,_,x,k,w,D,T,S,M,N,C,A,I,P,F,H,z,j,E,O,L,W=new Date,R=this._daylightSavingAdjust(new Date(W.getFullYear(),W.getMonth(),W.getDate())),Y=this._get(e,"isRTL"),J=this._get(e,"showButtonPanel"),B=this._get(e,"hideIfNoPrevNext"),K=this._get(e,"navigationAsDateFormat"),V=this._getNumberOfMonths(e),q=this._get(e,"showCurrentAtPos"),U=this._get(e,"stepMonths"),G=1!==V[0]||1!==V[1],Q=this._daylightSavingAdjust(e.currentDay?new Date(e.currentYear,e.currentMonth,e.currentDay):new Date(9999,9,9)),X=this._getMinMaxDate(e,"min"),$=this._getMinMaxDate(e,"max"),Z=e.drawMonth-q,et=e.drawYear;if(0>Z&&(Z+=12,et--),$)for(t=this._daylightSavingAdjust(new Date($.getFullYear(),$.getMonth()-V[0]*V[1]+1,$.getDate())),t=X&&X>t?X:t;this._daylightSavingAdjust(new Date(et,Z,1))>t;)Z--,0>Z&&(Z=11,et--);for(e.drawMonth=Z,e.drawYear=et,i=this._get(e,"prevText"),i=K?this.formatDate(i,this._daylightSavingAdjust(new Date(et,Z-U,1)),this._getFormatConfig(e)):i,s=this._canAdjustMonth(e,-1,et,Z)?"<a class='ui-datepicker-prev ui-corner-all' data-handler='prev' data-event='click' title='"+i+"'><span class='ui-icon ui-icon-circle-triangle-"+(Y?"e":"w")+"'>"+i+"</span></a>":B?"":"<a class='ui-datepicker-prev ui-corner-all ui-state-disabled' title='"+i+"'><span class='ui-icon ui-icon-circle-triangle-"+(Y?"e":"w")+"'>"+i+"</span></a>",a=this._get(e,"nextText"),a=K?this.formatDate(a,this._daylightSavingAdjust(new Date(et,Z+U,1)),this._getFormatConfig(e)):a,n=this._canAdjustMonth(e,1,et,Z)?"<a class='ui-datepicker-next ui-corner-all' data-handler='next' data-event='click' title='"+a+"'><span class='ui-icon ui-icon-circle-triangle-"+(Y?"w":"e")+"'>"+a+"</span></a>":B?"":"<a class='ui-datepicker-next ui-corner-all ui-state-disabled' title='"+a+"'><span class='ui-icon ui-icon-circle-triangle-"+(Y?"w":"e")+"'>"+a+"</span></a>",r=this._get(e,"currentText"),o=this._get(e,"gotoCurrent")&&e.currentDay?Q:R,r=K?this.formatDate(r,o,this._getFormatConfig(e)):r,h=e.inline?"":"<button type='button' class='ui-datepicker-close ui-state-default ui-priority-primary ui-corner-all' data-handler='hide' data-event='click'>"+this._get(e,"closeText")+"</button>",l=J?"<div class='ui-datepicker-buttonpane ui-widget-content'>"+(Y?h:"")+(this._isInRange(e,o)?"<button type='button' class='ui-datepicker-current ui-state-default ui-priority-secondary ui-corner-all' data-handler='today' data-event='click'>"+r+"</button>":"")+(Y?"":h)+"</div>":"",u=parseInt(this._get(e,"firstDay"),10),u=isNaN(u)?0:u,d=this._get(e,"showWeek"),c=this._get(e,"dayNames"),p=this._get(e,"dayNamesMin"),f=this._get(e,"monthNames"),m=this._get(e,"monthNamesShort"),g=this._get(e,"beforeShowDay"),v=this._get(e,"showOtherMonths"),y=this._get(e,"selectOtherMonths"),b=this._getDefaultDate(e),_="",k=0;V[0]>k;k++){for(w="",this.maxRows=4,D=0;V[1]>D;D++){if(T=this._daylightSavingAdjust(new Date(et,Z,e.selectedDay)),S=" ui-corner-all",M="",G){if(M+="<div class='ui-datepicker-group",V[1]>1)switch(D){case 0:M+=" ui-datepicker-group-first",S=" ui-corner-"+(Y?"right":"left");break;case V[1]-1:M+=" ui-datepicker-group-last",S=" ui-corner-"+(Y?"left":"right");break;default:M+=" ui-datepicker-group-middle",S=""}M+="'>"}for(M+="<div class='ui-datepicker-header ui-widget-header ui-helper-clearfix"+S+"'>"+(/all|left/.test(S)&&0===k?Y?n:s:"")+(/all|right/.test(S)&&0===k?Y?s:n:"")+this._generateMonthYearHeader(e,Z,et,X,$,k>0||D>0,f,m)+"</div><table class='ui-datepicker-calendar'><thead>"+"<tr>",N=d?"<th class='ui-datepicker-week-col'>"+this._get(e,"weekHeader")+"</th>":"",x=0;7>x;x++)C=(x+u)%7,N+="<th scope='col'"+((x+u+6)%7>=5?" class='ui-datepicker-week-end'":"")+">"+"<span title='"+c[C]+"'>"+p[C]+"</span></th>";for(M+=N+"</tr></thead><tbody>",A=this._getDaysInMonth(et,Z),et===e.selectedYear&&Z===e.selectedMonth&&(e.selectedDay=Math.min(e.selectedDay,A)),I=(this._getFirstDayOfMonth(et,Z)-u+7)%7,P=Math.ceil((I+A)/7),F=G?this.maxRows>P?this.maxRows:P:P,this.maxRows=F,H=this._daylightSavingAdjust(new Date(et,Z,1-I)),z=0;F>z;z++){for(M+="<tr>",j=d?"<td class='ui-datepicker-week-col'>"+this._get(e,"calculateWeek")(H)+"</td>":"",x=0;7>x;x++)E=g?g.apply(e.input?e.input[0]:null,[H]):[!0,""],O=H.getMonth()!==Z,L=O&&!y||!E[0]||X&&X>H||$&&H>$,j+="<td class='"+((x+u+6)%7>=5?" ui-datepicker-week-end":"")+(O?" ui-datepicker-other-month":"")+(H.getTime()===T.getTime()&&Z===e.selectedMonth&&e._keyEvent||b.getTime()===H.getTime()&&b.getTime()===T.getTime()?" "+this._dayOverClass:"")+(L?" "+this._unselectableClass+" ui-state-disabled":"")+(O&&!v?"":" "+E[1]+(H.getTime()===Q.getTime()?" "+this._currentClass:"")+(H.getTime()===R.getTime()?" ui-datepicker-today":""))+"'"+(O&&!v||!E[2]?"":" title='"+E[2].replace(/'/g,"&#39;")+"'")+(L?"":" data-handler='selectDay' data-event='click' data-month='"+H.getMonth()+"' data-year='"+H.getFullYear()+"'")+">"+(O&&!v?"&#xa0;":L?"<span class='ui-state-default'>"+H.getDate()+"</span>":"<a class='ui-state-default"+(H.getTime()===R.getTime()?" ui-state-highlight":"")+(H.getTime()===Q.getTime()?" ui-state-active":"")+(O?" ui-priority-secondary":"")+"' href='#'>"+H.getDate()+"</a>")+"</td>",H.setDate(H.getDate()+1),H=this._daylightSavingAdjust(H);M+=j+"</tr>"}Z++,Z>11&&(Z=0,et++),M+="</tbody></table>"+(G?"</div>"+(V[0]>0&&D===V[1]-1?"<div class='ui-datepicker-row-break'></div>":""):""),w+=M}_+=w}return _+=l,e._keyEvent=!1,_},_generateMonthYearHeader:function(e,t,i,s,a,n,r,o){var h,l,u,d,c,p,f,m,g=this._get(e,"changeMonth"),v=this._get(e,"changeYear"),y=this._get(e,"showMonthAfterYear"),b="<div class='ui-datepicker-title'>",_="";if(n||!g)_+="<span class='ui-datepicker-month'>"+r[t]+"</span>";else{for(h=s&&s.getFullYear()===i,l=a&&a.getFullYear()===i,_+="<select class='ui-datepicker-month' data-handler='selectMonth' data-event='change'>",u=0;12>u;u++)(!h||u>=s.getMonth())&&(!l||a.getMonth()>=u)&&(_+="<option value='"+u+"'"+(u===t?" selected='selected'":"")+">"+o[u]+"</option>");_+="</select>"}if(y||(b+=_+(!n&&g&&v?"":"&#xa0;")),!e.yearshtml)if(e.yearshtml="",n||!v)b+="<span class='ui-datepicker-year'>"+i+"</span>";else{for(d=this._get(e,"yearRange").split(":"),c=(new Date).getFullYear(),p=function(e){var t=e.match(/c[+\-].*/)?i+parseInt(e.substring(1),10):e.match(/[+\-].*/)?c+parseInt(e,10):parseInt(e,10);return isNaN(t)?c:t},f=p(d[0]),m=Math.max(f,p(d[1]||"")),f=s?Math.max(f,s.getFullYear()):f,m=a?Math.min(m,a.getFullYear()):m,e.yearshtml+="<select class='ui-datepicker-year' data-handler='selectYear' data-event='change'>";m>=f;f++)e.yearshtml+="<option value='"+f+"'"+(f===i?" selected='selected'":"")+">"+f+"</option>";e.yearshtml+="</select>",b+=e.yearshtml,e.yearshtml=null}return b+=this._get(e,"yearSuffix"),y&&(b+=(!n&&g&&v?"":"&#xa0;")+_),b+="</div>"},_adjustInstDate:function(e,t,i){var s=e.drawYear+("Y"===i?t:0),a=e.drawMonth+("M"===i?t:0),n=Math.min(e.selectedDay,this._getDaysInMonth(s,a))+("D"===i?t:0),r=this._restrictMinMax(e,this._daylightSavingAdjust(new Date(s,a,n)));e.selectedDay=r.getDate(),e.drawMonth=e.selectedMonth=r.getMonth(),e.drawYear=e.selectedYear=r.getFullYear(),("M"===i||"Y"===i)&&this._notifyChange(e)},_restrictMinMax:function(e,t){var i=this._getMinMaxDate(e,"min"),s=this._getMinMaxDate(e,"max"),a=i&&i>t?i:t;return s&&a>s?s:a},_notifyChange:function(e){var t=this._get(e,"onChangeMonthYear");t&&t.apply(e.input?e.input[0]:null,[e.selectedYear,e.selectedMonth+1,e])},_getNumberOfMonths:function(e){var t=this._get(e,"numberOfMonths");return null==t?[1,1]:"number"==typeof t?[1,t]:t},_getMinMaxDate:function(e,t){return this._determineDate(e,this._get(e,t+"Date"),null)},_getDaysInMonth:function(e,t){return 32-this._daylightSavingAdjust(new Date(e,t,32)).getDate()},_getFirstDayOfMonth:function(e,t){return new Date(e,t,1).getDay()},_canAdjustMonth:function(e,t,i,s){var a=this._getNumberOfMonths(e),n=this._daylightSavingAdjust(new Date(i,s+(0>t?t:a[0]*a[1]),1));return 0>t&&n.setDate(this._getDaysInMonth(n.getFullYear(),n.getMonth())),this._isInRange(e,n)},_isInRange:function(e,t){var i,s,a=this._getMinMaxDate(e,"min"),n=this._getMinMaxDate(e,"max"),r=null,o=null,h=this._get(e,"yearRange");return h&&(i=h.split(":"),s=(new Date).getFullYear(),r=parseInt(i[0],10),o=parseInt(i[1],10),i[0].match(/[+\-].*/)&&(r+=s),i[1].match(/[+\-].*/)&&(o+=s)),(!a||t.getTime()>=a.getTime())&&(!n||t.getTime()<=n.getTime())&&(!r||t.getFullYear()>=r)&&(!o||o>=t.getFullYear())},_getFormatConfig:function(e){var t=this._get(e,"shortYearCutoff");return t="string"!=typeof t?t:(new Date).getFullYear()%100+parseInt(t,10),{shortYearCutoff:t,dayNamesShort:this._get(e,"dayNamesShort"),dayNames:this._get(e,"dayNames"),monthNamesShort:this._get(e,"monthNamesShort"),monthNames:this._get(e,"monthNames")}},_formatDate:function(e,t,i,s){t||(e.currentDay=e.selectedDay,e.currentMonth=e.selectedMonth,e.currentYear=e.selectedYear);var a=t?"object"==typeof t?t:this._daylightSavingAdjust(new Date(s,i,t)):this._daylightSavingAdjust(new Date(e.currentYear,e.currentMonth,e.currentDay));return this.formatDate(this._get(e,"dateFormat"),a,this._getFormatConfig(e))}}),e.fn.datepicker=function(t){if(!this.length)return this;e.datepicker.initialized||(e(document).mousedown(e.datepicker._checkExternalClick),e.datepicker.initialized=!0),0===e("#"+e.datepicker._mainDivId).length&&e("body").append(e.datepicker.dpDiv);var i=Array.prototype.slice.call(arguments,1);return"string"!=typeof t||"isDisabled"!==t&&"getDate"!==t&&"widget"!==t?"option"===t&&2===arguments.length&&"string"==typeof arguments[1]?e.datepicker["_"+t+"Datepicker"].apply(e.datepicker,[this[0]].concat(i)):this.each(function(){"string"==typeof t?e.datepicker["_"+t+"Datepicker"].apply(e.datepicker,[this].concat(i)):e.datepicker._attachDatepicker(this,t)}):e.datepicker["_"+t+"Datepicker"].apply(e.datepicker,[this[0]].concat(i))},e.datepicker=new a,e.datepicker.initialized=!1,e.datepicker.uuid=(new Date).getTime(),e.datepicker.version="1.11.0",e.datepicker,e.widget("ui.dialog",{version:"1.11.0",options:{appendTo:"body",autoOpen:!0,buttons:[],closeOnEscape:!0,closeText:"Close",dialogClass:"",draggable:!0,hide:null,height:"auto",maxHeight:null,maxWidth:null,minHeight:150,minWidth:150,modal:!1,position:{my:"center",at:"center",of:window,collision:"fit",using:function(t){var i=e(this).css(t).offset().top;0>i&&e(this).css("top",t.top-i)}},resizable:!0,show:null,title:null,width:300,beforeClose:null,close:null,drag:null,dragStart:null,dragStop:null,focus:null,open:null,resize:null,resizeStart:null,resizeStop:null},sizeRelatedOptions:{buttons:!0,height:!0,maxHeight:!0,maxWidth:!0,minHeight:!0,minWidth:!0,width:!0},resizableRelatedOptions:{maxHeight:!0,maxWidth:!0,minHeight:!0,minWidth:!0},_create:function(){this.originalCss={display:this.element[0].style.display,width:this.element[0].style.width,minHeight:this.element[0].style.minHeight,maxHeight:this.element[0].style.maxHeight,height:this.element[0].style.height},this.originalPosition={parent:this.element.parent(),index:this.element.parent().children().index(this.element)},this.originalTitle=this.element.attr("title"),this.options.title=this.options.title||this.originalTitle,this._createWrapper(),this.element.show().removeAttr("title").addClass("ui-dialog-content ui-widget-content").appendTo(this.uiDialog),this._createTitlebar(),this._createButtonPane(),this.options.draggable&&e.fn.draggable&&this._makeDraggable(),this.options.resizable&&e.fn.resizable&&this._makeResizable(),this._isOpen=!1,this._trackFocus()},_init:function(){this.options.autoOpen&&this.open()},_appendTo:function(){var t=this.options.appendTo;return t&&(t.jquery||t.nodeType)?e(t):this.document.find(t||"body").eq(0)},_destroy:function(){var e,t=this.originalPosition;this._destroyOverlay(),this.element.removeUniqueId().removeClass("ui-dialog-content ui-widget-content").css(this.originalCss).detach(),this.uiDialog.stop(!0,!0).remove(),this.originalTitle&&this.element.attr("title",this.originalTitle),e=t.parent.children().eq(t.index),e.length&&e[0]!==this.element[0]?e.before(this.element):t.parent.append(this.element)},widget:function(){return this.uiDialog},disable:e.noop,enable:e.noop,close:function(t){var i,s=this;if(this._isOpen&&this._trigger("beforeClose",t)!==!1){if(this._isOpen=!1,this._focusedElement=null,this._destroyOverlay(),this._untrackInstance(),!this.opener.filter(":focusable").focus().length)try{i=this.document[0].activeElement,i&&"body"!==i.nodeName.toLowerCase()&&e(i).blur()}catch(a){}this._hide(this.uiDialog,this.options.hide,function(){s._trigger("close",t)})}},isOpen:function(){return this._isOpen},moveToTop:function(){this._moveToTop()},_moveToTop:function(t,i){var s=!1,a=this.uiDialog.siblings(".ui-front:visible").map(function(){return+e(this).css("z-index")}).get(),n=Math.max.apply(null,a);return n>=+this.uiDialog.css("z-index")&&(this.uiDialog.css("z-index",n+1),s=!0),s&&!i&&this._trigger("focus",t),s},open:function(){var t=this;return this._isOpen?(this._moveToTop()&&this._focusTabbable(),void 0):(this._isOpen=!0,this.opener=e(this.document[0].activeElement),this._size(),this._position(),this._createOverlay(),this._moveToTop(null,!0),this._show(this.uiDialog,this.options.show,function(){t._focusTabbable(),t._trigger("focus")}),this._trigger("open"),void 0)},_focusTabbable:function(){var e=this._focusedElement;e||(e=this.element.find("[autofocus]")),e.length||(e=this.element.find(":tabbable")),e.length||(e=this.uiDialogButtonPane.find(":tabbable")),e.length||(e=this.uiDialogTitlebarClose.filter(":tabbable")),e.length||(e=this.uiDialog),e.eq(0).focus()
},_keepFocus:function(t){function i(){var t=this.document[0].activeElement,i=this.uiDialog[0]===t||e.contains(this.uiDialog[0],t);i||this._focusTabbable()}t.preventDefault(),i.call(this),this._delay(i)},_createWrapper:function(){this.uiDialog=e("<div>").addClass("ui-dialog ui-widget ui-widget-content ui-corner-all ui-front "+this.options.dialogClass).hide().attr({tabIndex:-1,role:"dialog"}).appendTo(this._appendTo()),this._on(this.uiDialog,{keydown:function(t){if(this.options.closeOnEscape&&!t.isDefaultPrevented()&&t.keyCode&&t.keyCode===e.ui.keyCode.ESCAPE)return t.preventDefault(),this.close(t),void 0;if(t.keyCode===e.ui.keyCode.TAB&&!t.isDefaultPrevented()){var i=this.uiDialog.find(":tabbable"),s=i.filter(":first"),a=i.filter(":last");t.target!==a[0]&&t.target!==this.uiDialog[0]||t.shiftKey?t.target!==s[0]&&t.target!==this.uiDialog[0]||!t.shiftKey||(this._delay(function(){a.focus()}),t.preventDefault()):(this._delay(function(){s.focus()}),t.preventDefault())}},mousedown:function(e){this._moveToTop(e)&&this._focusTabbable()}}),this.element.find("[aria-describedby]").length||this.uiDialog.attr({"aria-describedby":this.element.uniqueId().attr("id")})},_createTitlebar:function(){var t;this.uiDialogTitlebar=e("<div>").addClass("ui-dialog-titlebar ui-widget-header ui-corner-all ui-helper-clearfix").prependTo(this.uiDialog),this._on(this.uiDialogTitlebar,{mousedown:function(t){e(t.target).closest(".ui-dialog-titlebar-close")||this.uiDialog.focus()}}),this.uiDialogTitlebarClose=e("<button type='button'></button>").button({label:this.options.closeText,icons:{primary:"ui-icon-closethick"},text:!1}).addClass("ui-dialog-titlebar-close").appendTo(this.uiDialogTitlebar),this._on(this.uiDialogTitlebarClose,{click:function(e){e.preventDefault(),this.close(e)}}),t=e("<span>").uniqueId().addClass("ui-dialog-title").prependTo(this.uiDialogTitlebar),this._title(t),this.uiDialog.attr({"aria-labelledby":t.attr("id")})},_title:function(e){this.options.title||e.html("&#160;"),e.text(this.options.title)},_createButtonPane:function(){this.uiDialogButtonPane=e("<div>").addClass("ui-dialog-buttonpane ui-widget-content ui-helper-clearfix"),this.uiButtonSet=e("<div>").addClass("ui-dialog-buttonset").appendTo(this.uiDialogButtonPane),this._createButtons()},_createButtons:function(){var t=this,i=this.options.buttons;return this.uiDialogButtonPane.remove(),this.uiButtonSet.empty(),e.isEmptyObject(i)||e.isArray(i)&&!i.length?(this.uiDialog.removeClass("ui-dialog-buttons"),void 0):(e.each(i,function(i,s){var a,n;s=e.isFunction(s)?{click:s,text:i}:s,s=e.extend({type:"button"},s),a=s.click,s.click=function(){a.apply(t.element[0],arguments)},n={icons:s.icons,text:s.showText},delete s.icons,delete s.showText,e("<button></button>",s).button(n).appendTo(t.uiButtonSet)}),this.uiDialog.addClass("ui-dialog-buttons"),this.uiDialogButtonPane.appendTo(this.uiDialog),void 0)},_makeDraggable:function(){function t(e){return{position:e.position,offset:e.offset}}var i=this,s=this.options;this.uiDialog.draggable({cancel:".ui-dialog-content, .ui-dialog-titlebar-close",handle:".ui-dialog-titlebar",containment:"document",start:function(s,a){e(this).addClass("ui-dialog-dragging"),i._blockFrames(),i._trigger("dragStart",s,t(a))},drag:function(e,s){i._trigger("drag",e,t(s))},stop:function(a,n){var r=n.offset.left-i.document.scrollLeft(),o=n.offset.top-i.document.scrollTop();s.position={my:"left top",at:"left"+(r>=0?"+":"")+r+" "+"top"+(o>=0?"+":"")+o,of:i.window},e(this).removeClass("ui-dialog-dragging"),i._unblockFrames(),i._trigger("dragStop",a,t(n))}})},_makeResizable:function(){function t(e){return{originalPosition:e.originalPosition,originalSize:e.originalSize,position:e.position,size:e.size}}var i=this,s=this.options,a=s.resizable,n=this.uiDialog.css("position"),r="string"==typeof a?a:"n,e,s,w,se,sw,ne,nw";this.uiDialog.resizable({cancel:".ui-dialog-content",containment:"document",alsoResize:this.element,maxWidth:s.maxWidth,maxHeight:s.maxHeight,minWidth:s.minWidth,minHeight:this._minHeight(),handles:r,start:function(s,a){e(this).addClass("ui-dialog-resizing"),i._blockFrames(),i._trigger("resizeStart",s,t(a))},resize:function(e,s){i._trigger("resize",e,t(s))},stop:function(a,n){var r=i.uiDialog.offset(),o=r.left-i.document.scrollLeft(),h=r.top-i.document.scrollTop();s.height=i.uiDialog.height(),s.width=i.uiDialog.width(),s.position={my:"left top",at:"left"+(o>=0?"+":"")+o+" "+"top"+(h>=0?"+":"")+h,of:i.window},e(this).removeClass("ui-dialog-resizing"),i._unblockFrames(),i._trigger("resizeStop",a,t(n))}}).css("position",n)},_trackFocus:function(){this._on(this.widget(),{focusin:function(t){this._untrackInstance(),this._trackingInstances().unshift(this),this._focusedElement=e(t.target)}})},_untrackInstance:function(){var t=this._trackingInstances(),i=e.inArray(this,t);-1!==i&&t.splice(i,1)},_trackingInstances:function(){var e=this.document.data("ui-dialog-instances");return e||(e=[],this.document.data("ui-dialog-instances",e)),e},_minHeight:function(){var e=this.options;return"auto"===e.height?e.minHeight:Math.min(e.minHeight,e.height)},_position:function(){var e=this.uiDialog.is(":visible");e||this.uiDialog.show(),this.uiDialog.position(this.options.position),e||this.uiDialog.hide()},_setOptions:function(t){var i=this,s=!1,a={};e.each(t,function(e,t){i._setOption(e,t),e in i.sizeRelatedOptions&&(s=!0),e in i.resizableRelatedOptions&&(a[e]=t)}),s&&(this._size(),this._position()),this.uiDialog.is(":data(ui-resizable)")&&this.uiDialog.resizable("option",a)},_setOption:function(e,t){var i,s,a=this.uiDialog;"dialogClass"===e&&a.removeClass(this.options.dialogClass).addClass(t),"disabled"!==e&&(this._super(e,t),"appendTo"===e&&this.uiDialog.appendTo(this._appendTo()),"buttons"===e&&this._createButtons(),"closeText"===e&&this.uiDialogTitlebarClose.button({label:""+t}),"draggable"===e&&(i=a.is(":data(ui-draggable)"),i&&!t&&a.draggable("destroy"),!i&&t&&this._makeDraggable()),"position"===e&&this._position(),"resizable"===e&&(s=a.is(":data(ui-resizable)"),s&&!t&&a.resizable("destroy"),s&&"string"==typeof t&&a.resizable("option","handles",t),s||t===!1||this._makeResizable()),"title"===e&&this._title(this.uiDialogTitlebar.find(".ui-dialog-title")))},_size:function(){var e,t,i,s=this.options;this.element.show().css({width:"auto",minHeight:0,maxHeight:"none",height:0}),s.minWidth>s.width&&(s.width=s.minWidth),e=this.uiDialog.css({height:"auto",width:s.width}).outerHeight(),t=Math.max(0,s.minHeight-e),i="number"==typeof s.maxHeight?Math.max(0,s.maxHeight-e):"none","auto"===s.height?this.element.css({minHeight:t,maxHeight:i,height:"auto"}):this.element.height(Math.max(0,s.height-e)),this.uiDialog.is(":data(ui-resizable)")&&this.uiDialog.resizable("option","minHeight",this._minHeight())},_blockFrames:function(){this.iframeBlocks=this.document.find("iframe").map(function(){var t=e(this);return e("<div>").css({position:"absolute",width:t.outerWidth(),height:t.outerHeight()}).appendTo(t.parent()).offset(t.offset())[0]})},_unblockFrames:function(){this.iframeBlocks&&(this.iframeBlocks.remove(),delete this.iframeBlocks)},_allowInteraction:function(t){return e(t.target).closest(".ui-dialog").length?!0:!!e(t.target).closest(".ui-datepicker").length},_createOverlay:function(){if(this.options.modal){var t=!0;this._delay(function(){t=!1}),this.document.data("ui-dialog-overlays")||this._on(this.document,{focusin:function(e){t||this._allowInteraction(e)||(e.preventDefault(),this._trackingInstances()[0]._focusTabbable())}}),this.overlay=e("<div>").addClass("ui-widget-overlay ui-front").appendTo(this._appendTo()),this._on(this.overlay,{mousedown:"_keepFocus"}),this.document.data("ui-dialog-overlays",(this.document.data("ui-dialog-overlays")||0)+1)}},_destroyOverlay:function(){if(this.options.modal&&this.overlay){var e=this.document.data("ui-dialog-overlays")-1;e?this.document.data("ui-dialog-overlays",e):this.document.unbind("focusin").removeData("ui-dialog-overlays"),this.overlay.remove(),this.overlay=null}}}),e.widget("ui.progressbar",{version:"1.11.0",options:{max:100,value:0,change:null,complete:null},min:0,_create:function(){this.oldValue=this.options.value=this._constrainedValue(),this.element.addClass("ui-progressbar ui-widget ui-widget-content ui-corner-all").attr({role:"progressbar","aria-valuemin":this.min}),this.valueDiv=e("<div class='ui-progressbar-value ui-widget-header ui-corner-left'></div>").appendTo(this.element),this._refreshValue()},_destroy:function(){this.element.removeClass("ui-progressbar ui-widget ui-widget-content ui-corner-all").removeAttr("role").removeAttr("aria-valuemin").removeAttr("aria-valuemax").removeAttr("aria-valuenow"),this.valueDiv.remove()},value:function(e){return void 0===e?this.options.value:(this.options.value=this._constrainedValue(e),this._refreshValue(),void 0)},_constrainedValue:function(e){return void 0===e&&(e=this.options.value),this.indeterminate=e===!1,"number"!=typeof e&&(e=0),this.indeterminate?!1:Math.min(this.options.max,Math.max(this.min,e))},_setOptions:function(e){var t=e.value;delete e.value,this._super(e),this.options.value=this._constrainedValue(t),this._refreshValue()},_setOption:function(e,t){"max"===e&&(t=Math.max(this.min,t)),"disabled"===e&&this.element.toggleClass("ui-state-disabled",!!t).attr("aria-disabled",t),this._super(e,t)},_percentage:function(){return this.indeterminate?100:100*(this.options.value-this.min)/(this.options.max-this.min)},_refreshValue:function(){var t=this.options.value,i=this._percentage();this.valueDiv.toggle(this.indeterminate||t>this.min).toggleClass("ui-corner-right",t===this.options.max).width(i.toFixed(0)+"%"),this.element.toggleClass("ui-progressbar-indeterminate",this.indeterminate),this.indeterminate?(this.element.removeAttr("aria-valuenow"),this.overlayDiv||(this.overlayDiv=e("<div class='ui-progressbar-overlay'></div>").appendTo(this.valueDiv))):(this.element.attr({"aria-valuemax":this.options.max,"aria-valuenow":t}),this.overlayDiv&&(this.overlayDiv.remove(),this.overlayDiv=null)),this.oldValue!==t&&(this.oldValue=t,this._trigger("change")),t===this.options.max&&this._trigger("complete")}}),e.widget("ui.selectmenu",{version:"1.11.0",defaultElement:"<select>",options:{appendTo:null,disabled:null,icons:{button:"ui-icon-triangle-1-s"},position:{my:"left top",at:"left bottom",collision:"none"},width:null,change:null,close:null,focus:null,open:null,select:null},_create:function(){var e=this.element.uniqueId().attr("id");this.ids={element:e,button:e+"-button",menu:e+"-menu"},this._drawButton(),this._drawMenu(),this.options.disabled&&this.disable()},_drawButton:function(){var t=this,i=this.element.attr("tabindex");this.label=e("label[for='"+this.ids.element+"']").attr("for",this.ids.button),this._on(this.label,{click:function(e){this.button.focus(),e.preventDefault()}}),this.element.hide(),this.button=e("<span>",{"class":"ui-selectmenu-button ui-widget ui-state-default ui-corner-all",tabindex:i||this.options.disabled?-1:0,id:this.ids.button,role:"combobox","aria-expanded":"false","aria-autocomplete":"list","aria-owns":this.ids.menu,"aria-haspopup":"true"}).insertAfter(this.element),e("<span>",{"class":"ui-icon "+this.options.icons.button}).prependTo(this.button),this.buttonText=e("<span>",{"class":"ui-selectmenu-text"}).appendTo(this.button),this._setText(this.buttonText,this.element.find("option:selected").text()),this._setOption("width",this.options.width),this._on(this.button,this._buttonEvents),this.button.one("focusin",function(){t.menuItems||t._refreshMenu()}),this._hoverable(this.button),this._focusable(this.button)},_drawMenu:function(){var t=this;this.menu=e("<ul>",{"aria-hidden":"true","aria-labelledby":this.ids.button,id:this.ids.menu}),this.menuWrap=e("<div>",{"class":"ui-selectmenu-menu ui-front"}).append(this.menu).appendTo(this._appendTo()),this.menuInstance=this.menu.menu({role:"listbox",select:function(e,i){e.preventDefault(),t._select(i.item.data("ui-selectmenu-item"),e)},focus:function(e,i){var s=i.item.data("ui-selectmenu-item");null!=t.focusIndex&&s.index!==t.focusIndex&&(t._trigger("focus",e,{item:s}),t.isOpen||t._select(s,e)),t.focusIndex=s.index,t.button.attr("aria-activedescendant",t.menuItems.eq(s.index).attr("id"))}}).menu("instance"),this.menu.addClass("ui-corner-bottom").removeClass("ui-corner-all"),this.menuInstance._off(this.menu,"mouseleave"),this.menuInstance._closeOnDocumentClick=function(){return!1},this.menuInstance._isDivider=function(){return!1}},refresh:function(){this._refreshMenu(),this._setText(this.buttonText,this._getSelectedItem().text()),this._setOption("width",this.options.width)},_refreshMenu:function(){this.menu.empty();var e,t=this.element.find("option");t.length&&(this._parseOptions(t),this._renderMenu(this.menu,this.items),this.menuInstance.refresh(),this.menuItems=this.menu.find("li").not(".ui-selectmenu-optgroup"),e=this._getSelectedItem(),this.menuInstance.focus(null,e),this._setAria(e.data("ui-selectmenu-item")),this._setOption("disabled",this.element.prop("disabled")))},open:function(e){this.options.disabled||(this.menuItems?(this.menu.find(".ui-state-focus").removeClass("ui-state-focus"),this.menuInstance.focus(null,this._getSelectedItem())):this._refreshMenu(),this.isOpen=!0,this._toggleAttr(),this._resizeMenu(),this._position(),this._on(this.document,this._documentClick),this._trigger("open",e))},_position:function(){this.menuWrap.position(e.extend({of:this.button},this.options.position))},close:function(e){this.isOpen&&(this.isOpen=!1,this._toggleAttr(),this._off(this.document),this._trigger("close",e))},widget:function(){return this.button},menuWidget:function(){return this.menu},_renderMenu:function(t,i){var s=this,a="";e.each(i,function(i,n){n.optgroup!==a&&(e("<li>",{"class":"ui-selectmenu-optgroup ui-menu-divider"+(n.element.parent("optgroup").prop("disabled")?" ui-state-disabled":""),text:n.optgroup}).appendTo(t),a=n.optgroup),s._renderItemData(t,n)})},_renderItemData:function(e,t){return this._renderItem(e,t).data("ui-selectmenu-item",t)},_renderItem:function(t,i){var s=e("<li>");return i.disabled&&s.addClass("ui-state-disabled"),this._setText(s,i.label),s.appendTo(t)},_setText:function(e,t){t?e.text(t):e.html("&#160;")},_move:function(e,t){var i,s,a=".ui-menu-item";this.isOpen?i=this.menuItems.eq(this.focusIndex):(i=this.menuItems.eq(this.element[0].selectedIndex),a+=":not(.ui-state-disabled)"),s="first"===e||"last"===e?i["first"===e?"prevAll":"nextAll"](a).eq(-1):i[e+"All"](a).eq(0),s.length&&this.menuInstance.focus(t,s)},_getSelectedItem:function(){return this.menuItems.eq(this.element[0].selectedIndex)},_toggle:function(e){this[this.isOpen?"close":"open"](e)},_documentClick:{mousedown:function(t){this.isOpen&&(e(t.target).closest(".ui-selectmenu-menu, #"+this.ids.button).length||this.close(t))}},_buttonEvents:{click:"_toggle",keydown:function(t){var i=!0;switch(t.keyCode){case e.ui.keyCode.TAB:case e.ui.keyCode.ESCAPE:this.close(t),i=!1;break;case e.ui.keyCode.ENTER:this.isOpen&&this._selectFocusedItem(t);break;case e.ui.keyCode.UP:t.altKey?this._toggle(t):this._move("prev",t);break;case e.ui.keyCode.DOWN:t.altKey?this._toggle(t):this._move("next",t);break;case e.ui.keyCode.SPACE:this.isOpen?this._selectFocusedItem(t):this._toggle(t);break;case e.ui.keyCode.LEFT:this._move("prev",t);break;case e.ui.keyCode.RIGHT:this._move("next",t);break;case e.ui.keyCode.HOME:case e.ui.keyCode.PAGE_UP:this._move("first",t);break;case e.ui.keyCode.END:case e.ui.keyCode.PAGE_DOWN:this._move("last",t);break;default:this.menu.trigger(t),i=!1}i&&t.preventDefault()}},_selectFocusedItem:function(e){var t=this.menuItems.eq(this.focusIndex);t.hasClass("ui-state-disabled")||this._select(t.data("ui-selectmenu-item"),e)},_select:function(e,t){var i=this.element[0].selectedIndex;this.element[0].selectedIndex=e.index,this._setText(this.buttonText,e.label),this._setAria(e),this._trigger("select",t,{item:e}),e.index!==i&&this._trigger("change",t,{item:e}),this.close(t)},_setAria:function(e){var t=this.menuItems.eq(e.index).attr("id");this.button.attr({"aria-labelledby":t,"aria-activedescendant":t}),this.menu.attr("aria-activedescendant",t)},_setOption:function(e,t){"icons"===e&&this.button.find("span.ui-icon").removeClass(this.options.icons.button).addClass(t.button),this._super(e,t),"appendTo"===e&&this.menuWrap.appendTo(this._appendTo()),"disabled"===e&&(this.menuInstance.option("disabled",t),this.button.toggleClass("ui-state-disabled",t).attr("aria-disabled",t),this.element.prop("disabled",t),t?(this.button.attr("tabindex",-1),this.close()):this.button.attr("tabindex",0)),"width"===e&&(t||(t=this.element.outerWidth()),this.button.outerWidth(t))},_appendTo:function(){var t=this.options.appendTo;return t&&(t=t.jquery||t.nodeType?e(t):this.document.find(t).eq(0)),t&&t[0]||(t=this.element.closest(".ui-front")),t.length||(t=this.document[0].body),t},_toggleAttr:function(){this.button.toggleClass("ui-corner-top",this.isOpen).toggleClass("ui-corner-all",!this.isOpen).attr("aria-expanded",this.isOpen),this.menuWrap.toggleClass("ui-selectmenu-open",this.isOpen),this.menu.attr("aria-hidden",!this.isOpen)},_resizeMenu:function(){this.menu.outerWidth(Math.max(this.button.outerWidth(),this.menu.width("").outerWidth()+1))},_getCreateOptions:function(){return{disabled:this.element.prop("disabled")}},_parseOptions:function(t){var i=[];t.each(function(t,s){var a=e(s),n=a.parent("optgroup");i.push({element:a,index:t,value:a.attr("value"),label:a.text(),optgroup:n.attr("label")||"",disabled:n.prop("disabled")||a.prop("disabled")})}),this.items=i},_destroy:function(){this.menuWrap.remove(),this.button.remove(),this.element.show(),this.element.removeUniqueId(),this.label.attr("for",this.ids.element)}}),e.widget("ui.slider",e.ui.mouse,{version:"1.11.0",widgetEventPrefix:"slide",options:{animate:!1,distance:0,max:100,min:0,orientation:"horizontal",range:!1,step:1,value:0,values:null,change:null,slide:null,start:null,stop:null},numPages:5,_create:function(){this._keySliding=!1,this._mouseSliding=!1,this._animateOff=!0,this._handleIndex=null,this._detectOrientation(),this._mouseInit(),this.element.addClass("ui-slider ui-slider-"+this.orientation+" ui-widget"+" ui-widget-content"+" ui-corner-all"),this._refresh(),this._setOption("disabled",this.options.disabled),this._animateOff=!1},_refresh:function(){this._createRange(),this._createHandles(),this._setupEvents(),this._refreshValue()},_createHandles:function(){var t,i,s=this.options,a=this.element.find(".ui-slider-handle").addClass("ui-state-default ui-corner-all"),n="<span class='ui-slider-handle ui-state-default ui-corner-all' tabindex='0'></span>",r=[];for(i=s.values&&s.values.length||1,a.length>i&&(a.slice(i).remove(),a=a.slice(0,i)),t=a.length;i>t;t++)r.push(n);this.handles=a.add(e(r.join("")).appendTo(this.element)),this.handle=this.handles.eq(0),this.handles.each(function(t){e(this).data("ui-slider-handle-index",t)})},_createRange:function(){var t=this.options,i="";t.range?(t.range===!0&&(t.values?t.values.length&&2!==t.values.length?t.values=[t.values[0],t.values[0]]:e.isArray(t.values)&&(t.values=t.values.slice(0)):t.values=[this._valueMin(),this._valueMin()]),this.range&&this.range.length?this.range.removeClass("ui-slider-range-min ui-slider-range-max").css({left:"",bottom:""}):(this.range=e("<div></div>").appendTo(this.element),i="ui-slider-range ui-widget-header ui-corner-all"),this.range.addClass(i+("min"===t.range||"max"===t.range?" ui-slider-range-"+t.range:""))):(this.range&&this.range.remove(),this.range=null)},_setupEvents:function(){this._off(this.handles),this._on(this.handles,this._handleEvents),this._hoverable(this.handles),this._focusable(this.handles)},_destroy:function(){this.handles.remove(),this.range&&this.range.remove(),this.element.removeClass("ui-slider ui-slider-horizontal ui-slider-vertical ui-widget ui-widget-content ui-corner-all"),this._mouseDestroy()},_mouseCapture:function(t){var i,s,a,n,r,o,h,l,u=this,d=this.options;return d.disabled?!1:(this.elementSize={width:this.element.outerWidth(),height:this.element.outerHeight()},this.elementOffset=this.element.offset(),i={x:t.pageX,y:t.pageY},s=this._normValueFromMouse(i),a=this._valueMax()-this._valueMin()+1,this.handles.each(function(t){var i=Math.abs(s-u.values(t));(a>i||a===i&&(t===u._lastChangedValue||u.values(t)===d.min))&&(a=i,n=e(this),r=t)}),o=this._start(t,r),o===!1?!1:(this._mouseSliding=!0,this._handleIndex=r,n.addClass("ui-state-active").focus(),h=n.offset(),l=!e(t.target).parents().addBack().is(".ui-slider-handle"),this._clickOffset=l?{left:0,top:0}:{left:t.pageX-h.left-n.width()/2,top:t.pageY-h.top-n.height()/2-(parseInt(n.css("borderTopWidth"),10)||0)-(parseInt(n.css("borderBottomWidth"),10)||0)+(parseInt(n.css("marginTop"),10)||0)},this.handles.hasClass("ui-state-hover")||this._slide(t,r,s),this._animateOff=!0,!0))},_mouseStart:function(){return!0},_mouseDrag:function(e){var t={x:e.pageX,y:e.pageY},i=this._normValueFromMouse(t);return this._slide(e,this._handleIndex,i),!1},_mouseStop:function(e){return this.handles.removeClass("ui-state-active"),this._mouseSliding=!1,this._stop(e,this._handleIndex),this._change(e,this._handleIndex),this._handleIndex=null,this._clickOffset=null,this._animateOff=!1,!1},_detectOrientation:function(){this.orientation="vertical"===this.options.orientation?"vertical":"horizontal"},_normValueFromMouse:function(e){var t,i,s,a,n;return"horizontal"===this.orientation?(t=this.elementSize.width,i=e.x-this.elementOffset.left-(this._clickOffset?this._clickOffset.left:0)):(t=this.elementSize.height,i=e.y-this.elementOffset.top-(this._clickOffset?this._clickOffset.top:0)),s=i/t,s>1&&(s=1),0>s&&(s=0),"vertical"===this.orientation&&(s=1-s),a=this._valueMax()-this._valueMin(),n=this._valueMin()+s*a,this._trimAlignValue(n)},_start:function(e,t){var i={handle:this.handles[t],value:this.value()};return this.options.values&&this.options.values.length&&(i.value=this.values(t),i.values=this.values()),this._trigger("start",e,i)},_slide:function(e,t,i){var s,a,n;this.options.values&&this.options.values.length?(s=this.values(t?0:1),2===this.options.values.length&&this.options.range===!0&&(0===t&&i>s||1===t&&s>i)&&(i=s),i!==this.values(t)&&(a=this.values(),a[t]=i,n=this._trigger("slide",e,{handle:this.handles[t],value:i,values:a}),s=this.values(t?0:1),n!==!1&&this.values(t,i))):i!==this.value()&&(n=this._trigger("slide",e,{handle:this.handles[t],value:i}),n!==!1&&this.value(i))},_stop:function(e,t){var i={handle:this.handles[t],value:this.value()};this.options.values&&this.options.values.length&&(i.value=this.values(t),i.values=this.values()),this._trigger("stop",e,i)},_change:function(e,t){if(!this._keySliding&&!this._mouseSliding){var i={handle:this.handles[t],value:this.value()};this.options.values&&this.options.values.length&&(i.value=this.values(t),i.values=this.values()),this._lastChangedValue=t,this._trigger("change",e,i)}},value:function(e){return arguments.length?(this.options.value=this._trimAlignValue(e),this._refreshValue(),this._change(null,0),void 0):this._value()},values:function(t,i){var s,a,n;if(arguments.length>1)return this.options.values[t]=this._trimAlignValue(i),this._refreshValue(),this._change(null,t),void 0;if(!arguments.length)return this._values();if(!e.isArray(arguments[0]))return this.options.values&&this.options.values.length?this._values(t):this.value();for(s=this.options.values,a=arguments[0],n=0;s.length>n;n+=1)s[n]=this._trimAlignValue(a[n]),this._change(null,n);this._refreshValue()},_setOption:function(t,i){var s,a=0;switch("range"===t&&this.options.range===!0&&("min"===i?(this.options.value=this._values(0),this.options.values=null):"max"===i&&(this.options.value=this._values(this.options.values.length-1),this.options.values=null)),e.isArray(this.options.values)&&(a=this.options.values.length),"disabled"===t&&this.element.toggleClass("ui-state-disabled",!!i),this._super(t,i),t){case"orientation":this._detectOrientation(),this.element.removeClass("ui-slider-horizontal ui-slider-vertical").addClass("ui-slider-"+this.orientation),this._refreshValue();break;case"value":this._animateOff=!0,this._refreshValue(),this._change(null,0),this._animateOff=!1;break;case"values":for(this._animateOff=!0,this._refreshValue(),s=0;a>s;s+=1)this._change(null,s);this._animateOff=!1;break;case"min":case"max":this._animateOff=!0,this._refreshValue(),this._animateOff=!1;break;case"range":this._animateOff=!0,this._refresh(),this._animateOff=!1}},_value:function(){var e=this.options.value;return e=this._trimAlignValue(e)},_values:function(e){var t,i,s;if(arguments.length)return t=this.options.values[e],t=this._trimAlignValue(t);if(this.options.values&&this.options.values.length){for(i=this.options.values.slice(),s=0;i.length>s;s+=1)i[s]=this._trimAlignValue(i[s]);return i}return[]},_trimAlignValue:function(e){if(this._valueMin()>=e)return this._valueMin();if(e>=this._valueMax())return this._valueMax();var t=this.options.step>0?this.options.step:1,i=(e-this._valueMin())%t,s=e-i;return 2*Math.abs(i)>=t&&(s+=i>0?t:-t),parseFloat(s.toFixed(5))},_valueMin:function(){return this.options.min},_valueMax:function(){return this.options.max},_refreshValue:function(){var t,i,s,a,n,r=this.options.range,o=this.options,h=this,l=this._animateOff?!1:o.animate,u={};this.options.values&&this.options.values.length?this.handles.each(function(s){i=100*((h.values(s)-h._valueMin())/(h._valueMax()-h._valueMin())),u["horizontal"===h.orientation?"left":"bottom"]=i+"%",e(this).stop(1,1)[l?"animate":"css"](u,o.animate),h.options.range===!0&&("horizontal"===h.orientation?(0===s&&h.range.stop(1,1)[l?"animate":"css"]({left:i+"%"},o.animate),1===s&&h.range[l?"animate":"css"]({width:i-t+"%"},{queue:!1,duration:o.animate})):(0===s&&h.range.stop(1,1)[l?"animate":"css"]({bottom:i+"%"},o.animate),1===s&&h.range[l?"animate":"css"]({height:i-t+"%"},{queue:!1,duration:o.animate}))),t=i}):(s=this.value(),a=this._valueMin(),n=this._valueMax(),i=n!==a?100*((s-a)/(n-a)):0,u["horizontal"===this.orientation?"left":"bottom"]=i+"%",this.handle.stop(1,1)[l?"animate":"css"](u,o.animate),"min"===r&&"horizontal"===this.orientation&&this.range.stop(1,1)[l?"animate":"css"]({width:i+"%"},o.animate),"max"===r&&"horizontal"===this.orientation&&this.range[l?"animate":"css"]({width:100-i+"%"},{queue:!1,duration:o.animate}),"min"===r&&"vertical"===this.orientation&&this.range.stop(1,1)[l?"animate":"css"]({height:i+"%"},o.animate),"max"===r&&"vertical"===this.orientation&&this.range[l?"animate":"css"]({height:100-i+"%"},{queue:!1,duration:o.animate}))},_handleEvents:{keydown:function(t){var i,s,a,n,r=e(t.target).data("ui-slider-handle-index");switch(t.keyCode){case e.ui.keyCode.HOME:case e.ui.keyCode.END:case e.ui.keyCode.PAGE_UP:case e.ui.keyCode.PAGE_DOWN:case e.ui.keyCode.UP:case e.ui.keyCode.RIGHT:case e.ui.keyCode.DOWN:case e.ui.keyCode.LEFT:if(t.preventDefault(),!this._keySliding&&(this._keySliding=!0,e(t.target).addClass("ui-state-active"),i=this._start(t,r),i===!1))return}switch(n=this.options.step,s=a=this.options.values&&this.options.values.length?this.values(r):this.value(),t.keyCode){case e.ui.keyCode.HOME:a=this._valueMin();break;case e.ui.keyCode.END:a=this._valueMax();break;case e.ui.keyCode.PAGE_UP:a=this._trimAlignValue(s+(this._valueMax()-this._valueMin())/this.numPages);break;case e.ui.keyCode.PAGE_DOWN:a=this._trimAlignValue(s-(this._valueMax()-this._valueMin())/this.numPages);break;case e.ui.keyCode.UP:case e.ui.keyCode.RIGHT:if(s===this._valueMax())return;a=this._trimAlignValue(s+n);break;case e.ui.keyCode.DOWN:case e.ui.keyCode.LEFT:if(s===this._valueMin())return;a=this._trimAlignValue(s-n)}this._slide(t,r,a)},keyup:function(t){var i=e(t.target).data("ui-slider-handle-index");this._keySliding&&(this._keySliding=!1,this._stop(t,i),this._change(t,i),e(t.target).removeClass("ui-state-active"))}}}),e.widget("ui.spinner",{version:"1.11.0",defaultElement:"<input>",widgetEventPrefix:"spin",options:{culture:null,icons:{down:"ui-icon-triangle-1-s",up:"ui-icon-triangle-1-n"},incremental:!0,max:null,min:null,numberFormat:null,page:10,step:1,change:null,spin:null,start:null,stop:null},_create:function(){this._setOption("max",this.options.max),this._setOption("min",this.options.min),this._setOption("step",this.options.step),""!==this.value()&&this._value(this.element.val(),!0),this._draw(),this._on(this._events),this._refresh(),this._on(this.window,{beforeunload:function(){this.element.removeAttr("autocomplete")}})},_getCreateOptions:function(){var t={},i=this.element;return e.each(["min","max","step"],function(e,s){var a=i.attr(s);void 0!==a&&a.length&&(t[s]=a)}),t},_events:{keydown:function(e){this._start(e)&&this._keydown(e)&&e.preventDefault()},keyup:"_stop",focus:function(){this.previous=this.element.val()},blur:function(e){return this.cancelBlur?(delete this.cancelBlur,void 0):(this._stop(),this._refresh(),this.previous!==this.element.val()&&this._trigger("change",e),void 0)},mousewheel:function(e,t){if(t){if(!this.spinning&&!this._start(e))return!1;this._spin((t>0?1:-1)*this.options.step,e),clearTimeout(this.mousewheelTimer),this.mousewheelTimer=this._delay(function(){this.spinning&&this._stop(e)},100),e.preventDefault()}},"mousedown .ui-spinner-button":function(t){function i(){var e=this.element[0]===this.document[0].activeElement;e||(this.element.focus(),this.previous=s,this._delay(function(){this.previous=s}))}var s;s=this.element[0]===this.document[0].activeElement?this.previous:this.element.val(),t.preventDefault(),i.call(this),this.cancelBlur=!0,this._delay(function(){delete this.cancelBlur,i.call(this)}),this._start(t)!==!1&&this._repeat(null,e(t.currentTarget).hasClass("ui-spinner-up")?1:-1,t)},"mouseup .ui-spinner-button":"_stop","mouseenter .ui-spinner-button":function(t){return e(t.currentTarget).hasClass("ui-state-active")?this._start(t)===!1?!1:(this._repeat(null,e(t.currentTarget).hasClass("ui-spinner-up")?1:-1,t),void 0):void 0},"mouseleave .ui-spinner-button":"_stop"},_draw:function(){var e=this.uiSpinner=this.element.addClass("ui-spinner-input").attr("autocomplete","off").wrap(this._uiSpinnerHtml()).parent().append(this._buttonHtml());this.element.attr("role","spinbutton"),this.buttons=e.find(".ui-spinner-button").attr("tabIndex",-1).button().removeClass("ui-corner-all"),this.buttons.height()>Math.ceil(.5*e.height())&&e.height()>0&&e.height(e.height()),this.options.disabled&&this.disable()},_keydown:function(t){var i=this.options,s=e.ui.keyCode;switch(t.keyCode){case s.UP:return this._repeat(null,1,t),!0;case s.DOWN:return this._repeat(null,-1,t),!0;case s.PAGE_UP:return this._repeat(null,i.page,t),!0;case s.PAGE_DOWN:return this._repeat(null,-i.page,t),!0}return!1},_uiSpinnerHtml:function(){return"<span class='ui-spinner ui-widget ui-widget-content ui-corner-all'></span>"},_buttonHtml:function(){return"<a class='ui-spinner-button ui-spinner-up ui-corner-tr'><span class='ui-icon "+this.options.icons.up+"'>&#9650;</span>"+"</a>"+"<a class='ui-spinner-button ui-spinner-down ui-corner-br'>"+"<span class='ui-icon "+this.options.icons.down+"'>&#9660;</span>"+"</a>"},_start:function(e){return this.spinning||this._trigger("start",e)!==!1?(this.counter||(this.counter=1),this.spinning=!0,!0):!1},_repeat:function(e,t,i){e=e||500,clearTimeout(this.timer),this.timer=this._delay(function(){this._repeat(40,t,i)},e),this._spin(t*this.options.step,i)},_spin:function(e,t){var i=this.value()||0;this.counter||(this.counter=1),i=this._adjustValue(i+e*this._increment(this.counter)),this.spinning&&this._trigger("spin",t,{value:i})===!1||(this._value(i),this.counter++)},_increment:function(t){var i=this.options.incremental;return i?e.isFunction(i)?i(t):Math.floor(t*t*t/5e4-t*t/500+17*t/200+1):1},_precision:function(){var e=this._precisionOf(this.options.step);return null!==this.options.min&&(e=Math.max(e,this._precisionOf(this.options.min))),e},_precisionOf:function(e){var t=""+e,i=t.indexOf(".");return-1===i?0:t.length-i-1},_adjustValue:function(e){var t,i,s=this.options;return t=null!==s.min?s.min:0,i=e-t,i=Math.round(i/s.step)*s.step,e=t+i,e=parseFloat(e.toFixed(this._precision())),null!==s.max&&e>s.max?s.max:null!==s.min&&s.min>e?s.min:e
},_stop:function(e){this.spinning&&(clearTimeout(this.timer),clearTimeout(this.mousewheelTimer),this.counter=0,this.spinning=!1,this._trigger("stop",e))},_setOption:function(e,t){if("culture"===e||"numberFormat"===e){var i=this._parse(this.element.val());return this.options[e]=t,this.element.val(this._format(i)),void 0}("max"===e||"min"===e||"step"===e)&&"string"==typeof t&&(t=this._parse(t)),"icons"===e&&(this.buttons.first().find(".ui-icon").removeClass(this.options.icons.up).addClass(t.up),this.buttons.last().find(".ui-icon").removeClass(this.options.icons.down).addClass(t.down)),this._super(e,t),"disabled"===e&&(this.widget().toggleClass("ui-state-disabled",!!t),this.element.prop("disabled",!!t),this.buttons.button(t?"disable":"enable"))},_setOptions:o(function(e){this._super(e)}),_parse:function(e){return"string"==typeof e&&""!==e&&(e=window.Globalize&&this.options.numberFormat?Globalize.parseFloat(e,10,this.options.culture):+e),""===e||isNaN(e)?null:e},_format:function(e){return""===e?"":window.Globalize&&this.options.numberFormat?Globalize.format(e,this.options.numberFormat,this.options.culture):e},_refresh:function(){this.element.attr({"aria-valuemin":this.options.min,"aria-valuemax":this.options.max,"aria-valuenow":this._parse(this.element.val())})},isValid:function(){var e=this.value();return null===e?!1:e===this._adjustValue(e)},_value:function(e,t){var i;""!==e&&(i=this._parse(e),null!==i&&(t||(i=this._adjustValue(i)),e=this._format(i))),this.element.val(e),this._refresh()},_destroy:function(){this.element.removeClass("ui-spinner-input").prop("disabled",!1).removeAttr("autocomplete").removeAttr("role").removeAttr("aria-valuemin").removeAttr("aria-valuemax").removeAttr("aria-valuenow"),this.uiSpinner.replaceWith(this.element)},stepUp:o(function(e){this._stepUp(e)}),_stepUp:function(e){this._start()&&(this._spin((e||1)*this.options.step),this._stop())},stepDown:o(function(e){this._stepDown(e)}),_stepDown:function(e){this._start()&&(this._spin((e||1)*-this.options.step),this._stop())},pageUp:o(function(e){this._stepUp((e||1)*this.options.page)}),pageDown:o(function(e){this._stepDown((e||1)*this.options.page)}),value:function(e){return arguments.length?(o(this._value).call(this,e),void 0):this._parse(this.element.val())},widget:function(){return this.uiSpinner}}),e.widget("ui.tabs",{version:"1.11.0",delay:300,options:{active:null,collapsible:!1,event:"click",heightStyle:"content",hide:null,show:null,activate:null,beforeActivate:null,beforeLoad:null,load:null},_isLocal:function(){var e=/#.*$/;return function(t){var i,s;t=t.cloneNode(!1),i=t.href.replace(e,""),s=location.href.replace(e,"");try{i=decodeURIComponent(i)}catch(a){}try{s=decodeURIComponent(s)}catch(a){}return t.hash.length>1&&i===s}}(),_create:function(){var t=this,i=this.options;this.running=!1,this.element.addClass("ui-tabs ui-widget ui-widget-content ui-corner-all").toggleClass("ui-tabs-collapsible",i.collapsible).delegate(".ui-tabs-nav > li","mousedown"+this.eventNamespace,function(t){e(this).is(".ui-state-disabled")&&t.preventDefault()}).delegate(".ui-tabs-anchor","focus"+this.eventNamespace,function(){e(this).closest("li").is(".ui-state-disabled")&&this.blur()}),this._processTabs(),i.active=this._initialActive(),e.isArray(i.disabled)&&(i.disabled=e.unique(i.disabled.concat(e.map(this.tabs.filter(".ui-state-disabled"),function(e){return t.tabs.index(e)}))).sort()),this.active=this.options.active!==!1&&this.anchors.length?this._findActive(i.active):e(),this._refresh(),this.active.length&&this.load(i.active)},_initialActive:function(){var t=this.options.active,i=this.options.collapsible,s=location.hash.substring(1);return null===t&&(s&&this.tabs.each(function(i,a){return e(a).attr("aria-controls")===s?(t=i,!1):void 0}),null===t&&(t=this.tabs.index(this.tabs.filter(".ui-tabs-active"))),(null===t||-1===t)&&(t=this.tabs.length?0:!1)),t!==!1&&(t=this.tabs.index(this.tabs.eq(t)),-1===t&&(t=i?!1:0)),!i&&t===!1&&this.anchors.length&&(t=0),t},_getCreateEventData:function(){return{tab:this.active,panel:this.active.length?this._getPanelForTab(this.active):e()}},_tabKeydown:function(t){var i=e(this.document[0].activeElement).closest("li"),s=this.tabs.index(i),a=!0;if(!this._handlePageNav(t)){switch(t.keyCode){case e.ui.keyCode.RIGHT:case e.ui.keyCode.DOWN:s++;break;case e.ui.keyCode.UP:case e.ui.keyCode.LEFT:a=!1,s--;break;case e.ui.keyCode.END:s=this.anchors.length-1;break;case e.ui.keyCode.HOME:s=0;break;case e.ui.keyCode.SPACE:return t.preventDefault(),clearTimeout(this.activating),this._activate(s),void 0;case e.ui.keyCode.ENTER:return t.preventDefault(),clearTimeout(this.activating),this._activate(s===this.options.active?!1:s),void 0;default:return}t.preventDefault(),clearTimeout(this.activating),s=this._focusNextTab(s,a),t.ctrlKey||(i.attr("aria-selected","false"),this.tabs.eq(s).attr("aria-selected","true"),this.activating=this._delay(function(){this.option("active",s)},this.delay))}},_panelKeydown:function(t){this._handlePageNav(t)||t.ctrlKey&&t.keyCode===e.ui.keyCode.UP&&(t.preventDefault(),this.active.focus())},_handlePageNav:function(t){return t.altKey&&t.keyCode===e.ui.keyCode.PAGE_UP?(this._activate(this._focusNextTab(this.options.active-1,!1)),!0):t.altKey&&t.keyCode===e.ui.keyCode.PAGE_DOWN?(this._activate(this._focusNextTab(this.options.active+1,!0)),!0):void 0},_findNextTab:function(t,i){function s(){return t>a&&(t=0),0>t&&(t=a),t}for(var a=this.tabs.length-1;-1!==e.inArray(s(),this.options.disabled);)t=i?t+1:t-1;return t},_focusNextTab:function(e,t){return e=this._findNextTab(e,t),this.tabs.eq(e).focus(),e},_setOption:function(e,t){return"active"===e?(this._activate(t),void 0):"disabled"===e?(this._setupDisabled(t),void 0):(this._super(e,t),"collapsible"===e&&(this.element.toggleClass("ui-tabs-collapsible",t),t||this.options.active!==!1||this._activate(0)),"event"===e&&this._setupEvents(t),"heightStyle"===e&&this._setupHeightStyle(t),void 0)},_sanitizeSelector:function(e){return e?e.replace(/[!"$%&'()*+,.\/:;<=>?@\[\]\^`{|}~]/g,"\\$&"):""},refresh:function(){var t=this.options,i=this.tablist.children(":has(a[href])");t.disabled=e.map(i.filter(".ui-state-disabled"),function(e){return i.index(e)}),this._processTabs(),t.active!==!1&&this.anchors.length?this.active.length&&!e.contains(this.tablist[0],this.active[0])?this.tabs.length===t.disabled.length?(t.active=!1,this.active=e()):this._activate(this._findNextTab(Math.max(0,t.active-1),!1)):t.active=this.tabs.index(this.active):(t.active=!1,this.active=e()),this._refresh()},_refresh:function(){this._setupDisabled(this.options.disabled),this._setupEvents(this.options.event),this._setupHeightStyle(this.options.heightStyle),this.tabs.not(this.active).attr({"aria-selected":"false","aria-expanded":"false",tabIndex:-1}),this.panels.not(this._getPanelForTab(this.active)).hide().attr({"aria-hidden":"true"}),this.active.length?(this.active.addClass("ui-tabs-active ui-state-active").attr({"aria-selected":"true","aria-expanded":"true",tabIndex:0}),this._getPanelForTab(this.active).show().attr({"aria-hidden":"false"})):this.tabs.eq(0).attr("tabIndex",0)},_processTabs:function(){var t=this;this.tablist=this._getList().addClass("ui-tabs-nav ui-helper-reset ui-helper-clearfix ui-widget-header ui-corner-all").attr("role","tablist"),this.tabs=this.tablist.find("> li:has(a[href])").addClass("ui-state-default ui-corner-top").attr({role:"tab",tabIndex:-1}),this.anchors=this.tabs.map(function(){return e("a",this)[0]}).addClass("ui-tabs-anchor").attr({role:"presentation",tabIndex:-1}),this.panels=e(),this.anchors.each(function(i,s){var a,n,r,o=e(s).uniqueId().attr("id"),h=e(s).closest("li"),l=h.attr("aria-controls");t._isLocal(s)?(a=s.hash,r=a.substring(1),n=t.element.find(t._sanitizeSelector(a))):(r=h.attr("aria-controls")||e({}).uniqueId()[0].id,a="#"+r,n=t.element.find(a),n.length||(n=t._createPanel(r),n.insertAfter(t.panels[i-1]||t.tablist)),n.attr("aria-live","polite")),n.length&&(t.panels=t.panels.add(n)),l&&h.data("ui-tabs-aria-controls",l),h.attr({"aria-controls":r,"aria-labelledby":o}),n.attr("aria-labelledby",o)}),this.panels.addClass("ui-tabs-panel ui-widget-content ui-corner-bottom").attr("role","tabpanel")},_getList:function(){return this.tablist||this.element.find("ol,ul").eq(0)},_createPanel:function(t){return e("<div>").attr("id",t).addClass("ui-tabs-panel ui-widget-content ui-corner-bottom").data("ui-tabs-destroy",!0)},_setupDisabled:function(t){e.isArray(t)&&(t.length?t.length===this.anchors.length&&(t=!0):t=!1);for(var i,s=0;i=this.tabs[s];s++)t===!0||-1!==e.inArray(s,t)?e(i).addClass("ui-state-disabled").attr("aria-disabled","true"):e(i).removeClass("ui-state-disabled").removeAttr("aria-disabled");this.options.disabled=t},_setupEvents:function(t){var i={};t&&e.each(t.split(" "),function(e,t){i[t]="_eventHandler"}),this._off(this.anchors.add(this.tabs).add(this.panels)),this._on(!0,this.anchors,{click:function(e){e.preventDefault()}}),this._on(this.anchors,i),this._on(this.tabs,{keydown:"_tabKeydown"}),this._on(this.panels,{keydown:"_panelKeydown"}),this._focusable(this.tabs),this._hoverable(this.tabs)},_setupHeightStyle:function(t){var i,s=this.element.parent();"fill"===t?(i=s.height(),i-=this.element.outerHeight()-this.element.height(),this.element.siblings(":visible").each(function(){var t=e(this),s=t.css("position");"absolute"!==s&&"fixed"!==s&&(i-=t.outerHeight(!0))}),this.element.children().not(this.panels).each(function(){i-=e(this).outerHeight(!0)}),this.panels.each(function(){e(this).height(Math.max(0,i-e(this).innerHeight()+e(this).height()))}).css("overflow","auto")):"auto"===t&&(i=0,this.panels.each(function(){i=Math.max(i,e(this).height("").height())}).height(i))},_eventHandler:function(t){var i=this.options,s=this.active,a=e(t.currentTarget),n=a.closest("li"),r=n[0]===s[0],o=r&&i.collapsible,h=o?e():this._getPanelForTab(n),l=s.length?this._getPanelForTab(s):e(),u={oldTab:s,oldPanel:l,newTab:o?e():n,newPanel:h};t.preventDefault(),n.hasClass("ui-state-disabled")||n.hasClass("ui-tabs-loading")||this.running||r&&!i.collapsible||this._trigger("beforeActivate",t,u)===!1||(i.active=o?!1:this.tabs.index(n),this.active=r?e():n,this.xhr&&this.xhr.abort(),l.length||h.length||e.error("jQuery UI Tabs: Mismatching fragment identifier."),h.length&&this.load(this.tabs.index(n),t),this._toggle(t,u))},_toggle:function(t,i){function s(){n.running=!1,n._trigger("activate",t,i)}function a(){i.newTab.closest("li").addClass("ui-tabs-active ui-state-active"),r.length&&n.options.show?n._show(r,n.options.show,s):(r.show(),s())}var n=this,r=i.newPanel,o=i.oldPanel;this.running=!0,o.length&&this.options.hide?this._hide(o,this.options.hide,function(){i.oldTab.closest("li").removeClass("ui-tabs-active ui-state-active"),a()}):(i.oldTab.closest("li").removeClass("ui-tabs-active ui-state-active"),o.hide(),a()),o.attr("aria-hidden","true"),i.oldTab.attr({"aria-selected":"false","aria-expanded":"false"}),r.length&&o.length?i.oldTab.attr("tabIndex",-1):r.length&&this.tabs.filter(function(){return 0===e(this).attr("tabIndex")}).attr("tabIndex",-1),r.attr("aria-hidden","false"),i.newTab.attr({"aria-selected":"true","aria-expanded":"true",tabIndex:0})},_activate:function(t){var i,s=this._findActive(t);s[0]!==this.active[0]&&(s.length||(s=this.active),i=s.find(".ui-tabs-anchor")[0],this._eventHandler({target:i,currentTarget:i,preventDefault:e.noop}))},_findActive:function(t){return t===!1?e():this.tabs.eq(t)},_getIndex:function(e){return"string"==typeof e&&(e=this.anchors.index(this.anchors.filter("[href$='"+e+"']"))),e},_destroy:function(){this.xhr&&this.xhr.abort(),this.element.removeClass("ui-tabs ui-widget ui-widget-content ui-corner-all ui-tabs-collapsible"),this.tablist.removeClass("ui-tabs-nav ui-helper-reset ui-helper-clearfix ui-widget-header ui-corner-all").removeAttr("role"),this.anchors.removeClass("ui-tabs-anchor").removeAttr("role").removeAttr("tabIndex").removeUniqueId(),this.tabs.add(this.panels).each(function(){e.data(this,"ui-tabs-destroy")?e(this).remove():e(this).removeClass("ui-state-default ui-state-active ui-state-disabled ui-corner-top ui-corner-bottom ui-widget-content ui-tabs-active ui-tabs-panel").removeAttr("tabIndex").removeAttr("aria-live").removeAttr("aria-busy").removeAttr("aria-selected").removeAttr("aria-labelledby").removeAttr("aria-hidden").removeAttr("aria-expanded").removeAttr("role")}),this.tabs.each(function(){var t=e(this),i=t.data("ui-tabs-aria-controls");i?t.attr("aria-controls",i).removeData("ui-tabs-aria-controls"):t.removeAttr("aria-controls")}),this.panels.show(),"content"!==this.options.heightStyle&&this.panels.css("height","")},enable:function(t){var i=this.options.disabled;i!==!1&&(void 0===t?i=!1:(t=this._getIndex(t),i=e.isArray(i)?e.map(i,function(e){return e!==t?e:null}):e.map(this.tabs,function(e,i){return i!==t?i:null})),this._setupDisabled(i))},disable:function(t){var i=this.options.disabled;if(i!==!0){if(void 0===t)i=!0;else{if(t=this._getIndex(t),-1!==e.inArray(t,i))return;i=e.isArray(i)?e.merge([t],i).sort():[t]}this._setupDisabled(i)}},load:function(t,i){t=this._getIndex(t);var s=this,a=this.tabs.eq(t),n=a.find(".ui-tabs-anchor"),r=this._getPanelForTab(a),o={tab:a,panel:r};this._isLocal(n[0])||(this.xhr=e.ajax(this._ajaxSettings(n,i,o)),this.xhr&&"canceled"!==this.xhr.statusText&&(a.addClass("ui-tabs-loading"),r.attr("aria-busy","true"),this.xhr.success(function(e){setTimeout(function(){r.html(e),s._trigger("load",i,o)},1)}).complete(function(e,t){setTimeout(function(){"abort"===t&&s.panels.stop(!1,!0),a.removeClass("ui-tabs-loading"),r.removeAttr("aria-busy"),e===s.xhr&&delete s.xhr},1)})))},_ajaxSettings:function(t,i,s){var a=this;return{url:t.attr("href"),beforeSend:function(t,n){return a._trigger("beforeLoad",i,e.extend({jqXHR:t,ajaxSettings:n},s))}}},_getPanelForTab:function(t){var i=e(t).attr("aria-controls");return this.element.find(this._sanitizeSelector("#"+i))}}),e.widget("ui.tooltip",{version:"1.11.0",options:{content:function(){var t=e(this).attr("title")||"";return e("<a>").text(t).html()},hide:!0,items:"[title]:not([disabled])",position:{my:"left top+15",at:"left bottom",collision:"flipfit flip"},show:!0,tooltipClass:null,track:!1,close:null,open:null},_addDescribedBy:function(t,i){var s=(t.attr("aria-describedby")||"").split(/\s+/);s.push(i),t.data("ui-tooltip-id",i).attr("aria-describedby",e.trim(s.join(" ")))},_removeDescribedBy:function(t){var i=t.data("ui-tooltip-id"),s=(t.attr("aria-describedby")||"").split(/\s+/),a=e.inArray(i,s);-1!==a&&s.splice(a,1),t.removeData("ui-tooltip-id"),s=e.trim(s.join(" ")),s?t.attr("aria-describedby",s):t.removeAttr("aria-describedby")},_create:function(){this._on({mouseover:"open",focusin:"open"}),this.tooltips={},this.parents={},this.options.disabled&&this._disable(),this.liveRegion=e("<div>").attr({role:"log","aria-live":"assertive","aria-relevant":"additions"}).addClass("ui-helper-hidden-accessible").appendTo(this.document[0].body)},_setOption:function(t,i){var s=this;return"disabled"===t?(this[i?"_disable":"_enable"](),this.options[t]=i,void 0):(this._super(t,i),"content"===t&&e.each(this.tooltips,function(e,t){s._updateContent(t)}),void 0)},_disable:function(){var t=this;e.each(this.tooltips,function(i,s){var a=e.Event("blur");a.target=a.currentTarget=s[0],t.close(a,!0)}),this.element.find(this.options.items).addBack().each(function(){var t=e(this);t.is("[title]")&&t.data("ui-tooltip-title",t.attr("title")).removeAttr("title")})},_enable:function(){this.element.find(this.options.items).addBack().each(function(){var t=e(this);t.data("ui-tooltip-title")&&t.attr("title",t.data("ui-tooltip-title"))})},open:function(t){var i=this,s=e(t?t.target:this.element).closest(this.options.items);s.length&&!s.data("ui-tooltip-id")&&(s.attr("title")&&s.data("ui-tooltip-title",s.attr("title")),s.data("ui-tooltip-open",!0),t&&"mouseover"===t.type&&s.parents().each(function(){var t,s=e(this);s.data("ui-tooltip-open")&&(t=e.Event("blur"),t.target=t.currentTarget=this,i.close(t,!0)),s.attr("title")&&(s.uniqueId(),i.parents[this.id]={element:this,title:s.attr("title")},s.attr("title",""))}),this._updateContent(s,t))},_updateContent:function(e,t){var i,s=this.options.content,a=this,n=t?t.type:null;return"string"==typeof s?this._open(t,e,s):(i=s.call(e[0],function(i){e.data("ui-tooltip-open")&&a._delay(function(){t&&(t.type=n),this._open(t,e,i)})}),i&&this._open(t,e,i),void 0)},_open:function(t,i,s){function a(e){l.of=e,n.is(":hidden")||n.position(l)}var n,r,o,h,l=e.extend({},this.options.position);if(s){if(n=this._find(i),n.length)return n.find(".ui-tooltip-content").html(s),void 0;i.is("[title]")&&(t&&"mouseover"===t.type?i.attr("title",""):i.removeAttr("title")),n=this._tooltip(i),this._addDescribedBy(i,n.attr("id")),n.find(".ui-tooltip-content").html(s),this.liveRegion.children().hide(),s.clone?(h=s.clone(),h.removeAttr("id").find("[id]").removeAttr("id")):h=s,e("<div>").html(h).appendTo(this.liveRegion),this.options.track&&t&&/^mouse/.test(t.type)?(this._on(this.document,{mousemove:a}),a(t)):n.position(e.extend({of:i},this.options.position)),n.hide(),this._show(n,this.options.show),this.options.show&&this.options.show.delay&&(o=this.delayedShow=setInterval(function(){n.is(":visible")&&(a(l.of),clearInterval(o))},e.fx.interval)),this._trigger("open",t,{tooltip:n}),r={keyup:function(t){if(t.keyCode===e.ui.keyCode.ESCAPE){var s=e.Event(t);s.currentTarget=i[0],this.close(s,!0)}}},i[0]!==this.element[0]&&(r.remove=function(){this._removeTooltip(n)}),t&&"mouseover"!==t.type||(r.mouseleave="close"),t&&"focusin"!==t.type||(r.focusout="close"),this._on(!0,i,r)}},close:function(t){var i=this,s=e(t?t.currentTarget:this.element),a=this._find(s);this.closing||(clearInterval(this.delayedShow),s.data("ui-tooltip-title")&&!s.attr("title")&&s.attr("title",s.data("ui-tooltip-title")),this._removeDescribedBy(s),a.stop(!0),this._hide(a,this.options.hide,function(){i._removeTooltip(e(this))}),s.removeData("ui-tooltip-open"),this._off(s,"mouseleave focusout keyup"),s[0]!==this.element[0]&&this._off(s,"remove"),this._off(this.document,"mousemove"),t&&"mouseleave"===t.type&&e.each(this.parents,function(t,s){e(s.element).attr("title",s.title),delete i.parents[t]}),this.closing=!0,this._trigger("close",t,{tooltip:a}),this.closing=!1)},_tooltip:function(t){var i=e("<div>").attr("role","tooltip").addClass("ui-tooltip ui-widget ui-corner-all ui-widget-content "+(this.options.tooltipClass||"")),s=i.uniqueId().attr("id");return e("<div>").addClass("ui-tooltip-content").appendTo(i),i.appendTo(this.document[0].body),this.tooltips[s]=t,i},_find:function(t){var i=t.data("ui-tooltip-id");return i?e("#"+i):e()},_removeTooltip:function(e){e.remove(),delete this.tooltips[e.attr("id")]},_destroy:function(){var t=this;e.each(this.tooltips,function(i,s){var a=e.Event("blur");a.target=a.currentTarget=s[0],t.close(a,!0),e("#"+i).remove(),s.data("ui-tooltip-title")&&(s.attr("title")||s.attr("title",s.data("ui-tooltip-title")),s.removeData("ui-tooltip-title"))}),this.liveRegion.remove()}});var v="ui-effects-";e.effects={effect:{}},function(e,t){function i(e,t,i){var s=d[t.type]||{};return null==e?i||!t.def?null:t.def:(e=s.floor?~~e:parseFloat(e),isNaN(e)?t.def:s.mod?(e+s.mod)%s.mod:0>e?0:e>s.max?s.max:e)}function s(i){var s=l(),a=s._rgba=[];return i=i.toLowerCase(),f(h,function(e,n){var r,o=n.re.exec(i),h=o&&n.parse(o),l=n.space||"rgba";return h?(r=s[l](h),s[u[l].cache]=r[u[l].cache],a=s._rgba=r._rgba,!1):t}),a.length?("0,0,0,0"===a.join()&&e.extend(a,n.transparent),s):n[i]}function a(e,t,i){return i=(i+1)%1,1>6*i?e+6*(t-e)*i:1>2*i?t:2>3*i?e+6*(t-e)*(2/3-i):e}var n,r="backgroundColor borderBottomColor borderLeftColor borderRightColor borderTopColor color columnRuleColor outlineColor textDecorationColor textEmphasisColor",o=/^([\-+])=\s*(\d+\.?\d*)/,h=[{re:/rgba?\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,parse:function(e){return[e[1],e[2],e[3],e[4]]}},{re:/rgba?\(\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,parse:function(e){return[2.55*e[1],2.55*e[2],2.55*e[3],e[4]]}},{re:/#([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})/,parse:function(e){return[parseInt(e[1],16),parseInt(e[2],16),parseInt(e[3],16)]}},{re:/#([a-f0-9])([a-f0-9])([a-f0-9])/,parse:function(e){return[parseInt(e[1]+e[1],16),parseInt(e[2]+e[2],16),parseInt(e[3]+e[3],16)]}},{re:/hsla?\(\s*(\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,space:"hsla",parse:function(e){return[e[1],e[2]/100,e[3]/100,e[4]]}}],l=e.Color=function(t,i,s,a){return new e.Color.fn.parse(t,i,s,a)},u={rgba:{props:{red:{idx:0,type:"byte"},green:{idx:1,type:"byte"},blue:{idx:2,type:"byte"}}},hsla:{props:{hue:{idx:0,type:"degrees"},saturation:{idx:1,type:"percent"},lightness:{idx:2,type:"percent"}}}},d={"byte":{floor:!0,max:255},percent:{max:1},degrees:{mod:360,floor:!0}},c=l.support={},p=e("<p>")[0],f=e.each;p.style.cssText="background-color:rgba(1,1,1,.5)",c.rgba=p.style.backgroundColor.indexOf("rgba")>-1,f(u,function(e,t){t.cache="_"+e,t.props.alpha={idx:3,type:"percent",def:1}}),l.fn=e.extend(l.prototype,{parse:function(a,r,o,h){if(a===t)return this._rgba=[null,null,null,null],this;(a.jquery||a.nodeType)&&(a=e(a).css(r),r=t);var d=this,c=e.type(a),p=this._rgba=[];return r!==t&&(a=[a,r,o,h],c="array"),"string"===c?this.parse(s(a)||n._default):"array"===c?(f(u.rgba.props,function(e,t){p[t.idx]=i(a[t.idx],t)}),this):"object"===c?(a instanceof l?f(u,function(e,t){a[t.cache]&&(d[t.cache]=a[t.cache].slice())}):f(u,function(t,s){var n=s.cache;f(s.props,function(e,t){if(!d[n]&&s.to){if("alpha"===e||null==a[e])return;d[n]=s.to(d._rgba)}d[n][t.idx]=i(a[e],t,!0)}),d[n]&&0>e.inArray(null,d[n].slice(0,3))&&(d[n][3]=1,s.from&&(d._rgba=s.from(d[n])))}),this):t},is:function(e){var i=l(e),s=!0,a=this;return f(u,function(e,n){var r,o=i[n.cache];return o&&(r=a[n.cache]||n.to&&n.to(a._rgba)||[],f(n.props,function(e,i){return null!=o[i.idx]?s=o[i.idx]===r[i.idx]:t})),s}),s},_space:function(){var e=[],t=this;return f(u,function(i,s){t[s.cache]&&e.push(i)}),e.pop()},transition:function(e,t){var s=l(e),a=s._space(),n=u[a],r=0===this.alpha()?l("transparent"):this,o=r[n.cache]||n.to(r._rgba),h=o.slice();return s=s[n.cache],f(n.props,function(e,a){var n=a.idx,r=o[n],l=s[n],u=d[a.type]||{};null!==l&&(null===r?h[n]=l:(u.mod&&(l-r>u.mod/2?r+=u.mod:r-l>u.mod/2&&(r-=u.mod)),h[n]=i((l-r)*t+r,a)))}),this[a](h)},blend:function(t){if(1===this._rgba[3])return this;var i=this._rgba.slice(),s=i.pop(),a=l(t)._rgba;return l(e.map(i,function(e,t){return(1-s)*a[t]+s*e}))},toRgbaString:function(){var t="rgba(",i=e.map(this._rgba,function(e,t){return null==e?t>2?1:0:e});return 1===i[3]&&(i.pop(),t="rgb("),t+i.join()+")"},toHslaString:function(){var t="hsla(",i=e.map(this.hsla(),function(e,t){return null==e&&(e=t>2?1:0),t&&3>t&&(e=Math.round(100*e)+"%"),e});return 1===i[3]&&(i.pop(),t="hsl("),t+i.join()+")"},toHexString:function(t){var i=this._rgba.slice(),s=i.pop();return t&&i.push(~~(255*s)),"#"+e.map(i,function(e){return e=(e||0).toString(16),1===e.length?"0"+e:e}).join("")},toString:function(){return 0===this._rgba[3]?"transparent":this.toRgbaString()}}),l.fn.parse.prototype=l.fn,u.hsla.to=function(e){if(null==e[0]||null==e[1]||null==e[2])return[null,null,null,e[3]];var t,i,s=e[0]/255,a=e[1]/255,n=e[2]/255,r=e[3],o=Math.max(s,a,n),h=Math.min(s,a,n),l=o-h,u=o+h,d=.5*u;return t=h===o?0:s===o?60*(a-n)/l+360:a===o?60*(n-s)/l+120:60*(s-a)/l+240,i=0===l?0:.5>=d?l/u:l/(2-u),[Math.round(t)%360,i,d,null==r?1:r]},u.hsla.from=function(e){if(null==e[0]||null==e[1]||null==e[2])return[null,null,null,e[3]];var t=e[0]/360,i=e[1],s=e[2],n=e[3],r=.5>=s?s*(1+i):s+i-s*i,o=2*s-r;return[Math.round(255*a(o,r,t+1/3)),Math.round(255*a(o,r,t)),Math.round(255*a(o,r,t-1/3)),n]},f(u,function(s,a){var n=a.props,r=a.cache,h=a.to,u=a.from;l.fn[s]=function(s){if(h&&!this[r]&&(this[r]=h(this._rgba)),s===t)return this[r].slice();var a,o=e.type(s),d="array"===o||"object"===o?s:arguments,c=this[r].slice();return f(n,function(e,t){var s=d["object"===o?e:t.idx];null==s&&(s=c[t.idx]),c[t.idx]=i(s,t)}),u?(a=l(u(c)),a[r]=c,a):l(c)},f(n,function(t,i){l.fn[t]||(l.fn[t]=function(a){var n,r=e.type(a),h="alpha"===t?this._hsla?"hsla":"rgba":s,l=this[h](),u=l[i.idx];return"undefined"===r?u:("function"===r&&(a=a.call(this,u),r=e.type(a)),null==a&&i.empty?this:("string"===r&&(n=o.exec(a),n&&(a=u+parseFloat(n[2])*("+"===n[1]?1:-1))),l[i.idx]=a,this[h](l)))})})}),l.hook=function(t){var i=t.split(" ");f(i,function(t,i){e.cssHooks[i]={set:function(t,a){var n,r,o="";if("transparent"!==a&&("string"!==e.type(a)||(n=s(a)))){if(a=l(n||a),!c.rgba&&1!==a._rgba[3]){for(r="backgroundColor"===i?t.parentNode:t;(""===o||"transparent"===o)&&r&&r.style;)try{o=e.css(r,"backgroundColor"),r=r.parentNode}catch(h){}a=a.blend(o&&"transparent"!==o?o:"_default")}a=a.toRgbaString()}try{t.style[i]=a}catch(h){}}},e.fx.step[i]=function(t){t.colorInit||(t.start=l(t.elem,i),t.end=l(t.end),t.colorInit=!0),e.cssHooks[i].set(t.elem,t.start.transition(t.end,t.pos))}})},l.hook(r),e.cssHooks.borderColor={expand:function(e){var t={};return f(["Top","Right","Bottom","Left"],function(i,s){t["border"+s+"Color"]=e}),t}},n=e.Color.names={aqua:"#00ffff",black:"#000000",blue:"#0000ff",fuchsia:"#ff00ff",gray:"#808080",green:"#008000",lime:"#00ff00",maroon:"#800000",navy:"#000080",olive:"#808000",purple:"#800080",red:"#ff0000",silver:"#c0c0c0",teal:"#008080",white:"#ffffff",yellow:"#ffff00",transparent:[null,null,null,0],_default:"#ffffff"}}(jQuery),function(){function t(t){var i,s,a=t.ownerDocument.defaultView?t.ownerDocument.defaultView.getComputedStyle(t,null):t.currentStyle,n={};if(a&&a.length&&a[0]&&a[a[0]])for(s=a.length;s--;)i=a[s],"string"==typeof a[i]&&(n[e.camelCase(i)]=a[i]);else for(i in a)"string"==typeof a[i]&&(n[i]=a[i]);return n}function i(t,i){var s,n,r={};for(s in i)n=i[s],t[s]!==n&&(a[s]||(e.fx.step[s]||!isNaN(parseFloat(n)))&&(r[s]=n));return r}var s=["add","remove","toggle"],a={border:1,borderBottom:1,borderColor:1,borderLeft:1,borderRight:1,borderTop:1,borderWidth:1,margin:1,padding:1};e.each(["borderLeftStyle","borderRightStyle","borderBottomStyle","borderTopStyle"],function(t,i){e.fx.step[i]=function(e){("none"!==e.end&&!e.setAttr||1===e.pos&&!e.setAttr)&&(jQuery.style(e.elem,i,e.end),e.setAttr=!0)}}),e.fn.addBack||(e.fn.addBack=function(e){return this.add(null==e?this.prevObject:this.prevObject.filter(e))}),e.effects.animateClass=function(a,n,r,o){var h=e.speed(n,r,o);return this.queue(function(){var n,r=e(this),o=r.attr("class")||"",l=h.children?r.find("*").addBack():r;l=l.map(function(){var i=e(this);return{el:i,start:t(this)}}),n=function(){e.each(s,function(e,t){a[t]&&r[t+"Class"](a[t])})},n(),l=l.map(function(){return this.end=t(this.el[0]),this.diff=i(this.start,this.end),this}),r.attr("class",o),l=l.map(function(){var t=this,i=e.Deferred(),s=e.extend({},h,{queue:!1,complete:function(){i.resolve(t)}});return this.el.animate(this.diff,s),i.promise()}),e.when.apply(e,l.get()).done(function(){n(),e.each(arguments,function(){var t=this.el;e.each(this.diff,function(e){t.css(e,"")})}),h.complete.call(r[0])})})},e.fn.extend({addClass:function(t){return function(i,s,a,n){return s?e.effects.animateClass.call(this,{add:i},s,a,n):t.apply(this,arguments)}}(e.fn.addClass),removeClass:function(t){return function(i,s,a,n){return arguments.length>1?e.effects.animateClass.call(this,{remove:i},s,a,n):t.apply(this,arguments)}}(e.fn.removeClass),toggleClass:function(t){return function(i,s,a,n,r){return"boolean"==typeof s||void 0===s?a?e.effects.animateClass.call(this,s?{add:i}:{remove:i},a,n,r):t.apply(this,arguments):e.effects.animateClass.call(this,{toggle:i},s,a,n)}}(e.fn.toggleClass),switchClass:function(t,i,s,a,n){return e.effects.animateClass.call(this,{add:i,remove:t},s,a,n)}})}(),function(){function t(t,i,s,a){return e.isPlainObject(t)&&(i=t,t=t.effect),t={effect:t},null==i&&(i={}),e.isFunction(i)&&(a=i,s=null,i={}),("number"==typeof i||e.fx.speeds[i])&&(a=s,s=i,i={}),e.isFunction(s)&&(a=s,s=null),i&&e.extend(t,i),s=s||i.duration,t.duration=e.fx.off?0:"number"==typeof s?s:s in e.fx.speeds?e.fx.speeds[s]:e.fx.speeds._default,t.complete=a||i.complete,t}function i(t){return!t||"number"==typeof t||e.fx.speeds[t]?!0:"string"!=typeof t||e.effects.effect[t]?e.isFunction(t)?!0:"object"!=typeof t||t.effect?!1:!0:!0}e.extend(e.effects,{version:"1.11.0",save:function(e,t){for(var i=0;t.length>i;i++)null!==t[i]&&e.data(v+t[i],e[0].style[t[i]])},restore:function(e,t){var i,s;for(s=0;t.length>s;s++)null!==t[s]&&(i=e.data(v+t[s]),void 0===i&&(i=""),e.css(t[s],i))},setMode:function(e,t){return"toggle"===t&&(t=e.is(":hidden")?"show":"hide"),t},getBaseline:function(e,t){var i,s;switch(e[0]){case"top":i=0;break;case"middle":i=.5;break;case"bottom":i=1;break;default:i=e[0]/t.height}switch(e[1]){case"left":s=0;break;case"center":s=.5;break;case"right":s=1;break;default:s=e[1]/t.width}return{x:s,y:i}},createWrapper:function(t){if(t.parent().is(".ui-effects-wrapper"))return t.parent();var i={width:t.outerWidth(!0),height:t.outerHeight(!0),"float":t.css("float")},s=e("<div></div>").addClass("ui-effects-wrapper").css({fontSize:"100%",background:"transparent",border:"none",margin:0,padding:0}),a={width:t.width(),height:t.height()},n=document.activeElement;try{n.id}catch(r){n=document.body}return t.wrap(s),(t[0]===n||e.contains(t[0],n))&&e(n).focus(),s=t.parent(),"static"===t.css("position")?(s.css({position:"relative"}),t.css({position:"relative"})):(e.extend(i,{position:t.css("position"),zIndex:t.css("z-index")}),e.each(["top","left","bottom","right"],function(e,s){i[s]=t.css(s),isNaN(parseInt(i[s],10))&&(i[s]="auto")}),t.css({position:"relative",top:0,left:0,right:"auto",bottom:"auto"})),t.css(a),s.css(i).show()},removeWrapper:function(t){var i=document.activeElement;return t.parent().is(".ui-effects-wrapper")&&(t.parent().replaceWith(t),(t[0]===i||e.contains(t[0],i))&&e(i).focus()),t},setTransition:function(t,i,s,a){return a=a||{},e.each(i,function(e,i){var n=t.cssUnit(i);n[0]>0&&(a[i]=n[0]*s+n[1])}),a}}),e.fn.extend({effect:function(){function i(t){function i(){e.isFunction(n)&&n.call(a[0]),e.isFunction(t)&&t()}var a=e(this),n=s.complete,o=s.mode;(a.is(":hidden")?"hide"===o:"show"===o)?(a[o](),i()):r.call(a[0],s,i)}var s=t.apply(this,arguments),a=s.mode,n=s.queue,r=e.effects.effect[s.effect];return e.fx.off||!r?a?this[a](s.duration,s.complete):this.each(function(){s.complete&&s.complete.call(this)}):n===!1?this.each(i):this.queue(n||"fx",i)},show:function(e){return function(s){if(i(s))return e.apply(this,arguments);var a=t.apply(this,arguments);return a.mode="show",this.effect.call(this,a)}}(e.fn.show),hide:function(e){return function(s){if(i(s))return e.apply(this,arguments);var a=t.apply(this,arguments);return a.mode="hide",this.effect.call(this,a)}}(e.fn.hide),toggle:function(e){return function(s){if(i(s)||"boolean"==typeof s)return e.apply(this,arguments);var a=t.apply(this,arguments);return a.mode="toggle",this.effect.call(this,a)}}(e.fn.toggle),cssUnit:function(t){var i=this.css(t),s=[];return e.each(["em","px","%","pt"],function(e,t){i.indexOf(t)>0&&(s=[parseFloat(i),t])}),s}})}(),function(){var t={};e.each(["Quad","Cubic","Quart","Quint","Expo"],function(e,i){t[i]=function(t){return Math.pow(t,e+2)}}),e.extend(t,{Sine:function(e){return 1-Math.cos(e*Math.PI/2)},Circ:function(e){return 1-Math.sqrt(1-e*e)},Elastic:function(e){return 0===e||1===e?e:-Math.pow(2,8*(e-1))*Math.sin((80*(e-1)-7.5)*Math.PI/15)},Back:function(e){return e*e*(3*e-2)},Bounce:function(e){for(var t,i=4;((t=Math.pow(2,--i))-1)/11>e;);return 1/Math.pow(4,3-i)-7.5625*Math.pow((3*t-2)/22-e,2)}}),e.each(t,function(t,i){e.easing["easeIn"+t]=i,e.easing["easeOut"+t]=function(e){return 1-i(1-e)},e.easing["easeInOut"+t]=function(e){return.5>e?i(2*e)/2:1-i(-2*e+2)/2}})}(),e.effects,e.effects.effect.blind=function(t,i){var s,a,n,r=e(this),o=/up|down|vertical/,h=/up|left|vertical|horizontal/,l=["position","top","bottom","left","right","height","width"],u=e.effects.setMode(r,t.mode||"hide"),d=t.direction||"up",c=o.test(d),p=c?"height":"width",f=c?"top":"left",m=h.test(d),g={},v="show"===u;
r.parent().is(".ui-effects-wrapper")?e.effects.save(r.parent(),l):e.effects.save(r,l),r.show(),s=e.effects.createWrapper(r).css({overflow:"hidden"}),a=s[p](),n=parseFloat(s.css(f))||0,g[p]=v?a:0,m||(r.css(c?"bottom":"right",0).css(c?"top":"left","auto").css({position:"absolute"}),g[f]=v?n:a+n),v&&(s.css(p,0),m||s.css(f,n+a)),s.animate(g,{duration:t.duration,easing:t.easing,queue:!1,complete:function(){"hide"===u&&r.hide(),e.effects.restore(r,l),e.effects.removeWrapper(r),i()}})},e.effects.effect.bounce=function(t,i){var s,a,n,r=e(this),o=["position","top","bottom","left","right","height","width"],h=e.effects.setMode(r,t.mode||"effect"),l="hide"===h,u="show"===h,d=t.direction||"up",c=t.distance,p=t.times||5,f=2*p+(u||l?1:0),m=t.duration/f,g=t.easing,v="up"===d||"down"===d?"top":"left",y="up"===d||"left"===d,b=r.queue(),_=b.length;for((u||l)&&o.push("opacity"),e.effects.save(r,o),r.show(),e.effects.createWrapper(r),c||(c=r["top"===v?"outerHeight":"outerWidth"]()/3),u&&(n={opacity:1},n[v]=0,r.css("opacity",0).css(v,y?2*-c:2*c).animate(n,m,g)),l&&(c/=Math.pow(2,p-1)),n={},n[v]=0,s=0;p>s;s++)a={},a[v]=(y?"-=":"+=")+c,r.animate(a,m,g).animate(n,m,g),c=l?2*c:c/2;l&&(a={opacity:0},a[v]=(y?"-=":"+=")+c,r.animate(a,m,g)),r.queue(function(){l&&r.hide(),e.effects.restore(r,o),e.effects.removeWrapper(r),i()}),_>1&&b.splice.apply(b,[1,0].concat(b.splice(_,f+1))),r.dequeue()},e.effects.effect.clip=function(t,i){var s,a,n,r=e(this),o=["position","top","bottom","left","right","height","width"],h=e.effects.setMode(r,t.mode||"hide"),l="show"===h,u=t.direction||"vertical",d="vertical"===u,c=d?"height":"width",p=d?"top":"left",f={};e.effects.save(r,o),r.show(),s=e.effects.createWrapper(r).css({overflow:"hidden"}),a="IMG"===r[0].tagName?s:r,n=a[c](),l&&(a.css(c,0),a.css(p,n/2)),f[c]=l?n:0,f[p]=l?0:n/2,a.animate(f,{queue:!1,duration:t.duration,easing:t.easing,complete:function(){l||r.hide(),e.effects.restore(r,o),e.effects.removeWrapper(r),i()}})},e.effects.effect.drop=function(t,i){var s,a=e(this),n=["position","top","bottom","left","right","opacity","height","width"],r=e.effects.setMode(a,t.mode||"hide"),o="show"===r,h=t.direction||"left",l="up"===h||"down"===h?"top":"left",u="up"===h||"left"===h?"pos":"neg",d={opacity:o?1:0};e.effects.save(a,n),a.show(),e.effects.createWrapper(a),s=t.distance||a["top"===l?"outerHeight":"outerWidth"](!0)/2,o&&a.css("opacity",0).css(l,"pos"===u?-s:s),d[l]=(o?"pos"===u?"+=":"-=":"pos"===u?"-=":"+=")+s,a.animate(d,{queue:!1,duration:t.duration,easing:t.easing,complete:function(){"hide"===r&&a.hide(),e.effects.restore(a,n),e.effects.removeWrapper(a),i()}})},e.effects.effect.explode=function(t,i){function s(){b.push(this),b.length===d*c&&a()}function a(){p.css({visibility:"visible"}),e(b).remove(),m||p.hide(),i()}var n,r,o,h,l,u,d=t.pieces?Math.round(Math.sqrt(t.pieces)):3,c=d,p=e(this),f=e.effects.setMode(p,t.mode||"hide"),m="show"===f,g=p.show().css("visibility","hidden").offset(),v=Math.ceil(p.outerWidth()/c),y=Math.ceil(p.outerHeight()/d),b=[];for(n=0;d>n;n++)for(h=g.top+n*y,u=n-(d-1)/2,r=0;c>r;r++)o=g.left+r*v,l=r-(c-1)/2,p.clone().appendTo("body").wrap("<div></div>").css({position:"absolute",visibility:"visible",left:-r*v,top:-n*y}).parent().addClass("ui-effects-explode").css({position:"absolute",overflow:"hidden",width:v,height:y,left:o+(m?l*v:0),top:h+(m?u*y:0),opacity:m?0:1}).animate({left:o+(m?0:l*v),top:h+(m?0:u*y),opacity:m?1:0},t.duration||500,t.easing,s)},e.effects.effect.fade=function(t,i){var s=e(this),a=e.effects.setMode(s,t.mode||"toggle");s.animate({opacity:a},{queue:!1,duration:t.duration,easing:t.easing,complete:i})},e.effects.effect.fold=function(t,i){var s,a,n=e(this),r=["position","top","bottom","left","right","height","width"],o=e.effects.setMode(n,t.mode||"hide"),h="show"===o,l="hide"===o,u=t.size||15,d=/([0-9]+)%/.exec(u),c=!!t.horizFirst,p=h!==c,f=p?["width","height"]:["height","width"],m=t.duration/2,g={},v={};e.effects.save(n,r),n.show(),s=e.effects.createWrapper(n).css({overflow:"hidden"}),a=p?[s.width(),s.height()]:[s.height(),s.width()],d&&(u=parseInt(d[1],10)/100*a[l?0:1]),h&&s.css(c?{height:0,width:u}:{height:u,width:0}),g[f[0]]=h?a[0]:u,v[f[1]]=h?a[1]:0,s.animate(g,m,t.easing).animate(v,m,t.easing,function(){l&&n.hide(),e.effects.restore(n,r),e.effects.removeWrapper(n),i()})},e.effects.effect.highlight=function(t,i){var s=e(this),a=["backgroundImage","backgroundColor","opacity"],n=e.effects.setMode(s,t.mode||"show"),r={backgroundColor:s.css("backgroundColor")};"hide"===n&&(r.opacity=0),e.effects.save(s,a),s.show().css({backgroundImage:"none",backgroundColor:t.color||"#ffff99"}).animate(r,{queue:!1,duration:t.duration,easing:t.easing,complete:function(){"hide"===n&&s.hide(),e.effects.restore(s,a),i()}})},e.effects.effect.size=function(t,i){var s,a,n,r=e(this),o=["position","top","bottom","left","right","width","height","overflow","opacity"],h=["position","top","bottom","left","right","overflow","opacity"],l=["width","height","overflow"],u=["fontSize"],d=["borderTopWidth","borderBottomWidth","paddingTop","paddingBottom"],c=["borderLeftWidth","borderRightWidth","paddingLeft","paddingRight"],p=e.effects.setMode(r,t.mode||"effect"),f=t.restore||"effect"!==p,m=t.scale||"both",g=t.origin||["middle","center"],v=r.css("position"),y=f?o:h,b={height:0,width:0,outerHeight:0,outerWidth:0};"show"===p&&r.show(),s={height:r.height(),width:r.width(),outerHeight:r.outerHeight(),outerWidth:r.outerWidth()},"toggle"===t.mode&&"show"===p?(r.from=t.to||b,r.to=t.from||s):(r.from=t.from||("show"===p?b:s),r.to=t.to||("hide"===p?b:s)),n={from:{y:r.from.height/s.height,x:r.from.width/s.width},to:{y:r.to.height/s.height,x:r.to.width/s.width}},("box"===m||"both"===m)&&(n.from.y!==n.to.y&&(y=y.concat(d),r.from=e.effects.setTransition(r,d,n.from.y,r.from),r.to=e.effects.setTransition(r,d,n.to.y,r.to)),n.from.x!==n.to.x&&(y=y.concat(c),r.from=e.effects.setTransition(r,c,n.from.x,r.from),r.to=e.effects.setTransition(r,c,n.to.x,r.to))),("content"===m||"both"===m)&&n.from.y!==n.to.y&&(y=y.concat(u).concat(l),r.from=e.effects.setTransition(r,u,n.from.y,r.from),r.to=e.effects.setTransition(r,u,n.to.y,r.to)),e.effects.save(r,y),r.show(),e.effects.createWrapper(r),r.css("overflow","hidden").css(r.from),g&&(a=e.effects.getBaseline(g,s),r.from.top=(s.outerHeight-r.outerHeight())*a.y,r.from.left=(s.outerWidth-r.outerWidth())*a.x,r.to.top=(s.outerHeight-r.to.outerHeight)*a.y,r.to.left=(s.outerWidth-r.to.outerWidth)*a.x),r.css(r.from),("content"===m||"both"===m)&&(d=d.concat(["marginTop","marginBottom"]).concat(u),c=c.concat(["marginLeft","marginRight"]),l=o.concat(d).concat(c),r.find("*[width]").each(function(){var i=e(this),s={height:i.height(),width:i.width(),outerHeight:i.outerHeight(),outerWidth:i.outerWidth()};f&&e.effects.save(i,l),i.from={height:s.height*n.from.y,width:s.width*n.from.x,outerHeight:s.outerHeight*n.from.y,outerWidth:s.outerWidth*n.from.x},i.to={height:s.height*n.to.y,width:s.width*n.to.x,outerHeight:s.height*n.to.y,outerWidth:s.width*n.to.x},n.from.y!==n.to.y&&(i.from=e.effects.setTransition(i,d,n.from.y,i.from),i.to=e.effects.setTransition(i,d,n.to.y,i.to)),n.from.x!==n.to.x&&(i.from=e.effects.setTransition(i,c,n.from.x,i.from),i.to=e.effects.setTransition(i,c,n.to.x,i.to)),i.css(i.from),i.animate(i.to,t.duration,t.easing,function(){f&&e.effects.restore(i,l)})})),r.animate(r.to,{queue:!1,duration:t.duration,easing:t.easing,complete:function(){0===r.to.opacity&&r.css("opacity",r.from.opacity),"hide"===p&&r.hide(),e.effects.restore(r,y),f||("static"===v?r.css({position:"relative",top:r.to.top,left:r.to.left}):e.each(["top","left"],function(e,t){r.css(t,function(t,i){var s=parseInt(i,10),a=e?r.to.left:r.to.top;return"auto"===i?a+"px":s+a+"px"})})),e.effects.removeWrapper(r),i()}})},e.effects.effect.scale=function(t,i){var s=e(this),a=e.extend(!0,{},t),n=e.effects.setMode(s,t.mode||"effect"),r=parseInt(t.percent,10)||(0===parseInt(t.percent,10)?0:"hide"===n?0:100),o=t.direction||"both",h=t.origin,l={height:s.height(),width:s.width(),outerHeight:s.outerHeight(),outerWidth:s.outerWidth()},u={y:"horizontal"!==o?r/100:1,x:"vertical"!==o?r/100:1};a.effect="size",a.queue=!1,a.complete=i,"effect"!==n&&(a.origin=h||["middle","center"],a.restore=!0),a.from=t.from||("show"===n?{height:0,width:0,outerHeight:0,outerWidth:0}:l),a.to={height:l.height*u.y,width:l.width*u.x,outerHeight:l.outerHeight*u.y,outerWidth:l.outerWidth*u.x},a.fade&&("show"===n&&(a.from.opacity=0,a.to.opacity=1),"hide"===n&&(a.from.opacity=1,a.to.opacity=0)),s.effect(a)},e.effects.effect.puff=function(t,i){var s=e(this),a=e.effects.setMode(s,t.mode||"hide"),n="hide"===a,r=parseInt(t.percent,10)||150,o=r/100,h={height:s.height(),width:s.width(),outerHeight:s.outerHeight(),outerWidth:s.outerWidth()};e.extend(t,{effect:"scale",queue:!1,fade:!0,mode:a,complete:i,percent:n?r:100,from:n?h:{height:h.height*o,width:h.width*o,outerHeight:h.outerHeight*o,outerWidth:h.outerWidth*o}}),s.effect(t)},e.effects.effect.pulsate=function(t,i){var s,a=e(this),n=e.effects.setMode(a,t.mode||"show"),r="show"===n,o="hide"===n,h=r||"hide"===n,l=2*(t.times||5)+(h?1:0),u=t.duration/l,d=0,c=a.queue(),p=c.length;for((r||!a.is(":visible"))&&(a.css("opacity",0).show(),d=1),s=1;l>s;s++)a.animate({opacity:d},u,t.easing),d=1-d;a.animate({opacity:d},u,t.easing),a.queue(function(){o&&a.hide(),i()}),p>1&&c.splice.apply(c,[1,0].concat(c.splice(p,l+1))),a.dequeue()},e.effects.effect.shake=function(t,i){var s,a=e(this),n=["position","top","bottom","left","right","height","width"],r=e.effects.setMode(a,t.mode||"effect"),o=t.direction||"left",h=t.distance||20,l=t.times||3,u=2*l+1,d=Math.round(t.duration/u),c="up"===o||"down"===o?"top":"left",p="up"===o||"left"===o,f={},m={},g={},v=a.queue(),y=v.length;for(e.effects.save(a,n),a.show(),e.effects.createWrapper(a),f[c]=(p?"-=":"+=")+h,m[c]=(p?"+=":"-=")+2*h,g[c]=(p?"-=":"+=")+2*h,a.animate(f,d,t.easing),s=1;l>s;s++)a.animate(m,d,t.easing).animate(g,d,t.easing);a.animate(m,d,t.easing).animate(f,d/2,t.easing).queue(function(){"hide"===r&&a.hide(),e.effects.restore(a,n),e.effects.removeWrapper(a),i()}),y>1&&v.splice.apply(v,[1,0].concat(v.splice(y,u+1))),a.dequeue()},e.effects.effect.slide=function(t,i){var s,a=e(this),n=["position","top","bottom","left","right","width","height"],r=e.effects.setMode(a,t.mode||"show"),o="show"===r,h=t.direction||"left",l="up"===h||"down"===h?"top":"left",u="up"===h||"left"===h,d={};e.effects.save(a,n),a.show(),s=t.distance||a["top"===l?"outerHeight":"outerWidth"](!0),e.effects.createWrapper(a).css({overflow:"hidden"}),o&&a.css(l,u?isNaN(s)?"-"+s:-s:s),d[l]=(o?u?"+=":"-=":u?"-=":"+=")+s,a.animate(d,{queue:!1,duration:t.duration,easing:t.easing,complete:function(){"hide"===r&&a.hide(),e.effects.restore(a,n),e.effects.removeWrapper(a),i()}})},e.effects.effect.transfer=function(t,i){var s=e(this),a=e(t.to),n="fixed"===a.css("position"),r=e("body"),o=n?r.scrollTop():0,h=n?r.scrollLeft():0,l=a.offset(),u={top:l.top-o,left:l.left-h,height:a.innerHeight(),width:a.innerWidth()},d=s.offset(),c=e("<div class='ui-effects-transfer'></div>").appendTo(document.body).addClass(t.className).css({top:d.top-o,left:d.left-h,height:s.innerHeight(),width:s.innerWidth(),position:n?"fixed":"absolute"}).animate(u,t.duration,t.easing,function(){c.remove(),i()})}});
/******************************************************************************* 
* Copyright 2012, 2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES 
* 
* This file is part of SITools2. 
* 
* SITools2 is free software: you can redistribute it and/or modify 
* it under the terms of the GNU General Public License as published by 
* the Free Software Foundation, either version 3 of the License, or 
* (at your option) any later version. 
* 
* SITools2 is distributed in the hope that it will be useful, 
* but WITHOUT ANY WARRANTY; without even the implied warranty of 
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
* GNU General Public License for more details. 
* 
* You should have received a copy of the GNU General Public License 
* along with SITools2. If not, see <http://www.gnu.org/licenses/>. 
******************************************************************************/ 

/**
 * Samp module : performing communication between applications using SAMP protocol
 */
define('Samp',["jquery", "underscore-min", "gw/CoordinateSystem", "gw/FeatureStyle", "gw/VectorLayer", "./Utils", "./JsonProcessor", "samp", "jquery.ui"],
	function($, _, CoordinateSystem, FeatureStyle, VectorLayer, Utils, JsonProcessor) {

var mizar;
var sky;
var navigation;
var additionalLayersView;
var imageManager;
var tables = {};
var highlightStyle = new FeatureStyle( {
	strokeColor: [1., 1., 1., 1.],
	fillColor: [1., 1., 1., 1.]
} );
var highlightedData;

var connector;	// SAMP connector
var sampLayer;	// SAMP vector layer containing all incoming fits images
var pointAtReceived = false; // Parameter avoiding looping while receiving coord.pointAt.sky SAMP event
var votable2geojsonBaseUrl;
var sitoolsBaseUrl;

/**************************************************************************************************************/

/**
 *	Create samp dialog, implement UI events
 */
function initUI()
{	
	// Don't use connector.createRegButtons() because there is no unregistration callback
	// to refresh jquery UI buttons
	var dialogContent = '<div id="sampContent"><button id="registerSamp">Register</button>\
					<button id="unregisterSamp" disabled>Unregister</button>\
					<button id="sendVOTable">Send VO table</button>\
					<span><strong>Registered: </strong><span id="sampResult">No</span></span>\
					<br/>\
					<div style="display: none;" id="sampStatus"></div>\
					</div>';

	var $dialog = $(dialogContent).appendTo('body')
		.dialog({
			title: 'Samp',
			autoOpen: false,
			show: {
				effect: "fade",
				duration: 300
			},
			hide: {
				effect: "fade",
				duration: 300
			},
			open: function()
			{
				// Remove auto-focus
				$(this).find('button:first-child').blur();
			},
			resizable: false,
			width: 'auto',
			minHeight: 'auto',
			close: function(event, ui)
			{
				$(this).dialog("close");
			}
		});

	$dialog.find('#registerSamp').button()
		.click(function(){
			connector.register();
		}).end()
	.find("#unregisterSamp").button()
		.click(function(){
			connector.unregister();
			
			// Update jQuery UI buttons
			$('#registerSamp').removeAttr('disabled').button("refresh");
			$(this).attr('disabled','disabled').button("refresh");
			$('#sampInvoker').css('background-image', 'url(css/images/samp_off.png)');
		}).end()
	.find('#sendVOTable').button()
		.click(function(){
			// DEBUG:
			var tableUrl = sitoolsBaseUrl + "/sia/search?order=3&healpix=293&coordSystem=EQUATORIAL&media=votable";
			var msg = new samp.Message("table.load.votable", {"url": tableUrl});
			connector.connection.notifyAll([msg]);
		});

	$('#sampInvoker').on('click', function(){
		$dialog.dialog("open");
	}).hover(function(){
		$(this).animate({left: '-10px'}, 100);
	}, function() {
		$(this).animate({left: '-20px'}, 100);
	});
}

/**************************************************************************************************************/

/**
 *	Create SAMP ClientTracker object which handles incoming messages
 */
function createClientTracker()
{
	// Initialize client tracker
	var clientTracker = new samp.ClientTracker();

	// Init available samp income message handlers(as ping, load.votable..)
	var callHandler = clientTracker.callHandler;
	callHandler["samp.app.ping"] = function(senderId, message, isCall)
	{
		if ( isCall )
		{
			return { text: "ping to you, " + clientTracker.getName(senderId) };
		}
	}

	callHandler["table.load.votable"] = function(senderId, message, isCall) {

		if ( votable2geojsonBaseUrl )
		{
			var params = message["samp.params"];
	        var origUrl = params["url"];
	        var proxyUrl = clientTracker.connection.translateUrl(origUrl);
	        var xhr = samp.XmlRpcClient.createXHR();
	        var e;
	        xhr.open("GET", proxyUrl);
	        xhr.onload = function() {
	            var xml = xhr.responseXML;
	            if (xml) {
	            	try {
	                    // Send response of xml to SiTools2 to convert it to GeoJSON
	                    $.ajax({
	                    	type: "POST",
	                    	url: votable2geojsonBaseUrl,
	                    	data: {
	                    		votable: xhr.responseText,
								coordSystem: "EQUATORIAL"
	                    	},
	                    	success: function(response)
	                    	{
	                 			// Add feature collection
								JsonProcessor.handleFeatureCollection( sampLayer, response );
								sampLayer.addFeatureCollection( response );
	                    	},
	                    	error: function(thrownError)
	                    	{
	                    		console.error(thrownError);
	                    	}
	                    });
	                }
	                catch (e) {
	                    console.log("Error displaying table:\n" +
	                    e.toString());
	                }
	            }
	            else {
	                console.log("No XML response");
	            }
	        };
	        xhr.onerror = function(err) {
	            console.log("Error getting table " + origUrl + "\n" +
	                            "(" + err + ")");
	        };
	        xhr.send(null);
		}
		else
		{
			ErrorDialog.open('votable2geojson plugin base url isn\'t defined');
		}
	};

	// callHandler["table.highlight.row"] = function(senderId, message, isCall) {
	// 	var params = message["samp.params"];
	// 	var url = params['url'];
	// 	var row = params['row'];

	// 	if ( highlightedData )
	// 	{
	// 		highlightedData.layer.modifyFeatureStyle( highlightedData.feature, highlightedData.layer.style );
	// 	}

	// 	if ( tables[url] )
	// 	{
	// 		var layer = tables[url].layer;
	// 		var feature = tables[url].features[parseInt(row)];

	// 		layer.modifyFeatureStyle( feature, highlightStyle );
	// 		highlightedData = {
	// 			layer: layer,
	// 			feature: feature
	// 		}

	// 		var barycenter = Utils.computeGeometryBarycenter( feature.geometry );
	// 		navigation.zoomTo( barycenter, (navigation.renderContext.fov < 1. ? navigation.renderContext.fov : 1.), 300. );
	// 	}
	// };

	callHandler["image.load.fits"] = function(senderId, message, isCall) {
		var params = message["samp.params"];

		// Create feature
		var feature = {
			"geometry": {
				"gid": params['name'],
				"coordinates": [],
				"type": "Polygon"
			},
			"properties": {
				"identifier": params['name']
			},
			"services": {
				"download": {
					"mimetype": "image/fits",
					"url": params['image-id']
				}
			},
			"type": "Feature"
		};

		// Get fits texture from url
		var featureData = {
			layer: sampLayer,
			feature: feature,
			isFits: true
		};
		var url = sitoolsBaseUrl + "/proxy?external_url=" + encodeURIComponent(params['image-id']);
		mizar.publish("image:add", featureData);
		imageManager.computeFits(featureData, url, function(featureData, fits){
			// Update feature coordinates according to Fits header
			var coords = Utils.getPolygonCoordinatesFromFits(fits);
			featureData.feature.geometry.coordinates = [coords];
			sampLayer.addFeature(featureData.feature);
		});
	};

	callHandler["coord.pointAt.sky"] = function(senderId, message, isCall) {
		pointAtReceived = true;
		var params = message["samp.params"];
		var ra = parseFloat(params["ra"]);
		var dec = parseFloat(params["dec"]);
		// var proxyUrl = clientTracker.connection.translateUrl(origUrl);
		var geoPick = [ra, dec];
		var center3d = [];
		CoordinateSystem.fromGeoTo3D( geoPick, center3d );
		navigation.center3d = center3d;
		navigation.computeViewMatrix();
		sky.renderContext.requestFrame();
	};

	callHandler["samp.hub.event.unregister"] = function(senderId, message, isCall) {
		// Update jQuery UI buttons
		$('#registerSamp').removeAttr('disabled').button("refresh");
		$("#unregisterSamp").attr('disabled','disabled').button("refresh");
		$('#sampInvoker').css('background-image', 'url(css/images/samp_off.png)');
	}

	return clientTracker;
}

/**************************************************************************************************************/

/**
 *	Init SAMP connector 
 */
function initSamp()
{
	var clientTracker = createClientTracker();

	// Samp event callbacks
	var logCc = {
		receiveNotification: function(senderId, message) {
			var handled = clientTracker.receiveNotification(senderId, message);
			if ( message["samp.mtype"] == "samp.hub.event.subscriptions" )
		    {
		    	// Update jQuery UI buttons
				$('#unregisterSamp').removeAttr('disabled').button("refresh");
				$('#registerSamp').attr('disabled','disabled').button("refresh");
				$('#sampInvoker').css('background-image', 'url(css/images/samp_on.png)');
		    }
		},
		receiveCall: function(senderId, msgId, message) {
			var handled = clientTracker.receiveCall(senderId, msgId, message);
		},
		receiveResponse: function(responderId, msgTag, response) {
			var handled = clientTracker.receiveResponse(responderId, msgTag, response);
		},
		init: function(connection) {
			clientTracker.init(connection);
		}
	};

	// Meta-data
	var meta = {
		"samp.name": "Mizar",
		"samp.description.text": "Module for Interactive visualiZation from Astronomical Repositories",
		"mizar.version": "v0.1",
		"author.affiliation": "CNES/TPZ",
		"home.page": "http://github.com/TPZF/RTWeb3D"
	};

	// Generate subscriptions map
	var subs = clientTracker.calculateSubscriptions();

	connector = new samp.Connector("Mizar", meta, logCc, subs);

	// Uncomment for automatic registration(check every 2 sec if Hub is available)
	  // Adjusts page content depending on whether the hub exists or not.
	  // var configureSampEnabled = function(isHubRunning) {
	  //     // TODO
	  // };
	// connector.onHubAvailability(configureSampEnabled, 2000);

	// Registration status element is updated by samp.js
	connector.regTextNodes.push($('#sampResult')[0]);
}

/**************************************************************************************************************/

/**
 *	Init SAMP module
 */
function init(m, lm, im, configuration)
{
	mizar = m;
	sky = mizar.sky;
	navigation = mizar.navigation;
	layerManager = lm;
	imageManager = im;

	if ( configuration.votable2geojson )
	{
		sitoolsBaseUrl = configuration.sitoolsBaseUrl;
		votable2geojsonBaseUrl = configuration.votable2geojson.baseUrl;
	}

	initUI();
	initSamp();
	
	// Send pointAt messages when navigation modified
	navigation.subscribe("modified", function(){

		if ( connector.connection )
		{
			if ( !pointAtReceived )
			{
				// Mizar is connected to Hub
				var geoPick = CoordinateSystem.from3DToGeo( navigation.center3d );
				var message = new samp.Message("coord.pointAt.sky",
												{"ra": geoPick[0].toString(), "dec": geoPick[1].toString()});
				connector.connection.notifyAll([message]);
			}
			else
			{
				pointAtReceived = false;
			}
		}
	});

	var sampDesc = {
		type: "Vector",
		name: "SAMP",
		pickable: true,
		dataType: "line"
	};

	sampLayer = layerManager.addLayer(sampDesc);
	
	window.onbeforeunload = function() {
		// Doesn't work onrefresh actually
		connector.unregister();
	}
	
}

/**************************************************************************************************************/

return {
	init: init,
	sendImage: function(url)
	{
		if (this.isConnected())
		{
			// Send message
			var msg = new samp.Message("image.load.fits", {url: url});
			connector.connection.notifyAll([msg]);
			return "Image has been sent";
		}
		else
		{
			return "Connect to SAMP Hub first";
		}
	},

	sendVOTable: function(layer, url)
	{
		if (this.isConnected())
		{
			// Send message
			var msg = new samp.Message("table.load.votable", {url: url+"&media=votable"});
			connector.connection.notifyAll([msg]);
			
			// Part used to highlighting
			// $.ajax({
			// 	type: "GET",
			// 	url: url,
			// 	success: function(response) {

			// 		if ( response.totalResults > 0 )
			// 		{
			// 			// Store table to be able to highlight features later
			// 			tables[ url+'&media=votable' ] = {
			// 				layer: layer,
			// 				features: []
			// 			};
			// 			for ( var i=0; i<response.features.length; i++ )
			// 			{
			// 				var feature = response.features[i];
			// 				tables[url+'&media=votable'].features.push(feature);
			// 			}
			// 		}
			// 		// Send message
			// 		var msg = new samp.Message("table.load.votable", {url: url+"&media=votable"});
			// 		connector.connection.notifyAll([msg]);
			// 	},
			// 	error: function(thrownError)
			// 	{
			// 		console.error(thrownError);
			// 	}
			// });
			return "VOTable has been sent";
		}
		else
		{
			return "Connect to SAMP Hub first";
		}
	},

	// Commented part is used for highlighting feature which wasn't implemented due to
	// difficulty of SAMP protocol (client doesn't know the feature from row)
	highlightFeature: function(layer, feature)
	{
		if ( this.isConnected() )
		{
			// for ( var url in tables )
			// {
			// 	var table = tables[url];
			// 	if ( layer == table.layer )
			// 	{
			// 		var featureToHighlight = _.filter( table.features, function(x){ return(feature.properties.identifier == x.properties.identifier) } );
			// 		if ( featureToHighlight.length )
			// 		{
						// var featureRow = table.features.indexOf(featureToHighlight[0]);
						// var msg = new samp.Message("table.highlight.row", {url: url, row: featureRow.toString()});
						// connector.connection.notifyAll([msg]);
			// 		}
			// 	}
			// }
		}
	},

	isConnected: function()
	{
		return connector.connection;
	}
}

});
/******************************************************************************* 
* Copyright 2012, 2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES 
* 
* This file is part of SITools2. 
* 
* SITools2 is free software: you can redistribute it and/or modify 
* it under the terms of the GNU General Public License as published by 
* the Free Software Foundation, either version 3 of the License, or 
* (at your option) any later version. 
* 
* SITools2 is distributed in the hope that it will be useful, 
* but WITHOUT ANY WARRANTY; without even the implied warranty of 
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
* GNU General Public License for more details. 
* 
* You should have received a copy of the GNU General Public License 
* along with SITools2. If not, see <http://www.gnu.org/licenses/>. 
******************************************************************************/ 

/**
 * Animated button
 */
define('AnimatedButton', [ "jquery", "jquery.ui"], function($) {

var AnimatedButton = function(element, options)
{
	this.$element = $(element).button();
	this.stopped = true;
	if ( options )
	{
		this.$element.on('click', $.proxy( options.onclick, this ));
	}
}

/**************************************************************************************************************/

/**
 *	Start animation
 */
AnimatedButton.prototype.startAnimation = function()
{
	this.stopped = false;
	this.iterateAnimation();
}

/**************************************************************************************************************/

/**
 *	Stop animation
 */
AnimatedButton.prototype.stopAnimation = function()
{
	this.stopped = true;
}

/**************************************************************************************************************/

/**
 *	Loading animation
 */
AnimatedButton.prototype.iterateAnimation = function()
{
	var self = this;
	this.$element.children('span').animate({ backgroundColor: "rgb(255, 165, 0);" }, 300, function(){
		$(this).animate({ backgroundColor: "transparent" }, 300, function(){
			if ( !self.stopped )
			{
				self.iterateAnimation();
			}
		});
	});
}

/**************************************************************************************************************/

return AnimatedButton;

});
/******************************************************************************* 
* Copyright 2012, 2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES 
* 
* This file is part of SITools2. 
* 
* SITools2 is free software: you can redistribute it and/or modify 
* it under the terms of the GNU General Public License as published by 
* the Free Software Foundation, either version 3 of the License, or 
* (at your option) any later version. 
* 
* SITools2 is distributed in the hope that it will be useful, 
* but WITHOUT ANY WARRANTY; without even the implied warranty of 
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
* GNU General Public License for more details. 
* 
* You should have received a copy of the GNU General Public License 
* along with SITools2. If not, see <http://www.gnu.org/licenses/>. 
******************************************************************************/ 

/**
 * Error dialog module
 */
define('ErrorDialog',["jquery", "jquery.ui"], function($) {

// The main div for error
var errorDiv = '<div id="errorDiv" style="text-align: justify" title="Error"></div>';

// Create the div, use jQuery UI dialog
var $errorDiv = $(errorDiv)
					.appendTo('body')
					.dialog({
						autoOpen: false,
						resizable: false,
						draggable: false,
						width: '300px',
						minHeight: 'auto',
						dialogClass: 'errorBox'
					});

return {
	/**
	 *	Open dialog
	 *
	 *	@param html HTML text
	 */
	open: function( html ){
		$errorDiv
			.html(html)
			.dialog( "open" );
		}
};

});
define('text!../templates/cutOut.html',[],function () { return '<div class="cutOutService">\n\t<div style="text-align: center;">\n\t\t<button id="selectionTool">Select area</button>\n\t\t<button id="clearSelection">Clear area</button>\n\t\t<br/>\n\t\t<button id="runJob">Cut</button>\n\t\t<div style="display: none;" class="jobStatus"></div>\n\t</div>\n\t<hr />\n\t<em>Results</em>\n\t<div class="cutoutResults">\n\t\t<ul style="list-style-type: none;">\n\t\t</ul>\n\t</div>\n</div>';});

define('text!../templates/cutResultItem.html',[],function () { return '<li data-jobid="<%= result.jobId %>" class="cutResult" style="display: none;"><%= result.name %>:\n\t<img data-url="<%= result.url %>" title="Export image by SAMP" class="sampExport" src="css/images/exportSamp.png" />\n\t<a href="<%= result.url %>" download="<% (result.downloadName) ? print(result.downloadName) : print(result.name) %>"><img style="vertical-align: middle; width: 20px; height: 20px;" title="Download" src="css/images/download1.png"></a>\n\t<img title="Delete result" class="deleteResult" src="css/images/delete.png" />\n</li>';});

/******************************************************************************* 
* Copyright 2012, 2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES 
* 
* This file is part of SITools2. 
* 
* SITools2 is free software: you can redistribute it and/or modify 
* it under the terms of the GNU General Public License as published by 
* the Free Software Foundation, either version 3 of the License, or 
* (at your option) any later version. 
* 
* SITools2 is distributed in the hope that it will be useful, 
* but WITHOUT ANY WARRANTY; without even the implied warranty of 
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
* GNU General Public License for more details. 
* 
* You should have received a copy of the GNU General Public License 
* along with SITools2. If not, see <http://www.gnu.org/licenses/>. 
******************************************************************************/ 

define('CutOutView', [ "jquery", "./SelectionTool", "./UWSManager", "./Samp", "gw/CoordinateSystem", "./AnimatedButton", "./ErrorDialog", "underscore-min", "text!../templates/cutOut.html", "text!../templates/cutResultItem.html", "jquery.ui" ],
		function($, SelectionTool, UWSManager, Samp, CoordinateSystem, AnimatedButton, ErrorDialog, _, cutOutHTMLTemplate, cutResultHTMLTemplate) {

// Template generating UWS services div
var cutOutTemplate = _.template(cutOutHTMLTemplate);

// Template generating the cutOut result li
var cutResultTemplate = _.template(cutResultHTMLTemplate);

/**
 * UWS CutOut View
 */
var CutOutView = function(element, selectionTool, pickingManager)
{
	this.url;
	this.pickingManager = pickingManager;
	// Initialize selection tool
	this.selectionTool = selectionTool;

	var cutOutContent = cutOutTemplate();
	var self = this;
	$('#'+element).html("");
	this.$content = $(cutOutContent)
		.appendTo('#'+element)
		.find('#selectionTool')
			.button()
			.click(function(){
				self.$content.slideUp();
				// Deactivate picking events
				self.pickingManager.deactivate();
				self.selectionTool.toggle();
			}).end()
		.find('#clearSelection')
			.button()
			.click(function(){
				self.selectionTool.clear();
			}).end();

	this.runButton = new AnimatedButton( $('#'+element).find('#runJob')[0], {
		onclick: $.proxy(this.runJob, this)
	} );

	this.$content.on('click', '.sampExport', function(event){
		if ( Samp.isConnected() )
		{
			Samp.sendImage( $(this).data('url') );
		}
		else
		{
			ErrorDialog.open('You must be connected to SAMP Hub');
		}			
	});

	this.$content.on('click', '.deleteResult', function(event){
		var $job = $(this).parent();
		var jobId = $job.data('jobid');

		UWSManager.delete( 'cutout', jobId, {
			successCallback: function()
			{
				// Remove all job-related results
				$job.parent().find('li[data-jobid='+$job.data('jobid')+']').each(function(){
					$(this).fadeOut(function(){
						$(this).remove();
					});
				});
			},
			failCallback: function(thrownError)
			{
				console.error(thrownError);
				// Fade out anyway
				$job.parent().find('li[data-jobid='+$job.data('jobid')+']').each(function(){
					$(this).fadeOut(function(){
						$(this).remove();
					});
				});
			}
		} );
	});
}

/**************************************************************************************************************/

/**
 *	Run job
 */
CutOutView.prototype.runJob = function()
{	
	if ( this.selectionTool.selectionFeature )
	{
		this.runButton.startAnimation();

		var parameters = {
			PHASE: "RUN",
			uri: this.url,
			ra: this.selectionTool.geoPickPoint[0],
			dec: this.selectionTool.geoPickPoint[1],
			radius: this.selectionTool.geoRadius
		};
		var self = this;
		UWSManager.post('cutout', parameters, {
			successCallback: function(response, jobId)
			{
				self.showMessage('Completed');
				for ( var i=0; i<response.results.result.length; i++ )
				{
					var result = response.results.result[i];
					var name = result['@id'];
					var url =  result['@xlink:href'];

					//Encode special caracters(at least '?')
					if ( url.search("[?]") > 0 )
					{
						var lastSlash = url.lastIndexOf('/') + 1;
						url = url.substr( 0, lastSlash ) + encodeURIComponent(name);
					}

					var proxyIndex = name.search('file_id=');
					var shortName;
					if ( proxyIndex >= 0 )
					{
						shortName = name.substr(proxyIndex+8);
					}
					else
					{
						shortName = name;
					}
					self.runButton.stopAnimation();

					result = {
						name: shortName,
						url: url,
						jobId: jobId
					};

					var cutOutResult = cutResultTemplate({result: result});
					$(cutOutResult)
						.appendTo(self.$content.find('.cutoutResults').find('ul'))
						.fadeIn(400);
				}
			},
			failCallback: function(error)
			{
				self.runButton.stopAnimation();
				self.showMessage(error);
			}
		});
	}
	else
	{
		this.showMessage('Please, select area to cut');
	}
}

/**************************************************************************************************************/

CutOutView.prototype.showMessage = function(message)
{
	this.$content.find('.jobStatus').html(message).stop().slideDown(300).delay(2000).slideUp();
}

/**************************************************************************************************************/

CutOutView.prototype.setUrl = function(url)
{
	this.url = url;
}

/**************************************************************************************************************/

return CutOutView;

});
/******************************************************************************* 
* Copyright 2012, 2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES 
* 
* This file is part of SITools2. 
* 
* SITools2 is free software: you can redistribute it and/or modify 
* it under the terms of the GNU General Public License as published by 
* the Free Software Foundation, either version 3 of the License, or 
* (at your option) any later version. 
* 
* SITools2 is distributed in the hope that it will be useful, 
* but WITHOUT ANY WARRANTY; without even the implied warranty of 
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
* GNU General Public License for more details. 
* 
* You should have received a copy of the GNU General Public License 
* along with SITools2. If not, see <http://www.gnu.org/licenses/>. 
******************************************************************************/ 

/**
 * 	UWS CutOutViewFactory
 *	Designed to share selectionTool & picking manager between views
 */
define('CutOutViewFactory', [ "jquery", "SelectionTool", "CutOutView" ],
		function($, SelectionTool, CutOutView) {

var selectionTool;
var pickingManager;
var views = [];

/**************************************************************************************************************/

return {
	init: function(gl, nav, pm)
	{
		pickingManager = pm;

		// Initialize selection tool
		selectionTool = new SelectionTool({
			globe: gl,
			navigation: nav,
			onselect: function(){
				$('.cutOutService').slideDown();
				// Activate picking events
				pickingManager.activate();
				selectionTool.toggle();
			}
		});

		views = [];
	},

	addView: function(element)
	{
		var view = new CutOutView(element, selectionTool, pickingManager);
		views.push(view);
		return view;	
	},

	removeView: function(view)
	{
		var index = views.indexOf(view);
		views.splice(index, 1);		
	}


}

});
/******************************************************************************* 
* Copyright 2012, 2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES 
* 
* This file is part of SITools2. 
* 
* SITools2 is free software: you can redistribute it and/or modify 
* it under the terms of the GNU General Public License as published by 
* the Free Software Foundation, either version 3 of the License, or 
* (at your option) any later version. 
* 
* SITools2 is distributed in the hope that it will be useful, 
* but WITHOUT ANY WARRANTY; without even the implied warranty of 
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
* GNU General Public License for more details. 
* 
* You should have received a copy of the GNU General Public License 
* along with SITools2. If not, see <http://www.gnu.org/licenses/>. 
******************************************************************************/ 

/**
 * Histogram module : create histogram to the given image
 */
define('Histogram',[], function() {

// Private variables
var nbBins;

var hist = [];
var hmax; // histogram max to scale in image space

// Origin histogram point
var originX = 5.;
var originY;
var hwidth;
var paddingBottom = 15.;

/**************************************************************************************************************/

/**
 *	Get mouse position on canvas
 */
function _getMousePos(canvas, evt) {
var rect = canvas.getBoundingClientRect();
	return {
		x: evt.clientX - rect.left,
		y: evt.clientY - rect.top
	};
}

/**************************************************************************************************************/

/**
 *	Isoscele triangle object for thresholds manipulation
 *	
 *	@param a Pointer of threshold pointing on histogram
 *	@param b Isoscele point 1
 *	@param c Isoscele point 2
 */
var Triangle = function(a,b,c)
{
	this.initA = a.slice(0);
	this.initB = b.slice(0);
	this.initC = c.slice(0);

	this.a = a; // Pointer to histogram
	this.b = b; // Isoscele point 1
	this.c = c; // Isoscele point 2

	this.dragging = false;
	this.hover = false;
	this.halfWidth = Math.abs( (c[0] - b[0])/2 );
}

/**************************************************************************************************************/

/**
 *	Reset to initial position
 */
Triangle.prototype.reset = function()
{
	this.a = this.initA.slice(0);
	this.b = this.initB.slice(0);
	this.c = this.initC.slice(0);
}

/**************************************************************************************************************/

/**
 *	Test if triangle contains the given point
 */
Triangle.prototype.contains = function(p)
{
	return _pointInTriangle(p,this.a,this.b,this.c);
}

/**************************************************************************************************************/

/**
 *	Draw the triangle
 */
Triangle.prototype.draw = function(ctx)
{
	if ( this.dragging )
	{
		ctx.fillStyle = "#FF0";
	}
	else
	{
		ctx.fillStyle = "#F00";	
	}

    ctx.beginPath();
    ctx.moveTo(this.a[0],this.a[1]);
    ctx.lineTo(this.b[0],this.b[1]);
    ctx.lineTo(this.c[0],this.c[1]);
    ctx.closePath();
    ctx.fill();

    if ( !this.dragging && this.hover )
    {
    	ctx.strokeStyle = "#FF0";
    	ctx.stroke();
    }
}

/**************************************************************************************************************/

/**
 *	Modify triangle's position by the given "pointer" point
 *	(could be modified only by X-axis)
 */
Triangle.prototype.modifyPosition = function(point)
{
	this.a[0] = point[0];
	this.b[0] = point[0]-this.halfWidth;
	this.c[0] = point[0]+this.halfWidth;
}

/**************************************************************************************************************/

/**
 *	Test returning true if p1 and p2 are both lying on the same side of a-b, false otherwise
 */
function _sameSide(p1,p2,a,b)
{
	var temp1 = [];
	var temp2 = [];
	var temp3 = [];
	var cp1 = [];
	var cp2 = [];
	vec3.cross( vec3.subtract(b,a, temp1), vec3.subtract(p1,a,temp2), cp1 );
	vec3.cross( temp1, vec3.subtract(p2,a,temp3), cp2 );
	if ( vec3.dot( cp1,cp2 ) >= 0 )
	{
		return true;
	}
	else
	{
		return false;
	}
}

/**************************************************************************************************************/

/**
 *	Private function to check if point is inside the given triangle
 *	If the point was on the same side of a-b as c and is also on the same side of b-c as a and on the same side of c-a as b, then it is in the triangle
 */
function _pointInTriangle(p,a,b,c)
{
	if ( _sameSide(p,a,b,c) && _sameSide(p,b,a,c) && _sameSide(p,c,a,b) )
	{
		return true;
	}
	else
	{
		return false;
	}
}

/**************************************************************************************************************/

/**
 *	TODO: split on HistogramView and Histogram
 *	Histogram contructor
 *	@param options Histogram options
 *		<ul>
 *			<li>image: The image which is represented by current histogram(required)</li>
 *			<li>nbBins: Number of bins, representing the sampling of histogram(optional)</li>
 *			<li>onUpdate: On update callback
 *			<li>accuracy: The accuracy of histogram(numbers after floating point)
 *		</ul>
 */
var Histogram = function(options)
{
	nbBins = options.nbBins || 256;
	this.image = options.image;
	this.onUpdate = options.onUpdate;
	this.accuracy = options.accuracy || 6;

	// Init canvas
	var canvas = document.getElementById(options.canvas);
	this.ctx = canvas.getContext('2d');

	// Init origins
	originY = canvas.height - paddingBottom;
	hwidth = nbBins + originX > canvas.width ? canvas.width : nbBins + originX; // clamp to canvas.width
	var triangleHalfWidth = 5;
	this.minThreshold = new Triangle(
								[originX,originY+1,0],
								[originX-triangleHalfWidth,originY+paddingBottom-1,0],
								[originX+triangleHalfWidth,originY+paddingBottom-1,0]
						);
	this.maxThreshold = new Triangle(
								[hwidth,originY+1, 0],
								[hwidth-triangleHalfWidth,originY+paddingBottom-1, 0],
								[hwidth+triangleHalfWidth,originY+paddingBottom-1, 0]
						);


	// Show bin pointed by mouse
	var self = this;
	canvas.addEventListener('mousemove', function(evt) {
		var mousePos = _getMousePos(canvas, evt);

		self.ctx.clearRect(0., originY, canvas.width, paddingBottom);			

		if ( self.minThreshold.contains( [mousePos.x, mousePos.y, 0] ) )
		{
			self.minThreshold.hover = true;
		}
		else
		{
			self.minThreshold.hover = false;
		}

		if ( self.maxThreshold.contains( [mousePos.x, mousePos.y, 0] ) )
		{
			self.maxThreshold.hover = true;
		}
		else
		{
			self.maxThreshold.hover = false;
		}

		// Draw threshold controls
		if ( self.minThreshold.dragging && mousePos.x >= self.minThreshold.initA[0] && mousePos.x < self.maxThreshold.a[0] )
		{
			self.minThreshold.modifyPosition([mousePos.x, self.minThreshold.a[1]]);
		}

		if ( self.maxThreshold.dragging && mousePos.x <= self.maxThreshold.initA[0] && mousePos.x > self.minThreshold.a[0] )
		{
			self.maxThreshold.modifyPosition([mousePos.x, self.maxThreshold.a[1]]);
		}
		self.drawThresholdControls();

		// Don't draw histogram values if the mouse is out of histogram canvas
		if ( mousePos.y > canvas.height || mousePos.y < 0. || mousePos.x > originX + nbBins || mousePos.x < originX )
		{
			return;
		}

		// Draw the text indicating the histogram value on mouse position
		self.ctx.font = '8pt Calibri';
		self.ctx.fillStyle = 'yellow';
		var thresholdValue = self.getHistValue( [mousePos.x, mousePos.y] );
		self.ctx.fillText(thresholdValue, canvas.width/2-15., originY+paddingBottom);
		// Draw a tiny line indicating the mouse position on X-axis
		self.ctx.fillRect( mousePos.x, originY, 1, 2 );
	});
	
	// Handle threshold controller selection
	canvas.addEventListener('mousedown', function(evt) {
		var mousePos = _getMousePos(canvas, evt);

		if ( self.minThreshold.contains( [mousePos.x, mousePos.y, 0] ) )
		{
			self.minThreshold.dragging = true;
			self.minThreshold.draw(self.ctx);
		}

		if ( self.maxThreshold.contains( [mousePos.x, mousePos.y, 0] ) )
		{
			self.maxThreshold.dragging = true;
			self.maxThreshold.draw(self.ctx);
		}
	});
	
	// Update histogram on mouseup
	canvas.addEventListener('mouseup', function(evt) {
		self.minThreshold.dragging = false;
		self.maxThreshold.dragging = false;

		if ( self.onUpdate )
		{
			var min = self.getHistValue(self.minThreshold.a);
			var max = self.getHistValue(self.maxThreshold.a);

			self.minThreshold.reset();
			self.maxThreshold.reset();

			self.onUpdate(min,max);
		}


	});
}

/**************************************************************************************************************/

/**
 *	Get histogram value from the given X-position on canvas
 */
Histogram.prototype.getHistValue = function( position )
{
	return Math.floor((((position[0]-originX)/256.)*(this.image.tmax-this.image.tmin) + this.image.tmin)*Math.pow(10,this.accuracy))/Math.pow(10, this.accuracy);
}

/**************************************************************************************************************/

/**
 *	Draw threshold controls(two triangles which represents min/max of current histogram)
 */
Histogram.prototype.drawThresholdControls = function()
{
	this.minThreshold.draw(this.ctx);
    this.maxThreshold.draw(this.ctx);
}

/**************************************************************************************************************/

/**
 *	Draw histogram
 */
Histogram.prototype.drawHistogram = function() {
	this.ctx.fillStyle = "blue";
	for ( var i=0; i<hist.length; i++ )
	{
		// Scale to y-axis height
		var rectHeight = (hist[i]/hmax)*originY;
		this.ctx.fillRect( originX + i, originY, 1, -rectHeight );
	}
}

/**************************************************************************************************************/

/**
 *	Draw histogram axis
 */
Histogram.prototype.drawAxes = function() {

	var leftY, rightX;
	leftY = 0;
	rightX = originX + hwidth;
	// Draw y axis.
	this.ctx.beginPath();
	this.ctx.moveTo(originX, leftY);
	this.ctx.lineTo(originX, originY);

	// Draw x axis.
	this.ctx.moveTo(originX, originY);
	this.ctx.lineTo(rightX, originY);

	// Define style and stroke lines.
	this.ctx.closePath();
	this.ctx.strokeStyle = "#fff";
	this.ctx.stroke();
}

/**************************************************************************************************************/

/**
 *	Draw transfer function(linear, log, asin, sqrt, sqr)
 */
Histogram.prototype.drawTransferFunction = function()
{
	// Draw transfer functions
	// "Grey" colormap for now(luminance curve only)
	this.ctx.fillStyle = "red";
	for ( var i=0; i<nbBins; i++ )
	{
		var value = i;
		var posX = originX + value;

		var scaledValue;
		switch( this.image.transferFn )
		{
			case "linear":
				scaledValue = (value/nbBins)*originY;
				break;
			case "log":
				scaledValue = Math.log(value/10.+1)/Math.log(nbBins/10. + 1)*originY;
				break;
			case "sqrt":
				scaledValue = Math.sqrt(value/10.)/Math.sqrt(nbBins/10.)*originY;
				break;
			case "sqr":
				scaledValue = Math.pow(value,2)/Math.pow(nbBins, 2)*originY;
				break;
      		case "asin":
      			scaledValue = Math.log(value + Math.sqrt(Math.pow(value,2)+1.))/Math.log(nbBins + Math.sqrt(Math.pow(nbBins,2)+1.))*originY;
      			break;
			default:
				break;
		}

		if ( !this.image.inverse )
		{
			scaledValue = originY - scaledValue
		}

		this.ctx.fillRect( posX, scaledValue, 1, 1);
	}
}

/**************************************************************************************************************/

/**
 *	Draw the histogram in canvas
 */
Histogram.prototype.draw = function()
{
	this.ctx.clearRect(0,0, this.ctx.canvas.width, this.ctx.canvas.height);
	this.drawHistogram();
	this.drawTransferFunction();
	this.drawAxes();
	this.drawThresholdControls();
}

/**************************************************************************************************************/

/**
 *	TODO : create different module
 *	Compute histogram values
 */
Histogram.prototype.compute = function()
{
	var image = this.image;
	// Initialize histogram
	hist = new Array(nbBins);
	for ( var i=0; i<hist.length; i++ )
	{
		hist[i] = 0;
	}

	// Compute histogram
	hmax = Number.MIN_VALUE;
	for ( var i=0; i<image.pixels.length; i++ )
	{
		var val = image.pixels[i];
		
		// Skip NaN
		if ( isNaN(val) )
			continue;
		// Take only values which belongs to the interval [tmin,tmax]
		if ( val < image.tmin )
			continue;
		if ( val >= image.tmax )
			continue;

		// Scale to [0,255]
		var bin = Math.floor(nbBins * (val - image.tmin)/(image.tmax - image.tmin));
		hist[bin]++;

		// Compute histogram max value
		if ( hist[bin] > hmax )
		{
			hmax = hist[bin];
		}
	}

	// Logarithmic scale for better layout
	for ( var i=0; i<hist.length; i++ )
	{
		hist[i] = Math.log(1 + hist[i]);
	}
	hmax = Math.log(1 + hmax);
}

/**************************************************************************************************************/

/**
 *	Set image
 */
Histogram.prototype.setImage = function(image)
{
	this.image = image;
}

/**************************************************************************************************************/

return Histogram;
});
define('text!../templates/dynamicImageView.html',[],function () { return '<div id="imageProcessing">\n\t<div>\n\t\t<span class="processOption">Contrast : </span>\n\t\t<div class="contrast" style="display: inline-block;">\n\t\t\t<input name="fitsScale_<%= id %>" type="radio" value="raw" id="raw_<%= id %>" checked="checked" /><label for="raw_<%= id %>">Raw</label>\n\t\t\t<input name="fitsScale_<%= id %>" type="radio" value="linear" id="linear_<%= id %>" /><label for="linear_<%= id %>">Linear</label>\n\t\t  \t<input name="fitsScale_<%= id %>" type="radio" value="log" id="log_<%= id %>" /><label for="log_<%= id %>">Log</label>\n\t\t  \t<input name="fitsScale_<%= id %>" type="radio" value="sqrt" id="sqrt_<%= id %>" /><label for="sqrt_<%= id %>">Sqrt</label>\n\t\t  \t<input name="fitsScale_<%= id %>" type="radio" value="sqr" id="sqr_<%= id %>" /><label for="sqr_<%= id %>">Pow2</label>\n\t\t  \t<input name="fitsScale_<%= id %>" type="radio" value="asin" id="asin_<%= id %>" /><label for="asin_<%= id %>">AsinH</label>\n\t\t</div>\n\t</div>\n\n\t<div>\n\t\t<span class="processOption">Colormap : </span>\n\t\t<select class="colormap" style="width:100px;" disabled>\n\t\t\t<option value="grey">Grey</option>\n\t\t\t<option value="rainbow">Rainbow</option>\n\t\t\t<option value="stern">Stern</option>\n\t\t\t<option value="fire">Fire</option>\n\t\t\t<option value="eosb">EOSB</option>\n\t\t</select>\n\t</div>\n\n\t<div>\n  \t\t<span class="processOption"> Threshold : </span>\n\t\t<div class="thresholdSlider"></div>\n\t</div>\n\n\t<div>\n\t  \t<span class="thresholdInputs">\n\t  \t\t<label for="min">Min : </label><input type="text" id="min" disabled />\n\t  \t\t<label for="max">Max : </label><input type="text" id="max" disabled />\n\t  \t</span>\n\t</div>\n\n\t<div>\n\t\t<button disabled class="zScale">ZScale</button>\n\t</div>\n\n\t<div>\n\t\t<span style="width: auto" class="processOption"> Inverse : </span>\n\t\t<input id="inverse_<%= id %>" class="inverse" type="checkbox" disabled /><label for="inverse_<%= id %>"></label>\n\t</div>\n\n\t<div>\n\t\t<div class="processOption" >Histogram : </div>\n\t\t<canvas class="noSelect" id="histogram_<%= id %>" width="275" height="160"></canvas>\n\t</div>\n</div>';});

/******************************************************************************* 
* Copyright 2012, 2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES 
* 
* This file is part of SITools2. 
* 
* SITools2 is free software: you can redistribute it and/or modify 
* it under the terms of the GNU General Public License as published by 
* the Free Software Foundation, either version 3 of the License, or 
* (at your option) any later version. 
* 
* SITools2 is distributed in the hope that it will be useful, 
* but WITHOUT ANY WARRANTY; without even the implied warranty of 
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
* GNU General Public License for more details. 
* 
* You should have received a copy of the GNU General Public License 
* along with SITools2. If not, see <http://www.gnu.org/licenses/>. 
******************************************************************************/ 

define('DynamicImageView',['jquery', 'underscore-min', "gw/FeatureStyle", "./Histogram", "./UWSManager", "./AnimatedButton", "./ErrorDialog", "text!../templates/dynamicImageView.html", /*"jquery.ui.selectmenu"*/ "jquery.ui"],
	function($,_, FeatureStyle, Histogram, UWSManager, AnimatedButton, ErrorDialog, dynamicImageViewHTML) {
 
/**************************************************************************************************************/

/** @constructor 
 *	DynamicImageView constructor
 *	Creates jQuery view of the given <GlobWeb.DynamicImage>
 *	
 *	@param options
 *		<h3>Required:</h3>
 *		<ul>
 *			<li>id: Identifier</li>
 *		</ul>
 *		<h3>Optional:</h3>
 *		<ul>
 *			<li>image: The image represented by this view</li>
 *			<li>changeShaderCallback: Callback for shader changing</li>
 *		</ul>
 */
var DynamicImageView = function(element, options)
{
	this.id = options.id;
	this.changeShaderCallback = options.changeShaderCallback;

	// Interaction parameters
	var selectedColormap = "grey";
	var selectedContrast = "raw";
	var isInversed = false;

	// Create dialog
	var self = this;

	var imageViewContent = _.template(dynamicImageViewHTML, { id: this.id });
	this.$element = $('#'+element);
	this.$element.html(imageViewContent);

	// Initialize contrast buttonset
	this.$element.find('.contrast').buttonset().find('input')
			.each(function(i){
				$(this).click(function(){
					selectedContrast = $(this).val();
					switch(selectedContrast){
						case "linear":
						case "log":
						case "sqrt":
						case "sqr":
						case "asin":
							// Enable all interactive components
							self.enableUI();
							break;
						case "raw":
							// Disable all interactive components
							self.disableUI();
							break;
						default:
							break;
					}

					self.image.updateColormap(selectedContrast, selectedColormap, isInversed);
					if ( self.changeShaderCallback )
						self.changeShaderCallback(selectedContrast);

					self.render();
				});
			});

	// Initialize threshold 
	var $slider = this.$element.find('.thresholdSlider').slider({
			range: true,
			slide: function( event, ui ) {
				self.$element.find( "#min" ).val( ui.values[0] );
				self.$element.find( "#max" ).val( ui.values[1] );
			},
			// Compute histogram on stop, because it's more efficient with huge amount of data
			stop: function( event, ui ) {
				self.updateThreshold(ui.values[0], ui.values[1]);
			}
		}).slider("disable");

	this.$element.find('.thresholdInputs').change(function(){
		// Check validity
		var inputMin = parseFloat($(this).children('#min').val());
		if ( isNaN(inputMin) || inputMin < self.image.min )
		{
			$(this).children('#min').val(self.image.min);
			inputMin = self.image.min;
		}

        var inputMax = parseFloat($(this).children('#max').val());
        if ( isNaN(inputMax) || inputMax > self.image.max)
        {
        	$(this).children('#max').val(self.image.max);
        	inputMax = self.image.max;
        }

        self.updateThreshold( inputMin, inputMax );
	});
	
	// Initialize colormap selectmenu
	var $selectmenu = this.$element.find('.colormap').selectmenu({
		select: function(e)
		{
			selectedColormap = $(this).children('option:selected').val();
			self.image.colormap = selectedColormap;
			self.image.updateColormap(selectedContrast, selectedColormap, isInversed);
			self.image.renderContext.requestFrame();
		}
	});
	
	this.$element.find('.inverse').button({
		text: false,
		icons: {
        	primary: ""
      	}
	});

	// Initialize inverse checkbox
	this.$element.find('.inverse').click(function(){

		$(this).button("option", {
			icons: {
				primary: $(this)[0].checked ? "ui-icon-check" : ""
			}
		});
		isInversed = $(this).is(':checked');
		self.image.updateColormap(selectedContrast, selectedColormap, isInversed);

		self.render();
	});

	var zScaleButton = new AnimatedButton(this.$element.find('.zScale')[0], {
		onclick: function(){
			var params = {
				PHASE: "RUN",
				uri: self.image.url
			};

			if ( !self.image.url )
			{
				ErrorDialog.open('ZScale can\'t find image url');
			}

			zScaleButton.startAnimation();
			UWSManager.post('zscale', params, {
				successCallback: function(response)
				{
					zScaleButton.stopAnimation();
					var z1 = parseFloat(response.results.result[0]['@xlink:href']);
					var z2 = parseFloat(response.results.result[1]['@xlink:href']);

					self.$element.find( "#min" ).val( z1 ).animate({ color: '#6BCAFF', 'border-color': '#6BCAFF' }, 300, function(){
						$(this).animate({color: '#F8A102', 'border-color': 'transparent'});
					});
					self.$element.find( "#max" ).val( z2 ).animate({ color: '#6BCAFF', 'border-color': '#6BCAFF' }, 300, function(){
						$(this).animate({color: '#F8A102', 'border-color': 'transparent'});
					});

					self.updateThreshold(z1,z2);
				},
				failCallback: function()
				{
					zScaleButton.stopAnimation();
					ErrorDialog.open("ZScale internal server error<br/>");
				}
			});
		}
	});

	// Create histogram attached to the canvas2d
	this.histogram = new Histogram({
		canvas: 'histogram_'+this.id,
		nbBeans: 256,
		onUpdate: $.proxy(this.updateThreshold, this)
	});

	// Set image if defined
	if ( options.image )
	{
		options.image.colormap = "grey";
		this.setImage(options.image);
	}
}

/**************************************************************************************************************/

/**
 *	Enable all UI elements
 */
DynamicImageView.prototype.enableUI = function()
{
	this.$element.find('.colormap').selectmenu( "enable" );
	this.$element.find('.thresholdSlider').slider( "enable" );
	this.$element.find('.inverse').removeAttr('disabled').button("refresh");
	this.$element.find('.zScale').removeAttr('disabled').button("refresh");
	this.$element.find('.thresholdInputs input').each(function(i){
		$(this).removeAttr('disabled');
	});
}

/**************************************************************************************************************/

/**
 *	Disable all UI elements
 */
DynamicImageView.prototype.disableUI = function()
{
	this.$element.find('.colormap').selectmenu( "disable" );
	this.$element.find('.thresholdSlider').slider( "disable" );
	this.$element.find('.inverse').attr('disabled', 'disabled').button("refresh");
	this.$element.find('.zScale').attr('disabled', 'disabled').button("refresh");
	this.$element.find('.thresholdInputs input').each(function(i){
		$(this).attr('disabled', 'disabled');
	});
}

/**************************************************************************************************************/

/**
 *	Update threshold
 */
DynamicImageView.prototype.updateThreshold = function(min, max)
{
	this.image.tmin = min;
	this.image.tmax = max;

	this.$element.find( "#min" ).val( min );
	this.$element.find( "#max" ).val( max );

	// Update slider
	this.$element.find('.thresholdSlider').slider({
		values: [min, max]
	});

	this.histogram.compute();
	this.render();
}

/**************************************************************************************************************/

/**
 *	Set image and update image related composants(histogram, slider, placeholder)
 */
DynamicImageView.prototype.setImage = function(image)
{
	var step = (image.max-image.min)/1000;
	var self = this;
	this.$element.find('.thresholdSlider').slider('option', {
		values: [image.min, image.max],
		min: image.min,
		max: image.max,
		step: step
	});

	this.histogram.setImage(image);

	// Put min/max values into placeholder
	// Maybe not the most ergonomic way to do, but I found it cool J
	this.$element.find('#min').attr("placeholder", image.min).end()
				 .find('#max').attr("placeholder", image.max);
	
	// Update UI values
	this.$element.find('.inverse').attr('checked', (image.inverse) ? 'checked' : false).button('refresh').end()
				 .find('.contrast')
					.find('input[value='+image.transferFn+']').attr('checked','checked').end()
				 .buttonset("refresh").end()
				 .find('.colormap').val(image.colormap).selectmenu();

	if( image.transferFn == "raw" )
	{
		this.disableUI();
	}
	else
	{
		this.enableUI();
	}

	this.image = image;
	this.updateThreshold(image.tmin, image.tmax);
	this.render();
}

/**************************************************************************************************************/

/**
 *	Remove view
 */
DynamicImageView.prototype.remove = function()
{
	this.image.dispose();
}

/**************************************************************************************************************/

/**
 *	Render
 */
DynamicImageView.prototype.render = function()
{
	this.histogram.draw();
	this.image.renderContext.requestFrame();
}

/**************************************************************************************************************/

return DynamicImageView;


});
/******************************************************************************* 
* Copyright 2012, 2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES 
* 
* This file is part of SITools2. 
* 
* SITools2 is free software: you can redistribute it and/or modify 
* it under the terms of the GNU General Public License as published by 
* the Free Software Foundation, either version 3 of the License, or 
* (at your option) any later version. 
* 
* SITools2 is distributed in the hope that it will be useful, 
* but WITHOUT ANY WARRANTY; without even the implied warranty of 
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
* GNU General Public License for more details. 
* 
* You should have received a copy of the GNU General Public License 
* along with SITools2. If not, see <http://www.gnu.org/licenses/>. 
******************************************************************************/ 

/**
 *	ImageProcessing module
 */
define('ImageProcessing', [ "jquery", "./SelectionTool", "./CutOutViewFactory", "./DynamicImageView", "gw/FeatureStyle", "jquery.ui" ],
		function($, SelectionTool, CutOutViewFactory, DynamicImageView, FeatureStyle) {

/**************************************************************************************************************/

var feature;
var layer;
var disable;
var unselect;
var $dialog;
var histogramElement;
var cutOutElement;

/**************************************************************************************************************/

/**
 *	Toggle visibility of dialog
 */
function toggle()
{
	if ( $dialog.dialog( "isOpen" ) )
	{
		$dialog.dialog("close");
	}
	else
	{
		$dialog.dialog("open");
	}
}

/**************************************************************************************************************/

/**
 *	Remove view
 */
function remove()
{
	if ( unselect )
	{
		unselect();
	}

	if( disable )
	{
		disable();
	}

	if ( histogramElement )
		histogramElement.remove();

	CutOutViewFactory.removeView(cutOutElement);
	$dialog.remove();
}

/**************************************************************************************************************/

/**
 *	Set data to process
 *
 *	@param selectedData Object containing feature and layer extracted by <PickingManager>
 */
function setData(selectedData)
{
    if ( feature && feature.properties.identifier == selectedData.feature.properties.identifier )
    {
        this.toggle();
    }
    else
    {
       if ( !$dialog.dialog( "isOpen" ) )
       {
            this.toggle();
       }
    }
    
    feature = selectedData.feature;
	layer = selectedData.layer;

	if ( selectedData.feature.services )
	{
    	cutOutElement.setUrl(selectedData.feature.services.download.url);
    }
	else
	{
		// TODO : disable cutOutElement if feature's url isn't defined
	}

    var image = selectedData.feature.properties.style.uniformValues;
	if ( !image )
    {
        $dialog.find('.histogramContent').children('div').fadeOut(function(){
				$(this).siblings('p').fadeIn();
		});
    }
    else
    {
    	this.setImage(image);
    }
}

/**************************************************************************************************************/

return {

	/**
	 *	Init
	 *
	 *	@param options
	 *		<ul>
	 *			<li>feature: The feature to process
	 *			<li>layer: The layer to which the feature belongs to
	 *			<li>disable: Disable callback</li>
	 *			<li>unselect: Unselect callback</li>
	 *		</ul>
	 */
	init: function(options)
	{
		if ( options )
		{
			//this.id = options.id;
			feature = options.feature || null;
			layer = options.layer || null;

			// Callbacks
			disable = options.disable || null;
			unselect = options.unselect || null;
		}

		var dialog =
			'<div>\
				<div class="imageProcessing" id="imageProcessing" title="Image processing">\
					<h3>Histogram</h3>\
					<div class="histogramContent">\
						<p> Fits isn\'t loaded, thus histogram information isn\'t available</p>\
						<div style="display: none;" id="histogramView"></div>\
					</div>\
					<h3>Cutout</h3>\
					<div id="cutOutView"></div>\
				</div>\
			</div>';

		$dialog = $(dialog).appendTo('body').dialog({
			title: 'Image processing',
			autoOpen: false,
			show: {
				effect: "fade",
				duration: 300
			},
			hide: {
				effect: "fade",
				duration: 300
			},
			width: 500,
			resizable: false,
			minHeight: 'auto',
			close: function(event, ui)
			{
				if ( unselect )
				{
					unselect();
				}
				
				$(this).dialog("close");

			}
		}).find(".imageProcessing").accordion({
			autoHeight: false,
			active: 0,
			collapsible: true,
			heightStyle: "content"
		}).end();

		histogramElement = new DynamicImageView( "histogramView", {
			id: "featureImageProcessing",
			changeShaderCallback: function(contrast){
				if ( contrast == "raw" )
				{
					var targetStyle = new FeatureStyle( feature.properties.style );
					targetStyle.fillShader = {
						fragmentCode: null,
						updateUniforms: null
					};
					layer.modifyFeatureStyle( feature, targetStyle );
				}
				else
				{
					var targetStyle = new FeatureStyle( feature.properties.style );
					targetStyle.fillShader = {
						fragmentCode: this.image.fragmentCode,
						updateUniforms: this.image.updateUniforms
					};
					layer.modifyFeatureStyle( feature, targetStyle );
				}
			}
		})
		cutOutElement = CutOutViewFactory.addView("cutOutView");
	},

	setData: setData,
	setImage: function(image)
	{
		histogramElement.setImage(image);
		if ( image.url )
		{
			cutOutElement.setUrl(image.url);
		}
		
		$dialog.find('.histogramContent').children('p').fadeOut(function(){
			$(this).siblings('div').fadeIn();
		});
	},
	toggle: toggle,
	isOpened: function()
	{
		return $dialog.dialog( "isOpen" );
	},
	removeData: function(data)
	{
		if ( feature && data.feature.properties.identifier == feature.properties.identifier )
		{
			if ( this.isOpened() )
			{
				this.toggle();
			}
			$dialog.find('.histogramContent').children('div').fadeOut(function(){
				$(this).siblings('p').fadeIn();
			});
			feature = null;
			layer = null;
		}
	}
};

});
define('text!../templates/featureList.html',[],function () { return '<div id="overlappedObjects">\n\t<% if ( selection.length > 1 ) {%>\n\t\t<u>Overlapped observations:</u><br/>\n\t<% } else { %>\n\t\t<u>Object:</u><br/>\n\t<% } %>\n\t<div id="scroll-arrow-up" style="display: none" class="scroll-arrow-up"></div>\n\t<div id="featureListDiv">\n\t\t<div id="featureList">\n\t\t\t<%\n\t\t\tvar title = "";\n\t\t\tfor ( var i=0; i<selection.length; i++ )\n\t\t\t{ \n\t\t\t\tvar properties = selection[i].feature.properties;\n\t\t\t\ttitle = ( properties.title ) ? properties.title : properties.identifier;\n\t\t\t%>\n\t\t\t\t<div title=<%= title %> class="featureTitle"> <%= title %> <br/></div>\n\t\t\t<%\n\t\t\t}\n\t\t\t%>\n\t\t</div>\n\t</div>\n\t<div id="scroll-arrow-down" style="display: none" class="scroll-arrow-down clickable"></div>\n</div>';});

define('text!../templates/featureDescription.html',[],function () { return '<div class="detailedInfo">\n\t<% if ( properties.thumbnail ) \n\t{ %>\n\t\t<div class="thumbnail"><img src="<%= properties.thumbnail %>" /></div>\n\t<% } %>\n\t<div class="featureProperties">\n\t\t<table class="propertiesTable" rules="rows">\n\t\t\t<tbody>\n\t\t\t\t<% print(descriptionTableTemplate( { properties: properties, descriptionTableTemplate: descriptionTableTemplate, dictionary: dictionary }) ); %>\n\t\t\t</tbody>\n\t\t</table>\n\t</div>\n\t\n\t<% if ( services ) {\n\t%>\n\t\t<div id="services">\n\t\t\t<%\n\t\t\tif ( properties.quicklook ) { %>\n\t\t\t\t<span class="featureService" title="Quicklook" id=\'quicklook\' class=<%= (properties.style.fillTextureUrl && properties.style.fill ? \'selected\' : \'\' ) %> ></span>\n\t\t\t<% } %>\n\n\t\t\t<% if ( services )\n\t\t\t{\n\t\t\t\tif ( services.download )\n\t\t\t\t{\n\t\t\t\t\tif ( services.download.mimetype == "image/fits" )\n\t\t\t\t\t{\n\t\t\t\t\t\tif ( !isMobile ) \n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvar fitsQuicklookOn = properties.style.fill && !properties.style.fillTextureUrl;\n\t\t\t\t\t\t\t%>\n\t\t\t\t\t\t\t<span class="featureService" title="Fits quicklook" id=\'quicklookFits\' class=<%= (fitsQuicklookOn ? \'selected\' : \'\' ) %> ></span>\n\t\t\t\t\t\t<% } %>\n\t\t\t\t\t\t<span style="display: inline-block; position: relative;">\n\t\t\t\t\t\t\t<span class="featureService" title="Solar object service" id="solarObjects" class=<%= (services.solarObjects && services.solarObjects.layer.visible() ? \'selected\' : \'\' ) %>></span>\n\t\t\t\t\t\t\t<div style="display: none" id="solarObjectsSpinner"></div>\n\t\t\t\t\t\t</span>\n\t\t\t\t\t\t<span title="Image processing" id="dynamicImageView" class=\'dynamicAvailable\' />\n\t\t\t\t\t\t<span class="featureService" title="Export image by SAMP" id="sendImage"></span>\n\t\t\t\t\t<%\n\t\t\t\t\t}\n\t\t\t\t \t%>\n\t\t\t\t\t<a href="<%= services ? services.download.url : "" %>" target="_self" download><span class="featureService" id="downloadImage" title="Download"></span></a>\n\t\t\t\t\t<%\n\t\t\t\t}\n\t\t\t\tif ( services.healpix ) { %>\n\t\t\t\t\t<span class="featureService" title="Healpix service" id=\'healpix\' class=<%= (services.healpix.layer.visible() ? \'selected\' : \'\' ) %> ></span>\n\t\t\t\t<% }\n\t\t\t} %>\n\t\t\t<div style="display: none;" id="serviceStatus"></div>\n\t\t</div>\n\t<% } %>\n\n</div>';});

define('text!../templates/descriptionTable.html',[],function () { return '<% for ( var key in properties )\n{ \n\tif ( key != \'style\' && key != \'title\' && key != \'quicklook\' && key != \'thumbnail\' )\n\t{\t\n\t\tvar stringKey = key.toString(); %>\n\t<tr height="30%">\n\t\t<% // Test if section\n\t\tvar title = dictionary[stringKey];\n\t\tif (typeof (properties[key]) === "object" )\n\t\t{\t\n\t\t\tif ( key == \'crs\' )\n\t\t\t{%>\n\t\t\t\t<td id="<%=stringKey%>" title="<%= title%>" class="selectProperty"><em><%= stringKey %>:</em></td>\n\t\t\t\t<td title="<%= properties[key].properties.name %>" class="selectValue"><%= properties[key].properties.name %></td>\n\t\t\t<% } else { %>\n\t\t\t\t<td  id="<%=stringKey%>" title="<%= title%>" class="selectProperty" colspan="2">\n\t\t\t\t\t<div id="arrow" class="arrow-right"></div><div class="section"><b><%= stringKey %></b></div>\n\t\t\t\t\t<table class="propertiesTable" style="display: none; margin-left: 10px" rules="rows">\n\t\t\t\t\t\t<tbody>\n\t\t\t\t\t\t\t<% print( descriptionTableTemplate( { dictionary: dictionary, properties: properties[key], descriptionTableTemplate: descriptionTableTemplate }) );\n\t\t\t\t\t\t\t %>\n\t\t\t\t\t\t</tbody>\n\t\t\t\t\t</table>\n\t\t\t\t</td>\n\t\t<%\t}\n\t\t}\n\t\telse\n\t\t{%>\n\t\t\t<td  id="<%=stringKey%>" title="<%= title%>" class="selectProperty"><em><%= stringKey %>:</em></td>\n\t\t\t<% \n\t\t\tvar isUrl = ( typeof (properties[key]) === "string" && properties[key].substr(0,4) == \'http\' ) ? true : false;\n\t\t\tif (isUrl) {%>\n\t\t\t\t<td class="selectValue"><a href="<%= properties[key] %>"><%= properties[key] %></a></td>\n\t\t\t<% } else { %>\n\t\t\t\t<td class="selectValue" title="<%= properties[key] %>"><%= properties[key] %></td>\n\t\t\t<% }\n\t\t} %>\n\t</tr>\n\t<% }\n} %>';});

/* jquery.nicescroll 3.5.4 InuYaksa*2013 MIT http://areaaperta.com/nicescroll */(function(e){"function"===typeof define&&define.amd?define('jquery.nicescroll.min',["jquery"],e):e(jQuery)})(function(e){var y=!1,C=!1,J=5E3,K=2E3,x=0,F=["ms","moz","webkit","o"],s=window.requestAnimationFrame||!1,v=window.cancelAnimationFrame||!1;if(!s)for(var L in F){var D=F[L];s||(s=window[D+"RequestAnimationFrame"]);v||(v=window[D+"CancelAnimationFrame"]||window[D+"CancelRequestAnimationFrame"])}var z=window.MutationObserver||window.WebKitMutationObserver||!1,G={zindex:"auto",cursoropacitymin:0,cursoropacitymax:1,cursorcolor:"#424242",
cursorwidth:"5px",cursorborder:"1px solid #fff",cursorborderradius:"5px",scrollspeed:60,mousescrollstep:24,touchbehavior:!1,hwacceleration:!0,usetransition:!0,boxzoom:!1,dblclickzoom:!0,gesturezoom:!0,grabcursorenabled:!0,autohidemode:!0,background:"",iframeautoresize:!0,cursorminheight:32,preservenativescrolling:!0,railoffset:!1,bouncescroll:!0,spacebarenabled:!0,railpadding:{top:0,right:0,left:0,bottom:0},disableoutline:!0,horizrailenabled:!0,railalign:"right",railvalign:"bottom",enabletranslate3d:!0,
enablemousewheel:!0,enablekeyboard:!0,smoothscroll:!0,sensitiverail:!0,enablemouselockapi:!0,cursorfixedheight:!1,directionlockdeadzone:6,hidecursordelay:400,nativeparentscrolling:!0,enablescrollonselection:!0,overflowx:!0,overflowy:!0,cursordragspeed:0.3,rtlmode:"auto",cursordragontouch:!1,oneaxismousemode:"auto",scriptpath:function(){var e=document.getElementsByTagName("script"),e=e[e.length-1].src.split("?")[0];return 0<e.split("/").length?e.split("/").slice(0,-1).join("/")+"/":""}()},E=!1,M=function(){if(E)return E;
var e=document.createElement("DIV"),b={haspointerlock:"pointerLockElement"in document||"mozPointerLockElement"in document||"webkitPointerLockElement"in document};b.isopera="opera"in window;b.isopera12=b.isopera&&"getUserMedia"in navigator;b.isoperamini="[object OperaMini]"===Object.prototype.toString.call(window.operamini);b.isie="all"in document&&"attachEvent"in e&&!b.isopera;b.isieold=b.isie&&!("msInterpolationMode"in e.style);b.isie7=b.isie&&!b.isieold&&(!("documentMode"in document)||7==document.documentMode);
b.isie8=b.isie&&"documentMode"in document&&8==document.documentMode;b.isie9=b.isie&&"performance"in window&&9<=document.documentMode;b.isie10=b.isie&&"performance"in window&&10<=document.documentMode;b.isie9mobile=/iemobile.9/i.test(navigator.userAgent);b.isie9mobile&&(b.isie9=!1);b.isie7mobile=!b.isie9mobile&&b.isie7&&/iemobile/i.test(navigator.userAgent);b.ismozilla="MozAppearance"in e.style;b.iswebkit="WebkitAppearance"in e.style;b.ischrome="chrome"in window;b.ischrome22=b.ischrome&&b.haspointerlock;
b.ischrome26=b.ischrome&&"transition"in e.style;b.cantouch="ontouchstart"in document.documentElement||"ontouchstart"in window;b.hasmstouch=window.navigator.msPointerEnabled||!1;b.ismac=/^mac$/i.test(navigator.platform);b.isios=b.cantouch&&/iphone|ipad|ipod/i.test(navigator.platform);b.isios4=b.isios&&!("seal"in Object);b.isandroid=/android/i.test(navigator.userAgent);b.trstyle=!1;b.hastransform=!1;b.hastranslate3d=!1;b.transitionstyle=!1;b.hastransition=!1;b.transitionend=!1;for(var h=["transform",
"msTransform","webkitTransform","MozTransform","OTransform"],k=0;k<h.length;k++)if("undefined"!=typeof e.style[h[k]]){b.trstyle=h[k];break}b.hastransform=!1!=b.trstyle;b.hastransform&&(e.style[b.trstyle]="translate3d(1px,2px,3px)",b.hastranslate3d=/translate3d/.test(e.style[b.trstyle]));b.transitionstyle=!1;b.prefixstyle="";b.transitionend=!1;for(var h="transition webkitTransition MozTransition OTransition OTransition msTransition KhtmlTransition".split(" "),l=" -webkit- -moz- -o- -o -ms- -khtml-".split(" "),
q="transitionend webkitTransitionEnd transitionend otransitionend oTransitionEnd msTransitionEnd KhtmlTransitionEnd".split(" "),k=0;k<h.length;k++)if(h[k]in e.style){b.transitionstyle=h[k];b.prefixstyle=l[k];b.transitionend=q[k];break}b.ischrome26&&(b.prefixstyle=l[1]);b.hastransition=b.transitionstyle;a:{h=["-moz-grab","-webkit-grab","grab"];if(b.ischrome&&!b.ischrome22||b.isie)h=[];for(k=0;k<h.length;k++)if(l=h[k],e.style.cursor=l,e.style.cursor==l){h=l;break a}h="url(http://www.google.com/intl/en_ALL/mapfiles/openhand.cur),n-resize"}b.cursorgrabvalue=
h;b.hasmousecapture="setCapture"in e;b.hasMutationObserver=!1!==z;return E=b},N=function(g,b){function h(){var c=a.win;if("zIndex"in c)return c.zIndex();for(;0<c.length&&9!=c[0].nodeType;){var b=c.css("zIndex");if(!isNaN(b)&&0!=b)return parseInt(b);c=c.parent()}return!1}function k(c,b,f){b=c.css(b);c=parseFloat(b);return isNaN(c)?(c=w[b]||0,f=3==c?f?a.win.outerHeight()-a.win.innerHeight():a.win.outerWidth()-a.win.innerWidth():1,a.isie8&&c&&(c+=1),f?c:0):c}function l(c,b,f,e){a._bind(c,b,function(a){a=
a?a:window.event;var e={original:a,target:a.target||a.srcElement,type:"wheel",deltaMode:"MozMousePixelScroll"==a.type?0:1,deltaX:0,deltaZ:0,preventDefault:function(){a.preventDefault?a.preventDefault():a.returnValue=!1;return!1},stopImmediatePropagation:function(){a.stopImmediatePropagation?a.stopImmediatePropagation():a.cancelBubble=!0}};"mousewheel"==b?(e.deltaY=-0.025*a.wheelDelta,a.wheelDeltaX&&(e.deltaX=-0.025*a.wheelDeltaX)):e.deltaY=a.detail;return f.call(c,e)},e)}function q(c,b,f){var e,d;
0==c.deltaMode?(e=-Math.floor(c.deltaX*(a.opt.mousescrollstep/54)),d=-Math.floor(c.deltaY*(a.opt.mousescrollstep/54))):1==c.deltaMode&&(e=-Math.floor(c.deltaX*a.opt.mousescrollstep),d=-Math.floor(c.deltaY*a.opt.mousescrollstep));b&&(a.opt.oneaxismousemode&&0==e&&d)&&(e=d,d=0);e&&(a.scrollmom&&a.scrollmom.stop(),a.lastdeltax+=e,a.debounced("mousewheelx",function(){var c=a.lastdeltax;a.lastdeltax=0;a.rail.drag||a.doScrollLeftBy(c)},15));if(d){if(a.opt.nativeparentscrolling&&f&&!a.ispage&&!a.zoomactive)if(0>
d){if(a.getScrollTop()>=a.page.maxh)return!0}else if(0>=a.getScrollTop())return!0;a.scrollmom&&a.scrollmom.stop();a.lastdeltay+=d;a.debounced("mousewheely",function(){var c=a.lastdeltay;a.lastdeltay=0;a.rail.drag||a.doScrollBy(c)},15)}c.stopImmediatePropagation();return c.preventDefault()}var a=this;this.version="3.5.4";this.name="nicescroll";this.me=b;this.opt={doc:e("body"),win:!1};e.extend(this.opt,G);this.opt.snapbackspeed=80;if(g)for(var p in a.opt)"undefined"!=typeof g[p]&&(a.opt[p]=g[p]);this.iddoc=
(this.doc=a.opt.doc)&&this.doc[0]?this.doc[0].id||"":"";this.ispage=/^BODY|HTML/.test(a.opt.win?a.opt.win[0].nodeName:this.doc[0].nodeName);this.haswrapper=!1!==a.opt.win;this.win=a.opt.win||(this.ispage?e(window):this.doc);this.docscroll=this.ispage&&!this.haswrapper?e(window):this.win;this.body=e("body");this.iframe=this.isfixed=this.viewport=!1;this.isiframe="IFRAME"==this.doc[0].nodeName&&"IFRAME"==this.win[0].nodeName;this.istextarea="TEXTAREA"==this.win[0].nodeName;this.forcescreen=!1;this.canshowonmouseevent=
"scroll"!=a.opt.autohidemode;this.page=this.view=this.onzoomout=this.onzoomin=this.onscrollcancel=this.onscrollend=this.onscrollstart=this.onclick=this.ongesturezoom=this.onkeypress=this.onmousewheel=this.onmousemove=this.onmouseup=this.onmousedown=!1;this.scroll={x:0,y:0};this.scrollratio={x:0,y:0};this.cursorheight=20;this.scrollvaluemax=0;this.observerremover=this.observer=this.scrollmom=this.scrollrunning=this.isrtlmode=!1;do this.id="ascrail"+K++;while(document.getElementById(this.id));this.hasmousefocus=
this.hasfocus=this.zoomactive=this.zoom=this.selectiondrag=this.cursorfreezed=this.cursor=this.rail=!1;this.visibility=!0;this.hidden=this.locked=!1;this.cursoractive=!0;this.wheelprevented=!1;this.overflowx=a.opt.overflowx;this.overflowy=a.opt.overflowy;this.nativescrollingarea=!1;this.checkarea=0;this.events=[];this.saved={};this.delaylist={};this.synclist={};this.lastdeltay=this.lastdeltax=0;this.detected=M();var d=e.extend({},this.detected);this.ishwscroll=(this.canhwscroll=d.hastransform&&a.opt.hwacceleration)&&
a.haswrapper;this.istouchcapable=!1;d.cantouch&&(d.ischrome&&!d.isios&&!d.isandroid)&&(this.istouchcapable=!0,d.cantouch=!1);d.cantouch&&(d.ismozilla&&!d.isios&&!d.isandroid)&&(this.istouchcapable=!0,d.cantouch=!1);a.opt.enablemouselockapi||(d.hasmousecapture=!1,d.haspointerlock=!1);this.delayed=function(c,b,f,e){var d=a.delaylist[c],h=(new Date).getTime();if(!e&&d&&d.tt)return!1;d&&d.tt&&clearTimeout(d.tt);if(d&&d.last+f>h&&!d.tt)a.delaylist[c]={last:h+f,tt:setTimeout(function(){a&&(a.delaylist[c].tt=
0,b.call())},f)};else if(!d||!d.tt)a.delaylist[c]={last:h,tt:0},setTimeout(function(){b.call()},0)};this.debounced=function(c,b,f){var d=a.delaylist[c];(new Date).getTime();a.delaylist[c]=b;d||setTimeout(function(){var b=a.delaylist[c];a.delaylist[c]=!1;b.call()},f)};var r=!1;this.synched=function(c,b){a.synclist[c]=b;(function(){r||(s(function(){r=!1;for(c in a.synclist){var b=a.synclist[c];b&&b.call(a);a.synclist[c]=!1}}),r=!0)})();return c};this.unsynched=function(c){a.synclist[c]&&(a.synclist[c]=
!1)};this.css=function(c,b){for(var f in b)a.saved.css.push([c,f,c.css(f)]),c.css(f,b[f])};this.scrollTop=function(c){return"undefined"==typeof c?a.getScrollTop():a.setScrollTop(c)};this.scrollLeft=function(c){return"undefined"==typeof c?a.getScrollLeft():a.setScrollLeft(c)};BezierClass=function(a,b,f,d,e,h,k){this.st=a;this.ed=b;this.spd=f;this.p1=d||0;this.p2=e||1;this.p3=h||0;this.p4=k||1;this.ts=(new Date).getTime();this.df=this.ed-this.st};BezierClass.prototype={B2:function(a){return 3*a*a*(1-
a)},B3:function(a){return 3*a*(1-a)*(1-a)},B4:function(a){return(1-a)*(1-a)*(1-a)},getNow:function(){var a=1-((new Date).getTime()-this.ts)/this.spd,b=this.B2(a)+this.B3(a)+this.B4(a);return 0>a?this.ed:this.st+Math.round(this.df*b)},update:function(a,b){this.st=this.getNow();this.ed=a;this.spd=b;this.ts=(new Date).getTime();this.df=this.ed-this.st;return this}};if(this.ishwscroll){this.doc.translate={x:0,y:0,tx:"0px",ty:"0px"};d.hastranslate3d&&d.isios&&this.doc.css("-webkit-backface-visibility",
"hidden");var t=function(){var c=a.doc.css(d.trstyle);return c&&"matrix"==c.substr(0,6)?c.replace(/^.*\((.*)\)$/g,"$1").replace(/px/g,"").split(/, +/):!1};this.getScrollTop=function(c){if(!c){if(c=t())return 16==c.length?-c[13]:-c[5];if(a.timerscroll&&a.timerscroll.bz)return a.timerscroll.bz.getNow()}return a.doc.translate.y};this.getScrollLeft=function(c){if(!c){if(c=t())return 16==c.length?-c[12]:-c[4];if(a.timerscroll&&a.timerscroll.bh)return a.timerscroll.bh.getNow()}return a.doc.translate.x};
this.notifyScrollEvent=document.createEvent?function(a){var b=document.createEvent("UIEvents");b.initUIEvent("scroll",!1,!0,window,1);a.dispatchEvent(b)}:document.fireEvent?function(a){var b=document.createEventObject();a.fireEvent("onscroll");b.cancelBubble=!0}:function(a,b){};d.hastranslate3d&&a.opt.enabletranslate3d?(this.setScrollTop=function(c,b){a.doc.translate.y=c;a.doc.translate.ty=-1*c+"px";a.doc.css(d.trstyle,"translate3d("+a.doc.translate.tx+","+a.doc.translate.ty+",0px)");b||a.notifyScrollEvent(a.win[0])},
this.setScrollLeft=function(c,b){a.doc.translate.x=c;a.doc.translate.tx=-1*c+"px";a.doc.css(d.trstyle,"translate3d("+a.doc.translate.tx+","+a.doc.translate.ty+",0px)");b||a.notifyScrollEvent(a.win[0])}):(this.setScrollTop=function(c,b){a.doc.translate.y=c;a.doc.translate.ty=-1*c+"px";a.doc.css(d.trstyle,"translate("+a.doc.translate.tx+","+a.doc.translate.ty+")");b||a.notifyScrollEvent(a.win[0])},this.setScrollLeft=function(c,b){a.doc.translate.x=c;a.doc.translate.tx=-1*c+"px";a.doc.css(d.trstyle,
"translate("+a.doc.translate.tx+","+a.doc.translate.ty+")");b||a.notifyScrollEvent(a.win[0])})}else this.getScrollTop=function(){return a.docscroll.scrollTop()},this.setScrollTop=function(c){return a.docscroll.scrollTop(c)},this.getScrollLeft=function(){return a.docscroll.scrollLeft()},this.setScrollLeft=function(c){return a.docscroll.scrollLeft(c)};this.getTarget=function(a){return!a?!1:a.target?a.target:a.srcElement?a.srcElement:!1};this.hasParent=function(a,b){if(!a)return!1;for(var f=a.target||
a.srcElement||a||!1;f&&f.id!=b;)f=f.parentNode||!1;return!1!==f};var w={thin:1,medium:3,thick:5};this.getOffset=function(){if(a.isfixed)return{top:parseFloat(a.win.css("top")),left:parseFloat(a.win.css("left"))};if(!a.viewport)return a.win.offset();var c=a.win.offset(),b=a.viewport.offset();return{top:c.top-b.top+a.viewport.scrollTop(),left:c.left-b.left+a.viewport.scrollLeft()}};this.updateScrollBar=function(c){if(a.ishwscroll)a.rail.css({height:a.win.innerHeight()}),a.railh&&a.railh.css({width:a.win.innerWidth()});
else{var b=a.getOffset(),f=b.top,d=b.left,f=f+k(a.win,"border-top-width",!0);a.win.outerWidth();a.win.innerWidth();var d=d+(a.rail.align?a.win.outerWidth()-k(a.win,"border-right-width")-a.rail.width:k(a.win,"border-left-width")),e=a.opt.railoffset;e&&(e.top&&(f+=e.top),a.rail.align&&e.left&&(d+=e.left));a.locked||a.rail.css({top:f,left:d,height:c?c.h:a.win.innerHeight()});a.zoom&&a.zoom.css({top:f+1,left:1==a.rail.align?d-20:d+a.rail.width+4});a.railh&&!a.locked&&(f=b.top,d=b.left,c=a.railh.align?
f+k(a.win,"border-top-width",!0)+a.win.innerHeight()-a.railh.height:f+k(a.win,"border-top-width",!0),d+=k(a.win,"border-left-width"),a.railh.css({top:c,left:d,width:a.railh.width}))}};this.doRailClick=function(c,b,f){var d;a.locked||(a.cancelEvent(c),b?(b=f?a.doScrollLeft:a.doScrollTop,d=f?(c.pageX-a.railh.offset().left-a.cursorwidth/2)*a.scrollratio.x:(c.pageY-a.rail.offset().top-a.cursorheight/2)*a.scrollratio.y,b(d)):(b=f?a.doScrollLeftBy:a.doScrollBy,d=f?a.scroll.x:a.scroll.y,c=f?c.pageX-a.railh.offset().left:
c.pageY-a.rail.offset().top,f=f?a.view.w:a.view.h,d>=c?b(f):b(-f)))};a.hasanimationframe=s;a.hascancelanimationframe=v;a.hasanimationframe?a.hascancelanimationframe||(v=function(){a.cancelAnimationFrame=!0}):(s=function(a){return setTimeout(a,15-Math.floor(+new Date/1E3)%16)},v=clearInterval);this.init=function(){a.saved.css=[];if(d.isie7mobile||d.isoperamini)return!0;d.hasmstouch&&a.css(a.ispage?e("html"):a.win,{"-ms-touch-action":"none"});a.zindex="auto";a.zindex=!a.ispage&&"auto"==a.opt.zindex?
h()||"auto":a.opt.zindex;!a.ispage&&"auto"!=a.zindex&&a.zindex>x&&(x=a.zindex);a.isie&&(0==a.zindex&&"auto"==a.opt.zindex)&&(a.zindex="auto");if(!a.ispage||!d.cantouch&&!d.isieold&&!d.isie9mobile){var c=a.docscroll;a.ispage&&(c=a.haswrapper?a.win:a.doc);d.isie9mobile||a.css(c,{"overflow-y":"hidden"});a.ispage&&d.isie7&&("BODY"==a.doc[0].nodeName?a.css(e("html"),{"overflow-y":"hidden"}):"HTML"==a.doc[0].nodeName&&a.css(e("body"),{"overflow-y":"hidden"}));d.isios&&(!a.ispage&&!a.haswrapper)&&a.css(e("body"),
{"-webkit-overflow-scrolling":"touch"});var b=e(document.createElement("div"));b.css({position:"relative",top:0,"float":"right",width:a.opt.cursorwidth,height:"0px","background-color":a.opt.cursorcolor,border:a.opt.cursorborder,"background-clip":"padding-box","-webkit-border-radius":a.opt.cursorborderradius,"-moz-border-radius":a.opt.cursorborderradius,"border-radius":a.opt.cursorborderradius});b.hborder=parseFloat(b.outerHeight()-b.innerHeight());a.cursor=b;var f=e(document.createElement("div"));
f.attr("id",a.id);f.addClass("nicescroll-rails");var u,k,g=["left","right"],l;for(l in g)k=g[l],(u=a.opt.railpadding[k])?f.css("padding-"+k,u+"px"):a.opt.railpadding[k]=0;f.append(b);f.width=Math.max(parseFloat(a.opt.cursorwidth),b.outerWidth())+a.opt.railpadding.left+a.opt.railpadding.right;f.css({width:f.width+"px",zIndex:a.zindex,background:a.opt.background,cursor:"default"});f.visibility=!0;f.scrollable=!0;f.align="left"==a.opt.railalign?0:1;a.rail=f;b=a.rail.drag=!1;a.opt.boxzoom&&(!a.ispage&&
!d.isieold)&&(b=document.createElement("div"),a.bind(b,"click",a.doZoom),a.zoom=e(b),a.zoom.css({cursor:"pointer","z-index":a.zindex,backgroundImage:"url("+a.opt.scriptpath+"zoomico.png)",height:18,width:18,backgroundPosition:"0px 0px"}),a.opt.dblclickzoom&&a.bind(a.win,"dblclick",a.doZoom),d.cantouch&&a.opt.gesturezoom&&(a.ongesturezoom=function(c){1.5<c.scale&&a.doZoomIn(c);0.8>c.scale&&a.doZoomOut(c);return a.cancelEvent(c)},a.bind(a.win,"gestureend",a.ongesturezoom)));a.railh=!1;if(a.opt.horizrailenabled){a.css(c,
{"overflow-x":"hidden"});b=e(document.createElement("div"));b.css({position:"relative",top:0,height:a.opt.cursorwidth,width:"0px","background-color":a.opt.cursorcolor,border:a.opt.cursorborder,"background-clip":"padding-box","-webkit-border-radius":a.opt.cursorborderradius,"-moz-border-radius":a.opt.cursorborderradius,"border-radius":a.opt.cursorborderradius});b.wborder=parseFloat(b.outerWidth()-b.innerWidth());a.cursorh=b;var m=e(document.createElement("div"));m.attr("id",a.id+"-hr");m.addClass("nicescroll-rails");
m.height=Math.max(parseFloat(a.opt.cursorwidth),b.outerHeight());m.css({height:m.height+"px",zIndex:a.zindex,background:a.opt.background});m.append(b);m.visibility=!0;m.scrollable=!0;m.align="top"==a.opt.railvalign?0:1;a.railh=m;a.railh.drag=!1}a.ispage?(f.css({position:"fixed",top:"0px",height:"100%"}),f.align?f.css({right:"0px"}):f.css({left:"0px"}),a.body.append(f),a.railh&&(m.css({position:"fixed",left:"0px",width:"100%"}),m.align?m.css({bottom:"0px"}):m.css({top:"0px"}),a.body.append(m))):(a.ishwscroll?
("static"==a.win.css("position")&&a.css(a.win,{position:"relative"}),c="HTML"==a.win[0].nodeName?a.body:a.win,a.zoom&&(a.zoom.css({position:"absolute",top:1,right:0,"margin-right":f.width+4}),c.append(a.zoom)),f.css({position:"absolute",top:0}),f.align?f.css({right:0}):f.css({left:0}),c.append(f),m&&(m.css({position:"absolute",left:0,bottom:0}),m.align?m.css({bottom:0}):m.css({top:0}),c.append(m))):(a.isfixed="fixed"==a.win.css("position"),c=a.isfixed?"fixed":"absolute",a.isfixed||(a.viewport=a.getViewport(a.win[0])),
a.viewport&&(a.body=a.viewport,!1==/fixed|relative|absolute/.test(a.viewport.css("position"))&&a.css(a.viewport,{position:"relative"})),f.css({position:c}),a.zoom&&a.zoom.css({position:c}),a.updateScrollBar(),a.body.append(f),a.zoom&&a.body.append(a.zoom),a.railh&&(m.css({position:c}),a.body.append(m))),d.isios&&a.css(a.win,{"-webkit-tap-highlight-color":"rgba(0,0,0,0)","-webkit-touch-callout":"none"}),d.isie&&a.opt.disableoutline&&a.win.attr("hideFocus","true"),d.iswebkit&&a.opt.disableoutline&&
a.win.css({outline:"none"}));!1===a.opt.autohidemode?(a.autohidedom=!1,a.rail.css({opacity:a.opt.cursoropacitymax}),a.railh&&a.railh.css({opacity:a.opt.cursoropacitymax})):!0===a.opt.autohidemode||"leave"===a.opt.autohidemode?(a.autohidedom=e().add(a.rail),d.isie8&&(a.autohidedom=a.autohidedom.add(a.cursor)),a.railh&&(a.autohidedom=a.autohidedom.add(a.railh)),a.railh&&d.isie8&&(a.autohidedom=a.autohidedom.add(a.cursorh))):"scroll"==a.opt.autohidemode?(a.autohidedom=e().add(a.rail),a.railh&&(a.autohidedom=
a.autohidedom.add(a.railh))):"cursor"==a.opt.autohidemode?(a.autohidedom=e().add(a.cursor),a.railh&&(a.autohidedom=a.autohidedom.add(a.cursorh))):"hidden"==a.opt.autohidemode&&(a.autohidedom=!1,a.hide(),a.locked=!1);if(d.isie9mobile)a.scrollmom=new H(a),a.onmangotouch=function(c){c=a.getScrollTop();var b=a.getScrollLeft();if(c==a.scrollmom.lastscrolly&&b==a.scrollmom.lastscrollx)return!0;var f=c-a.mangotouch.sy,d=b-a.mangotouch.sx;if(0!=Math.round(Math.sqrt(Math.pow(d,2)+Math.pow(f,2)))){var n=0>
f?-1:1,e=0>d?-1:1,h=+new Date;a.mangotouch.lazy&&clearTimeout(a.mangotouch.lazy);80<h-a.mangotouch.tm||a.mangotouch.dry!=n||a.mangotouch.drx!=e?(a.scrollmom.stop(),a.scrollmom.reset(b,c),a.mangotouch.sy=c,a.mangotouch.ly=c,a.mangotouch.sx=b,a.mangotouch.lx=b,a.mangotouch.dry=n,a.mangotouch.drx=e,a.mangotouch.tm=h):(a.scrollmom.stop(),a.scrollmom.update(a.mangotouch.sx-d,a.mangotouch.sy-f),a.mangotouch.tm=h,f=Math.max(Math.abs(a.mangotouch.ly-c),Math.abs(a.mangotouch.lx-b)),a.mangotouch.ly=c,a.mangotouch.lx=
b,2<f&&(a.mangotouch.lazy=setTimeout(function(){a.mangotouch.lazy=!1;a.mangotouch.dry=0;a.mangotouch.drx=0;a.mangotouch.tm=0;a.scrollmom.doMomentum(30)},100)))}},f=a.getScrollTop(),m=a.getScrollLeft(),a.mangotouch={sy:f,ly:f,dry:0,sx:m,lx:m,drx:0,lazy:!1,tm:0},a.bind(a.docscroll,"scroll",a.onmangotouch);else{if(d.cantouch||a.istouchcapable||a.opt.touchbehavior||d.hasmstouch){a.scrollmom=new H(a);a.ontouchstart=function(c){if(c.pointerType&&2!=c.pointerType)return!1;a.hasmoving=!1;if(!a.locked){if(d.hasmstouch)for(var b=
c.target?c.target:!1;b;){var f=e(b).getNiceScroll();if(0<f.length&&f[0].me==a.me)break;if(0<f.length)return!1;if("DIV"==b.nodeName&&b.id==a.id)break;b=b.parentNode?b.parentNode:!1}a.cancelScroll();if((b=a.getTarget(c))&&/INPUT/i.test(b.nodeName)&&/range/i.test(b.type))return a.stopPropagation(c);!("clientX"in c)&&"changedTouches"in c&&(c.clientX=c.changedTouches[0].clientX,c.clientY=c.changedTouches[0].clientY);a.forcescreen&&(f=c,c={original:c.original?c.original:c},c.clientX=f.screenX,c.clientY=
f.screenY);a.rail.drag={x:c.clientX,y:c.clientY,sx:a.scroll.x,sy:a.scroll.y,st:a.getScrollTop(),sl:a.getScrollLeft(),pt:2,dl:!1};if(a.ispage||!a.opt.directionlockdeadzone)a.rail.drag.dl="f";else{var f=e(window).width(),n=e(window).height(),h=Math.max(document.body.scrollWidth,document.documentElement.scrollWidth),k=Math.max(document.body.scrollHeight,document.documentElement.scrollHeight),n=Math.max(0,k-n),f=Math.max(0,h-f);a.rail.drag.ck=!a.rail.scrollable&&a.railh.scrollable?0<n?"v":!1:a.rail.scrollable&&
!a.railh.scrollable?0<f?"h":!1:!1;a.rail.drag.ck||(a.rail.drag.dl="f")}a.opt.touchbehavior&&(a.isiframe&&d.isie)&&(f=a.win.position(),a.rail.drag.x+=f.left,a.rail.drag.y+=f.top);a.hasmoving=!1;a.lastmouseup=!1;a.scrollmom.reset(c.clientX,c.clientY);if(!d.cantouch&&!this.istouchcapable&&!d.hasmstouch){if(!b||!/INPUT|SELECT|TEXTAREA/i.test(b.nodeName))return!a.ispage&&d.hasmousecapture&&b.setCapture(),a.opt.touchbehavior?(b.onclick&&!b._onclick&&(b._onclick=b.onclick,b.onclick=function(c){if(a.hasmoving)return!1;
b._onclick.call(this,c)}),a.cancelEvent(c)):a.stopPropagation(c);/SUBMIT|CANCEL|BUTTON/i.test(e(b).attr("type"))&&(pc={tg:b,click:!1},a.preventclick=pc)}}};a.ontouchend=function(c){if(c.pointerType&&2!=c.pointerType)return!1;if(a.rail.drag&&2==a.rail.drag.pt&&(a.scrollmom.doMomentum(),a.rail.drag=!1,a.hasmoving&&(a.lastmouseup=!0,a.hideCursor(),d.hasmousecapture&&document.releaseCapture(),!d.cantouch)))return a.cancelEvent(c)};var q=a.opt.touchbehavior&&a.isiframe&&!d.hasmousecapture;a.ontouchmove=
function(c,b){if(c.pointerType&&2!=c.pointerType)return!1;if(a.rail.drag&&2==a.rail.drag.pt){if(d.cantouch&&"undefined"==typeof c.original)return!0;a.hasmoving=!0;a.preventclick&&!a.preventclick.click&&(a.preventclick.click=a.preventclick.tg.onclick||!1,a.preventclick.tg.onclick=a.onpreventclick);c=e.extend({original:c},c);"changedTouches"in c&&(c.clientX=c.changedTouches[0].clientX,c.clientY=c.changedTouches[0].clientY);if(a.forcescreen){var f=c;c={original:c.original?c.original:c};c.clientX=f.screenX;
c.clientY=f.screenY}f=ofy=0;if(q&&!b){var n=a.win.position(),f=-n.left;ofy=-n.top}var h=c.clientY+ofy,n=h-a.rail.drag.y,k=c.clientX+f,u=k-a.rail.drag.x,g=a.rail.drag.st-n;a.ishwscroll&&a.opt.bouncescroll?0>g?g=Math.round(g/2):g>a.page.maxh&&(g=a.page.maxh+Math.round((g-a.page.maxh)/2)):(0>g&&(h=g=0),g>a.page.maxh&&(g=a.page.maxh,h=0));if(a.railh&&a.railh.scrollable){var l=a.rail.drag.sl-u;a.ishwscroll&&a.opt.bouncescroll?0>l?l=Math.round(l/2):l>a.page.maxw&&(l=a.page.maxw+Math.round((l-a.page.maxw)/
2)):(0>l&&(k=l=0),l>a.page.maxw&&(l=a.page.maxw,k=0))}f=!1;if(a.rail.drag.dl)f=!0,"v"==a.rail.drag.dl?l=a.rail.drag.sl:"h"==a.rail.drag.dl&&(g=a.rail.drag.st);else{var n=Math.abs(n),u=Math.abs(u),m=a.opt.directionlockdeadzone;if("v"==a.rail.drag.ck){if(n>m&&u<=0.3*n)return a.rail.drag=!1,!0;u>m&&(a.rail.drag.dl="f",e("body").scrollTop(e("body").scrollTop()))}else if("h"==a.rail.drag.ck){if(u>m&&n<=0.3*u)return a.rail.drag=!1,!0;n>m&&(a.rail.drag.dl="f",e("body").scrollLeft(e("body").scrollLeft()))}}a.synched("touchmove",
function(){a.rail.drag&&2==a.rail.drag.pt&&(a.prepareTransition&&a.prepareTransition(0),a.rail.scrollable&&a.setScrollTop(g),a.scrollmom.update(k,h),a.railh&&a.railh.scrollable?(a.setScrollLeft(l),a.showCursor(g,l)):a.showCursor(g),d.isie10&&document.selection.clear())});d.ischrome&&a.istouchcapable&&(f=!1);if(f)return a.cancelEvent(c)}}}a.onmousedown=function(c,b){if(!(a.rail.drag&&1!=a.rail.drag.pt)){if(a.locked)return a.cancelEvent(c);a.cancelScroll();a.rail.drag={x:c.clientX,y:c.clientY,sx:a.scroll.x,
sy:a.scroll.y,pt:1,hr:!!b};var f=a.getTarget(c);!a.ispage&&d.hasmousecapture&&f.setCapture();a.isiframe&&!d.hasmousecapture&&(a.saved.csspointerevents=a.doc.css("pointer-events"),a.css(a.doc,{"pointer-events":"none"}));a.hasmoving=!1;return a.cancelEvent(c)}};a.onmouseup=function(c){if(a.rail.drag&&(d.hasmousecapture&&document.releaseCapture(),a.isiframe&&!d.hasmousecapture&&a.doc.css("pointer-events",a.saved.csspointerevents),1==a.rail.drag.pt))return a.rail.drag=!1,a.hasmoving&&a.triggerScrollEnd(),
a.cancelEvent(c)};a.onmousemove=function(c){if(a.rail.drag&&1==a.rail.drag.pt){if(d.ischrome&&0==c.which)return a.onmouseup(c);a.cursorfreezed=!0;a.hasmoving=!0;if(a.rail.drag.hr){a.scroll.x=a.rail.drag.sx+(c.clientX-a.rail.drag.x);0>a.scroll.x&&(a.scroll.x=0);var b=a.scrollvaluemaxw;a.scroll.x>b&&(a.scroll.x=b)}else a.scroll.y=a.rail.drag.sy+(c.clientY-a.rail.drag.y),0>a.scroll.y&&(a.scroll.y=0),b=a.scrollvaluemax,a.scroll.y>b&&(a.scroll.y=b);a.synched("mousemove",function(){a.rail.drag&&1==a.rail.drag.pt&&
(a.showCursor(),a.rail.drag.hr?a.doScrollLeft(Math.round(a.scroll.x*a.scrollratio.x),a.opt.cursordragspeed):a.doScrollTop(Math.round(a.scroll.y*a.scrollratio.y),a.opt.cursordragspeed))});return a.cancelEvent(c)}};if(d.cantouch||a.opt.touchbehavior)a.onpreventclick=function(c){if(a.preventclick)return a.preventclick.tg.onclick=a.preventclick.click,a.preventclick=!1,a.cancelEvent(c)},a.bind(a.win,"mousedown",a.ontouchstart),a.onclick=d.isios?!1:function(c){return a.lastmouseup?(a.lastmouseup=!1,a.cancelEvent(c)):
!0},a.opt.grabcursorenabled&&d.cursorgrabvalue&&(a.css(a.ispage?a.doc:a.win,{cursor:d.cursorgrabvalue}),a.css(a.rail,{cursor:d.cursorgrabvalue}));else{var p=function(c){if(a.selectiondrag){if(c){var b=a.win.outerHeight();c=c.pageY-a.selectiondrag.top;0<c&&c<b&&(c=0);c>=b&&(c-=b);a.selectiondrag.df=c}0!=a.selectiondrag.df&&(a.doScrollBy(2*-Math.floor(a.selectiondrag.df/6)),a.debounced("doselectionscroll",function(){p()},50))}};a.hasTextSelected="getSelection"in document?function(){return 0<document.getSelection().rangeCount}:
"selection"in document?function(){return"None"!=document.selection.type}:function(){return!1};a.onselectionstart=function(c){a.ispage||(a.selectiondrag=a.win.offset())};a.onselectionend=function(c){a.selectiondrag=!1};a.onselectiondrag=function(c){a.selectiondrag&&a.hasTextSelected()&&a.debounced("selectionscroll",function(){p(c)},250)}}d.hasmstouch&&(a.css(a.rail,{"-ms-touch-action":"none"}),a.css(a.cursor,{"-ms-touch-action":"none"}),a.bind(a.win,"MSPointerDown",a.ontouchstart),a.bind(document,
"MSPointerUp",a.ontouchend),a.bind(document,"MSPointerMove",a.ontouchmove),a.bind(a.cursor,"MSGestureHold",function(a){a.preventDefault()}),a.bind(a.cursor,"contextmenu",function(a){a.preventDefault()}));this.istouchcapable&&(a.bind(a.win,"touchstart",a.ontouchstart),a.bind(document,"touchend",a.ontouchend),a.bind(document,"touchcancel",a.ontouchend),a.bind(document,"touchmove",a.ontouchmove));a.bind(a.cursor,"mousedown",a.onmousedown);a.bind(a.cursor,"mouseup",a.onmouseup);a.railh&&(a.bind(a.cursorh,
"mousedown",function(c){a.onmousedown(c,!0)}),a.bind(a.cursorh,"mouseup",a.onmouseup));if(a.opt.cursordragontouch||!d.cantouch&&!a.opt.touchbehavior)a.rail.css({cursor:"default"}),a.railh&&a.railh.css({cursor:"default"}),a.jqbind(a.rail,"mouseenter",function(){if(!a.win.is(":visible"))return!1;a.canshowonmouseevent&&a.showCursor();a.rail.active=!0}),a.jqbind(a.rail,"mouseleave",function(){a.rail.active=!1;a.rail.drag||a.hideCursor()}),a.opt.sensitiverail&&(a.bind(a.rail,"click",function(c){a.doRailClick(c,
!1,!1)}),a.bind(a.rail,"dblclick",function(c){a.doRailClick(c,!0,!1)}),a.bind(a.cursor,"click",function(c){a.cancelEvent(c)}),a.bind(a.cursor,"dblclick",function(c){a.cancelEvent(c)})),a.railh&&(a.jqbind(a.railh,"mouseenter",function(){if(!a.win.is(":visible"))return!1;a.canshowonmouseevent&&a.showCursor();a.rail.active=!0}),a.jqbind(a.railh,"mouseleave",function(){a.rail.active=!1;a.rail.drag||a.hideCursor()}),a.opt.sensitiverail&&(a.bind(a.railh,"click",function(c){a.doRailClick(c,!1,!0)}),a.bind(a.railh,
"dblclick",function(c){a.doRailClick(c,!0,!0)}),a.bind(a.cursorh,"click",function(c){a.cancelEvent(c)}),a.bind(a.cursorh,"dblclick",function(c){a.cancelEvent(c)})));!d.cantouch&&!a.opt.touchbehavior?(a.bind(d.hasmousecapture?a.win:document,"mouseup",a.onmouseup),a.bind(document,"mousemove",a.onmousemove),a.onclick&&a.bind(document,"click",a.onclick),!a.ispage&&a.opt.enablescrollonselection&&(a.bind(a.win[0],"mousedown",a.onselectionstart),a.bind(document,"mouseup",a.onselectionend),a.bind(a.cursor,
"mouseup",a.onselectionend),a.cursorh&&a.bind(a.cursorh,"mouseup",a.onselectionend),a.bind(document,"mousemove",a.onselectiondrag)),a.zoom&&(a.jqbind(a.zoom,"mouseenter",function(){a.canshowonmouseevent&&a.showCursor();a.rail.active=!0}),a.jqbind(a.zoom,"mouseleave",function(){a.rail.active=!1;a.rail.drag||a.hideCursor()}))):(a.bind(d.hasmousecapture?a.win:document,"mouseup",a.ontouchend),a.bind(document,"mousemove",a.ontouchmove),a.onclick&&a.bind(document,"click",a.onclick),a.opt.cursordragontouch&&
(a.bind(a.cursor,"mousedown",a.onmousedown),a.bind(a.cursor,"mousemove",a.onmousemove),a.cursorh&&a.bind(a.cursorh,"mousedown",function(c){a.onmousedown(c,!0)}),a.cursorh&&a.bind(a.cursorh,"mousemove",a.onmousemove)));a.opt.enablemousewheel&&(a.isiframe||a.bind(d.isie&&a.ispage?document:a.win,"mousewheel",a.onmousewheel),a.bind(a.rail,"mousewheel",a.onmousewheel),a.railh&&a.bind(a.railh,"mousewheel",a.onmousewheelhr));!a.ispage&&(!d.cantouch&&!/HTML|^BODY/.test(a.win[0].nodeName))&&(a.win.attr("tabindex")||
a.win.attr({tabindex:J++}),a.jqbind(a.win,"focus",function(c){y=a.getTarget(c).id||!0;a.hasfocus=!0;a.canshowonmouseevent&&a.noticeCursor()}),a.jqbind(a.win,"blur",function(c){y=!1;a.hasfocus=!1}),a.jqbind(a.win,"mouseenter",function(c){C=a.getTarget(c).id||!0;a.hasmousefocus=!0;a.canshowonmouseevent&&a.noticeCursor()}),a.jqbind(a.win,"mouseleave",function(){C=!1;a.hasmousefocus=!1;a.rail.drag||a.hideCursor()}))}a.onkeypress=function(c){if(a.locked&&0==a.page.maxh)return!0;c=c?c:window.e;var b=a.getTarget(c);
if(b&&/INPUT|TEXTAREA|SELECT|OPTION/.test(b.nodeName)&&(!b.getAttribute("type")&&!b.type||!/submit|button|cancel/i.tp)||e(b).attr("contenteditable"))return!0;if(a.hasfocus||a.hasmousefocus&&!y||a.ispage&&!y&&!C){b=c.keyCode;if(a.locked&&27!=b)return a.cancelEvent(c);var f=c.ctrlKey||!1,n=c.shiftKey||!1,d=!1;switch(b){case 38:case 63233:a.doScrollBy(72);d=!0;break;case 40:case 63235:a.doScrollBy(-72);d=!0;break;case 37:case 63232:a.railh&&(f?a.doScrollLeft(0):a.doScrollLeftBy(72),d=!0);break;case 39:case 63234:a.railh&&
(f?a.doScrollLeft(a.page.maxw):a.doScrollLeftBy(-72),d=!0);break;case 33:case 63276:a.doScrollBy(a.view.h);d=!0;break;case 34:case 63277:a.doScrollBy(-a.view.h);d=!0;break;case 36:case 63273:a.railh&&f?a.doScrollPos(0,0):a.doScrollTo(0);d=!0;break;case 35:case 63275:a.railh&&f?a.doScrollPos(a.page.maxw,a.page.maxh):a.doScrollTo(a.page.maxh);d=!0;break;case 32:a.opt.spacebarenabled&&(n?a.doScrollBy(a.view.h):a.doScrollBy(-a.view.h),d=!0);break;case 27:a.zoomactive&&(a.doZoom(),d=!0)}if(d)return a.cancelEvent(c)}};
a.opt.enablekeyboard&&a.bind(document,d.isopera&&!d.isopera12?"keypress":"keydown",a.onkeypress);a.bind(document,"keydown",function(c){c.ctrlKey&&(a.wheelprevented=!0)});a.bind(document,"keyup",function(c){c.ctrlKey||(a.wheelprevented=!1)});a.bind(window,"resize",a.lazyResize);a.bind(window,"orientationchange",a.lazyResize);a.bind(window,"load",a.lazyResize);if(d.ischrome&&!a.ispage&&!a.haswrapper){var r=a.win.attr("style"),f=parseFloat(a.win.css("width"))+1;a.win.css("width",f);a.synched("chromefix",
function(){a.win.attr("style",r)})}a.onAttributeChange=function(c){a.lazyResize(250)};!a.ispage&&!a.haswrapper&&(!1!==z?(a.observer=new z(function(c){c.forEach(a.onAttributeChange)}),a.observer.observe(a.win[0],{childList:!0,characterData:!1,attributes:!0,subtree:!1}),a.observerremover=new z(function(c){c.forEach(function(c){if(0<c.removedNodes.length)for(var b in c.removedNodes)if(c.removedNodes[b]==a.win[0])return a.remove()})}),a.observerremover.observe(a.win[0].parentNode,{childList:!0,characterData:!1,
attributes:!1,subtree:!1})):(a.bind(a.win,d.isie&&!d.isie9?"propertychange":"DOMAttrModified",a.onAttributeChange),d.isie9&&a.win[0].attachEvent("onpropertychange",a.onAttributeChange),a.bind(a.win,"DOMNodeRemoved",function(c){c.target==a.win[0]&&a.remove()})));!a.ispage&&a.opt.boxzoom&&a.bind(window,"resize",a.resizeZoom);a.istextarea&&a.bind(a.win,"mouseup",a.lazyResize);a.lazyResize(30)}if("IFRAME"==this.doc[0].nodeName){var I=function(c){a.iframexd=!1;try{var b="contentDocument"in this?this.contentDocument:
this.contentWindow.document}catch(f){a.iframexd=!0,b=!1}if(a.iframexd)return"console"in window&&console.log("NiceScroll error: policy restriced iframe"),!0;a.forcescreen=!0;a.isiframe&&(a.iframe={doc:e(b),html:a.doc.contents().find("html")[0],body:a.doc.contents().find("body")[0]},a.getContentSize=function(){return{w:Math.max(a.iframe.html.scrollWidth,a.iframe.body.scrollWidth),h:Math.max(a.iframe.html.scrollHeight,a.iframe.body.scrollHeight)}},a.docscroll=e(a.iframe.body));!d.isios&&(a.opt.iframeautoresize&&
!a.isiframe)&&(a.win.scrollTop(0),a.doc.height(""),c=Math.max(b.getElementsByTagName("html")[0].scrollHeight,b.body.scrollHeight),a.doc.height(c));a.lazyResize(30);d.isie7&&a.css(e(a.iframe.html),{"overflow-y":"hidden"});a.css(e(a.iframe.body),{"overflow-y":"hidden"});d.isios&&a.haswrapper&&a.css(e(b.body),{"-webkit-transform":"translate3d(0,0,0)"});"contentWindow"in this?a.bind(this.contentWindow,"scroll",a.onscroll):a.bind(b,"scroll",a.onscroll);a.opt.enablemousewheel&&a.bind(b,"mousewheel",a.onmousewheel);
a.opt.enablekeyboard&&a.bind(b,d.isopera?"keypress":"keydown",a.onkeypress);if(d.cantouch||a.opt.touchbehavior)a.bind(b,"mousedown",a.ontouchstart),a.bind(b,"mousemove",function(c){a.ontouchmove(c,!0)}),a.opt.grabcursorenabled&&d.cursorgrabvalue&&a.css(e(b.body),{cursor:d.cursorgrabvalue});a.bind(b,"mouseup",a.ontouchend);a.zoom&&(a.opt.dblclickzoom&&a.bind(b,"dblclick",a.doZoom),a.ongesturezoom&&a.bind(b,"gestureend",a.ongesturezoom))};this.doc[0].readyState&&"complete"==this.doc[0].readyState&&
setTimeout(function(){I.call(a.doc[0],!1)},500);a.bind(this.doc,"load",I)}};this.showCursor=function(c,b){a.cursortimeout&&(clearTimeout(a.cursortimeout),a.cursortimeout=0);if(a.rail){a.autohidedom&&(a.autohidedom.stop().css({opacity:a.opt.cursoropacitymax}),a.cursoractive=!0);if(!a.rail.drag||1!=a.rail.drag.pt)"undefined"!=typeof c&&!1!==c&&(a.scroll.y=Math.round(1*c/a.scrollratio.y)),"undefined"!=typeof b&&(a.scroll.x=Math.round(1*b/a.scrollratio.x));a.cursor.css({height:a.cursorheight,top:a.scroll.y});
a.cursorh&&(!a.rail.align&&a.rail.visibility?a.cursorh.css({width:a.cursorwidth,left:a.scroll.x+a.rail.width}):a.cursorh.css({width:a.cursorwidth,left:a.scroll.x}),a.cursoractive=!0);a.zoom&&a.zoom.stop().css({opacity:a.opt.cursoropacitymax})}};this.hideCursor=function(c){!a.cursortimeout&&(a.rail&&a.autohidedom&&!(a.hasmousefocus&&"leave"==a.opt.autohidemode))&&(a.cursortimeout=setTimeout(function(){if(!a.rail.active||!a.showonmouseevent)a.autohidedom.stop().animate({opacity:a.opt.cursoropacitymin}),
a.zoom&&a.zoom.stop().animate({opacity:a.opt.cursoropacitymin}),a.cursoractive=!1;a.cursortimeout=0},c||a.opt.hidecursordelay))};this.noticeCursor=function(c,b,f){a.showCursor(b,f);a.rail.active||a.hideCursor(c)};this.getContentSize=a.ispage?function(){return{w:Math.max(document.body.scrollWidth,document.documentElement.scrollWidth),h:Math.max(document.body.scrollHeight,document.documentElement.scrollHeight)}}:a.haswrapper?function(){return{w:a.doc.outerWidth()+parseInt(a.win.css("paddingLeft"))+
parseInt(a.win.css("paddingRight")),h:a.doc.outerHeight()+parseInt(a.win.css("paddingTop"))+parseInt(a.win.css("paddingBottom"))}}:function(){return{w:a.docscroll[0].scrollWidth,h:a.docscroll[0].scrollHeight}};this.onResize=function(c,b){if(!a||!a.win)return!1;if(!a.haswrapper&&!a.ispage){if("none"==a.win.css("display"))return a.visibility&&a.hideRail().hideRailHr(),!1;!a.hidden&&!a.visibility&&a.showRail().showRailHr()}var f=a.page.maxh,d=a.page.maxw,e=a.view.w;a.view={w:a.ispage?a.win.width():parseInt(a.win[0].clientWidth),
h:a.ispage?a.win.height():parseInt(a.win[0].clientHeight)};a.page=b?b:a.getContentSize();a.page.maxh=Math.max(0,a.page.h-a.view.h);a.page.maxw=Math.max(0,a.page.w-a.view.w);if(a.page.maxh==f&&a.page.maxw==d&&a.view.w==e){if(a.ispage)return a;f=a.win.offset();if(a.lastposition&&(d=a.lastposition,d.top==f.top&&d.left==f.left))return a;a.lastposition=f}0==a.page.maxh?(a.hideRail(),a.scrollvaluemax=0,a.scroll.y=0,a.scrollratio.y=0,a.cursorheight=0,a.setScrollTop(0),a.rail.scrollable=!1):a.rail.scrollable=
!0;0==a.page.maxw?(a.hideRailHr(),a.scrollvaluemaxw=0,a.scroll.x=0,a.scrollratio.x=0,a.cursorwidth=0,a.setScrollLeft(0),a.railh.scrollable=!1):a.railh.scrollable=!0;a.locked=0==a.page.maxh&&0==a.page.maxw;if(a.locked)return a.ispage||a.updateScrollBar(a.view),!1;!a.hidden&&!a.visibility?a.showRail().showRailHr():!a.hidden&&!a.railh.visibility&&a.showRailHr();a.istextarea&&(a.win.css("resize")&&"none"!=a.win.css("resize"))&&(a.view.h-=20);a.cursorheight=Math.min(a.view.h,Math.round(a.view.h*(a.view.h/
a.page.h)));a.cursorheight=a.opt.cursorfixedheight?a.opt.cursorfixedheight:Math.max(a.opt.cursorminheight,a.cursorheight);a.cursorwidth=Math.min(a.view.w,Math.round(a.view.w*(a.view.w/a.page.w)));a.cursorwidth=a.opt.cursorfixedheight?a.opt.cursorfixedheight:Math.max(a.opt.cursorminheight,a.cursorwidth);a.scrollvaluemax=a.view.h-a.cursorheight-a.cursor.hborder;a.railh&&(a.railh.width=0<a.page.maxh?a.view.w-a.rail.width:a.view.w,a.scrollvaluemaxw=a.railh.width-a.cursorwidth-a.cursorh.wborder);a.ispage||
a.updateScrollBar(a.view);a.scrollratio={x:a.page.maxw/a.scrollvaluemaxw,y:a.page.maxh/a.scrollvaluemax};a.getScrollTop()>a.page.maxh?a.doScrollTop(a.page.maxh):(a.scroll.y=Math.round(a.getScrollTop()*(1/a.scrollratio.y)),a.scroll.x=Math.round(a.getScrollLeft()*(1/a.scrollratio.x)),a.cursoractive&&a.noticeCursor());a.scroll.y&&0==a.getScrollTop()&&a.doScrollTo(Math.floor(a.scroll.y*a.scrollratio.y));return a};this.resize=a.onResize;this.lazyResize=function(c){c=isNaN(c)?30:c;a.delayed("resize",a.resize,
c);return a};this._bind=function(c,b,f,d){a.events.push({e:c,n:b,f:f,b:d,q:!1});c.addEventListener?c.addEventListener(b,f,d||!1):c.attachEvent?c.attachEvent("on"+b,f):c["on"+b]=f};this.jqbind=function(c,b,f){a.events.push({e:c,n:b,f:f,q:!0});e(c).bind(b,f)};this.bind=function(c,b,f,e){var h="jquery"in c?c[0]:c;"mousewheel"==b?"onwheel"in a.win?a._bind(h,"wheel",f,e||!1):(c="undefined"!=typeof document.onmousewheel?"mousewheel":"DOMMouseScroll",l(h,c,f,e||!1),"DOMMouseScroll"==c&&l(h,"MozMousePixelScroll",
f,e||!1)):h.addEventListener?(d.cantouch&&/mouseup|mousedown|mousemove/.test(b)&&a._bind(h,"mousedown"==b?"touchstart":"mouseup"==b?"touchend":"touchmove",function(a){if(a.touches){if(2>a.touches.length){var c=a.touches.length?a.touches[0]:a;c.original=a;f.call(this,c)}}else a.changedTouches&&(c=a.changedTouches[0],c.original=a,f.call(this,c))},e||!1),a._bind(h,b,f,e||!1),d.cantouch&&"mouseup"==b&&a._bind(h,"touchcancel",f,e||!1)):a._bind(h,b,function(c){if((c=c||window.event||!1)&&c.srcElement)c.target=
c.srcElement;"pageY"in c||(c.pageX=c.clientX+document.documentElement.scrollLeft,c.pageY=c.clientY+document.documentElement.scrollTop);return!1===f.call(h,c)||!1===e?a.cancelEvent(c):!0})};this._unbind=function(a,b,f,d){a.removeEventListener?a.removeEventListener(b,f,d):a.detachEvent?a.detachEvent("on"+b,f):a["on"+b]=!1};this.unbindAll=function(){for(var c=0;c<a.events.length;c++){var b=a.events[c];b.q?b.e.unbind(b.n,b.f):a._unbind(b.e,b.n,b.f,b.b)}};this.cancelEvent=function(a){a=a.original?a.original:
a?a:window.event||!1;if(!a)return!1;a.preventDefault&&a.preventDefault();a.stopPropagation&&a.stopPropagation();a.preventManipulation&&a.preventManipulation();a.cancelBubble=!0;a.cancel=!0;return a.returnValue=!1};this.stopPropagation=function(a){a=a.original?a.original:a?a:window.event||!1;if(!a)return!1;if(a.stopPropagation)return a.stopPropagation();a.cancelBubble&&(a.cancelBubble=!0);return!1};this.showRail=function(){if(0!=a.page.maxh&&(a.ispage||"none"!=a.win.css("display")))a.visibility=!0,
a.rail.visibility=!0,a.rail.css("display","block");return a};this.showRailHr=function(){if(!a.railh)return a;if(0!=a.page.maxw&&(a.ispage||"none"!=a.win.css("display")))a.railh.visibility=!0,a.railh.css("display","block");return a};this.hideRail=function(){a.visibility=!1;a.rail.visibility=!1;a.rail.css("display","none");return a};this.hideRailHr=function(){if(!a.railh)return a;a.railh.visibility=!1;a.railh.css("display","none");return a};this.show=function(){a.hidden=!1;a.locked=!1;return a.showRail().showRailHr()};
this.hide=function(){a.hidden=!0;a.locked=!0;return a.hideRail().hideRailHr()};this.toggle=function(){return a.hidden?a.show():a.hide()};this.remove=function(){a.stop();a.cursortimeout&&clearTimeout(a.cursortimeout);a.doZoomOut();a.unbindAll();d.isie9&&a.win[0].detachEvent("onpropertychange",a.onAttributeChange);!1!==a.observer&&a.observer.disconnect();!1!==a.observerremover&&a.observerremover.disconnect();a.events=null;a.cursor&&a.cursor.remove();a.cursorh&&a.cursorh.remove();a.rail&&a.rail.remove();
a.railh&&a.railh.remove();a.zoom&&a.zoom.remove();for(var c=0;c<a.saved.css.length;c++){var b=a.saved.css[c];b[0].css(b[1],"undefined"==typeof b[2]?"":b[2])}a.saved=!1;a.me.data("__nicescroll","");var f=e.nicescroll;f.each(function(c){if(this&&this.id===a.id){delete f[c];for(var b=++c;b<f.length;b++,c++)f[c]=f[b];f.length--;f.length&&delete f[f.length]}});for(var h in a)a[h]=null,delete a[h];a=null};this.scrollstart=function(c){this.onscrollstart=c;return a};this.scrollend=function(c){this.onscrollend=
c;return a};this.scrollcancel=function(c){this.onscrollcancel=c;return a};this.zoomin=function(c){this.onzoomin=c;return a};this.zoomout=function(c){this.onzoomout=c;return a};this.isScrollable=function(a){a=a.target?a.target:a;if("OPTION"==a.nodeName)return!0;for(;a&&1==a.nodeType&&!/^BODY|HTML/.test(a.nodeName);){var b=e(a),b=b.css("overflowY")||b.css("overflowX")||b.css("overflow")||"";if(/scroll|auto/.test(b))return a.clientHeight!=a.scrollHeight;a=a.parentNode?a.parentNode:!1}return!1};this.getViewport=
function(a){for(a=a&&a.parentNode?a.parentNode:!1;a&&1==a.nodeType&&!/^BODY|HTML/.test(a.nodeName);){var b=e(a);if(/fixed|absolute/.test(b.css("position")))return b;var f=b.css("overflowY")||b.css("overflowX")||b.css("overflow")||"";if(/scroll|auto/.test(f)&&a.clientHeight!=a.scrollHeight||0<b.getNiceScroll().length)return b;a=a.parentNode?a.parentNode:!1}return a?e(a):!1};this.triggerScrollEnd=function(){if(a.onscrollend){var c=a.getScrollLeft(),b=a.getScrollTop();a.onscrollend.call(a,{type:"scrollend",
current:{x:c,y:b},end:{x:c,y:b}})}};this.onmousewheel=function(c){if(!a.wheelprevented){if(a.locked)return a.debounced("checkunlock",a.resize,250),!0;if(a.rail.drag)return a.cancelEvent(c);"auto"==a.opt.oneaxismousemode&&0!=c.deltaX&&(a.opt.oneaxismousemode=!1);if(a.opt.oneaxismousemode&&0==c.deltaX&&!a.rail.scrollable)return a.railh&&a.railh.scrollable?a.onmousewheelhr(c):!0;var b=+new Date,f=!1;a.opt.preservenativescrolling&&a.checkarea+600<b&&(a.nativescrollingarea=a.isScrollable(c),f=!0);a.checkarea=
b;if(a.nativescrollingarea)return!0;if(c=q(c,!1,f))a.checkarea=0;return c}};this.onmousewheelhr=function(c){if(!a.wheelprevented){if(a.locked||!a.railh.scrollable)return!0;if(a.rail.drag)return a.cancelEvent(c);var b=+new Date,f=!1;a.opt.preservenativescrolling&&a.checkarea+600<b&&(a.nativescrollingarea=a.isScrollable(c),f=!0);a.checkarea=b;return a.nativescrollingarea?!0:a.locked?a.cancelEvent(c):q(c,!0,f)}};this.stop=function(){a.cancelScroll();a.scrollmon&&a.scrollmon.stop();a.cursorfreezed=!1;
a.scroll.y=Math.round(a.getScrollTop()*(1/a.scrollratio.y));a.noticeCursor();return a};this.getTransitionSpeed=function(b){var d=Math.round(10*a.opt.scrollspeed);b=Math.min(d,Math.round(b/20*a.opt.scrollspeed));return 20<b?b:0};a.opt.smoothscroll?a.ishwscroll&&d.hastransition&&a.opt.usetransition?(this.prepareTransition=function(b,e){var f=e?20<b?b:0:a.getTransitionSpeed(b),h=f?d.prefixstyle+"transform "+f+"ms ease-out":"";if(!a.lasttransitionstyle||a.lasttransitionstyle!=h)a.lasttransitionstyle=
h,a.doc.css(d.transitionstyle,h);return f},this.doScrollLeft=function(b,d){var f=a.scrollrunning?a.newscrolly:a.getScrollTop();a.doScrollPos(b,f,d)},this.doScrollTop=function(b,d){var f=a.scrollrunning?a.newscrollx:a.getScrollLeft();a.doScrollPos(f,b,d)},this.doScrollPos=function(b,e,f){var h=a.getScrollTop(),g=a.getScrollLeft();(0>(a.newscrolly-h)*(e-h)||0>(a.newscrollx-g)*(b-g))&&a.cancelScroll();!1==a.opt.bouncescroll&&(0>e?e=0:e>a.page.maxh&&(e=a.page.maxh),0>b?b=0:b>a.page.maxw&&(b=a.page.maxw));
if(a.scrollrunning&&b==a.newscrollx&&e==a.newscrolly)return!1;a.newscrolly=e;a.newscrollx=b;a.newscrollspeed=f||!1;if(a.timer)return!1;a.timer=setTimeout(function(){var f=a.getScrollTop(),h=a.getScrollLeft(),g,k;g=b-h;k=e-f;g=Math.round(Math.sqrt(Math.pow(g,2)+Math.pow(k,2)));g=a.newscrollspeed&&1<a.newscrollspeed?a.newscrollspeed:a.getTransitionSpeed(g);a.newscrollspeed&&1>=a.newscrollspeed&&(g*=a.newscrollspeed);a.prepareTransition(g,!0);a.timerscroll&&a.timerscroll.tm&&clearInterval(a.timerscroll.tm);
0<g&&(!a.scrollrunning&&a.onscrollstart&&a.onscrollstart.call(a,{type:"scrollstart",current:{x:h,y:f},request:{x:b,y:e},end:{x:a.newscrollx,y:a.newscrolly},speed:g}),d.transitionend?a.scrollendtrapped||(a.scrollendtrapped=!0,a.bind(a.doc,d.transitionend,a.onScrollTransitionEnd,!1)):(a.scrollendtrapped&&clearTimeout(a.scrollendtrapped),a.scrollendtrapped=setTimeout(a.onScrollTransitionEnd,g)),a.timerscroll={bz:new BezierClass(f,a.newscrolly,g,0,0,0.58,1),bh:new BezierClass(h,a.newscrollx,g,0,0,0.58,
1)},a.cursorfreezed||(a.timerscroll.tm=setInterval(function(){a.showCursor(a.getScrollTop(),a.getScrollLeft())},60)));a.synched("doScroll-set",function(){a.timer=0;a.scrollendtrapped&&(a.scrollrunning=!0);a.setScrollTop(a.newscrolly);a.setScrollLeft(a.newscrollx);if(!a.scrollendtrapped)a.onScrollTransitionEnd()})},50)},this.cancelScroll=function(){if(!a.scrollendtrapped)return!0;var b=a.getScrollTop(),e=a.getScrollLeft();a.scrollrunning=!1;d.transitionend||clearTimeout(d.transitionend);a.scrollendtrapped=
!1;a._unbind(a.doc,d.transitionend,a.onScrollTransitionEnd);a.prepareTransition(0);a.setScrollTop(b);a.railh&&a.setScrollLeft(e);a.timerscroll&&a.timerscroll.tm&&clearInterval(a.timerscroll.tm);a.timerscroll=!1;a.cursorfreezed=!1;a.showCursor(b,e);return a},this.onScrollTransitionEnd=function(){a.scrollendtrapped&&a._unbind(a.doc,d.transitionend,a.onScrollTransitionEnd);a.scrollendtrapped=!1;a.prepareTransition(0);a.timerscroll&&a.timerscroll.tm&&clearInterval(a.timerscroll.tm);a.timerscroll=!1;var b=
a.getScrollTop(),e=a.getScrollLeft();a.setScrollTop(b);a.railh&&a.setScrollLeft(e);a.noticeCursor(!1,b,e);a.cursorfreezed=!1;0>b?b=0:b>a.page.maxh&&(b=a.page.maxh);0>e?e=0:e>a.page.maxw&&(e=a.page.maxw);if(b!=a.newscrolly||e!=a.newscrollx)return a.doScrollPos(e,b,a.opt.snapbackspeed);a.onscrollend&&a.scrollrunning&&a.triggerScrollEnd();a.scrollrunning=!1}):(this.doScrollLeft=function(b,d){var f=a.scrollrunning?a.newscrolly:a.getScrollTop();a.doScrollPos(b,f,d)},this.doScrollTop=function(b,d){var f=
a.scrollrunning?a.newscrollx:a.getScrollLeft();a.doScrollPos(f,b,d)},this.doScrollPos=function(b,d,f){function e(){if(a.cancelAnimationFrame)return!0;a.scrollrunning=!0;if(p=1-p)return a.timer=s(e)||1;var b=0,c=sy=a.getScrollTop();if(a.dst.ay){var c=a.bzscroll?a.dst.py+a.bzscroll.getNow()*a.dst.ay:a.newscrolly,f=c-sy;if(0>f&&c<a.newscrolly||0<f&&c>a.newscrolly)c=a.newscrolly;a.setScrollTop(c);c==a.newscrolly&&(b=1)}else b=1;var d=sx=a.getScrollLeft();if(a.dst.ax){d=a.bzscroll?a.dst.px+a.bzscroll.getNow()*
a.dst.ax:a.newscrollx;f=d-sx;if(0>f&&d<a.newscrollx||0<f&&d>a.newscrollx)d=a.newscrollx;a.setScrollLeft(d);d==a.newscrollx&&(b+=1)}else b+=1;2==b?(a.timer=0,a.cursorfreezed=!1,a.bzscroll=!1,a.scrollrunning=!1,0>c?c=0:c>a.page.maxh&&(c=a.page.maxh),0>d?d=0:d>a.page.maxw&&(d=a.page.maxw),d!=a.newscrollx||c!=a.newscrolly?a.doScrollPos(d,c):a.onscrollend&&a.triggerScrollEnd()):a.timer=s(e)||1}d="undefined"==typeof d||!1===d?a.getScrollTop(!0):d;if(a.timer&&a.newscrolly==d&&a.newscrollx==b)return!0;a.timer&&
v(a.timer);a.timer=0;var h=a.getScrollTop(),g=a.getScrollLeft();(0>(a.newscrolly-h)*(d-h)||0>(a.newscrollx-g)*(b-g))&&a.cancelScroll();a.newscrolly=d;a.newscrollx=b;if(!a.bouncescroll||!a.rail.visibility)0>a.newscrolly?a.newscrolly=0:a.newscrolly>a.page.maxh&&(a.newscrolly=a.page.maxh);if(!a.bouncescroll||!a.railh.visibility)0>a.newscrollx?a.newscrollx=0:a.newscrollx>a.page.maxw&&(a.newscrollx=a.page.maxw);a.dst={};a.dst.x=b-g;a.dst.y=d-h;a.dst.px=g;a.dst.py=h;var k=Math.round(Math.sqrt(Math.pow(a.dst.x,
2)+Math.pow(a.dst.y,2)));a.dst.ax=a.dst.x/k;a.dst.ay=a.dst.y/k;var l=0,q=k;0==a.dst.x?(l=h,q=d,a.dst.ay=1,a.dst.py=0):0==a.dst.y&&(l=g,q=b,a.dst.ax=1,a.dst.px=0);k=a.getTransitionSpeed(k);f&&1>=f&&(k*=f);a.bzscroll=0<k?a.bzscroll?a.bzscroll.update(q,k):new BezierClass(l,q,k,0,1,0,1):!1;if(!a.timer){(h==a.page.maxh&&d>=a.page.maxh||g==a.page.maxw&&b>=a.page.maxw)&&a.checkContentSize();var p=1;a.cancelAnimationFrame=!1;a.timer=1;a.onscrollstart&&!a.scrollrunning&&a.onscrollstart.call(a,{type:"scrollstart",
current:{x:g,y:h},request:{x:b,y:d},end:{x:a.newscrollx,y:a.newscrolly},speed:k});e();(h==a.page.maxh&&d>=h||g==a.page.maxw&&b>=g)&&a.checkContentSize();a.noticeCursor()}},this.cancelScroll=function(){a.timer&&v(a.timer);a.timer=0;a.bzscroll=!1;a.scrollrunning=!1;return a}):(this.doScrollLeft=function(b,d){var f=a.getScrollTop();a.doScrollPos(b,f,d)},this.doScrollTop=function(b,d){var f=a.getScrollLeft();a.doScrollPos(f,b,d)},this.doScrollPos=function(b,d,f){var e=b>a.page.maxw?a.page.maxw:b;0>e&&
(e=0);var h=d>a.page.maxh?a.page.maxh:d;0>h&&(h=0);a.synched("scroll",function(){a.setScrollTop(h);a.setScrollLeft(e)})},this.cancelScroll=function(){});this.doScrollBy=function(b,d){var f=0,f=d?Math.floor((a.scroll.y-b)*a.scrollratio.y):(a.timer?a.newscrolly:a.getScrollTop(!0))-b;if(a.bouncescroll){var e=Math.round(a.view.h/2);f<-e?f=-e:f>a.page.maxh+e&&(f=a.page.maxh+e)}a.cursorfreezed=!1;py=a.getScrollTop(!0);if(0>f&&0>=py)return a.noticeCursor();if(f>a.page.maxh&&py>=a.page.maxh)return a.checkContentSize(),
a.noticeCursor();a.doScrollTop(f)};this.doScrollLeftBy=function(b,d){var f=0,f=d?Math.floor((a.scroll.x-b)*a.scrollratio.x):(a.timer?a.newscrollx:a.getScrollLeft(!0))-b;if(a.bouncescroll){var e=Math.round(a.view.w/2);f<-e?f=-e:f>a.page.maxw+e&&(f=a.page.maxw+e)}a.cursorfreezed=!1;px=a.getScrollLeft(!0);if(0>f&&0>=px||f>a.page.maxw&&px>=a.page.maxw)return a.noticeCursor();a.doScrollLeft(f)};this.doScrollTo=function(b,d){d&&Math.round(b*a.scrollratio.y);a.cursorfreezed=!1;a.doScrollTop(b)};this.checkContentSize=
function(){var b=a.getContentSize();(b.h!=a.page.h||b.w!=a.page.w)&&a.resize(!1,b)};a.onscroll=function(b){a.rail.drag||a.cursorfreezed||a.synched("scroll",function(){a.scroll.y=Math.round(a.getScrollTop()*(1/a.scrollratio.y));a.railh&&(a.scroll.x=Math.round(a.getScrollLeft()*(1/a.scrollratio.x)));a.noticeCursor()})};a.bind(a.docscroll,"scroll",a.onscroll);this.doZoomIn=function(b){if(!a.zoomactive){a.zoomactive=!0;a.zoomrestore={style:{}};var h="position top left zIndex backgroundColor marginTop marginBottom marginLeft marginRight".split(" "),
f=a.win[0].style,g;for(g in h){var k=h[g];a.zoomrestore.style[k]="undefined"!=typeof f[k]?f[k]:""}a.zoomrestore.style.width=a.win.css("width");a.zoomrestore.style.height=a.win.css("height");a.zoomrestore.padding={w:a.win.outerWidth()-a.win.width(),h:a.win.outerHeight()-a.win.height()};d.isios4&&(a.zoomrestore.scrollTop=e(window).scrollTop(),e(window).scrollTop(0));a.win.css({position:d.isios4?"absolute":"fixed",top:0,left:0,"z-index":x+100,margin:"0px"});h=a.win.css("backgroundColor");(""==h||/transparent|rgba\(0, 0, 0, 0\)|rgba\(0,0,0,0\)/.test(h))&&
a.win.css("backgroundColor","#fff");a.rail.css({"z-index":x+101});a.zoom.css({"z-index":x+102});a.zoom.css("backgroundPosition","0px -18px");a.resizeZoom();a.onzoomin&&a.onzoomin.call(a);return a.cancelEvent(b)}};this.doZoomOut=function(b){if(a.zoomactive)return a.zoomactive=!1,a.win.css("margin",""),a.win.css(a.zoomrestore.style),d.isios4&&e(window).scrollTop(a.zoomrestore.scrollTop),a.rail.css({"z-index":a.zindex}),a.zoom.css({"z-index":a.zindex}),a.zoomrestore=!1,a.zoom.css("backgroundPosition",
"0px 0px"),a.onResize(),a.onzoomout&&a.onzoomout.call(a),a.cancelEvent(b)};this.doZoom=function(b){return a.zoomactive?a.doZoomOut(b):a.doZoomIn(b)};this.resizeZoom=function(){if(a.zoomactive){var b=a.getScrollTop();a.win.css({width:e(window).width()-a.zoomrestore.padding.w+"px",height:e(window).height()-a.zoomrestore.padding.h+"px"});a.onResize();a.setScrollTop(Math.min(a.page.maxh,b))}};this.init();e.nicescroll.push(this)},H=function(e){var b=this;this.nc=e;this.steptime=this.lasttime=this.speedy=
this.speedx=this.lasty=this.lastx=0;this.snapy=this.snapx=!1;this.demuly=this.demulx=0;this.lastscrolly=this.lastscrollx=-1;this.timer=this.chky=this.chkx=0;this.time=function(){return+new Date};this.reset=function(e,g){b.stop();var l=b.time();b.steptime=0;b.lasttime=l;b.speedx=0;b.speedy=0;b.lastx=e;b.lasty=g;b.lastscrollx=-1;b.lastscrolly=-1};this.update=function(e,g){var l=b.time();b.steptime=l-b.lasttime;b.lasttime=l;var l=g-b.lasty,q=e-b.lastx,a=b.nc.getScrollTop(),p=b.nc.getScrollLeft(),a=a+
l,p=p+q;b.snapx=0>p||p>b.nc.page.maxw;b.snapy=0>a||a>b.nc.page.maxh;b.speedx=q;b.speedy=l;b.lastx=e;b.lasty=g};this.stop=function(){b.nc.unsynched("domomentum2d");b.timer&&clearTimeout(b.timer);b.timer=0;b.lastscrollx=-1;b.lastscrolly=-1};this.doSnapy=function(e,g){var l=!1;0>g?(g=0,l=!0):g>b.nc.page.maxh&&(g=b.nc.page.maxh,l=!0);0>e?(e=0,l=!0):e>b.nc.page.maxw&&(e=b.nc.page.maxw,l=!0);l?b.nc.doScrollPos(e,g,b.nc.opt.snapbackspeed):b.nc.triggerScrollEnd()};this.doMomentum=function(e){var g=b.time(),
l=e?g+e:b.lasttime;e=b.nc.getScrollLeft();var q=b.nc.getScrollTop(),a=b.nc.page.maxh,p=b.nc.page.maxw;b.speedx=0<p?Math.min(60,b.speedx):0;b.speedy=0<a?Math.min(60,b.speedy):0;l=l&&60>=g-l;if(0>q||q>a||0>e||e>p)l=!1;e=b.speedx&&l?b.speedx:!1;if(b.speedy&&l&&b.speedy||e){var d=Math.max(16,b.steptime);50<d&&(e=d/50,b.speedx*=e,b.speedy*=e,d=50);b.demulxy=0;b.lastscrollx=b.nc.getScrollLeft();b.chkx=b.lastscrollx;b.lastscrolly=b.nc.getScrollTop();b.chky=b.lastscrolly;var r=b.lastscrollx,t=b.lastscrolly,
s=function(){var c=600<b.time()-g?0.04:0.02;if(b.speedx&&(r=Math.floor(b.lastscrollx-b.speedx*(1-b.demulxy)),b.lastscrollx=r,0>r||r>p))c=0.1;if(b.speedy&&(t=Math.floor(b.lastscrolly-b.speedy*(1-b.demulxy)),b.lastscrolly=t,0>t||t>a))c=0.1;b.demulxy=Math.min(1,b.demulxy+c);b.nc.synched("domomentum2d",function(){b.speedx&&(b.nc.getScrollLeft()!=b.chkx&&b.stop(),b.chkx=r,b.nc.setScrollLeft(r));b.speedy&&(b.nc.getScrollTop()!=b.chky&&b.stop(),b.chky=t,b.nc.setScrollTop(t));b.timer||(b.nc.hideCursor(),
b.doSnapy(r,t))});1>b.demulxy?b.timer=setTimeout(s,d):(b.stop(),b.nc.hideCursor(),b.doSnapy(r,t))};s()}else b.doSnapy(b.nc.getScrollLeft(),b.nc.getScrollTop())}},w=e.fn.scrollTop;e.cssHooks.pageYOffset={get:function(g,b,h){return(b=e.data(g,"__nicescroll")||!1)&&b.ishwscroll?b.getScrollTop():w.call(g)},set:function(g,b){var h=e.data(g,"__nicescroll")||!1;h&&h.ishwscroll?h.setScrollTop(parseInt(b)):w.call(g,b);return this}};e.fn.scrollTop=function(g){if("undefined"==typeof g){var b=this[0]?e.data(this[0],
"__nicescroll")||!1:!1;return b&&b.ishwscroll?b.getScrollTop():w.call(this)}return this.each(function(){var b=e.data(this,"__nicescroll")||!1;b&&b.ishwscroll?b.setScrollTop(parseInt(g)):w.call(e(this),g)})};var A=e.fn.scrollLeft;e.cssHooks.pageXOffset={get:function(g,b,h){return(b=e.data(g,"__nicescroll")||!1)&&b.ishwscroll?b.getScrollLeft():A.call(g)},set:function(g,b){var h=e.data(g,"__nicescroll")||!1;h&&h.ishwscroll?h.setScrollLeft(parseInt(b)):A.call(g,b);return this}};e.fn.scrollLeft=function(g){if("undefined"==
typeof g){var b=this[0]?e.data(this[0],"__nicescroll")||!1:!1;return b&&b.ishwscroll?b.getScrollLeft():A.call(this)}return this.each(function(){var b=e.data(this,"__nicescroll")||!1;b&&b.ishwscroll?b.setScrollLeft(parseInt(g)):A.call(e(this),g)})};var B=function(g){var b=this;this.length=0;this.name="nicescrollarray";this.each=function(e){for(var g=0,a=0;g<b.length;g++)e.call(b[g],a++);return b};this.push=function(e){b[b.length]=e;b.length++};this.eq=function(e){return b[e]};if(g)for(var h=0;h<g.length;h++){var k=
e.data(g[h],"__nicescroll")||!1;k&&(this[this.length]=k,this.length++)}return this};(function(e,b,h){for(var k=0;k<b.length;k++)h(e,b[k])})(B.prototype,"show hide toggle onResize resize remove stop doScrollPos".split(" "),function(e,b){e[b]=function(){var e=arguments;return this.each(function(){this[b].apply(this,e)})}});e.fn.getNiceScroll=function(g){return"undefined"==typeof g?new B(this):this[g]&&e.data(this[g],"__nicescroll")||!1};e.extend(e.expr[":"],{nicescroll:function(g){return e.data(g,"__nicescroll")?
!0:!1}});e.fn.niceScroll=function(g,b){"undefined"==typeof b&&("object"==typeof g&&!("jquery"in g))&&(b=g,g=!1);var h=new B;"undefined"==typeof b&&(b={});g&&(b.doc=e(g),b.win=e(this));var k=!("doc"in b);!k&&!("win"in b)&&(b.win=e(this));this.each(function(){var g=e(this).data("__nicescroll")||!1;g||(b.doc=k?e(this):b.doc,g=new N(b,e(this)),e(this).data("__nicescroll",g));h.push(g)});return 1==h.length?h[0]:h};window.NiceScroll={getjQuery:function(){return e}};e.nicescroll||(e.nicescroll=new B,e.nicescroll.options=
G)});

/******************************************************************************* 
* Copyright 2012, 2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES 
* 
* This file is part of SITools2. 
* 
* SITools2 is free software: you can redistribute it and/or modify 
* it under the terms of the GNU General Public License as published by 
* the Free Software Foundation, either version 3 of the License, or 
* (at your option) any later version. 
* 
* SITools2 is distributed in the hope that it will be useful, 
* but WITHOUT ANY WARRANTY; without even the implied warranty of 
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
* GNU General Public License for more details. 
* 
* You should have received a copy of the GNU General Public License 
* along with SITools2. If not, see <http://www.gnu.org/licenses/>. 
******************************************************************************/ 

/**
 * FeaturePopup module
 */
define('FeaturePopup', [ "jquery", "./IFrame", "./JsonProcessor", "./Utils", "./ImageProcessing", "gw/FeatureStyle", "gw/VectorLayer", "./Samp", "underscore-min", "text!../templates/featureList.html", "text!../templates/featureDescription.html", "text!../templates/descriptionTable.html", "jquery.nicescroll.min", "jquery.ui" ],
	function($, IFrame, JsonProcessor, Utils, ImageProcessing, FeatureStyle, VectorLayer, Samp, _, featureListHTMLTemplate, featureDescriptionHTMLTemplate, descriptionTableHTMLTemplate) {

var featureListHTML = '';
var pickingManager = null;
var imageManager = null;
var globe = null;
var configuration;

var isMobile;

// Create selected feature div
var selectedFeatureDiv = '<div id="selectedFeatureDiv" class="contentBox ui-widget-content" style="display: none">\
				<div id="leftDiv"></div>\
				<div id="rightDiv"></div>\
				<div class="closeBtn">\
					<span class="defaultImg"></span>\
					<span style="opacity: 0" class="hoverImg"></span>\
				</div>\
				<div class="arrow-left"></div>\
			</div>';

var $selectedFeatureDiv;
var $leftDiv;
var $rightDiv;

// Template generating the list of selected features
var featureListTemplate = _.template(featureListHTMLTemplate);

// Template generating the detailed description of choosen feature
var featureDescriptionTemplate = _.template(featureDescriptionHTMLTemplate);

// Template generating the table of properties of choosen feature
var descriptionTableTemplate = _.template(descriptionTableHTMLTemplate);

// PileStash help HTML
var pileStashHelp = '<div id="pileStashHelp"> Some observations are overlapped. <br/> Click on the observation to see detailed informations about each observation. <br/> </div>';

/**********************************************************************************************/

/**
 * 	Selected feature div position calculations
 * 
 * 	@param x event.clientX
 * 	@param y event.clientY
 */
function computeDivPosition(clientX, clientY)
{
	
	var mousex = clientX; //Get X coodrinates
	var mousey = clientY; //Get Y coordinates

	mousex+= 20;
	mousey-= 100;
	
	// Positionning
	$('#selectedFeatureDiv').css(
		{
			position: 'absolute',
			left: mousex + 'px',
			top: mousey + 'px'
		}
	);
}

/**
 *	Compute optimal height of current viewport
 */
function computeHeight()
{
	return 2*$('#'+globe.renderContext.canvas.id).height()/5;
}

/**********************************************************************************************/

/**
 *	Appropriate layout of properties depending on displayProperties
 *
 *	@param properties Feature properties to modify
 *	@param {String[]} displayProperties Array containing properties which must be displayed at first
 *
 *	@return Properties matching displayProperties 
 */
function buildProperties(properties, displayProperties)
{
	if( displayProperties )
	{
		handledProperties = {}

		handledProperties.identifier = properties.identifier;
		handledProperties.title = properties.title ? properties.title : "";
		handledProperties.style = properties.style;

		// Fill handledProperties in order
		for(var j=0; j<displayProperties.length; j++)
		{
			var key = displayProperties[j];
			if (properties[key])
			{
				handledProperties[key] = properties[key];
			}
		}

		handledProperties.others = {};
		// Handle the rest into sub-section "others"
		for(var key in properties)
		{
			if (!handledProperties[key])
			{
				handledProperties.others[key] = properties[key];
			}
		}

		return handledProperties;
	}
	else
	{
		return properties;
	}
}

/**********************************************************************************************/

/**
 *	Add property description to the dictionary 
 *
 *	@param describeUrl Open Search describe document url
 *	@param property Property
 *	@param dictionary Dictionary to complete
 */
function addPropertyDescription(describeUrl, property, dictionary)
{
	$.ajax({
		type: "GET",
		url: describeUrl+property,
		dataType: 'text',
		success: function(response){
			dictionary[property] = response;
			$('#'+property).attr("title", response);
		},
		error: function (xhr, ajaxOptions, thrownError) {
			// console.error(xhr);
		}
	});
}

/**********************************************************************************************/

/**
 *	Create dictionary
 *
 *	@param layer Layer
 *	@param properties Feature properties
 */
function createDictionary( layer, properties )
{
	layer.dictionary = {};
	// Get dictionary template from open search description document
	$.ajax({
		type: "GET",
		url: layer.serviceUrl,
		dataType: "xml",
		success: function(xml) {
			var dicodesc = $(xml).find('Url[rel="dicodesc"]');
			var describeUrl = $(dicodesc).attr("template");

			if ( describeUrl )
			{
				// Cut unused part
				var splitIndex = describeUrl.indexOf( "{" );
				if ( splitIndex != -1 )
					describeUrl = describeUrl.substring( 0, splitIndex );

				for ( var key in properties )
				{
					addPropertyDescription(describeUrl, key, layer.dictionary);
				}
			}
			else
			{
				// No dico found
			}
		},
		error: function(xhr){
			// No dico found
		}
	});
}

/**********************************************************************************************/

/**
 * 	Insert HTML code of choosen feature
 */
function createHTMLSelectedFeatureDiv( layer, feature )
{
	if ( !layer.hasOwnProperty('dictionary') )
	{
		createDictionary(layer, feature.properties);
	}

	var output = featureDescriptionTemplate( {
		dictionary: layer.dictionary,
		services: feature.services,
		properties: buildProperties(feature.properties, layer.displayProperties),
		descriptionTableTemplate: descriptionTableTemplate,
		isMobile: isMobile
	} );
	
	$rightDiv.html( output );
	
	// Stay in canvas
	$rightDiv.find('.featureProperties').css('max-height', computeHeight());

	$selectedFeatureDiv.find('.featureProperties').niceScroll({
		autohidemode: false
	}).hide();
}

/**********************************************************************************************/

return {

	/**
	 *	Init
	 *
	 *	@param pm <PickingManager>
	 *	@param gl <GlobWeb.Globe>
	 */
	init: function(pm, im, gl, conf){
		pickingManager = pm;
		imageManager = im;
		globe = gl;
		configuration = conf;
		isMobile = conf.isMobile;

		$selectedFeatureDiv = $(selectedFeatureDiv).appendTo('body');
		$leftDiv = $('#leftDiv');
		$rightDiv = $('#rightDiv');

		// Initialize image processing popup
		ImageProcessing.init({
			disable: function(){
				$('#dynamicImageView').removeClass('dynamicAvailable').addClass('dynamicNotAvailable');	
			},
			unselect: function(){
				$('#dynamicImageView').removeClass('selected');
			}
		});

		// Show/hide quicklook
		$selectedFeatureDiv.on("click", '#quicklook', function(event){
			var selectedData = pickingManager.getSelectedData();

			var otherQuicklookOn = selectedData.feature.properties.style.fill && !selectedData.feature.properties.style.fillTextureUrl;
			if ( otherQuicklookOn )
			{
				// Remove fits quicklook
				imageManager.removeImage(selectedData);
			}

			selectedData.isFits = false;
			if ( selectedData.feature.properties.style.fill == true )
			{
				imageManager.removeImage(selectedData);
			} 
			else
			{
				imageManager.addImage(selectedData);
			}
		});

		$selectedFeatureDiv.on('click', "#quicklookFits", function(event){
			var selectedData = pickingManager.getSelectedData();

			var otherQuicklookOn = selectedData.feature.properties.style.fill && selectedData.feature.properties.style.fillTextureUrl;
			if ( otherQuicklookOn )
			{
				// Remove quicklook
				imageManager.removeImage(selectedData);
			}

			selectedData.isFits = true;
			if ( selectedData.feature.properties.style.fill == true )
			{
				imageManager.removeImage(selectedData);
			} 
			else
			{
				imageManager.addImage(selectedData);
			}
		});

		// Show/hide Dynamic image service
		$selectedFeatureDiv.on("click", '#dynamicImageView', function(event){
			$(this).toggleClass('selected');
			var selectedData = pickingManager.getSelectedData();
			ImageProcessing.setData(selectedData);
		});

		// Send image by Samp
		$selectedFeatureDiv.on("click", '#sendImage', function(event){
			var selectedData = pickingManager.getSelectedData();
			var message = Samp.sendImage(selectedData.feature.services.download.url);
			$('#serviceStatus').html(message).slideDown().delay(1500).slideUp();
		});

		// Show/hide HEALPix service
		$selectedFeatureDiv.on("click", '#healpix', function(event){
			var selectedData = pickingManager.getSelectedData();
			var healpixLayer = selectedData.feature.services.healpix.layer;

			if ( $('#healpix').is('.selected') )
			{
				$('#healpix').removeClass('selected');
				healpixLayer.visible(false);
			}
			else
			{
				$('#healpix').addClass('selected');
				healpixLayer.visible(true);
			}
		});

		// Show/hide Solar object service
		$selectedFeatureDiv.on("click", '#solarObjects', function(event){
			var selectedData = pickingManager.getSelectedData();
			var selection = pickingManager.getSelection();

			var solarObjectsLayer;
			var layer = selectedData.layer;

			if ( selectedData.feature.services.solarObjects )
			{
				solarObjectsLayer = selectedData.feature.services.solarObjects.layer;
			}
			else
			{
				// Create solar object layer
				var defaultVectorStyle = new FeatureStyle({ 
					iconUrl: configuration.mizarBaseUrl + "css/images/star.png",
					zIndex: 2
				});

				var options = {
					name: "SolarObjectsSublayer",
					style: defaultVectorStyle
				};

				solarObjectsLayer = new VectorLayer( options );
				globe.addLayer(solarObjectsLayer);
				pickingManager.addPickableLayer(solarObjectsLayer);

				var url = configuration.solarObjects.baseUrl;
				if ( globe.tileManager.imageryProvider.tiling.coordSystem == "EQ" )
            	{
            		url += "EQUATORIAL";
            	}
            	else
            	{
            		url += "GALACTIC";
            	}
            	
				$('#solarObjectsSpinner').show();
				$.ajax({
					type: "GET",
					url: url,
					data : {
						order: selection.selectedTile.order,
						healpix: selection.selectedTile.pixelIndex,
						EPOCH: selectedData.feature.properties['date-obs']
						// coordSystem: (globe.tileManager.imageryProvider.tiling.coordSystem == "EQ" ? "EQUATORIAL" : "GALACTIC")
					},
					success: function(response){
						JsonProcessor.handleFeatureCollection( solarObjectsLayer, response );
						$('#serviceStatus').html(response.totalResults + ' objects found').slideDown().delay(400).slideUp();
						solarObjectsLayer.addFeatureCollection(response);
					},
					complete: function(xhr){
						$('#solarObjectsSpinner').hide();
					},
					error: function(xhr)
					{
						$('#serviceStatus').html('No data found').slideDown().delay(400).slideUp();
					}
				});

				if ( !layer.subLayers )
				{
					layer.subLayers = [];
				}
				selectedData.feature.services.solarObjects = {
					layer: solarObjectsLayer
				}
				layer.subLayers.push(solarObjectsLayer);
			}

			if ( $('#solarObjects').is('.selected') )
			{
				$('#solarObjects').removeClass('selected');
				solarObjectsLayer.visible(false);
			}
			else
			{
				$('#solarObjects').addClass('selected');
				solarObjectsLayer.visible(true);
			}
		});

		// Arrow scroll events
		$selectedFeatureDiv.on("mousedown", '#scroll-arrow-down.clickable', function(event){
			$('#selectedFeatureDiv #scroll-arrow-up').css("border-bottom-color", "orange").addClass("clickable");
			var $featureList = $('#featureList');
			var animationStep = parseInt($('#featureListDiv').css('max-height'))/2;
			var topValue = parseInt($featureList.css("top"), 10) - animationStep;
			var height = $featureList.height();
			var maxHeight = parseInt( $('#featureListDiv').css("max-height") );
			if (topValue <= -(height - maxHeight))
			{
				topValue = -(height - maxHeight);
				$(this).css("border-top-color", "gray").removeClass("clickable");
			}
			$featureList.stop().animate({top: topValue +"px"}, 300);
		}).disableSelection();
		
		$selectedFeatureDiv.on("mousedown", '#scroll-arrow-up.clickable', function(event){
			$('#selectedFeatureDiv #scroll-arrow-down').css("border-top-color", "orange").addClass("clickable");
			var $featureList = $('#featureList');
			var animationStep = parseInt($('#featureListDiv').css('max-height'))/2;
			var topValue = parseInt($featureList.css("top"), 10) + animationStep;
			if (topValue >= 0)
			{
				topValue = 0;
				$(this).css("border-bottom-color", "gray").removeClass("clickable");
			}
			$featureList.stop().animate({top: topValue +"px"}, 300);
		}).disableSelection();

		// Show/hide subsection properties
		$selectedFeatureDiv.on("click", '.section', function(event){

			$selectedFeatureDiv.find('.featureProperties').getNiceScroll().hide();
			// TODO slideToggle works with div -> add div to the tab generation
			$(this).siblings('table').fadeToggle("slow", "linear", function(){
				$selectedFeatureDiv.find('.featureProperties').getNiceScroll().show();
				$selectedFeatureDiv.find('.featureProperties').getNiceScroll().resize();
			});/*slideToggle(300)*/;
			if ( $(this).siblings('#arrow').is('.arrow-right') )
			{
				$(this).siblings('#arrow').removeClass('arrow-right').addClass('arrow-bottom');
			}
			else
			{
				$(this).siblings('#arrow').removeClass('arrow-bottom').addClass('arrow-right');
			}
		});

		// Choose feature by clicking on its title
		var self = this;
		$selectedFeatureDiv.on("click", '.featureTitle', function(){
			pickingManager.blurSelectedFeature();
			$('#featureList div.selected').removeClass('selected');
			
			var featureIndexToFocus = $(this).index();
			pickingManager.focusFeatureByIndex( featureIndexToFocus );
			var selectedData = pickingManager.getSelectedData();
			
			$('#featureList div:eq('+featureIndexToFocus+')').addClass('selected');
			self.showFeatureInformation( selectedData.layer, selectedData.feature );

			globe.renderContext.requestFrame();

			// TODO highlight is not fully implemented
			// Samp.highlightFeature(selectedData.layer, selectedData.feature);
		});

		// Show/hide external resource
		$selectedFeatureDiv.on("click", '.propertiesTable a', function(event){
			event.preventDefault();
			IFrame.show(event.target.innerHTML);
		});

		$rightDiv.css('max-width', $('#'+globe.renderContext.canvas.id).width()/4 );
		// Make rightDiv always visible depending on viewport
		$(window).on('resize', function(){
			$rightDiv.find('.featureProperties').css('max-height', computeHeight());
			$rightDiv.css('max-width',$('#'+globe.renderContext.canvas.id).width()/4 );
		});

	},

	/**********************************************************************************************/

	/**
	 *	Hide popup
	 *
	 *	@param callback Callback 
	 */
	hide: function(callback){
		if ( $selectedFeatureDiv.css('display') != 'none') {
			$selectedFeatureDiv.find('.featureProperties').getNiceScroll().hide();
			 
			$selectedFeatureDiv.fadeOut(300, function(){
				$selectedFeatureDiv.find('.featureProperties').getNiceScroll().remove();

				if ( callback )
					callback();
			});
		}
		else if ( callback )
		{
			callback();
		}
	},

	/**********************************************************************************************/

	/**
	 *	Show popup
	 *
	 *	@param x X in window coordinate system
	 *	@param y Y in window coordinate system
	 *	@param callback Callback
	 */
	show: function(x, y, callback){
		computeDivPosition(x,y);
		$selectedFeatureDiv.fadeIn(500, function() {
			$selectedFeatureDiv.find('.featureProperties').getNiceScroll().resize();
			if (callback) callback();
		});
		var maxHeight = computeHeight();
		var popupMaxHeight = maxHeight - 60;
		$('#featureListDiv').css('max-height', popupMaxHeight);
		if ( $leftDiv.find('#featureList').height() > popupMaxHeight )
		{
			$leftDiv.find('.scroll-arrow-up, .scroll-arrow-down').css('display', 'block');
		}
	},

	/**********************************************************************************************/

	/**
	 * 	Insert HTML code of selected features
	 * 
	 * 	@param {<GlobWeb.Feature>[]} seleciton Array of features
	 */
	createFeatureList: function(selection){
		featureListHTML = featureListTemplate( { selection: selection });
		$leftDiv.html( featureListHTML );
	},

	/**********************************************************************************************/

	/**
	 * 	Insert HTML code of help to iterate on each feature
	 */
	createHelp: function(){
		$rightDiv.html( pileStashHelp );
	},

	/**********************************************************************************************/

	/**
	 * 	Show feature information
	 */
	showFeatureInformation: function(layer, feature){
		$rightDiv.find('.featureProperties').getNiceScroll().hide();
		$rightDiv.fadeOut(300, function(){
			$rightDiv.find('.featureProperties').getNiceScroll().remove();
			createHTMLSelectedFeatureDiv( layer, feature );
			$(this).fadeIn(300, function(){
				$selectedFeatureDiv.find('.featureProperties').getNiceScroll().resize();
				$selectedFeatureDiv.find('.featureProperties').getNiceScroll().show();
		 	});
		 });
	},

	/**********************************************************************************************/

	/**
	 *	Generate feature meta data for the given feature
	 */
	generateFeatureMetadata: function( layer, feature )
	{
		return featureDescriptionTemplate( {
			dictionary: layer.hasOwnProperty('dictionary') ? layer.dictionary : createDictionary(layer, feature.properties),
			services : false,
			properties: buildProperties(feature.properties, layer.displayProperties),
			descriptionTableTemplate: descriptionTableTemplate
		} );
	}

	/**********************************************************************************************/

};

});
/******************************************************************************* 
* Copyright 2012, 2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES 
* 
* This file is part of SITools2. 
* 
* SITools2 is free software: you can redistribute it and/or modify 
* it under the terms of the GNU General Public License as published by 
* the Free Software Foundation, either version 3 of the License, or 
* (at your option) any later version. 
* 
* SITools2 is distributed in the hope that it will be useful, 
* but WITHOUT ANY WARRANTY; without even the implied warranty of 
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
* GNU General Public License for more details. 
* 
* You should have received a copy of the GNU General Public License 
* along with SITools2. If not, see <http://www.gnu.org/licenses/>. 
******************************************************************************/ 

/**
 * Image manager
 */
define('ImageManager', [ "jquery", "gw/FeatureStyle", "gw/DynamicImage", "./FitsLoader", "./Utils", "./ImageProcessing", "fits" ],
			function($, FeatureStyle, DynamicImage, FitsLoader, Utils, ImageProcessing) {

var sky = null;
var sitoolsBaseUrl;

/**********************************************************************************************/

/**
 *	Send XHR request for FITS file
 *
 *	@param featureData Feature data(layer,feature)
 *	@param url Url of fits file
 */
function computeFits(featureData, url, preprocessing)
{
	var xhr = FitsLoader.loadFits(url, function(fits){
		delete featureData.xhr;

		var fitsData = fits.getHDU().data;
		if ( preprocessing )
		{
			preprocessing(featureData, fits);
		}

		handleFits(fitsData, featureData);
	});

	// Store xhr on feature data object to cancel it if needed
	featureData.xhr = xhr;
	this.mizar.publish("image:download", featureData);
}

/**********************************************************************************************/

/**
 *	Handle fits data on the given feature
 */
function handleFits(fitsData, featureData)
{
	// Create new image coming from Fits
	var typedArray = new Float32Array( fitsData.view.buffer, fitsData.begin, fitsData.length/4); // with gl.FLOAT
	var gl = sky.renderContext.gl;
	var image = new DynamicImage(sky.renderContext, typedArray, gl.LUMINANCE, gl.FLOAT, fitsData.width, fitsData.height);

	var feature = featureData.feature;
	var layer = featureData.layer;
	// Attach texture to style
	var targetStyle;
	if ( feature.properties.style )
	{
		targetStyle = new FeatureStyle( feature.properties.style );
	}
	else
	{
		targetStyle = new FeatureStyle( layer.style );
	}
	targetStyle.fillTexture = image.texture;
	targetStyle.uniformValues = image;
	targetStyle.fill = true;
	layer.modifyFeatureStyle( feature, targetStyle );

	// Store image url for zScale processing
	if ( feature.services )
	{
		image.url = feature.services.download.url;
	}

	// Set image on image processing popup
	ImageProcessing.setImage(image);
}

/**********************************************************************************************/

/**
 *	Remove fits texture from feature
 */
function removeFitsFromRenderer(featureData)
{
	// Abort xhr if inprogress
	if ( featureData.xhr )
	{
		featureData.xhr.abort();
		delete featureData.xhr;
	}

	var gl = sky.renderContext.gl;
	if ( featureData.feature.properties.style.uniformValues )
	{
		featureData.feature.properties.style.uniformValues.dispose();
	}
	// TODO : style could still contain fillTextures, is it normal ?
	var texture = featureData.feature.properties.style.fillTexture;
	if ( texture )
	{
		gl.deleteTexture( texture );
	}
 	var targetStyle = new FeatureStyle( featureData.feature.properties.style );
	targetStyle.fillTexture = null;
	targetStyle.fill = false;

	// Remove rendering
	targetStyle.fillShader = {
		fragmentCode: null,
		updateUniforms : null
	};
	delete targetStyle.uniformValues;

	featureData.layer.modifyFeatureStyle( featureData.feature, targetStyle );
}

/**********************************************************************************************/

return {

	/**
	 *	Initialize
	 */
	init: function(mizar, pm, configuration)
	{
		this.mizar = mizar;
		sky = mizar.sky;
		sitoolsBaseUrl = configuration.sitoolsBaseUrl;
		// Enable float texture extension to have higher luminance range
		var ext = sky.renderContext.gl.getExtension("OES_texture_float");
	},

	/**********************************************************************************************/

	/**
	 *	Hide image	
	 */
	hideImage: function(featureData)
	{
		var style = new FeatureStyle( featureData.feature.properties.style );
		style.fill = false;
		featureData.layer.modifyFeatureStyle( featureData.feature, style );
	},

	/**********************************************************************************************/

	/**
	 *	Show image	
	 */
	showImage: function(featureData)
	{
		// Attach texture to style
		var targetStyle = new FeatureStyle( featureData.feature.properties.style );
		targetStyle.fill = true;
	    featureData.layer.modifyFeatureStyle( featureData.feature, targetStyle );
	},

	/**********************************************************************************************/

	/**
	 *	Remove image from renderer
	 */
	removeImage: function(featureData)
	{

		// Publish event that the image of the given feature will be removed
		this.mizar.publish("image:remove", featureData);
		if ( featureData.isFits )
		{
			removeFitsFromRenderer(featureData);
			$('#quicklookFits').removeClass('selected');
		}
		else 
		{
			var style = featureData.feature.properties.style;
			style.fill = false;
			style.fillTextureUrl = null;
			featureData.layer.modifyFeatureStyle( featureData.feature, style );
			$('#quicklook').removeClass('selected');
		}
	},

	/**********************************************************************************************/

	/**
	 *	Start download of texture
	 */
	addImage: function(featureData)
	{
		var feature = featureData.feature;
		// Set fill to true while loading
		var style = new FeatureStyle( feature.properties.style );
		style.fill = true;
		
		// Publish event that the image for the given feature will be loaded
		this.mizar.publish("image:add", featureData);

		if ( featureData.isFits )
		{
			var url = sitoolsBaseUrl+"/proxy?external_url=" + encodeURIComponent(feature.services.download.url);
			this.computeFits(featureData, url);
			$('#quicklookFits').addClass('selected');
		}
		else
		{
			style.fillTextureUrl = sitoolsBaseUrl + "/proxy?external_url=" + feature.properties.quicklook + "&rewrite_redirection=true";
			// For DEBUG : 'upload/ADP_WFI_30DOR_RGB_V1.0_degraded.jpg';
			$('#quicklook').addClass('selected');
		}
		featureData.layer.modifyFeatureStyle( feature, style );
	},
	
	computeFits: computeFits,
	handleFits: handleFits
}

/**********************************************************************************************/

});
/******************************************************************************* 
* Copyright 2012, 2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES 
* 
* This file is part of SITools2. 
* 
* SITools2 is free software: you can redistribute it and/or modify 
* it under the terms of the GNU General Public License as published by 
* the Free Software Foundation, either version 3 of the License, or 
* (at your option) any later version. 
* 
* SITools2 is distributed in the hope that it will be useful, 
* but WITHOUT ANY WARRANTY; without even the implied warranty of 
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
* GNU General Public License for more details. 
* 
* You should have received a copy of the GNU General Public License 
* along with SITools2. If not, see <http://www.gnu.org/licenses/>. 
******************************************************************************/ 

/**
 * PickingManager module
 */
define('PickingManager', [ "jquery", "gw/FeatureStyle", "gw/CoordinateSystem", "gw/OpenSearchLayer", "./FeaturePopup", "./ImageManager", "./CutOutViewFactory", "./Utils" ],
		function($, FeatureStyle, CoordinateSystem, OpenSearchLayer, FeaturePopup, ImageManager, CutOutViewFactory, Utils) {

var sky;
var navigation;
var self;

var selection = [];
var stackSelectionIndex = -1;
var selectedStyle = new FeatureStyle( {
	strokeColor: [1., 1., 0., 1.],
	fillColor: [1., 1., 0., 1.],
	zIndex: 1
} );
var pickableLayers = [];
var selectedTile = null;

var mouseXStart;
var mouseYStart;
var timeStart;

var isMobile;

/**************************************************************************************************************/

/**
 *	Event handler for mouse down
 */
function _handleMouseDown(event)
{
	if ( isMobile && event.type.search("touch") >= 0 )
	{
		event.layerX = event.changedTouches[0].clientX;
		event.layerY = event.changedTouches[0].clientY;
	}

	timeStart = new Date();
	mouseXStart = event.layerX;
	mouseYStart = event.layerY;
	clearSelection();
}

/**************************************************************************************************************/

/**
 * Event handler for mouse up
 */
function _handleMouseUp(event)
{
	var timeEnd = new Date();
	var epsilon = 5;
	var diff = timeEnd - timeStart;

	if ( isMobile && event.type.search("touch") >= 0 )
	{
		event.layerX = event.changedTouches[0].clientX;
		event.layerY = event.changedTouches[0].clientY;
	}

	// If not pan and not reverse name resolver call
	if ( diff < 500 && Math.abs(mouseXStart - event.layerX) < epsilon && Math.abs(mouseYStart - event.layerY) < epsilon )
	{
		var pickPoint = sky.getLonLatFromPixel(event.layerX, event.layerY);

		// Remove selected style for previous selection
		clearSelection();

		var newSelection = computePickSelection(pickPoint);
		
		if ( newSelection.length > 0 )
		{
			// Hide previous popup if any
			FeaturePopup.hide( function() {
				// View on center
				if ( navigation.inertia )
				{
					navigation.inertia.stop();
				}
				navigation.moveTo( pickPoint, 800, function(){
					selection = newSelection;
					
					// Add selected style for new selection
					focusSelection(selection);
					selection.selectedTile = selectedTile;
					FeaturePopup.createFeatureList( selection );
					if ( selection.length > 1 )
					{
						// Create dialogue for the first selection call
						FeaturePopup.createHelp();
						stackSelectionIndex = -1;
					}
					else
					{
						// only one layer, no pile needed, create feature dialogue
						self.focusFeatureByIndex( 0 );
						$('#featureList div:eq(0)').addClass('selected');
						FeaturePopup.showFeatureInformation( selection[stackSelectionIndex].layer, selection[stackSelectionIndex].feature )
					}
					var offset = $(sky.renderContext.canvas).offset();
					FeaturePopup.show(offset.left + sky.renderContext.canvas.width/2, offset.top + sky.renderContext.canvas.height/2);
					}
				);
			});
		} else {
			FeaturePopup.hide();
		}
	}
}

/**************************************************************************************************************/

/**
 *	Activate picking
 */
function activate()
{
	sky.renderContext.canvas.addEventListener("mousedown", _handleMouseDown);
	sky.renderContext.canvas.addEventListener("mouseup", _handleMouseUp);

	if ( isMobile )
	{
		sky.renderContext.canvas.addEventListener("touchstart", _handleMouseDown);
		sky.renderContext.canvas.addEventListener("touchend", _handleMouseUp);
	}

	// Hide popup and blur selection when pan/zoom or animation
	navigation.subscribe("modified", function() { 
		clearSelection();
		FeaturePopup.hide();
	});
}

/**************************************************************************************************************/

/**
 *	Deactivate picking
 */
function deactivate()
{
	sky.renderContext.canvas.removeEventListener("mousedown", _handleMouseDown);
	sky.renderContext.canvas.removeEventListener("mouseup", _handleMouseUp);

	if ( isMobile )
	{
		sky.renderContext.canvas.removeEventListener("touchstart", _handleMouseDown);
		sky.renderContext.canvas.removeEventListener("touchend", _handleMouseUp);
	}
	
	// Hide popup and blur selection when pan/zoom or animation
	navigation.unsubscribe("modified", function() { 
		clearSelection();
		FeaturePopup.hide();
	});
}

/**************************************************************************************************************/

/**
 * 	Revert style of selection
 */
function blurSelection()
{
	for ( var i=0; i < selection.length; i++ ) {
		var selectedData = selection[i];
		var style = new FeatureStyle( selectedData.feature.properties.style );
		switch ( selectedData.feature.geometry.type )
		{
			case "Polygon":
			case "MultiPolygon":
				style.strokeColor = selectedData.layer.style.strokeColor;
				break;
			case "Point":
				style.fillColor = selectedData.layer.style.fillColor;
				break;
			default:
				break;
		}
		style.zIndex = selectedData.layer.style.zIndex;

		if ( selectedData.layer.globe )
		{
			// Layer is still attached to globe
			selectedData.layer.modifyFeatureStyle( selectedData.feature, style );
		}
	}
}

/**************************************************************************************************************/

/**
 * 	Apply selectedStyle to selection
 */
function focusSelection(newSelection)
{
	var style;
	for ( var i=0; i < newSelection.length; i++ ) {
		var selectedData = newSelection[i];

		if ( selectedData.feature.properties.style )
		{
			style = new FeatureStyle( selectedData.feature.properties.style );	
		}
		else
		{
			style = new FeatureStyle( selectedData.layer.style );
		}

		switch ( selectedData.feature.geometry.type )
		{
			case "Polygon":
			case "MultiPolygon":
				style.strokeColor = selectedStyle.strokeColor;
				break;
			case "Point":
				style.fillColor = selectedStyle.fillColor;
				break;
			default:
				break;
		}
		style.zIndex = selectedStyle.zIndex;
		selectedData.layer.modifyFeatureStyle( selectedData.feature, style );
	}
}

/**************************************************************************************************************/

/**
 *	Clear selection
 */
function clearSelection()
{
	blurSelection();
	selection = [];
}

/**************************************************************************************************************/

/**
 *	Check if a geometry crosses the date line
 */
function fixDateLine(pickPoint, coords)
{		
	var crossDateLine = false;
	var startLon = coords[0][0];
	for ( var i = 1; i < coords.length && !crossDateLine; i++) {
		var deltaLon = Math.abs( coords[i][0] - startLon );
		if ( deltaLon > 180 ) {
			// DateLine!
			crossDateLine =  true;
		}
	}
	
	if ( crossDateLine )
	{
		var fixCoords = [];
		
		if ( pickPoint[0] < 0. )
		{
			// Ensure coordinates are always negative
			for ( var n = 0; n < coords.length; n++) {
				if ( coords[n][0] > 0 ) {
					fixCoords[n] = [ coords[n][0] - 360, coords[n][1] ];
				} else {
					fixCoords[n] = [ coords[n][0], coords[n][1] ];
				}
			}
		}
		else
		{
			// Ensure coordinates are always positive
			for ( var n = 0; n < coords.length; n++) {
				if ( coords[n][0] < 0 ) {
					fixCoords[n] = [ coords[n][0] + 360, coords[n][1] ];
				} else {
					fixCoords[n] = [ coords[n][0], coords[n][1] ];
				}
			}
		}
		
		return fixCoords;
	}
	else
	{
		return coords;
	}
}

/**************************************************************************************************************/

/**
 * 	Compute the selection at the picking point
 */
function computePickSelection( pickPoint )
{
	selectedTile = sky.tileManager.getVisibleTile(pickPoint[0], pickPoint[1]);
	var newSelection = [];
	
	for ( var i=0; i<pickableLayers.length; i++ )
	{
		var pickableLayer = pickableLayers[i];
		if ( pickableLayer.visible() )
		{
			if ( pickableLayer instanceof OpenSearchLayer )
			{
				// Extension using layer
				// Search for features in each tile
				var tile = selectedTile;
				var tileData = tile.extension[pickableLayer.extId];

				if ( !tileData || tileData.state != OpenSearchLayer.TileState.LOADED )
				{
					while ( tile.parent && (!tileData || tileData.state != OpenSearchLayer.TileState.LOADED) )
					{
						tile = tile.parent;
						tileData = tile.extension[pickableLayer.extId];
					}
				}

				if ( tileData )
				{
					for ( var j=0; j<tileData.featureIds.length; j++ )
					{
						var feature = pickableLayer.features[pickableLayer.featuresSet[tileData.featureIds[j]].index];

						switch ( feature['geometry'].type )
						{
							case "Polygon":
								var ring = fixDateLine(pickPoint, feature['geometry']['coordinates'][0]);
								if ( Utils.pointInRing( pickPoint, ring ) )
								{
									newSelection.push( { feature: feature, layer: pickableLayer } );
								}
								break;
							case "MultiPolygon":
								for ( var p=0; p<feature['geometry']['coordinates'].length; p++ )
								{
									var ring = fixDateLine(pickPoint, feature['geometry']['coordinates'][p][0]);
									if( Utils.pointInRing( pickPoint, ring ) )
									{
										newSelection.push( { feature: feature, layer: pickableLayer } );
									}
								}
								break;
							case "Point":
								var point = feature['geometry']['coordinates'];
								if ( feature.cluster )
								{
									if ( Utils.pointInSphere( pickPoint, point, feature['geometry']._bucket.textureHeight ) )
									{
										newSelection.push( { feature: feature, layer: pickableLayer } );
									}
								}
								else
								{
									if ( Utils.pointInSphere( pickPoint, point, feature['geometry']._bucket.textureHeight ) )
									{
										newSelection.push( { feature: feature, layer: pickableLayer } );
									}
								}
								break;
							default:
								break;
						}
					}
				}	
			}
			else
			{
				// Vector layer
				// Search for picked features
				for ( var j=0; j<pickableLayer.features.length; j++ )
				{
					var feature =  pickableLayer.features[j];
					switch ( feature['geometry'].type )
					{
						case "Polygon":
							var ring = fixDateLine(pickPoint, feature['geometry']['coordinates'][0]);
							if ( Utils.pointInRing( pickPoint, ring ) )
							{
								newSelection.push( { feature: feature, layer: pickableLayer } );
							}
							break;
						case "MultiPolygon":
							for ( var p=0; p<feature['geometry']['coordinates'].length; p++ )
							{
								var ring = fixDateLine(pickPoint, feature['geometry']['coordinates'][p][0]);
								if( Utils.pointInRing( pickPoint, ring ) )
								{
									newSelection.push( { feature: feature, layer: pickableLayer } );
								}
							}
							break;
						case "Point":
							if ( Utils.pointInSphere( pickPoint, feature['geometry']['coordinates'], feature['geometry']._bucket.textureHeight ) )
							{
								newSelection.push( { feature: feature, layer: pickableLayer } );
							}
							break;
						default:
							break;
					}
				}
			}
		}
	}
	
	return newSelection;
}

/**************************************************************************************************************/

return {
	/**
	 *	Init picking manager
	 */
	init: function( mizar, configuration ) 
	{
		// Store the sky in the global module variable
		sky = mizar.sky;
		navigation = mizar.navigation;
		self = this;
		isMobile = configuration.isMobile;

		activate();
	
		// Initialize the fits manager
		ImageManager.init(mizar, this, configuration);

		if ( configuration.cutOut )
		{
			// CutOutView factory ... TODO : move it/refactor it/do something with it...
			CutOutViewFactory.init(sky, navigation, this);
		}
		FeaturePopup.init(this, ImageManager, sky, configuration);
	},

	/**************************************************************************************************************/
	
	/**
	 *	Add pickable layer
	 */
	addPickableLayer: function( layer )
	{
		pickableLayers.push( layer );
	},

	/**************************************************************************************************************/
	
	/**
	 *	Remove pickable layers
	 */
	removePickableLayer: function( layer )
	{
		for ( var i=0; i<pickableLayers.length; i++ )
		{
			if( layer.id == pickableLayers[i].id )
				pickableLayers.splice( i, 1 );
		}
	},

	/**************************************************************************************************************/

	/**
	 * 	Revert style of selected feature
	 */
	blurSelectedFeature: function()
	{
		var selectedData = selection[stackSelectionIndex];
		if ( selectedData )
		{
			var style = new FeatureStyle( selectedData.feature.properties.style );
			switch ( selectedData.feature.geometry.type )
			{
				case "Polygon":
				case "MultiPolygon":
					style.strokeColor = selectedData.layer.style.strokeColor; 
					break;
				case "Point":
					style.fillColor = selectedData.layer.style.fillColor; 
					break;
				default:
					break;
			}
			style.zIndex = selectedData.layer.style.zIndex;
			selectedData.layer.modifyFeatureStyle( selectedData.feature, style );
		}
	},

	/**************************************************************************************************************/

	/**
	 * 	Apply selected style to the feature by the given index in selection array
	 * 
	 * 	@param index Index of feature in selection array
	 */
	focusFeatureByIndex: function(index)
	{
		blurSelection();
		var selectedData = selection[index];
		if ( selectedData )
		{
			stackSelectionIndex = index;
			var style = new FeatureStyle( selectedData.feature.properties.style );
			switch ( selectedData.feature.geometry.type )
			{
				case "Polygon":
				case "MultiPolygon":
					style.strokeColor = selectedStyle.strokeColor;
					break;
				case "Point":
					style.fillColor = selectedStyle.fillColor;
					break;
				default:
					break;
			}
			style.zIndex = selectedStyle.zIndex;
			selectedData.layer.modifyFeatureStyle( selectedData.feature, style );
		}
	},

	/**************************************************************************************************************/

	/**
	 *	Apply selected style to the given feature
	 */
	focusFeature: function(selectedData)
	{
		clearSelection();
		selection = [selectedData];
		this.focusFeatureByIndex(0);
	},

	/**************************************************************************************************************/

	getSelectedData: function()
	{
		return selection[stackSelectionIndex];
	},

	/**************************************************************************************************************/

	getSelection: function()
	{
		return selection;
	},

	computePickSelection: computePickSelection,
	activate: activate,
	deactivate: deactivate
};

});
/******************************************************************************* 
* Copyright 2012, 2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES 
* 
* This file is part of SITools2. 
* 
* SITools2 is free software: you can redistribute it and/or modify 
* it under the terms of the GNU General Public License as published by 
* the Free Software Foundation, either version 3 of the License, or 
* (at your option) any later version. 
* 
* SITools2 is distributed in the hope that it will be useful, 
* but WITHOUT ANY WARRANTY; without even the implied warranty of 
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
* GNU General Public License for more details. 
* 
* You should have received a copy of the GNU General Public License 
* along with SITools2. If not, see <http://www.gnu.org/licenses/>. 
******************************************************************************/ 

/**
 * LayerManager module
 */
define('LayerManager', [ "jquery", "underscore-min", "gw/FeatureStyle", "gw/HEALPixLayer", "gw/VectorLayer", "gw/CoordinateGridLayer", "gw/TileWireframeLayer", "gw/OpenSearchLayer", "./ClusterOpenSearchLayer", "./MocLayer", "./HEALPixFITSLayer", "./PickingManager", "./Utils", "./JsonProcessor", "jquery.ui"], 
	function($, _, FeatureStyle, HEALPixLayer, VectorLayer, CoordinateGridLayer, TileWireframeLayer, OpenSearchLayer, ClusterOpenSearchLayer, MocLayer, HEALPixFITSLayer, PickingManager, Utils, JsonProcessor) {

/**
 * Private variables
 */
var sky;
var gwLayers = [];
var configuration;

// GeoJSON data providers
var dataProviders = {};
var votable2geojsonBaseUrl;


/**
 * Private functions
 */

/**************************************************************************************************************/

/**
 *	Create simple vector layer
 */
function createSimpleLayer(name)
{
	// Generate random color
	var rgb = Utils.generateColor();
	var rgba = rgb.concat([1]);
	
	// Create style
	var options = {
		name: name,
		style: new FeatureStyle({
			iconUrl: configuration.mizarBaseUrl + "css/images/star.png",
			fillColor: rgba,
			strokeColor: rgba,
			visible: true
		})
	};

	// Create vector layer
	var gwLayer = new VectorLayer( options );
	// Add the type GeoJSON to be able to zoom on the layer ! (cf HTML generation of additional layer)
	gwLayer.type = "GeoJSON";
	gwLayer.deletable = true;
	gwLayer.pickable = true;

	return gwLayer;
}

/**************************************************************************************************************/

/**
 *	Create layer from configuration file
 */
function createLayerFromConf(layer) {
	var gwLayer;

	// Insure that the link will be opened in new tab
	if ( layer.attribution && layer.attribution.search('<a') >= 0 && layer.attribution.search('target=') < 0 )
	{
		layer.attribution = layer.attribution.replace(' ', ' target=_blank ');
	}

	// default options
	var options = {
		name: layer.name,
		attribution: layer.attribution,
		visible: layer.visible,
		icon: layer.icon,
		description: layer.description,
		onready: layer.onready
	};

	if ( layer.color )
	{
		var rgba = FeatureStyle.fromStringToColor( layer.color );
	}
	else
	{
		// generate random color
		var rgb = Utils.generateColor();
		var rgba = rgb.concat([1]);
	}
	
	var defaultVectorStyle = new FeatureStyle({ 
				rendererHint: "Basic", 
				opacity: layer.opacity/100.,
				iconUrl: layer.icon ? layer.icon : configuration.mizarBaseUrl + "css/images/star.png",
				fillColor: rgba,
				strokeColor: rgba
	});

	switch(layer.type){
		case "healpix":
			// Add necessary options
			options.baseUrl = layer.baseUrl;
			options.coordSystem = layer.coordSystem || "EQ";
			options.dataType = layer.dataType || "jpg";
			options.numberOfLevels = layer.numberOfLevels;

			if ( layer.fitsSupported )
			{
				gwLayer = new HEALPixFITSLayer(options);
			}
			else
			{
				gwLayer = new HEALPixLayer(options);
			}
			if ( layer.availableServices )
			{
				gwLayer.availableServices = layer.availableServices;
				gwLayer.healpixCutFileName = layer.healpixCutFileName;
			}

			break;
		
		case "coordinateGrid":
			gwLayer = new CoordinateGridLayer( {
				name: layer.name,
				visible: layer.visible,
				longFormat: layer.longFormat,
				latFormat: layer.latFormat,
				coordSystem: layer.coordSystem,
				color: rgba
			} );
			break;
			
		case "healpixGrid":
			gwLayer = new TileWireframeLayer( {name: layer.name, visible: layer.visible, outline: layer.outline });
			gwLayer.style = defaultVectorStyle;
			break;
			
		case "GeoJSON":

			options.style = defaultVectorStyle;
			gwLayer = new VectorLayer(options);

			if ( dataProviders[layer.data.type] )
			{
				var callback = dataProviders[layer.data.type];
				var data = callback(gwLayer, layer.data);
			}

			gwLayer.dataType = layer.dataType || "line";
			gwLayer.pickable = layer.hasOwnProperty('pickable') ? layer.pickable : true;

			break;
			
		case "DynamicOpenSearch":
			
			// Add necessary option			
			options.serviceUrl = layer.serviceUrl;
			options.minOrder = layer.minOrder;
			if (layer.hasOwnProperty('invertY'))
				options.invertY = layer.invertY;

			options.style = defaultVectorStyle;
			if ( layer.hasOwnProperty('coordSystemRequired') ) 
			{
				options.coordSystemRequired = layer.coordSystemRequired;
			}
			if ( layer.useCluster )
			{
				if( layer.maxClusterOrder )
					options.maxClusterOrder = layer.maxClusterOrder;
				if ( layer.treshold )
					options.treshold = layer.treshold;
				if ( layer.accuracyOrder )
					options.accuracyOrder

				gwLayer = new ClusterOpenSearchLayer( options );
			}
			else
			{
				gwLayer = new OpenSearchLayer( options );
			}

			if (layer.displayProperties)
				gwLayer.displayProperties = layer.displayProperties;
			gwLayer.dataType = layer.dataType;
			gwLayer.pickable = layer.hasOwnProperty('pickable') ? layer.pickable : true;
			gwLayer.availableServices = layer.availableServices;
			break;

		case "Moc":
			options.style = defaultVectorStyle;
			options.serviceUrl = layer.serviceUrl;
			options.style.fill = true;
			options.style.fillColor[3] = 0.3 // make transparent
			gwLayer = new MocLayer( options );
			gwLayer.dataType = "line";
			break;
		case "Vector":
			gwLayer = createSimpleLayer(options.name);
			gwLayer.dataType = layer.dataType;
			gwLayer.pickable = layer.hasOwnProperty('pickable') ? layer.pickable : true;
			gwLayer.deletable = false;
			break;
		default:
			console.error(layer.type+" isn't not implemented");
			return null;
	}
	gwLayer.type = layer.type;

	return gwLayer;
}

/**************************************************************************************************************/

/**
 *	Fill the LayerManager table
 */
function initLayers(layers) 
{
	for (var i=0; i<layers.length; i++) {
		var layer = layers[i];
		this.addLayer(layer);
	}
}

/**************************************************************************************************************/

return {
	/**
	 *	Init
	 *
	 *	@param mizar
	 *		Mizar API object
	 *	@param conf
	 *		Mizar configuration
 	 */
	init: function(mizar, conf) {
		this.mizar = mizar;
		configuration = conf;
		// Store the sky in the global module variable
		sky = mizar.sky;

		// TODO : Call init layers
		//initLayers(configuration.layers);
	},
	
	/**
	 *	Register data provider
	 *
	 *	@param type Type of data
	 *	@param loadFunc Callback function loading and adding data to the layer
	 */
	registerDataProvider: function( type, loadFunc )
	{
		dataProviders[type.toString()] = loadFunc;
	},

	/**
	 *	Get current layers
	 */
	 getLayers: function()
	 {
	 	return gwLayers;
	 },

	 /**
	  *	Create layer from layer description and add it to corresponding LayersView
	  *
	  *	@param layer
	  *		Layer description
	  *	@return
	  *		Created layer if doesn't already exist, existing layer otherwise
	  */
	 addLayer: function(layerDesc) {

		var gwLayer = _.findWhere(gwLayers, {name: layerDesc.name});
		if ( !gwLayer ) {
			// If layer hasn't been already added
		 	// Define default optionnal parameters
			if(!layerDesc.opacity)
				layerDesc.opacity = 100.;
			if (!layerDesc.visible)
				layerDesc.visible = false;
		
			gwLayer = createLayerFromConf(layerDesc);
			if ( gwLayer )
			{
				if( layerDesc.background )
				{
					// Add to engine
					if ( gwLayer.visible() ) {
						// Change visibility's of previous layer(maybe GlobWeb should do it ?)
						if ( sky.tileManager.imageryProvider )
						{
							sky.tileManager.imageryProvider.visible(false);
						}

						sky.setBaseImagery( gwLayer );
						gwLayer.visible(true);
					}
					gwLayers.push(gwLayer);
					this.mizar.publish("backgroundLayer:add", gwLayer);

					// Store category name on GlobWeb layer object
					gwLayer.category = "background";
				}
				else
				{
					// Add to engine
					sky.addLayer( gwLayer );
					gwLayers.push(gwLayer);

					// Store category name on GlobWeb layer object
					gwLayer.category = layerDesc.category;

					this.mizar.publish("additionalLayer:add", gwLayer);
				}
			}
		}

		if ( gwLayer.pickable )
			PickingManager.addPickableLayer(gwLayer);

		return gwLayer;
	 },

	 /**
	  *	Remove the given layer
	  *	@param gwLayer
	  *		GlobWeb layer
	  */
	 removeLayer: function(gwLayer) {

	 	var index = gwLayers.indexOf(gwLayer);
	 	gwLayers.splice( index, 1 );
	 	if ( gwLayer.pickable )
			PickingManager.removePickableLayer(gwLayer);

		this.mizar.publish("layer:remove", gwLayer);
	 	sky.removeLayer(gwLayer);
	 },

	 /**
	  *	Set background survey from its name
	  *	@param survey
	  *		Survey name
	  */
	 setBackgroundSurvey: function(survey) {
	 	var gwLayer = _.findWhere(gwLayers, {name: survey});
	 	if ( gwLayer )
	 	{
		 	if ( gwLayer != sky.baseImagery )
		 	{
			 	// Change visibility's of previous layer, because visibility is used to know the active background layer in the layers list (layers can be shared)
				sky.baseImagery.visible(false);
				sky.setBaseImagery( gwLayer );
				gwLayer.visible(true);

				// Clear selection
				PickingManager.getSelection().length = 0;

				for ( var i=0; i<gwLayers.length; i++ )
				{
					var currentLayer = gwLayers[i];
					if ( currentLayer.subLayers )
					{
						var len = currentLayer.subLayers.length;
						for ( var j=0; j<len; j++ )
						{
							var subLayer = currentLayer.subLayers[j];
							if (subLayer.name == "SolarObjectsSublayer" )
							{
								PickingManager.removePickableLayer( subLayer );
								sky.removeLayer( subLayer );
								currentLayer.subLayers.splice(j,1);
							}
						}
					}
				}
			}
			this.mizar.publish("backgroundLayer:change", gwLayer);
	 	} else {
	 		this.mizar.publish("backgroundSurveyError", "Survey " + survey + " hasn't been found");
	 	}
	},

	/**
	 *	Create layer from FITS
	 */
	createLayerFromFits: function(name, fits) {
	 	var gwLayer = createSimpleLayer(name);
		gwLayer.dataType = "line";

		// Create feature
		var coords = Utils.getPolygonCoordinatesFromFits(fits);
		var feature = {
			"geometry": {
				"gid": name,
				"coordinates": [coords],
				"type": "Polygon"
			},
			"properties": {
				"identifier": name
			},
			"type": "Feature"
		};

		gwLayer.addFeature( feature );

		sky.addLayer(gwLayer);
		gwLayers.push(gwLayer);
		return gwLayer;
	},

	/**
	 *	Create layer from GeoJSON
	 */
	createLayerFromGeoJson: function(name, geoJson) {
	 	// Add feature collection
		var gwLayer = createSimpleLayer(name);

		// Add feature collection
		JsonProcessor.handleFeatureCollection( gwLayer, geoJson );
		gwLayer.addFeatureCollection( geoJson );

		sky.addLayer(gwLayer);
		gwLayers.push(gwLayer);
		return gwLayer;
	 },

	 createSimpleLayer: createSimpleLayer
};

});
define('text!../templates/openSearchService.html',[],function () { return '<div id="openSearchTabs">\n\t<ul>\n\t\t<% for ( var i=0; i<layers.length; i++ )\n\t\t{\n\t\t%>\n\t\t\t<li><a href="#osForm_<%=layers[i].id%>"><%= layers[i].name %></a></li>\n\t\t<%\n\t\t}\n\t\t%>\n\t</ul>\n\n<% for ( var i=0; i<layers.length; i++)\n{\n%>\n\t<div id="osForm_<%= layers[i].id %>"> <%= layers[i].openSearchForm %> </div>\n<%\n}\n%>\n</div>';});

define('text!../templates/openSearchForm.html',[],function () { return '<form class="openSearchForm" id="openSearchForm_<%= layer.id %>">\n\t<%\n\tfor(var i=0; i<properties.length; i++)\n\t{\n\t\tvar property = properties[i];\n\t\t%>\n\t\t<label for="<%= property.id %>"><%= property.title %></label>\n\t\t<%\n\t\tif(property.type == "text" || property.type == "number")\n\t\t{\n\t\t%>\n\t\t\t<input type="text" id="<%= property.id %>" name="<%= property.id %>"><br/>\n\t\t<%\n\t\t}\n\t\tif(property.type == "date")\n\t\t{\n\t\t%>\n\t\t\t<input type="text" id="<%= property.id %>" name="<%= property.id %>" class="datepicker" /><br/>\n\t\t<%\n\t\t}\n\t\tif(property.type == "enumeration")\n\t\t{\n\t\t%>\n\t\t\t<select name="<%= property.id %>">\n\t\t\t\t<option value="">None</option>\n\t\t\t\t<%\n\t\t\t\tfor(var j=0; j<property.son.length; j++)\n\t\t\t\t{\n\t\t\t\t%>\n\t\t\t\t\t<option value="<%= property.son[j].id  %>"><%= property.son[j].title %>(<%= property.son[j].population %>)</option>\n\t\t\t\t<% \n\t\t\t\t}\n\t\t\t\t%>\n\t\t\t</select><br/>\n\t\t<%\n\t\t}\n\t}\n\t%>\n\t<input class="submit" type="submit" value="Save parameters" />\n</form>';});

/*
 * jQuery timepicker addon
 * By: Trent Richardson [http://trentrichardson.com]
 * Version 1.2
 * Last Modified: 02/02/2013
 *
 * Copyright 2013 Trent Richardson
 * You may use this project under MIT or GPL licenses.
 * http://trentrichardson.com/Impromptu/GPL-LICENSE.txt
 * http://trentrichardson.com/Impromptu/MIT-LICENSE.txt
 */

/*jslint evil: true, white: false, undef: false, nomen: false */

(function(factory) {
if ( typeof define === "function" && define.amd ) {

		// AMD. Register as an anonymous module.
		define('jquery.ui.timepicker',[ "jquery", "jquery.ui" ], factory );
	} else {

		// Browser globals
		factory( jQuery );
	}
}(function( $ ) {
	/*
	* Lets not redefine timepicker, Prevent "Uncaught RangeError: Maximum call stack size exceeded"
	*/
	$.ui.timepicker = $.ui.timepicker || {};
	if ($.ui.timepicker.version) {
		return;
	}

	/*
	* Extend jQueryUI, get it started with our version number
	*/
	$.extend($.ui, {
		timepicker: {
			version: "1.2"
		}
	});

	/* 
	* Timepicker manager.
	* Use the singleton instance of this class, $.timepicker, to interact with the time picker.
	* Settings for (groups of) time pickers are maintained in an instance object,
	* allowing multiple different settings on the same page.
	*/
	var Timepicker = function() {
		this.regional = []; // Available regional settings, indexed by language code
		this.regional[''] = { // Default regional settings
			currentText: 'Now',
			closeText: 'Done',
			amNames: ['AM', 'A'],
			pmNames: ['PM', 'P'],
			timeFormat: 'HH:mm',
			timeSuffix: '',
			timeOnlyTitle: 'Choose Time',
			timeText: 'Time',
			hourText: 'Hour',
			minuteText: 'Minute',
			secondText: 'Second',
			millisecText: 'Millisecond',
			timezoneText: 'Time Zone',
			isRTL: false
		};
		this._defaults = { // Global defaults for all the datetime picker instances
			showButtonPanel: true,
			timeOnly: false,
			showHour: true,
			showMinute: true,
			showSecond: false,
			showMillisec: false,
			showTimezone: false,
			showTime: true,
			stepHour: 1,
			stepMinute: 1,
			stepSecond: 1,
			stepMillisec: 1,
			hour: 0,
			minute: 0,
			second: 0,
			millisec: 0,
			timezone: null,
			useLocalTimezone: false,
			defaultTimezone: "+0000",
			hourMin: 0,
			minuteMin: 0,
			secondMin: 0,
			millisecMin: 0,
			hourMax: 23,
			minuteMax: 59,
			secondMax: 59,
			millisecMax: 999,
			minDateTime: null,
			maxDateTime: null,
			onSelect: null,
			hourGrid: 0,
			minuteGrid: 0,
			secondGrid: 0,
			millisecGrid: 0,
			alwaysSetTime: true,
			separator: ' ',
			altFieldTimeOnly: true,
			altTimeFormat: null,
			altSeparator: null,
			altTimeSuffix: null,
			pickerTimeFormat: null,
			pickerTimeSuffix: null,
			showTimepicker: true,
			timezoneIso8601: false,
			timezoneList: null,
			addSliderAccess: false,
			sliderAccessArgs: null,
			controlType: 'slider',
			defaultValue: null,
			parse: 'strict'
		};
		$.extend(this._defaults, this.regional['']);
	};

	$.extend(Timepicker.prototype, {
		$input: null,
		$altInput: null,
		$timeObj: null,
		inst: null,
		hour_slider: null,
		minute_slider: null,
		second_slider: null,
		millisec_slider: null,
		timezone_select: null,
		hour: 0,
		minute: 0,
		second: 0,
		millisec: 0,
		timezone: null,
		defaultTimezone: "+0000",
		hourMinOriginal: null,
		minuteMinOriginal: null,
		secondMinOriginal: null,
		millisecMinOriginal: null,
		hourMaxOriginal: null,
		minuteMaxOriginal: null,
		secondMaxOriginal: null,
		millisecMaxOriginal: null,
		ampm: '',
		formattedDate: '',
		formattedTime: '',
		formattedDateTime: '',
		timezoneList: null,
		units: ['hour','minute','second','millisec'],
		control: null,

		/* 
		* Override the default settings for all instances of the time picker.
		* @param  settings  object - the new settings to use as defaults (anonymous object)
		* @return the manager object
		*/
		setDefaults: function(settings) {
			extendRemove(this._defaults, settings || {});
			return this;
		},

		/*
		* Create a new Timepicker instance
		*/
		_newInst: function($input, o) {
			var tp_inst = new Timepicker(),
				inlineSettings = {},
                fns = {},
		        overrides, i;

			for (var attrName in this._defaults) {
				if(this._defaults.hasOwnProperty(attrName)){
					var attrValue = $input.attr('time:' + attrName);
					if (attrValue) {
						try {
							inlineSettings[attrName] = eval(attrValue);
						} catch (err) {
							inlineSettings[attrName] = attrValue;
						}
					}
				}
			}
		    overrides = {
		        beforeShow: function (input, dp_inst) {
		            if ($.isFunction(tp_inst._defaults.evnts.beforeShow)) {
		                return tp_inst._defaults.evnts.beforeShow.call($input[0], input, dp_inst, tp_inst);
		            }
		        },
		        onChangeMonthYear: function (year, month, dp_inst) {
		            // Update the time as well : this prevents the time from disappearing from the $input field.
		            tp_inst._updateDateTime(dp_inst);
		            if ($.isFunction(tp_inst._defaults.evnts.onChangeMonthYear)) {
		                tp_inst._defaults.evnts.onChangeMonthYear.call($input[0], year, month, dp_inst, tp_inst);
		            }
		        },
		        onClose: function (dateText, dp_inst) {
		            if (tp_inst.timeDefined === true && $input.val() !== '') {
		                tp_inst._updateDateTime(dp_inst);
		            }
		            if ($.isFunction(tp_inst._defaults.evnts.onClose)) {
		                tp_inst._defaults.evnts.onClose.call($input[0], dateText, dp_inst, tp_inst);
		            }
		        }
		    };
		    for (i in overrides) {
		        if (overrides.hasOwnProperty(i)) {
		            fns[i] = o[i] || null;
		        }
		    }
		    tp_inst._defaults = $.extend({}, this._defaults, inlineSettings, o, overrides, {
		        evnts:fns,
		        timepicker: tp_inst // add timepicker as a property of datepicker: $.datepicker._get(dp_inst, 'timepicker');
		    });
			tp_inst.amNames = $.map(tp_inst._defaults.amNames, function(val) {
				return val.toUpperCase();
			});
			tp_inst.pmNames = $.map(tp_inst._defaults.pmNames, function(val) {
				return val.toUpperCase();
			});

			// controlType is string - key to our this._controls
			if(typeof(tp_inst._defaults.controlType) === 'string'){
				if($.fn[tp_inst._defaults.controlType] === undefined){
					tp_inst._defaults.controlType = 'select';
				}
				tp_inst.control = tp_inst._controls[tp_inst._defaults.controlType];
			}
			// controlType is an object and must implement create, options, value methods
			else{ 
				tp_inst.control = tp_inst._defaults.controlType;
			}

			if (tp_inst._defaults.timezoneList === null) {
				var timezoneList = ['-1200', '-1100', '-1000', '-0930', '-0900', '-0800', '-0700', '-0600', '-0500', '-0430', '-0400', '-0330', '-0300', '-0200', '-0100', '+0000', 
									'+0100', '+0200', '+0300', '+0330', '+0400', '+0430', '+0500', '+0530', '+0545', '+0600', '+0630', '+0700', '+0800', '+0845', '+0900', '+0930', 
									'+1000', '+1030', '+1100', '+1130', '+1200', '+1245', '+1300', '+1400'];

				if (tp_inst._defaults.timezoneIso8601) {
					timezoneList = $.map(timezoneList, function(val) {
						return val == '+0000' ? 'Z' : (val.substring(0, 3) + ':' + val.substring(3));
					});
				}
				tp_inst._defaults.timezoneList = timezoneList;
			}

			tp_inst.timezone = tp_inst._defaults.timezone;
			tp_inst.hour = tp_inst._defaults.hour < tp_inst._defaults.hourMin? tp_inst._defaults.hourMin : 
							tp_inst._defaults.hour > tp_inst._defaults.hourMax? tp_inst._defaults.hourMax : tp_inst._defaults.hour;
			tp_inst.minute = tp_inst._defaults.minute < tp_inst._defaults.minuteMin? tp_inst._defaults.minuteMin : 
							tp_inst._defaults.minute > tp_inst._defaults.minuteMax? tp_inst._defaults.minuteMax : tp_inst._defaults.minute;
			tp_inst.second = tp_inst._defaults.second < tp_inst._defaults.secondMin? tp_inst._defaults.secondMin : 
							tp_inst._defaults.second > tp_inst._defaults.secondMax? tp_inst._defaults.secondMax : tp_inst._defaults.second;
			tp_inst.millisec = tp_inst._defaults.millisec < tp_inst._defaults.millisecMin? tp_inst._defaults.millisecMin : 
							tp_inst._defaults.millisec > tp_inst._defaults.millisecMax? tp_inst._defaults.millisecMax : tp_inst._defaults.millisec;
			tp_inst.ampm = '';
			tp_inst.$input = $input;

			if (o.altField) {
				tp_inst.$altInput = $(o.altField).css({
					cursor: 'pointer'
				}).focus(function() {
					$input.trigger("focus");
				});
			}

			if (tp_inst._defaults.minDate === 0 || tp_inst._defaults.minDateTime === 0) {
				tp_inst._defaults.minDate = new Date();
			}
			if (tp_inst._defaults.maxDate === 0 || tp_inst._defaults.maxDateTime === 0) {
				tp_inst._defaults.maxDate = new Date();
			}

			// datepicker needs minDate/maxDate, timepicker needs minDateTime/maxDateTime..
			if (tp_inst._defaults.minDate !== undefined && tp_inst._defaults.minDate instanceof Date) {
				tp_inst._defaults.minDateTime = new Date(tp_inst._defaults.minDate.getTime());
			}
			if (tp_inst._defaults.minDateTime !== undefined && tp_inst._defaults.minDateTime instanceof Date) {
				tp_inst._defaults.minDate = new Date(tp_inst._defaults.minDateTime.getTime());
			}
			if (tp_inst._defaults.maxDate !== undefined && tp_inst._defaults.maxDate instanceof Date) {
				tp_inst._defaults.maxDateTime = new Date(tp_inst._defaults.maxDate.getTime());
			}
			if (tp_inst._defaults.maxDateTime !== undefined && tp_inst._defaults.maxDateTime instanceof Date) {
				tp_inst._defaults.maxDate = new Date(tp_inst._defaults.maxDateTime.getTime());
			}
			tp_inst.$input.bind('focus', function() {
				tp_inst._onFocus();
			});

			return tp_inst;
		},

		/*
		* add our sliders to the calendar
		*/
		_addTimePicker: function(dp_inst) {
			var currDT = (this.$altInput && this._defaults.altFieldTimeOnly) ? this.$input.val() + ' ' + this.$altInput.val() : this.$input.val();

			this.timeDefined = this._parseTime(currDT);
			this._limitMinMaxDateTime(dp_inst, false);
			this._injectTimePicker();
		},

		/*
		* parse the time string from input value or _setTime
		*/
		_parseTime: function(timeString, withDate) {
			if (!this.inst) {
				this.inst = $.datepicker._getInst(this.$input[0]);
			}

			if (withDate || !this._defaults.timeOnly) {
				var dp_dateFormat = $.datepicker._get(this.inst, 'dateFormat');
				try {
					var parseRes = parseDateTimeInternal(dp_dateFormat, this._defaults.timeFormat, timeString, $.datepicker._getFormatConfig(this.inst), this._defaults);
					if (!parseRes.timeObj) {
						return false;
					}
					$.extend(this, parseRes.timeObj);
				} catch (err) {
					$.timepicker.log("Error parsing the date/time string: " + err +
									"\ndate/time string = " + timeString +
									"\ntimeFormat = " + this._defaults.timeFormat +
									"\ndateFormat = " + dp_dateFormat);
					return false;
				}
				return true;
			} else {
				var timeObj = $.datepicker.parseTime(this._defaults.timeFormat, timeString, this._defaults);
				if (!timeObj) {
					return false;
				}
				$.extend(this, timeObj);
				return true;
			}
		},

		/*
		* generate and inject html for timepicker into ui datepicker
		*/
		_injectTimePicker: function() {
			var $dp = this.inst.dpDiv,
				o = this.inst.settings,
				tp_inst = this,
				litem = '',
				uitem = '',
				max = {},
				gridSize = {},
				size = null;

			// Prevent displaying twice
			if ($dp.find("div.ui-timepicker-div").length === 0 && o.showTimepicker) {
				var noDisplay = ' style="display:none;"',
					html = '<div class="ui-timepicker-div'+ (o.isRTL? ' ui-timepicker-rtl' : '') +'"><dl>' + '<dt class="ui_tpicker_time_label"' + ((o.showTime) ? '' : noDisplay) + '>' + o.timeText + '</dt>' + 
								'<dd class="ui_tpicker_time"' + ((o.showTime) ? '' : noDisplay) + '></dd>';

				// Create the markup
				for(var i=0,l=this.units.length; i<l; i++){
					litem = this.units[i];
					uitem = litem.substr(0,1).toUpperCase() + litem.substr(1);
					// Added by Peter Medeiros:
					// - Figure out what the hour/minute/second max should be based on the step values.
					// - Example: if stepMinute is 15, then minMax is 45.
					max[litem] = parseInt((o[litem+'Max'] - ((o[litem+'Max'] - o[litem+'Min']) % o['step'+uitem])), 10);
					gridSize[litem] = 0;

					html += '<dt class="ui_tpicker_'+ litem +'_label"' + ((o['show'+uitem]) ? '' : noDisplay) + '>' + o[litem +'Text'] + '</dt>' + 
								'<dd class="ui_tpicker_'+ litem +'"><div class="ui_tpicker_'+ litem +'_slider"' + ((o['show'+uitem]) ? '' : noDisplay) + '></div>';

					if (o['show'+uitem] && o[litem+'Grid'] > 0) {
						html += '<div style="padding-left: 1px"><table class="ui-tpicker-grid-label"><tr>';

						if(litem == 'hour'){
							for (var h = o[litem+'Min']; h <= max[litem]; h += parseInt(o[litem+'Grid'], 10)) {
								gridSize[litem]++;
								var tmph = $.datepicker.formatTime(useAmpm(o.pickerTimeFormat || o.timeFormat)? 'hht':'HH', {hour:h}, o);									
								html += '<td data-for="'+litem+'">' + tmph + '</td>';
							}
						}
						else{
							for (var m = o[litem+'Min']; m <= max[litem]; m += parseInt(o[litem+'Grid'], 10)) {
								gridSize[litem]++;
								html += '<td data-for="'+litem+'">' + ((m < 10) ? '0' : '') + m + '</td>';
							}
						}

						html += '</tr></table></div>';
					}
					html += '</dd>';
				}
				
				// Timezone
				html += '<dt class="ui_tpicker_timezone_label"' + ((o.showTimezone) ? '' : noDisplay) + '>' + o.timezoneText + '</dt>';
				html += '<dd class="ui_tpicker_timezone" ' + ((o.showTimezone) ? '' : noDisplay) + '></dd>';

				// Create the elements from string
				html += '</dl></div>';
				var $tp = $(html);

				// if we only want time picker...
				if (o.timeOnly === true) {
					$tp.prepend('<div class="ui-widget-header ui-helper-clearfix ui-corner-all">' + '<div class="ui-datepicker-title">' + o.timeOnlyTitle + '</div>' + '</div>');
					$dp.find('.ui-datepicker-header, .ui-datepicker-calendar').hide();
				}
				
				// add sliders, adjust grids, add events
				for(var i=0,l=tp_inst.units.length; i<l; i++){
					litem = tp_inst.units[i];
					uitem = litem.substr(0,1).toUpperCase() + litem.substr(1);

					// add the slider
					tp_inst[litem+'_slider'] = tp_inst.control.create(tp_inst, $tp.find('.ui_tpicker_'+litem+'_slider'), litem, tp_inst[litem], o[litem+'Min'], max[litem], o['step'+uitem]);

					// adjust the grid and add click event
					if (o['show'+uitem] && o[litem+'Grid'] > 0) {
						size = 100 * gridSize[litem] * o[litem+'Grid'] / (max[litem] - o[litem+'Min']);
						$tp.find('.ui_tpicker_'+litem+' table').css({
							width: size + "%",
							marginLeft: o.isRTL? '0' : ((size / (-2 * gridSize[litem])) + "%"),
							marginRight: o.isRTL? ((size / (-2 * gridSize[litem])) + "%") : '0',
							borderCollapse: 'collapse'
						}).find("td").click(function(e){
								var $t = $(this),
									h = $t.html(),
									n = parseInt(h.replace(/[^0-9]/g),10),
									ap = h.replace(/[^apm]/ig),
									f = $t.data('for'); // loses scope, so we use data-for

								if(f == 'hour'){
									if(ap.indexOf('p') !== -1 && n < 12){
										n += 12;
									}
									else{
										if(ap.indexOf('a') !== -1 && n === 12){
											n = 0;
										}
									}
								}
								
								tp_inst.control.value(tp_inst, tp_inst[f+'_slider'], litem, n);

								tp_inst._onTimeChange();
								tp_inst._onSelectHandler();
							})
						.css({
								cursor: 'pointer',
								width: (100 / gridSize[litem]) + '%',
								textAlign: 'center',
								overflow: 'hidden'
							});
					} // end if grid > 0
				} // end for loop

				// Add timezone options
				this.timezone_select = $tp.find('.ui_tpicker_timezone').append('<select></select>').find("select");
				$.fn.append.apply(this.timezone_select,
				$.map(o.timezoneList, function(val, idx) {
					return $("<option />").val(typeof val == "object" ? val.value : val).text(typeof val == "object" ? val.label : val);
				}));
				if (typeof(this.timezone) != "undefined" && this.timezone !== null && this.timezone !== "") {
					var local_date = new Date(this.inst.selectedYear, this.inst.selectedMonth, this.inst.selectedDay, 12);
					var local_timezone = $.timepicker.timeZoneOffsetString(local_date);
					if (local_timezone == this.timezone) {
						selectLocalTimeZone(tp_inst);
					} else {
						this.timezone_select.val(this.timezone);
					}
				} else {
					if (typeof(this.hour) != "undefined" && this.hour !== null && this.hour !== "") {
						this.timezone_select.val(o.defaultTimezone);
					} else {
						selectLocalTimeZone(tp_inst);
					}
				}
				this.timezone_select.change(function() {
					tp_inst._defaults.useLocalTimezone = false;
					tp_inst._onTimeChange();
					tp_inst._onSelectHandler();
				});
				// End timezone options
				
				// inject timepicker into datepicker
				var $buttonPanel = $dp.find('.ui-datepicker-buttonpane');
				if ($buttonPanel.length) {
					$buttonPanel.before($tp);
				} else {
					$dp.append($tp);
				}

				this.$timeObj = $tp.find('.ui_tpicker_time');

				if (this.inst !== null) {
					var timeDefined = this.timeDefined;
					this._onTimeChange();
					this.timeDefined = timeDefined;
				}

				// slideAccess integration: http://trentrichardson.com/2011/11/11/jquery-ui-sliders-and-touch-accessibility/
				if (this._defaults.addSliderAccess) {
					var sliderAccessArgs = this._defaults.sliderAccessArgs,
						rtl = this._defaults.isRTL;
					sliderAccessArgs.isRTL = rtl;
						
					setTimeout(function() { // fix for inline mode
						if ($tp.find('.ui-slider-access').length === 0) {
							$tp.find('.ui-slider:visible').sliderAccess(sliderAccessArgs);

							// fix any grids since sliders are shorter
							var sliderAccessWidth = $tp.find('.ui-slider-access:eq(0)').outerWidth(true);
							if (sliderAccessWidth) {
								$tp.find('table:visible').each(function() {
									var $g = $(this),
										oldWidth = $g.outerWidth(),
										oldMarginLeft = $g.css(rtl? 'marginRight':'marginLeft').toString().replace('%', ''),
										newWidth = oldWidth - sliderAccessWidth,
										newMarginLeft = ((oldMarginLeft * newWidth) / oldWidth) + '%',
										css = { width: newWidth, marginRight: 0, marginLeft: 0 };
									css[rtl? 'marginRight':'marginLeft'] = newMarginLeft;
									$g.css(css);
								});
							}
						}
					}, 10);
				}
				// end slideAccess integration

			}
		},

		/*
		* This function tries to limit the ability to go outside the
		* min/max date range
		*/
		_limitMinMaxDateTime: function(dp_inst, adjustSliders) {
			var o = this._defaults,
				dp_date = new Date(dp_inst.selectedYear, dp_inst.selectedMonth, dp_inst.selectedDay);

			if (!this._defaults.showTimepicker) {
				return;
			} // No time so nothing to check here

			if ($.datepicker._get(dp_inst, 'minDateTime') !== null && $.datepicker._get(dp_inst, 'minDateTime') !== undefined && dp_date) {
				var minDateTime = $.datepicker._get(dp_inst, 'minDateTime'),
					minDateTimeDate = new Date(minDateTime.getFullYear(), minDateTime.getMonth(), minDateTime.getDate(), 0, 0, 0, 0);

				if (this.hourMinOriginal === null || this.minuteMinOriginal === null || this.secondMinOriginal === null || this.millisecMinOriginal === null) {
					this.hourMinOriginal = o.hourMin;
					this.minuteMinOriginal = o.minuteMin;
					this.secondMinOriginal = o.secondMin;
					this.millisecMinOriginal = o.millisecMin;
				}

				if (dp_inst.settings.timeOnly || minDateTimeDate.getTime() == dp_date.getTime()) {
					this._defaults.hourMin = minDateTime.getHours();
					if (this.hour <= this._defaults.hourMin) {
						this.hour = this._defaults.hourMin;
						this._defaults.minuteMin = minDateTime.getMinutes();
						if (this.minute <= this._defaults.minuteMin) {
							this.minute = this._defaults.minuteMin;
							this._defaults.secondMin = minDateTime.getSeconds();
							if (this.second <= this._defaults.secondMin) {
								this.second = this._defaults.secondMin;
								this._defaults.millisecMin = minDateTime.getMilliseconds();
							} else {
								if (this.millisec < this._defaults.millisecMin) {
									this.millisec = this._defaults.millisecMin;
								}
								this._defaults.millisecMin = this.millisecMinOriginal;
							}
						} else {
							this._defaults.secondMin = this.secondMinOriginal;
							this._defaults.millisecMin = this.millisecMinOriginal;
						}
					} else {
						this._defaults.minuteMin = this.minuteMinOriginal;
						this._defaults.secondMin = this.secondMinOriginal;
						this._defaults.millisecMin = this.millisecMinOriginal;
					}
				} else {
					this._defaults.hourMin = this.hourMinOriginal;
					this._defaults.minuteMin = this.minuteMinOriginal;
					this._defaults.secondMin = this.secondMinOriginal;
					this._defaults.millisecMin = this.millisecMinOriginal;
				}
			}

			if ($.datepicker._get(dp_inst, 'maxDateTime') !== null && $.datepicker._get(dp_inst, 'maxDateTime') !== undefined && dp_date) {
				var maxDateTime = $.datepicker._get(dp_inst, 'maxDateTime'),
					maxDateTimeDate = new Date(maxDateTime.getFullYear(), maxDateTime.getMonth(), maxDateTime.getDate(), 0, 0, 0, 0);

				if (this.hourMaxOriginal === null || this.minuteMaxOriginal === null || this.secondMaxOriginal === null) {
					this.hourMaxOriginal = o.hourMax;
					this.minuteMaxOriginal = o.minuteMax;
					this.secondMaxOriginal = o.secondMax;
					this.millisecMaxOriginal = o.millisecMax;
				}

				if (dp_inst.settings.timeOnly || maxDateTimeDate.getTime() == dp_date.getTime()) {
					this._defaults.hourMax = maxDateTime.getHours();
					if (this.hour >= this._defaults.hourMax) {
						this.hour = this._defaults.hourMax;
						this._defaults.minuteMax = maxDateTime.getMinutes();
						if (this.minute >= this._defaults.minuteMax) {
							this.minute = this._defaults.minuteMax;
							this._defaults.secondMax = maxDateTime.getSeconds();
							if (this.second >= this._defaults.secondMax) {
								this.second = this._defaults.secondMax;
								this._defaults.millisecMax = maxDateTime.getMilliseconds();
							} else {
								if (this.millisec > this._defaults.millisecMax) {
									this.millisec = this._defaults.millisecMax;
								}
								this._defaults.millisecMax = this.millisecMaxOriginal;
							}
						} else {
							this._defaults.secondMax = this.secondMaxOriginal;
							this._defaults.millisecMax = this.millisecMaxOriginal;
						}
					} else {
						this._defaults.minuteMax = this.minuteMaxOriginal;
						this._defaults.secondMax = this.secondMaxOriginal;
						this._defaults.millisecMax = this.millisecMaxOriginal;
					}
				} else {
					this._defaults.hourMax = this.hourMaxOriginal;
					this._defaults.minuteMax = this.minuteMaxOriginal;
					this._defaults.secondMax = this.secondMaxOriginal;
					this._defaults.millisecMax = this.millisecMaxOriginal;
				}
			}

			if (adjustSliders !== undefined && adjustSliders === true) {
				var hourMax = parseInt((this._defaults.hourMax - ((this._defaults.hourMax - this._defaults.hourMin) % this._defaults.stepHour)), 10),
					minMax = parseInt((this._defaults.minuteMax - ((this._defaults.minuteMax - this._defaults.minuteMin) % this._defaults.stepMinute)), 10),
					secMax = parseInt((this._defaults.secondMax - ((this._defaults.secondMax - this._defaults.secondMin) % this._defaults.stepSecond)), 10),
					millisecMax = parseInt((this._defaults.millisecMax - ((this._defaults.millisecMax - this._defaults.millisecMin) % this._defaults.stepMillisec)), 10);

				if (this.hour_slider) {
					this.control.options(this, this.hour_slider, 'hour', { min: this._defaults.hourMin, max: hourMax });
					this.control.value(this, this.hour_slider, 'hour', this.hour - (this.hour % this._defaults.stepHour));
				}
				if (this.minute_slider) {
					this.control.options(this, this.minute_slider, 'minute', { min: this._defaults.minuteMin, max: minMax });
					this.control.value(this, this.minute_slider, 'minute', this.minute - (this.minute % this._defaults.stepMinute));
				}
				if (this.second_slider) {
					this.control.options(this, this.second_slider, 'second', { min: this._defaults.secondMin, max: secMax });
					this.control.value(this, this.second_slider, 'second', this.second - (this.second % this._defaults.stepSecond));
				}
				if (this.millisec_slider) {
					this.control.options(this, this.millisec_slider, 'millisec', { min: this._defaults.millisecMin, max: millisecMax });
					this.control.value(this, this.millisec_slider, 'millisec', this.millisec - (this.millisec % this._defaults.stepMillisec));
				}
			}

		},

		/*
		* when a slider moves, set the internal time...
		* on time change is also called when the time is updated in the text field
		*/
		_onTimeChange: function() {
			var hour = (this.hour_slider) ? this.control.value(this, this.hour_slider, 'hour') : false,
				minute = (this.minute_slider) ? this.control.value(this, this.minute_slider, 'minute') : false,
				second = (this.second_slider) ? this.control.value(this, this.second_slider, 'second') : false,
				millisec = (this.millisec_slider) ? this.control.value(this, this.millisec_slider, 'millisec') : false,
				timezone = (this.timezone_select) ? this.timezone_select.val() : false,
				o = this._defaults,
				pickerTimeFormat = o.pickerTimeFormat || o.timeFormat,
				pickerTimeSuffix = o.pickerTimeSuffix || o.timeSuffix;

			if (typeof(hour) == 'object') {
				hour = false;
			}
			if (typeof(minute) == 'object') {
				minute = false;
			}
			if (typeof(second) == 'object') {
				second = false;
			}
			if (typeof(millisec) == 'object') {
				millisec = false;
			}
			if (typeof(timezone) == 'object') {
				timezone = false;
			}

			if (hour !== false) {
				hour = parseInt(hour, 10);
			}
			if (minute !== false) {
				minute = parseInt(minute, 10);
			}
			if (second !== false) {
				second = parseInt(second, 10);
			}
			if (millisec !== false) {
				millisec = parseInt(millisec, 10);
			}

			var ampm = o[hour < 12 ? 'amNames' : 'pmNames'][0];

			// If the update was done in the input field, the input field should not be updated.
			// If the update was done using the sliders, update the input field.
			var hasChanged = (hour != this.hour || minute != this.minute || second != this.second || millisec != this.millisec 
								|| (this.ampm.length > 0 && (hour < 12) != ($.inArray(this.ampm.toUpperCase(), this.amNames) !== -1)) 
								|| ((this.timezone === null && timezone != this.defaultTimezone) || (this.timezone !== null && timezone != this.timezone)));

			if (hasChanged) {

				if (hour !== false) {
					this.hour = hour;
				}
				if (minute !== false) {
					this.minute = minute;
				}
				if (second !== false) {
					this.second = second;
				}
				if (millisec !== false) {
					this.millisec = millisec;
				}
				if (timezone !== false) {
					this.timezone = timezone;
				}

				if (!this.inst) {
					this.inst = $.datepicker._getInst(this.$input[0]);
				}

				this._limitMinMaxDateTime(this.inst, true);
			}
			if (useAmpm(o.timeFormat)) {
				this.ampm = ampm;
			}

			// Updates the time within the timepicker
			this.formattedTime = $.datepicker.formatTime(o.timeFormat, this, o);
			if (this.$timeObj) {
				if(pickerTimeFormat === o.timeFormat){
					this.$timeObj.text(this.formattedTime + pickerTimeSuffix);
				}
				else{
					this.$timeObj.text($.datepicker.formatTime(pickerTimeFormat, this, o) + pickerTimeSuffix);
				}
			}

			this.timeDefined = true;
			if (hasChanged) {
				this._updateDateTime();
			}
		},

		/*
		* call custom onSelect.
		* bind to sliders slidestop, and grid click.
		*/
		_onSelectHandler: function() {
			var onSelect = this._defaults.onSelect || this.inst.settings.onSelect;
			var inputEl = this.$input ? this.$input[0] : null;
			if (onSelect && inputEl) {
				onSelect.apply(inputEl, [this.formattedDateTime, this]);
			}
		},

		/*
		* update our input with the new date time..
		*/
		_updateDateTime: function(dp_inst) {
			dp_inst = this.inst || dp_inst;
			var dt = $.datepicker._daylightSavingAdjust(new Date(dp_inst.selectedYear, dp_inst.selectedMonth, dp_inst.selectedDay)),
				dateFmt = $.datepicker._get(dp_inst, 'dateFormat'),
				formatCfg = $.datepicker._getFormatConfig(dp_inst),
				timeAvailable = dt !== null && this.timeDefined;
			this.formattedDate = $.datepicker.formatDate(dateFmt, (dt === null ? new Date() : dt), formatCfg);
			var formattedDateTime = this.formattedDate;
			
			// if a slider was changed but datepicker doesn't have a value yet, set it
			if(dp_inst.lastVal==""){
                dp_inst.currentYear=dp_inst.selectedYear;
                dp_inst.currentMonth=dp_inst.selectedMonth;
                dp_inst.currentDay=dp_inst.selectedDay;
            }

			/*
			* remove following lines to force every changes in date picker to change the input value
			* Bug descriptions: when an input field has a default value, and click on the field to pop up the date picker. 
			* If the user manually empty the value in the input field, the date picker will never change selected value.
			*/
			//if (dp_inst.lastVal !== undefined && (dp_inst.lastVal.length > 0 && this.$input.val().length === 0)) {
			//	return;
			//}

			if (this._defaults.timeOnly === true) {
				formattedDateTime = this.formattedTime;
			} else if (this._defaults.timeOnly !== true && (this._defaults.alwaysSetTime || timeAvailable)) {
				formattedDateTime += this._defaults.separator + this.formattedTime + this._defaults.timeSuffix;
			}

			this.formattedDateTime = formattedDateTime;

			if (!this._defaults.showTimepicker) {
				this.$input.val(this.formattedDate);
			} else if (this.$altInput && this._defaults.altFieldTimeOnly === true) {
				this.$altInput.val(this.formattedTime);
				this.$input.val(this.formattedDate);
			} else if (this.$altInput) {
				this.$input.val(formattedDateTime);
				var altFormattedDateTime = '',
					altSeparator = this._defaults.altSeparator ? this._defaults.altSeparator : this._defaults.separator,
					altTimeSuffix = this._defaults.altTimeSuffix ? this._defaults.altTimeSuffix : this._defaults.timeSuffix;

				if (this._defaults.altFormat) altFormattedDateTime = $.datepicker.formatDate(this._defaults.altFormat, (dt === null ? new Date() : dt), formatCfg);
				else altFormattedDateTime = this.formattedDate;
				if (altFormattedDateTime) altFormattedDateTime += altSeparator;
				if (this._defaults.altTimeFormat) altFormattedDateTime += $.datepicker.formatTime(this._defaults.altTimeFormat, this, this._defaults) + altTimeSuffix;
				else altFormattedDateTime += this.formattedTime + altTimeSuffix;
				this.$altInput.val(altFormattedDateTime);
			} else {
				this.$input.val(formattedDateTime);
			}

			this.$input.trigger("change");
		},

		_onFocus: function() {
			if (!this.$input.val() && this._defaults.defaultValue) {
				this.$input.val(this._defaults.defaultValue);
				var inst = $.datepicker._getInst(this.$input.get(0)),
					tp_inst = $.datepicker._get(inst, 'timepicker');
				if (tp_inst) {
					if (tp_inst._defaults.timeOnly && (inst.input.val() != inst.lastVal)) {
						try {
							$.datepicker._updateDatepicker(inst);
						} catch (err) {
							$.timepicker.log(err);
						}
					}
				}
			}
		},

		/*
		* Small abstraction to control types
		* We can add more, just be sure to follow the pattern: create, options, value
		*/
		_controls: {
			// slider methods
			slider: {
				create: function(tp_inst, obj, unit, val, min, max, step){
					var rtl = tp_inst._defaults.isRTL; // if rtl go -60->0 instead of 0->60
					return obj.prop('slide', null).slider({
						orientation: "horizontal",
						value: rtl? val*-1 : val,
						min: rtl? max*-1 : min,
						max: rtl? min*-1 : max,
						step: step,
						slide: function(event, ui) {
							tp_inst.control.value(tp_inst, $(this), unit, rtl? ui.value*-1:ui.value);
							tp_inst._onTimeChange();
						},
						stop: function(event, ui) {
							tp_inst._onSelectHandler();
						}
					});	
				},
				options: function(tp_inst, obj, unit, opts, val){
					if(tp_inst._defaults.isRTL){
						if(typeof(opts) == 'string'){
							if(opts == 'min' || opts == 'max'){
								if(val !== undefined)
									return obj.slider(opts, val*-1);
								return Math.abs(obj.slider(opts));
							}
							return obj.slider(opts);
						}
						var min = opts.min, 
							max = opts.max;
						opts.min = opts.max = null;
						if(min !== undefined)
							opts.max = min * -1;
						if(max !== undefined)
							opts.min = max * -1;
						return obj.slider(opts);
					}
					if(typeof(opts) == 'string' && val !== undefined)
							return obj.slider(opts, val);
					return obj.slider(opts);
				},
				value: function(tp_inst, obj, unit, val){
					if(tp_inst._defaults.isRTL){
						if(val !== undefined)
							return obj.slider('value', val*-1);
						return Math.abs(obj.slider('value'));
					}
					if(val !== undefined)
						return obj.slider('value', val);
					return obj.slider('value');
				}
			},
			// select methods
			select: {
				create: function(tp_inst, obj, unit, val, min, max, step){
					var sel = '<select class="ui-timepicker-select" data-unit="'+ unit +'" data-min="'+ min +'" data-max="'+ max +'" data-step="'+ step +'">',
						ul = tp_inst._defaults.timeFormat.indexOf('t') !== -1? 'toLowerCase':'toUpperCase',
						m = 0;

					for(var i=min; i<=max; i+=step){						
						sel += '<option value="'+ i +'"'+ (i==val? ' selected':'') +'>';
						if(unit == 'hour' && useAmpm(tp_inst._defaults.pickerTimeFormat || tp_inst._defaults.timeFormat))
							sel += $.datepicker.formatTime("hh TT", {hour:i}, tp_inst._defaults);
						else if(unit == 'millisec' || i >= 10) sel += i;
						else sel += '0'+ i.toString();
						sel += '</option>';
					}
					sel += '</select>';

					obj.children('select').remove();

					$(sel).appendTo(obj).change(function(e){
						tp_inst._onTimeChange();
						tp_inst._onSelectHandler();
					});

					return obj;
				},
				options: function(tp_inst, obj, unit, opts, val){
					var o = {},
						$t = obj.children('select');
					if(typeof(opts) == 'string'){
						if(val === undefined)
							return $t.data(opts);
						o[opts] = val;	
					}
					else o = opts;
					return tp_inst.control.create(tp_inst, obj, $t.data('unit'), $t.val(), o.min || $t.data('min'), o.max || $t.data('max'), o.step || $t.data('step'));
				},
				value: function(tp_inst, obj, unit, val){
					var $t = obj.children('select');
					if(val !== undefined)
						return $t.val(val);
					return $t.val();
				}
			}
		} // end _controls

	});

	$.fn.extend({
		/*
		* shorthand just to use timepicker..
		*/
		timepicker: function(o) {
			o = o || {};
			var tmp_args = Array.prototype.slice.call(arguments);

			if (typeof o == 'object') {
				tmp_args[0] = $.extend(o, {
					timeOnly: true
				});
			}

			return $(this).each(function() {
				$.fn.datetimepicker.apply($(this), tmp_args);
			});
		},

		/*
		* extend timepicker to datepicker
		*/
		datetimepicker: function(o) {
			o = o || {};
			var tmp_args = arguments;

			if (typeof(o) == 'string') {
				if (o == 'getDate') {
					return $.fn.datepicker.apply($(this[0]), tmp_args);
				} else {
					return this.each(function() {
						var $t = $(this);
						$t.datepicker.apply($t, tmp_args);
					});
				}
			} else {
				return this.each(function() {
					var $t = $(this);
					$t.datepicker($.timepicker._newInst($t, o)._defaults);
				});
			}
		}
	});

	/*
	* Public Utility to parse date and time
	*/
	$.datepicker.parseDateTime = function(dateFormat, timeFormat, dateTimeString, dateSettings, timeSettings) {
		var parseRes = parseDateTimeInternal(dateFormat, timeFormat, dateTimeString, dateSettings, timeSettings);
		if (parseRes.timeObj) {
			var t = parseRes.timeObj;
			parseRes.date.setHours(t.hour, t.minute, t.second, t.millisec);
		}

		return parseRes.date;
	};

	/*
	* Public utility to parse time
	*/
	$.datepicker.parseTime = function(timeFormat, timeString, options) {		
		var o = extendRemove(extendRemove({}, $.timepicker._defaults), options || {});

		// Strict parse requires the timeString to match the timeFormat exactly
		var strictParse = function(f, s, o){

			// pattern for standard and localized AM/PM markers
			var getPatternAmpm = function(amNames, pmNames) {
				var markers = [];
				if (amNames) {
					$.merge(markers, amNames);
				}
				if (pmNames) {
					$.merge(markers, pmNames);
				}
				markers = $.map(markers, function(val) {
					return val.replace(/[.*+?|()\[\]{}\\]/g, '\\$&');
				});
				return '(' + markers.join('|') + ')?';
			};

			// figure out position of time elements.. cause js cant do named captures
			var getFormatPositions = function(timeFormat) {
				var finds = timeFormat.toLowerCase().match(/(h{1,2}|m{1,2}|s{1,2}|l{1}|t{1,2}|z|'.*?')/g),
					orders = {
						h: -1,
						m: -1,
						s: -1,
						l: -1,
						t: -1,
						z: -1
					};

				if (finds) {
					for (var i = 0; i < finds.length; i++) {
						if (orders[finds[i].toString().charAt(0)] == -1) {
							orders[finds[i].toString().charAt(0)] = i + 1;
						}
					}
				}
				return orders;
			};

			var regstr = '^' + f.toString()
					.replace(/([hH]{1,2}|mm?|ss?|[tT]{1,2}|[lz]|'.*?')/g, function (match) {
							var ml = match.length;
							switch (match.charAt(0).toLowerCase()) {
								case 'h': return ml === 1? '(\\d?\\d)':'(\\d{'+ml+'})';
								case 'm': return ml === 1? '(\\d?\\d)':'(\\d{'+ml+'})';
								case 's': return ml === 1? '(\\d?\\d)':'(\\d{'+ml+'})';
								case 'l': return '(\\d?\\d?\\d)';
								case 'z': return '(z|[-+]\\d\\d:?\\d\\d|\\S+)?';
								case 't': return getPatternAmpm(o.amNames, o.pmNames);
								default:    // literal escaped in quotes
									return '(' + match.replace(/\'/g, "").replace(/(\.|\$|\^|\\|\/|\(|\)|\[|\]|\?|\+|\*)/g, function (m) { return "\\" + m; }) + ')?';
							}
						})
					.replace(/\s/g, '\\s?') +
					o.timeSuffix + '$',
				order = getFormatPositions(f),
				ampm = '',
				treg;

			treg = s.match(new RegExp(regstr, 'i'));

			var resTime = {
				hour: 0,
				minute: 0,
				second: 0,
				millisec: 0
			};

			if (treg) {
				if (order.t !== -1) {
					if (treg[order.t] === undefined || treg[order.t].length === 0) {
						ampm = '';
						resTime.ampm = '';
					} else {
						ampm = $.inArray(treg[order.t].toUpperCase(), o.amNames) !== -1 ? 'AM' : 'PM';
						resTime.ampm = o[ampm == 'AM' ? 'amNames' : 'pmNames'][0];
					}
				}

				if (order.h !== -1) {
					if (ampm == 'AM' && treg[order.h] == '12') {
						resTime.hour = 0; // 12am = 0 hour
					} else {
						if (ampm == 'PM' && treg[order.h] != '12') {
							resTime.hour = parseInt(treg[order.h], 10) + 12; // 12pm = 12 hour, any other pm = hour + 12
						} else {
							resTime.hour = Number(treg[order.h]);
						}
					}
				}

				if (order.m !== -1) {
					resTime.minute = Number(treg[order.m]);
				}
				if (order.s !== -1) {
					resTime.second = Number(treg[order.s]);
				}
				if (order.l !== -1) {
					resTime.millisec = Number(treg[order.l]);
				}
				if (order.z !== -1 && treg[order.z] !== undefined) {
					var tz = treg[order.z].toUpperCase();
					switch (tz.length) {
					case 1:
						// Z
						tz = o.timezoneIso8601 ? 'Z' : '+0000';
						break;
					case 5:
						// +hhmm
						if (o.timezoneIso8601) {
							tz = tz.substring(1) == '0000' ? 'Z' : tz.substring(0, 3) + ':' + tz.substring(3);
						}
						break;
					case 6:
						// +hh:mm
						if (!o.timezoneIso8601) {
							tz = tz == 'Z' || tz.substring(1) == '00:00' ? '+0000' : tz.replace(/:/, '');
						} else {
							if (tz.substring(1) == '00:00') {
								tz = 'Z';
							}
						}
						break;
					}
					resTime.timezone = tz;
				}


				return resTime;
			}
			return false;
		};// end strictParse

		// First try JS Date, if that fails, use strictParse
		var looseParse = function(f,s,o){
			try{
				var d = new Date('2012-01-01 '+ s);
				if(isNaN(d.getTime())){
					d = new Date('2012-01-01T'+ s);
					if(isNaN(d.getTime())){
						d = new Date('01/01/2012 '+ s);
						if(isNaN(d.getTime())){
							throw "Unable to parse time with native Date: "+ s;
						}
					}
				}

				return {
					hour: d.getHours(),
					minute: d.getMinutes(),
					second: d.getSeconds(),
					millisec: d.getMilliseconds(),
					timezone: $.timepicker.timeZoneOffsetString(d)
				};
			}
			catch(err){
				try{
					return strictParse(f,s,o);
				}
				catch(err2){
					$.timepicker.log("Unable to parse \ntimeString: "+ s +"\ntimeFormat: "+ f);
				}				
			}
			return false;
		}; // end looseParse
		
		if(typeof o.parse === "function"){
			return o.parse(timeFormat, timeString, o)
		}
		if(o.parse === 'loose'){
			return looseParse(timeFormat, timeString, o);
		}
		return strictParse(timeFormat, timeString, o);
	};

	/*
	* Public utility to format the time
	* format = string format of the time
	* time = a {}, not a Date() for timezones
	* options = essentially the regional[].. amNames, pmNames, ampm
	*/
	$.datepicker.formatTime = function(format, time, options) {
		options = options || {};
		options = $.extend({}, $.timepicker._defaults, options);
		time = $.extend({
			hour: 0,
			minute: 0,
			second: 0,
			millisec: 0,
			timezone: '+0000'
		}, time);

		var tmptime = format,
			ampmName = options.amNames[0],
			hour = parseInt(time.hour, 10);

		if (hour > 11) {
			ampmName = options.pmNames[0];
		}

		tmptime = tmptime.replace(/(?:HH?|hh?|mm?|ss?|[tT]{1,2}|[lz]|('.*?'|".*?"))/g, function(match) {
		switch (match) {
			case 'HH':
				return ('0' + hour).slice(-2);
			case 'H':
				return hour;
			case 'hh':
				return ('0' + convert24to12(hour)).slice(-2);
			case 'h':
				return convert24to12(hour);
			case 'mm':
				return ('0' + time.minute).slice(-2);
			case 'm':
				return time.minute;
			case 'ss':
				return ('0' + time.second).slice(-2);
			case 's':
				return time.second;
			case 'l':
				return ('00' + time.millisec).slice(-3);
			case 'z':
				return time.timezone === null? options.defaultTimezone : time.timezone;
			case 'T': 
				return ampmName.charAt(0).toUpperCase();
			case 'TT': 
				return ampmName.toUpperCase();
			case 't':
				return ampmName.charAt(0).toLowerCase();
			case 'tt':
				return ampmName.toLowerCase();
			default:
				return match.replace(/\'/g, "") || "'";
			}
		});

		tmptime = $.trim(tmptime);
		return tmptime;
	};

	/*
	* the bad hack :/ override datepicker so it doesnt close on select
	// inspired: http://stackoverflow.com/questions/1252512/jquery-datepicker-prevent-closing-picker-when-clicking-a-date/1762378#1762378
	*/
	$.datepicker._base_selectDate = $.datepicker._selectDate;
	$.datepicker._selectDate = function(id, dateStr) {
		var inst = this._getInst($(id)[0]),
			tp_inst = this._get(inst, 'timepicker');

		if (tp_inst) {
			tp_inst._limitMinMaxDateTime(inst, true);
			inst.inline = inst.stay_open = true;
			//This way the onSelect handler called from calendarpicker get the full dateTime
			this._base_selectDate(id, dateStr);
			inst.inline = inst.stay_open = false;
			this._notifyChange(inst);
			this._updateDatepicker(inst);
		} else {
			this._base_selectDate(id, dateStr);
		}
	};

	/*
	* second bad hack :/ override datepicker so it triggers an event when changing the input field
	* and does not redraw the datepicker on every selectDate event
	*/
	$.datepicker._base_updateDatepicker = $.datepicker._updateDatepicker;
	$.datepicker._updateDatepicker = function(inst) {

		// don't popup the datepicker if there is another instance already opened
		var input = inst.input[0];
		if ($.datepicker._curInst && $.datepicker._curInst != inst && $.datepicker._datepickerShowing && $.datepicker._lastInput != input) {
			return;
		}

		if (typeof(inst.stay_open) !== 'boolean' || inst.stay_open === false) {

			this._base_updateDatepicker(inst);

			// Reload the time control when changing something in the input text field.
			var tp_inst = this._get(inst, 'timepicker');
			if (tp_inst) {
				tp_inst._addTimePicker(inst);

//				if (tp_inst._defaults.useLocalTimezone) { //checks daylight saving with the new date.
//					var date = new Date(inst.selectedYear, inst.selectedMonth, inst.selectedDay, 12);
//					selectLocalTimeZone(tp_inst, date);
//					tp_inst._onTimeChange();
//				}
			}
		}
	};

	/*
	* third bad hack :/ override datepicker so it allows spaces and colon in the input field
	*/
	$.datepicker._base_doKeyPress = $.datepicker._doKeyPress;
	$.datepicker._doKeyPress = function(event) {
		var inst = $.datepicker._getInst(event.target),
			tp_inst = $.datepicker._get(inst, 'timepicker');

		if (tp_inst) {
			if ($.datepicker._get(inst, 'constrainInput')) {
				var ampm = useAmpm(tp_inst._defaults.timeFormat),
					dateChars = $.datepicker._possibleChars($.datepicker._get(inst, 'dateFormat')),
					datetimeChars = tp_inst._defaults.timeFormat.toString()
											.replace(/[hms]/g, '')
											.replace(/TT/g, ampm ? 'APM' : '')
											.replace(/Tt/g, ampm ? 'AaPpMm' : '')
											.replace(/tT/g, ampm ? 'AaPpMm' : '')
											.replace(/T/g, ampm ? 'AP' : '')
											.replace(/tt/g, ampm ? 'apm' : '')
											.replace(/t/g, ampm ? 'ap' : '') + 
											" " + tp_inst._defaults.separator + 
											tp_inst._defaults.timeSuffix + 
											(tp_inst._defaults.showTimezone ? tp_inst._defaults.timezoneList.join('') : '') + 
											(tp_inst._defaults.amNames.join('')) + (tp_inst._defaults.pmNames.join('')) + 
											dateChars,
					chr = String.fromCharCode(event.charCode === undefined ? event.keyCode : event.charCode);
				return event.ctrlKey || (chr < ' ' || !dateChars || datetimeChars.indexOf(chr) > -1);
			}
		}

		return $.datepicker._base_doKeyPress(event);
	};

	/*
	* Fourth bad hack :/ override _updateAlternate function used in inline mode to init altField
	*/
	$.datepicker._base_updateAlternate = $.datepicker._updateAlternate;
	/* Update any alternate field to synchronise with the main field. */
	$.datepicker._updateAlternate = function(inst) {
		var tp_inst = this._get(inst, 'timepicker');
		if(tp_inst){
			var altField = tp_inst._defaults.altField;
			if (altField) { // update alternate field too
				var altFormat = tp_inst._defaults.altFormat || tp_inst._defaults.dateFormat,
					date = this._getDate(inst),
					formatCfg = $.datepicker._getFormatConfig(inst),
					altFormattedDateTime = '', 
					altSeparator = tp_inst._defaults.altSeparator ? tp_inst._defaults.altSeparator : tp_inst._defaults.separator, 
					altTimeSuffix = tp_inst._defaults.altTimeSuffix ? tp_inst._defaults.altTimeSuffix : tp_inst._defaults.timeSuffix,
					altTimeFormat = tp_inst._defaults.altTimeFormat !== null ? tp_inst._defaults.altTimeFormat : tp_inst._defaults.timeFormat;
				
				altFormattedDateTime += $.datepicker.formatTime(altTimeFormat, tp_inst, tp_inst._defaults) + altTimeSuffix;
				if(!tp_inst._defaults.timeOnly && !tp_inst._defaults.altFieldTimeOnly && date !== null){
					if(tp_inst._defaults.altFormat)
						altFormattedDateTime = $.datepicker.formatDate(tp_inst._defaults.altFormat, date, formatCfg) + altSeparator + altFormattedDateTime;
					else altFormattedDateTime = tp_inst.formattedDate + altSeparator + altFormattedDateTime;
				}
				$(altField).val(altFormattedDateTime);
			}
		}
		else{
			$.datepicker._base_updateAlternate(inst);
		}
	};

	/*
	* Override key up event to sync manual input changes.
	*/
	$.datepicker._base_doKeyUp = $.datepicker._doKeyUp;
	$.datepicker._doKeyUp = function(event) {
		var inst = $.datepicker._getInst(event.target),
			tp_inst = $.datepicker._get(inst, 'timepicker');

		if (tp_inst) {
			if (tp_inst._defaults.timeOnly && (inst.input.val() != inst.lastVal)) {
				try {
					$.datepicker._updateDatepicker(inst);
				} catch (err) {
					$.timepicker.log(err);
				}
			}
		}

		return $.datepicker._base_doKeyUp(event);
	};

	/*
	* override "Today" button to also grab the time.
	*/
	$.datepicker._base_gotoToday = $.datepicker._gotoToday;
	$.datepicker._gotoToday = function(id) {
		var inst = this._getInst($(id)[0]),
			$dp = inst.dpDiv;
		this._base_gotoToday(id);
		var tp_inst = this._get(inst, 'timepicker');
		selectLocalTimeZone(tp_inst);
		var now = new Date();
		this._setTime(inst, now);
		$('.ui-datepicker-today', $dp).click();
	};

	/*
	* Disable & enable the Time in the datetimepicker
	*/
	$.datepicker._disableTimepickerDatepicker = function(target) {
		var inst = this._getInst(target);
		if (!inst) {
			return;
		}

		var tp_inst = this._get(inst, 'timepicker');
		$(target).datepicker('getDate'); // Init selected[Year|Month|Day]
		if (tp_inst) {
			tp_inst._defaults.showTimepicker = false;
			tp_inst._updateDateTime(inst);
		}
	};

	$.datepicker._enableTimepickerDatepicker = function(target) {
		var inst = this._getInst(target);
		if (!inst) {
			return;
		}

		var tp_inst = this._get(inst, 'timepicker');
		$(target).datepicker('getDate'); // Init selected[Year|Month|Day]
		if (tp_inst) {
			tp_inst._defaults.showTimepicker = true;
			tp_inst._addTimePicker(inst); // Could be disabled on page load
			tp_inst._updateDateTime(inst);
		}
	};

	/*
	* Create our own set time function
	*/
	$.datepicker._setTime = function(inst, date) {
		var tp_inst = this._get(inst, 'timepicker');
		if (tp_inst) {
			var defaults = tp_inst._defaults;

			// calling _setTime with no date sets time to defaults
			tp_inst.hour = date ? date.getHours() : defaults.hour;
			tp_inst.minute = date ? date.getMinutes() : defaults.minute;
			tp_inst.second = date ? date.getSeconds() : defaults.second;
			tp_inst.millisec = date ? date.getMilliseconds() : defaults.millisec;

			//check if within min/max times.. 
			tp_inst._limitMinMaxDateTime(inst, true);

			tp_inst._onTimeChange();
			tp_inst._updateDateTime(inst);
		}
	};

	/*
	* Create new public method to set only time, callable as $().datepicker('setTime', date)
	*/
	$.datepicker._setTimeDatepicker = function(target, date, withDate) {
		var inst = this._getInst(target);
		if (!inst) {
			return;
		}

		var tp_inst = this._get(inst, 'timepicker');

		if (tp_inst) {
			this._setDateFromField(inst);
			var tp_date;
			if (date) {
				if (typeof date == "string") {
					tp_inst._parseTime(date, withDate);
					tp_date = new Date();
					tp_date.setHours(tp_inst.hour, tp_inst.minute, tp_inst.second, tp_inst.millisec);
				} else {
					tp_date = new Date(date.getTime());
				}
				if (tp_date.toString() == 'Invalid Date') {
					tp_date = undefined;
				}
				this._setTime(inst, tp_date);
			}
		}

	};

	/*
	* override setDate() to allow setting time too within Date object
	*/
	$.datepicker._base_setDateDatepicker = $.datepicker._setDateDatepicker;
	$.datepicker._setDateDatepicker = function(target, date) {
		var inst = this._getInst(target);
		if (!inst) {
			return;
		}

		var tp_date = (date instanceof Date) ? new Date(date.getTime()) : date;

		this._updateDatepicker(inst);
		this._base_setDateDatepicker.apply(this, arguments);
		this._setTimeDatepicker(target, tp_date, true);
	};

	/*
	* override getDate() to allow getting time too within Date object
	*/
	$.datepicker._base_getDateDatepicker = $.datepicker._getDateDatepicker;
	$.datepicker._getDateDatepicker = function(target, noDefault) {
		var inst = this._getInst(target);
		if (!inst) {
			return;
		}

		var tp_inst = this._get(inst, 'timepicker');

		if (tp_inst) {
			// if it hasn't yet been defined, grab from field
			if(inst.lastVal === undefined){
				this._setDateFromField(inst, noDefault);
			}

			var date = this._getDate(inst);
			if (date && tp_inst._parseTime($(target).val(), tp_inst.timeOnly)) {
				date.setHours(tp_inst.hour, tp_inst.minute, tp_inst.second, tp_inst.millisec);
			}
			return date;
		}
		return this._base_getDateDatepicker(target, noDefault);
	};

	/*
	* override parseDate() because UI 1.8.14 throws an error about "Extra characters"
	* An option in datapicker to ignore extra format characters would be nicer.
	*/
	$.datepicker._base_parseDate = $.datepicker.parseDate;
	$.datepicker.parseDate = function(format, value, settings) {
		var date;
		try {
			date = this._base_parseDate(format, value, settings);
		} catch (err) {
			// Hack!  The error message ends with a colon, a space, and
			// the "extra" characters.  We rely on that instead of
			// attempting to perfectly reproduce the parsing algorithm.
			date = this._base_parseDate(format, value.substring(0,value.length-(err.length-err.indexOf(':')-2)), settings);
			$.timepicker.log("Error parsing the date string: " + err + "\ndate string = " + value + "\ndate format = " + format);
		}
		return date;
	};

	/*
	* override formatDate to set date with time to the input
	*/
	$.datepicker._base_formatDate = $.datepicker._formatDate;
	$.datepicker._formatDate = function(inst, day, month, year) {
		var tp_inst = this._get(inst, 'timepicker');
		if (tp_inst) {
			tp_inst._updateDateTime(inst);
			return tp_inst.$input.val();
		}
		return this._base_formatDate(inst);
	};

	/*
	* override options setter to add time to maxDate(Time) and minDate(Time). MaxDate
	*/
	$.datepicker._base_optionDatepicker = $.datepicker._optionDatepicker;
	$.datepicker._optionDatepicker = function(target, name, value) {
		var inst = this._getInst(target),
	        name_clone;
		if (!inst) {
			return null;
		}

		var tp_inst = this._get(inst, 'timepicker');
		if (tp_inst) {
			var min = null,
				max = null,
				onselect = null,
				overrides = tp_inst._defaults.evnts,
				fns = {},
				prop;
		    if (typeof name == 'string') { // if min/max was set with the string
		        if (name === 'minDate' || name === 'minDateTime') {
		            min = value;
		        } else if (name === 'maxDate' || name === 'maxDateTime') {
		            max = value;
		        } else if (name === 'onSelect') {
		            onselect = value;
		        } else if (overrides.hasOwnProperty(name)) {
		            if (typeof (value) === 'undefined') {
		                return overrides[name];
		            }
		            fns[name] = value;
		            name_clone = {}; //empty results in exiting function after overrides updated
		        }
		    } else if (typeof name == 'object') { //if min/max was set with the JSON
		        if (name.minDate) {
		            min = name.minDate;
		        } else if (name.minDateTime) {
		            min = name.minDateTime;
		        } else if (name.maxDate) {
		            max = name.maxDate;
		        } else if (name.maxDateTime) {
		            max = name.maxDateTime;
		        }
		        for (prop in overrides) {
		            if (overrides.hasOwnProperty(prop) && name[prop]) {
		                fns[prop] = name[prop];
		            }
		        }
		    }
		    for (prop in fns) {
		        if (fns.hasOwnProperty(prop)) {
		            overrides[prop] = fns[prop];
		            if (!name_clone) { name_clone = $.extend({}, name);}
		            delete name_clone[prop];
		        }
		    }
		    if (name_clone && isEmptyObject(name_clone)) { return; }
		    if (min) { //if min was set
		        if (min === 0) {
		            min = new Date();
		        } else {
		            min = new Date(min);
		        }
		        tp_inst._defaults.minDate = min;
		        tp_inst._defaults.minDateTime = min;
		    } else if (max) { //if max was set
		        if (max === 0) {
		            max = new Date();
		        } else {
		            max = new Date(max);
		        }
		        tp_inst._defaults.maxDate = max;
		        tp_inst._defaults.maxDateTime = max;
		    } else if (onselect) {
		        tp_inst._defaults.onSelect = onselect;
		    }
		}
		if (value === undefined) {
			return this._base_optionDatepicker.call($.datepicker, target, name);
		}
		return this._base_optionDatepicker.call($.datepicker, target, name_clone || name, value);
	};
	/*
	* jQuery isEmptyObject does not check hasOwnProperty - if someone has added to the object prototype,
	* it will return false for all objects
	*/
	var isEmptyObject = function(obj) {
		var prop;
		for (prop in obj) {
			if (obj.hasOwnProperty(obj)) {
				return false;
			}
		}
		return true;
	};

	/*
	* jQuery extend now ignores nulls!
	*/
	var extendRemove = function(target, props) {
		$.extend(target, props);
		for (var name in props) {
			if (props[name] === null || props[name] === undefined) {
				target[name] = props[name];
			}
		}
		return target;
	};

	/*
	* Determine by the time format if should use ampm
	* Returns true if should use ampm, false if not
	*/
	var useAmpm = function(timeFormat){
		return (timeFormat.indexOf('t') !== -1 && timeFormat.indexOf('h') !== -1);
	};

	/*
	* Converts 24 hour format into 12 hour
	* Returns 12 hour without leading 0
	*/
	var convert24to12 = function(hour) {
		if (hour > 12) {
			hour = hour - 12;
		}

		if (hour == 0) {
			hour = 12;
		}

		return String(hour);
	};

	/*
	* Splits datetime string into date ans time substrings.
	* Throws exception when date can't be parsed
	* Returns [dateString, timeString]
	*/
	var splitDateTime = function(dateFormat, dateTimeString, dateSettings, timeSettings) {
		try {
			// The idea is to get the number separator occurances in datetime and the time format requested (since time has 
			// fewer unknowns, mostly numbers and am/pm). We will use the time pattern to split.
			var separator = timeSettings && timeSettings.separator ? timeSettings.separator : $.timepicker._defaults.separator,
				format = timeSettings && timeSettings.timeFormat ? timeSettings.timeFormat : $.timepicker._defaults.timeFormat,
				timeParts = format.split(separator), // how many occurances of separator may be in our format?
				timePartsLen = timeParts.length,
				allParts = dateTimeString.split(separator),
				allPartsLen = allParts.length;

			if (allPartsLen > 1) {
				return [
						allParts.splice(0,allPartsLen-timePartsLen).join(separator),
						allParts.splice(0,timePartsLen).join(separator)
					];
			}

		} catch (err) {
			$.timepicker.log('Could not split the date from the time. Please check the following datetimepicker options' +
					"\nthrown error: " + err +
					"\ndateTimeString" + dateTimeString +
					"\ndateFormat = " + dateFormat +
					"\nseparator = " + timeSettings.separator +
					"\ntimeFormat = " + timeSettings.timeFormat);

			if (err.indexOf(":") >= 0) {
				// Hack!  The error message ends with a colon, a space, and
				// the "extra" characters.  We rely on that instead of
				// attempting to perfectly reproduce the parsing algorithm.
				var dateStringLength = dateTimeString.length - (err.length - err.indexOf(':') - 2),
					timeString = dateTimeString.substring(dateStringLength);

				return [$.trim(dateTimeString.substring(0, dateStringLength)), $.trim(dateTimeString.substring(dateStringLength))];

			} else {
				throw err;
			}
		}
		return [dateTimeString, ''];
	};

	/*
	* Internal function to parse datetime interval
	* Returns: {date: Date, timeObj: Object}, where
	*   date - parsed date without time (type Date)
	*   timeObj = {hour: , minute: , second: , millisec: } - parsed time. Optional
	*/
	var parseDateTimeInternal = function(dateFormat, timeFormat, dateTimeString, dateSettings, timeSettings) {
		var date;
		var splitRes = splitDateTime(dateFormat, dateTimeString, dateSettings, timeSettings);
		date = $.datepicker._base_parseDate(dateFormat, splitRes[0], dateSettings);
		if (splitRes[1] !== '') {
			var timeString = splitRes[1],
				parsedTime = $.datepicker.parseTime(timeFormat, timeString, timeSettings);

			if (parsedTime === null) {
				throw 'Wrong time format';
			}
			return {
				date: date,
				timeObj: parsedTime
			};
		} else {
			return {
				date: date
			};
		}
	};

	/*
	* Internal function to set timezone_select to the local timezone
	*/
	var selectLocalTimeZone = function(tp_inst, date) {
		if (tp_inst && tp_inst.timezone_select) {
			tp_inst._defaults.useLocalTimezone = true;
			var now = typeof date !== 'undefined' ? date : new Date();
			var tzoffset = $.timepicker.timeZoneOffsetString(now);
			if (tp_inst._defaults.timezoneIso8601) {
				tzoffset = tzoffset.substring(0, 3) + ':' + tzoffset.substring(3);
			}
			tp_inst.timezone_select.val(tzoffset);
		}
	};

	/*
	* Create a Singleton Insance
	*/
	$.timepicker = new Timepicker();

	/**
	 * Get the timezone offset as string from a date object (eg '+0530' for UTC+5.5)
	 * @param  date
	 * @return string
	 */
	$.timepicker.timeZoneOffsetString = function(date) {
		var off = date.getTimezoneOffset() * -1,
			minutes = off % 60,
			hours = (off - minutes) / 60;
		return (off >= 0 ? '+' : '-') + ('0' + (hours * 101).toString()).slice(-2) + ('0' + (minutes * 101).toString()).slice(-2);
	};

	/**
	 * Calls `timepicker()` on the `startTime` and `endTime` elements, and configures them to
	 * enforce date range limits.
	 * n.b. The input value must be correctly formatted (reformatting is not supported)
	 * @param  Element startTime
	 * @param  Element endTime
	 * @param  obj options Options for the timepicker() call
	 * @return jQuery
	 */
	$.timepicker.timeRange = function(startTime, endTime, options) {
		return $.timepicker.handleRange('timepicker', startTime, endTime, options);
	};

	/**
	 * Calls `datetimepicker` on the `startTime` and `endTime` elements, and configures them to
	 * enforce date range limits.
	 * @param  Element startTime
	 * @param  Element endTime
	 * @param  obj options Options for the `timepicker()` call. Also supports `reformat`,
	 *   a boolean value that can be used to reformat the input values to the `dateFormat`.
	 * @param  string method Can be used to specify the type of picker to be added
	 * @return jQuery
	 */
	$.timepicker.dateTimeRange = function(startTime, endTime, options) {
		$.timepicker.dateRange(startTime, endTime, options, 'datetimepicker');
	};

	/**
	 * Calls `method` on the `startTime` and `endTime` elements, and configures them to
	 * enforce date range limits.
	 * @param  Element startTime
	 * @param  Element endTime
	 * @param  obj options Options for the `timepicker()` call. Also supports `reformat`,
	 *   a boolean value that can be used to reformat the input values to the `dateFormat`.
	 * @param  string method Can be used to specify the type of picker to be added
	 * @return jQuery
	 */
	$.timepicker.dateRange = function(startTime, endTime, options, method) {
		method = method || 'datepicker';
		$.timepicker.handleRange(method, startTime, endTime, options);
	};

	/**
	 * Calls `method` on the `startTime` and `endTime` elements, and configures them to
	 * enforce date range limits.
	 * @param  string method Can be used to specify the type of picker to be added
	 * @param  Element startTime
	 * @param  Element endTime
	 * @param  obj options Options for the `timepicker()` call. Also supports `reformat`,
	 *   a boolean value that can be used to reformat the input values to the `dateFormat`.
	 * @return jQuery
	 */
	$.timepicker.handleRange = function(method, startTime, endTime, options) {
		$.fn[method].call(startTime, $.extend({
			onClose: function(dateText, inst) {
				checkDates(this, endTime, dateText);
			},
			onSelect: function(selectedDateTime) {
				selected(this, endTime, 'minDate');
			}
		}, options, options.start));
		$.fn[method].call(endTime, $.extend({
			onClose: function(dateText, inst) {
				checkDates(this, startTime, dateText);
			},
			onSelect: function(selectedDateTime) {
				selected(this, startTime, 'maxDate');
			}
		}, options, options.end));
		// timepicker doesn't provide access to its 'timeFormat' option, 
		// nor could I get datepicker.formatTime() to behave with times, so I
		// have disabled reformatting for timepicker
		if (method != 'timepicker' && options.reformat) {
			$([startTime, endTime]).each(function() {
				var format = $(this)[method].call($(this), 'option', 'dateFormat'),
					date = new Date($(this).val());
				if ($(this).val() && date) {
					$(this).val($.datepicker.formatDate(format, date));
				}
			});
		}
		checkDates(startTime, endTime, startTime.val());

		function checkDates(changed, other, dateText) {
			if (other.val() && (new Date(startTime.val()) > new Date(endTime.val()))) {
				other.val(dateText);
			}
		}
		selected(startTime, endTime, 'minDate');
		selected(endTime, startTime, 'maxDate');

		function selected(changed, other, option) {
			if (!$(changed).val()) {
				return;
			}
			var date = $(changed)[method].call($(changed), 'getDate');
			// timepicker doesn't implement 'getDate' and returns a jQuery
			if (date.getTime) {
				$(other)[method].call($(other), 'option', option, date);
			}
		}
		return $([startTime.get(0), endTime.get(0)]);
	};

	/**
	 * Log error or data to the console during error or debugging
	 * @param  Object err pass any type object to log to the console during error or debugging
	 * @return void
	 */
	$.timepicker.log = function(err){
		if(window.console)
			console.log(err);
	};

	/*
	* Keep up with the version
	*/
	$.timepicker.version = "1.2";


}));
/******************************************************************************* 
* Copyright 2012, 2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES 
* 
* This file is part of SITools2. 
* 
* SITools2 is free software: you can redistribute it and/or modify 
* it under the terms of the GNU General Public License as published by 
* the Free Software Foundation, either version 3 of the License, or 
* (at your option) any later version. 
* 
* SITools2 is distributed in the hope that it will be useful, 
* but WITHOUT ANY WARRANTY; without even the implied warranty of 
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
* GNU General Public License for more details. 
* 
* You should have received a copy of the GNU General Public License 
* along with SITools2. If not, see <http://www.gnu.org/licenses/>. 
******************************************************************************/ 

/**
 * OpenSearch service
 */
define('OpenSearchService', [ "jquery", "underscore-min", "text!../templates/openSearchService.html", "text!../templates/openSearchForm.html", "jquery.ui", "jquery.ui.timepicker" ], function($,_,openSearchServiceHTMLTemplate, openSearchFormHTMLTemplate) {

// Template generating the open search service div
var openSearchServiceTemplate = _.template(openSearchServiceHTMLTemplate);
// Template generating the form of properties
var openSearchFormTemplate = _.template(openSearchFormHTMLTemplate);
var layers = [];

/**
 *	Handle submit event
 */
function handleSubmit(event)
{
	event.preventDefault();

	var layer = $(this).data("layer");
	// Get array of changed inputs
	var notEmptyInputs = $(this).find(':input[value!=""]').serializeArray();
	// Create new properties
	var properties = {}
	for(var i=0; i<notEmptyInputs.length; i++)
	{
		properties[notEmptyInputs[i].name.toString()] = notEmptyInputs[i].value.toString();
	}

	var selectOptions;
	$(this).find('select').each(function(i){
		if ( $(this).val() )
			properties[$(this).attr("name")] = $(this).val();
		
	});

	// Modify the request properties of choosen layer
	layer.setRequestProperties(properties);
}

/**
 *	Add OpenSearch form and handle jQuery stuff(events & widgets)
 */
function handleForm(layer)
{
	$('#osForm_'+layer.id)
	.html(layer.openSearchForm ? layer.openSearchForm : "Loading...")
	.find('.openSearchForm')
		.data("layer", layer)
		.submit(handleSubmit).end()
	.find(".datepicker").datetimepicker({
		showSecond: true,
		separator: 'T',
		timeSuffix: 'Z',
		timeFormat: 'HH:mm:ss'
	});
	$('#openSearchTabs').tabs("refresh");
}

/**
 *	Attach open search form to layer
 *
 *	@param layer GlobWeb layer
 */
function attachForm(layer)
{
	$.ajax({
		type: "GET",
		url: layer.serviceUrl,
		dataType: "xml",
		success: function(xml) {

			var mspdesc = $(xml).find('Url[rel="mspdesc"]');
			var describeUrl = $(mspdesc).attr("template");

			$.ajax({
				type: "GET",
				url: describeUrl,
				dataType: "json",
				success: function(json)
				{
					var formProperties = json.filters;
					layer.openSearchForm = openSearchFormTemplate( { layer: layer, properties: formProperties });
					handleForm(layer);
				},
				error: function()
				{
					layer.openSearchForm = "OpenSearch parameter isn't available";
					$('#osForm_'+layer.id)
						.html(layer.openSearchForm);
				}
			});
		},
		error: function(thrownError)
		{
			$('#osForm_'+layer.id)
				.html("("+thrownError.status+") "+thrownError.statusText+"<br/>For more details, contact administrator.");
		}
	});
}

return {
	/**
	 *	Add layer to the service
	 */
	addLayer: function(layer)
	{
		layers.push(layer);

		if ( !layer.openSearchForm )
			attachForm(layer);

		$('#openSearchTabs').children( ".ui-tabs-nav" ).append('<li><a href="#osForm_'+layer.id+'">'+layer.name+'</a></li>');
		$('#openSearchTabs').append('<div id="osForm_'+layer.id+'">'+layer.openSearchForm+'</div>');
		handleForm(layer);
	},

	/**
	 *	Remove layer from the service
	 */
	removeLayer: function(layer)
	{
		for(var i=0; i<layers.length; i++)
		{
			if(layers[i].id == layer.id)
			{
				layers.splice(i,1);
			}
		}

		var index = $('#openSearchTabs').find( '.ui-tabs-nav li[aria-controls="osForm_'+layer.id+'"]').index();
		$('#openSearchTabs').tabs("remove",index);
		$('#openSearchTabs').tabs("refresh");
	},

	/**
	 *	Add service to jQueryUI tabs
	 *
	 *	@param tabs jQueryUI tabs selector
	 */
	addService: function(tabs)
	{
		// Append header
		$('<li style="display: none;"><a href="#OpenSearchService">OpenSearch</a></li>')
			.appendTo( tabs.children( ".ui-tabs-nav" ) )
			.fadeIn(300);
		// Append content
		tabs.append('<div id="OpenSearchService"></div>');

		var openSearchService = openSearchServiceTemplate({ layers: layers });

		$(openSearchService)
			.appendTo('#OpenSearchService')
			.tabs({
				collapsible: true,
				hide: { effect: "fadeOut", duration: 300 },
				show: { effect: "fadeIn", duration: 300 }
			})
			.find('.openSearchForm')
				.submit(handleSubmit).end()
			.find('.datepicker').datetimepicker({
				showSecond: true,
				separator: 'T',
				timeSuffix: 'Z',
				timeFormat: 'HH:mm:ss'
			});

	},

	/**
	 *	Remove service from jQueryUI tabs
	 *
	 *	@param tabs jQueryUI tabs selector
	 */
	removeService: function(tabs)
	{
		var index = $(this).index();
		tabs.tabs("remove",index);
	}
}

});
/******************************************************************************* 
* Copyright 2012, 2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES 
* 
* This file is part of SITools2. 
* 
* SITools2 is free software: you can redistribute it and/or modify 
* it under the terms of the GNU General Public License as published by 
* the Free Software Foundation, either version 3 of the License, or 
* (at your option) any later version. 
* 
* SITools2 is distributed in the hope that it will be useful, 
* but WITHOUT ANY WARRANTY; without even the implied warranty of 
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
* GNU General Public License for more details. 
* 
* You should have received a copy of the GNU General Public License 
* along with SITools2. If not, see <http://www.gnu.org/licenses/>. 
******************************************************************************/ 

/**
 *	Moc base module
 */
define('MocBase', [ "jquery", "./MocLayer", "./Utils" ],
		function($, MocLayer, Utils) {

/**************************************************************************************************************/

/**
 *	Request moc description for the given layer
 */
function requestMocDesc(layer, successCallback, errorCallback)
{
	// Get moc template
	$.ajax({
		type: "GET",
		url: layer.serviceUrl,
		dataType: "xml",
		success: function(xml) {
			var mocdesc = $(xml).find('Url[rel="mocdesc"]');
			var describeUrl = $(mocdesc).attr("template");
			if ( describeUrl )
			{
				// Cut request parameters if exists
				var splitIndex = describeUrl.indexOf( "?q=" );
				if ( splitIndex != -1 )
				{
					describeUrl = describeUrl.substring( 0, splitIndex );
				}
				layer.describeUrl = describeUrl;
				successCallback(layer);

			}
			else
			{
				layer.describeUrl = "Not available";
				layer.coverage = "Not available";
				if( errorCallback )
					errorCallback(layer);
			}
		},
		error: function(xhr){
			layer.describeUrl = "Not available";
			layer.coverage = "Not available";
			if( errorCallback )
				errorCallback(layer);
		}
	});

}

/**************************************************************************************************************/

/**
 *	Get moc sky coverage information
 */
function getSkyCoverage(layer, successCallback, errorCallback)
{
	if ( layer.coverage != "Not available" )
	{
		if ( !layer.describeUrl )
		{
			requestMocDesc( layer, function(layer){
				requestSkyCoverage( layer, layer.describeUrl+"?media=txt", successCallback );
			}, errorCallback );
		}
		else
		{
			requestSkyCoverage( layer, layer.describeUrl+"?media=txt", successCallback );
		}
	}
	else
	{
		errorCallback(layer);
	}
}

/**************************************************************************************************************/

/**
 *	Create moc sublayer
 *
 *	@param layer Parent layer
 */
function createMocSublayer(layer, successCallback, errorCallback)
{
	if ( layer.describeUrl != "Not available" )
	{
		if ( !layer.describeUrl )
		{
			requestMocDesc( layer, function(layer){
				handleMocLayer( layer, layer.describeUrl );
				requestSkyCoverage( layer, layer.describeUrl+"?media=txt", successCallback );
			}, errorCallback );
		}
		else
		{
			handleMocLayer( layer, layer.describeUrl );
			requestSkyCoverage( layer, layer.describeUrl+"?media=txt", successCallback );
		}
	}
	else
	{
		errorCallback(layer);
	}
}

/**************************************************************************************************************/

/**
 *	Requesting moc sky coverage information and stock it as layer parameter
 */
function requestSkyCoverage( layer, mocServiceUrl, successCallback )
{
	if ( !layer.coverage )
	{
		// Request MOC space coverage
		$.ajax({
			type: "GET",
			url: mocServiceUrl,
			success: function(response){
				layer.coverage = Utils.roundNumber(parseFloat(response),5)+"%";
				if ( successCallback )
					successCallback(layer);
			}
		});	
	}
	else
	{
		successCallback(layer);
	}
}

/**************************************************************************************************************/

/**
 *	Handle moc layer as a sublayer
 *
 *	@param layer Parent layer
 *	@param mocServiceUrl Url to moc service
 */
function handleMocLayer(layer, mocServiceUrl)
{
	var style = layer.style;
	var serviceLayer = new MocLayer({
		serviceUrl: mocServiceUrl,
		style: layer.style,
		visible: false
	});

	serviceLayer.style.fill = true;
	serviceLayer.style.fillColor[3] = 0.3;
	if ( layer.globe && layer.visible() )
	{
		// Add sublayer to engine
		layer.globe.addLayer( serviceLayer );
	}

	if ( !layer.subLayers )
		layer.subLayers = [];

	layer.subLayers.push(serviceLayer);
}

/**************************************************************************************************************/

/**
 *	Search moc sublayer
 *	@return	Moc layer if found, null otherwise
 */
function findMocSublayer(layer)
{
	if ( layer.subLayers )
	{
		for ( var j=0; j<layer.subLayers.length; j++ )
		{
			if ( layer.subLayers[j] instanceof MocLayer )
			{
				return layer.subLayers[j];
			}
		}
	}
	return null;
}

/**************************************************************************************************************/

return {
	createMocSublayer: createMocSublayer,
	findMocSublayer: findMocSublayer,
	getSkyCoverage: getSkyCoverage,
	requestSkyCoverage: requestSkyCoverage
}

});
define('text!../templates/mocServiceItem.html',[],function () { return '<div class="mocLayer" id ="mocLayer_<%=layer.id%>">\n\t<% if( display )\n\t{\n\t%>\n\t\t<input class="display" id="display_<%=layer.id%>" type="checkbox" /><label for="display_<%=layer.id%>">Display</label>\n\t<%\n\t}\n\telse\n\t{\n\t%>\n\t\t<input id="mocCheck_<%=layer.id%>" type="checkbox" /><label for="mocCheck_<%=layer.id%>">Check</label>\n\t<%\n\t}\n\t%>\n\t<span class="mocName"><%=layer.name%></span>\n\t<span class="mocStatus"><% if ( layer.coverage == "Not available" ) print("(Not found)"); %> </span>\n\t<span class="mocCoverage">Sky coverage: <%= layer.coverage %></span>\n\t<br/>\n</div>\n';});

/******************************************************************************* 
* Copyright 2012, 2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES 
* 
* This file is part of SITools2. 
* 
* SITools2 is free software: you can redistribute it and/or modify 
* it under the terms of the GNU General Public License as published by 
* the Free Software Foundation, either version 3 of the License, or 
* (at your option) any later version. 
* 
* SITools2 is distributed in the hope that it will be useful, 
* but WITHOUT ANY WARRANTY; without even the implied warranty of 
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
* GNU General Public License for more details. 
* 
* You should have received a copy of the GNU General Public License 
* along with SITools2. If not, see <http://www.gnu.org/licenses/>. 
******************************************************************************/ 

/**
 * Moc display & Moc xMatch services
 */
define('MocService', [ "jquery", "./MocLayer", "./MocBase", "underscore-min", "text!../templates/mocServiceItem.html" ],
		function($, MocLayer, MocBase, _, mocServiceHTMLTemplate) {

// Template generating the services html
var mocServiceTemplate = _.template(mocServiceHTMLTemplate);

var globe = null;
var layers = [];

/**************************************************************************************************************/

/**
 *	Event for display button
 */
function displayClickEvent()
{
	var layer = $(this).parent().data("layer");

	var serviceLayer;
	if ( !(layer instanceof MocLayer) )
		serviceLayer = MocBase.findMocSublayer(layer);
	else
		serviceLayer = layer; 

	// Change visibility
	if ( serviceLayer )
	{
		if ( this.checked )
		{
			serviceLayer.visible(true)
		}
		else
		{
			serviceLayer.visible(false);
		}
	}
}

/**************************************************************************************************************/

/**
 *	Add HTML of moc layer
 */
function addHTMLMocLayer(layer)
{
	var content = mocServiceTemplate( { layer: layer, display: true });
	var serviceLayer = MocBase.findMocSublayer(layer);
	$(content)
		.appendTo('#MocService .mocLayers')
		.data("layer", layer)
		.find('input[type="checkbox"]')
				.attr("checked", (serviceLayer && serviceLayer.visible()) ? true : false)
				.attr("disabled", (serviceLayer) ? false : true)
				.button()
				.click(displayClickEvent);
}

/**************************************************************************************************************/

return {

	init: function(gl)
	{
		globe = gl;
	},

	/**************************************************************************************************************/

	/**
	 *	Add layer to the service
	 */
	addLayer: function(layer)
	{
		layers.push(layer);

		if ( !layer.subLayers )
		{
			layer.subLayers = [];
		}

		var serviceLayer = MocBase.findMocSublayer(layer);

		// Create if doesn't exist
		if ( !serviceLayer )
		{
			MocBase.createMocSublayer( layer, function(layer){
				$("#MocService #mocLayer_"+layer.id).find('input[type="checkbox"]').removeAttr("disabled").button("refresh");
				$("#MocService #mocLayer_"+layer.id).find('.mocCoverage').html("Sky coverage: "+layer.coverage);

			}, function(layer){
				$("#MocService #mocLayer_"+layer.id).find('.mocCoverage').html("Sky coverage: Not available").end()
										.find('.mocStatus').html('(Not found)');
			} );
		}

		addHTMLMocLayer( layer );
	},

	/**************************************************************************************************************/

	/**
	 *	Remove layer from the service
	 */
	removeLayer: function(layer)
	{
		for(var i=0; i<layers.length; i++)
		{
			if(layers[i].id == layer.id)
			{
				layers.splice(i,1);
			}
		}

		$( "#MocService #mocLayer_"+layer.id ).remove();
	},

	/**************************************************************************************************************/

	/**
	 *	Add service to jQueryUI tabs
	 *
	 *	@param tabs jQueryUI tabs selector
	 */
	addService: function(tabs)
	{
		// Append headers
		$('<li style="display: none;"><a href="#MocService">Moc</a></li>')
			.appendTo( tabs.children( ".ui-tabs-nav" ) )
			.fadeIn(300);		

		// Append content
		tabs.append('<div id="MocService">\
						<div class="mocLayers"></div>\
					</div>');

		for ( var i=0; i<layers.length; i++ )
		{
			var layer = layers[i];
			addHTMLMocLayer( layer );
		}
	},

	/**************************************************************************************************************/

	/**
	 *	Remove service from jQueryUI tabs
	 *
	 *	@param tabs jQueryUI tabs selector
	 */
	removeService: function(tabs)
	{
		// Remove MocService tab(content&header)
		$('li[aria-controls="MocService"]').remove();
		$( "#MocService" ).remove();
		tabs.tabs( "refresh" );
	}
}

});

/******************************************************************************* 
* Copyright 2012, 2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES 
* 
* This file is part of SITools2. 
* 
* SITools2 is free software: you can redistribute it and/or modify 
* it under the terms of the GNU General Public License as published by 
* the Free Software Foundation, either version 3 of the License, or 
* (at your option) any later version. 
* 
* SITools2 is distributed in the hope that it will be useful, 
* but WITHOUT ANY WARRANTY; without even the implied warranty of 
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
* GNU General Public License for more details. 
* 
* You should have received a copy of the GNU General Public License 
* along with SITools2. If not, see <http://www.gnu.org/licenses/>. 
******************************************************************************/ 

/**
 *	Moc xMatch service
 */
define('XMatchService', [ "jquery", "./LayerManager", "gw/FeatureStyle", "./MocLayer", "./MocBase", "gw/OpenSearchLayer", "./ErrorDialog", "underscore-min", "text!../templates/mocServiceItem.html", "jquery.ui" ],
		function($, LayerManager, FeatureStyle, MocLayer, MocBase, OpenSearchLayer, ErrorDialog, _, mocServiceHTMLTemplate) {

// Template generating the services html
var mocServiceTemplate = _.template(mocServiceHTMLTemplate);

var coverageServiceUrl;
var intersectionLayer;
var sky;

/**************************************************************************************************************/

/**
 *	Event for display button
 */
function displayClickEvent()
{
	var layer = $(this).parent().data("layer");

	var serviceLayer;
	if ( !(layer instanceof MocLayer) )
		serviceLayer = MocBase.findMocSublayer(layer);
	else
		serviceLayer = layer; 

	// Change visibility
	if ( serviceLayer )
	{
		if ( this.checked )
		{
			serviceLayer.visible(true)
		}
		else
		{
			serviceLayer.visible(false);
		}
	}
}

/**************************************************************************************************************/

/**
 *	Add HTML of xMatch layer
 */
function addHTMLXMatchLayer(layer)
{
	var content = mocServiceTemplate( { layer: layer, display: false } );
	$(content)
		.appendTo('#xMatchService .mocLayers')
		.data("layer",layer)
		.find('input[type="checkbox"]')
			.attr("disabled", (layer.coverage && layer.coverage != "Not available") ? false : true)
			.button({
				text:false,
				icons: {
					primary: "ui-icon-empty"
				}
			})
			.click(function(){
				$(this).button("option", {
					icons: {
	            		primary: $(this).is(':checked') ? "ui-icon-check" : "ui-icon-empty"
	            	}
	            });
			});
}

/**************************************************************************************************************/

/**
 *	Add HTML of intersection layer
 */
function addHTMLIntersectionLayer()
{
	// Add HTML
	var form = mocServiceTemplate( { layer: intersectionLayer, display: true });
	$(form)
		.appendTo('#intersectResult')
		.data("layer", intersectionLayer)
		.find(".display")
			.button()
			.click(displayClickEvent);
	$('#intersectResult').slideDown();
	$('#intersectMocBtn').removeAttr("disabled").button("refresh");
}

/**************************************************************************************************************/

/**
 *	Create & add intersection layer
 *
 *	@param layersToIntersect Layers to intersect
 */
function addIntersectionLayer(layersToIntersect)
{
	if ( coverageServiceUrl )
	{
		// Construct url & layerNames
		var url = coverageServiceUrl;
		var layerNames = "";
		for ( var i=0; i<layersToIntersect.length; i++ )
		{
			var layer = layersToIntersect[i];

			layerNames += layer.name;
			url += layer.describeUrl;
			if ( i != layersToIntersect.length-1 )
			{
				url += ';'
				layerNames += ' x ';
			}
		}

		if ( intersectionLayer )
			sky.removeLayer(intersectionLayer);

		// Create intersection MOC layer
		intersectionLayer = new MocLayer({
				name: "Intersection( "+layerNames+" )",
				serviceUrl: url + "&media=json",
				style: new FeatureStyle({
					rendererHint: "Basic",
					fill: true,
					fillColor: [1.,0.,0.,0.3]
				}),
				visible: false
			});
		sky.addLayer(intersectionLayer);

		MocBase.requestSkyCoverage( intersectionLayer, url + "&media=txt", function(layer){
			$("#xMatchService #mocLayer_"+layer.id).find('.mocCoverage').html("Sky coverage: "+layer.coverage);
		} );
		addHTMLIntersectionLayer();
	}
	else
	{
		ErrorDialog.open("Coverage service URL isn't defined in configuration file");
		$('#intersectMocBtn').removeAttr("disabled").button("refresh");
	}
}

/**************************************************************************************************************/

return {
	init: function(s, configuration)
	{
		sky = s;
		if ( configuration.coverageService )
		{
			coverageServiceUrl = configuration.coverageService.baseUrl;
		}
	},

	/**************************************************************************************************************/

	addLayer: function(layer)
	{
		// Check the layer to xMatch
		if ( layer.coverage != "Not available" )
		{
			$('#xMatchService #mocCheck_'+layer.id)
				.attr('checked', 'checked')
				.button("option", {
					icons: {
						primary: "ui-icon-check"
					},
				}).button('refresh');
		}

		// Replace its div on top
		$('#xMatchService #mocLayer_'+layer.id).append('<br/>').prependTo('#xMatchService .mocLayers');


	},

	/**************************************************************************************************************/

	removeLayer: function(layer)
	{
		// Uncheck the given layer
		$('#xMatchService #mocCheck_'+layer.id).removeAttr('checked');
	},

	/**************************************************************************************************************/

	/**
	 *	Add service to jQueryUI tabs
	 *
	 *	@param tabs jQueryUI tabs selector
	 */
	addService: function(tabs)
	{
		$('<li style="display: none;"><a href="#xMatchService">xMatch</a></li>')
			.appendTo( tabs.children( ".ui-tabs-nav" ) )
			.fadeIn(300);

		tabs.append('<div id="xMatchService">\
				<div class="mocLayers"></div>\
					<button id="intersectMocBtn">Intersect</button>\
				<div id="intersectResult"></div>\
			</div>');

		var allLayers = LayerManager.getLayers();
		var allOSLayers = _.filter(allLayers, function(layer){ return (layer instanceof OpenSearchLayer) });

		for ( var i=0; i<allOSLayers.length; i++ )
		{
			var layer = allOSLayers[i];
			var serviceLayer = MocBase.findMocSublayer(layer);
			// Create if doesn't exist
			if ( !serviceLayer )
			{
				MocBase.getSkyCoverage( layer, function(layer){
					$("#xMatchService #mocLayer_"+layer.id).find('.mocCoverage').html("Sky coverage: "+layer.coverage);
					$("#xMatchService #mocLayer_"+layer.id).find('input[type="checkbox"]').removeAttr("disabled").button("refresh");
				}, function(layer){
					$("#xMatchService #mocLayer_"+layer.id).find('.mocCoverage').html("Sky coverage: Not available").end()
										.find('.mocStatus').html('(Not found)');
					$("#xMatchService #mocLayer_"+layer.id).find('input[type="checkbox"]').removeAttr('checked').button("option", {
						icons: {
							primary: "ui-icon-empty"
						}
					}).button("refresh");

				});
			}

			addHTMLXMatchLayer( layer );
		}

		$( '#intersectMocBtn' )
			.button()
			.click(function(){
				$(this).attr("disabled","disabled").button("refresh");
				$('#intersectResult').clearQueue().stop().slideUp(function(){
					var checkedInputs = $(this).parent().find('.mocLayers .mocLayer input:checked');
					if ( checkedInputs.length < 2 )
					{
						$('#intersectResult').html('Check at least two layers')
								.slideDown().delay(700).slideUp(function(){
									$('#intersectMocBtn').removeAttr("disabled").button("refresh");
								});
					}
					else
					{
						$('#intersectResult').html('');
						var checkedLayers = [];
						checkedInputs.each(function(i){
							checkedLayers.push( $.data(checkedInputs[i].parentElement, "layer") );
						});

						addIntersectionLayer(checkedLayers);
					}
				});
			});
	},

	/**************************************************************************************************************/

	/**
	 *	Remove service from jQueryUI tabs
	 *
	 *	@param tabs jQueryUI tabs selector
	 */
	removeService: function(tabs)
	{
		// var index = $(this).index();
		// tabs.tabs("disable",index);
		tabs.find( '.ui-tabs-nav li[aria-controls="xMatchService"]').remove();
		$( "#xMatchService" ).remove();
		tabs.tabs( "refresh" );

		var allLayers = LayerManager.getLayers();
		var allOSLayers = _.filter(allLayers, function(layer){ return (layer instanceof OpenSearchLayer) });

		for ( var i=0; i<allOSLayers.length; i++ )
		{
			var layer = allOSLayers[i];
			$( "#xMatchService #mocLayer_"+layer.id ).remove();
		}

		if ( intersectionLayer )
		{
			sky.removeLayer( intersectionLayer );
			intersectionLayer = null;
		}
	}

	/**************************************************************************************************************/
}
});

define('text!../templates/healpixCutService.html',[],function () { return '<div id="HEALPixCut">\n\tArcsec per pixel of result:\n\t<div style="margin-left: 20px; margin-bottom: 10px;" class="imageProperties">\n\t\t<label for="cdelt1">X axis: </label><input type="text" id="cdelt1" /><br/>\n\t\t<label for="cdelt2">Y axis: </label><input type="text" id="cdelt2" />\n\t</div>\n\t<button style="margin-left: auto; margin-right: auto; display: block;" id="HEALPixCutBtn">Cut viewport</button>\n\t<div style="display: inline-block; width: auto; height: 1em;" class="status"></div>\n\t<div style="margin-top: 15px;">\n\t\t<em style="font-size: 14px;">Results</em>\n\t\t<div class="HEALPixCutResults">\n\t\t\t<ul style="list-style-type: none;">\n\t\t\t\t<% \n\t\t\t\tfor ( var i=0; i<results.length; i++ )\n\t\t\t\t{\n\t\t\t\t\tprint( itemTemplate( { result: results[i] } ) );\n\t\t\t\t}\n\t\t\t\t%>\n\t\t\t</ul>\n\t\t</div>\n\t</div>\n</div>';});

/******************************************************************************* 
* Copyright 2012, 2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES 
* 
* This file is part of SITools2. 
* 
* SITools2 is free software: you can redistribute it and/or modify 
* it under the terms of the GNU General Public License as published by 
* the Free Software Foundation, either version 3 of the License, or 
* (at your option) any later version. 
* 
* SITools2 is distributed in the hope that it will be useful, 
* but WITHOUT ANY WARRANTY; without even the implied warranty of 
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
* GNU General Public License for more details. 
* 
* You should have received a copy of the GNU General Public License 
* along with SITools2. If not, see <http://www.gnu.org/licenses/>. 
******************************************************************************/ 

/**
 * Moc display & Moc xMatch services
 */
define('HEALPixCutService', [ "jquery", "gw/CoordinateSystem", "gw/Numeric", "./UWSManager", "./Samp", "./ErrorDialog", "./Utils", "underscore-min", "text!../templates/healpixCutService.html", "text!../templates/cutResultItem.html", "jquery.ui" ],
		function($, CoordinateSystem, Numeric, UWSManager, Samp, ErrorDialog, Utils, _, healpixCutServiceHTMLTemplate, healpixCutServiceItemHTMLTemplate ) {

var globe;
var navigation;
var results = [];

// Template generating the healpixCut service content
var healpixCutServiceTemplate = _.template(healpixCutServiceHTMLTemplate);

// Template generating the result of healpix cut
var healpixCutServiceItemTemplate = _.template(healpixCutServiceItemHTMLTemplate);

return {
	init: function(gl, nav){
		globe = gl;
		navigation = nav;
	},

	addService: function(tabs, context)
	{
		// Append headers
		$('<li style="display: none;"><a href="#HEALPixCut">HEALPixCut</a></li>')
			.appendTo( tabs.children( ".ui-tabs-nav" ) )
			.fadeIn(300);		

		// Append content
		var healpixCutServiceContent = healpixCutServiceTemplate({ itemTemplate: healpixCutServiceItemTemplate, results: results });
		tabs.append(healpixCutServiceContent)
			.find('li').fadeIn();


		tabs.find('input').on('focus', function(){
			$(this).removeClass('inputError');
		});

		$('#HEALPixCut').on('click', '.sampExport', function(event){
			if ( Samp.isConnected() )
			{
				Samp.sendImage( $(this).data('url') );
			}
			else
			{
				ErrorDialog.open('You must be connected to SAMP Hub');
			}
		});

		$('#HEALPixCut').on('click', '.deleteResult', function(event){
			var $job = $(this).parent();
			var jobId = $job.data('jobid');
			UWSManager.delete( 'healpixcut', jobId, {
				successCallback: function()
				{
					$job.fadeOut(function(){
						$(this).remove();
					});
				},
				failCallback: function(thrownError)
				{
					console.error(thrownError);
					// Fade out anyway
					$job.fadeOut(function(){
						$(this).remove();
					})
				}
			} );
		});
		
		$('#HEALPixCutBtn').button().click(function(event){
			// Find RA/Dec of each corner of viewport
			var coords = [ [0,0], [globe.renderContext.canvas.width, 0], [globe.renderContext.canvas.width, globe.renderContext.canvas.height], [0, globe.renderContext.canvas.height] ];
			for ( var i=0; i<coords.length; i++ )
			{
				var geo = globe.getLonLatFromPixel( coords[i][0], coords[i][1] );
				// Convert to RA/Dec
				if ( geo[0] < 0 )
				{
					geo[0]+=360;
				}
				coords[i] = geo;
			}

			// Find angle between eye and north
			var geoEye = [];
			CoordinateSystem.from3DToGeo(navigation.center3d, geoEye);

			var LHV = [];
			CoordinateSystem.getLHVTransform(geoEye, LHV);

			var astro = Utils.formatCoordinates([ geoEye[0], geoEye[1] ]);
			
			var north = [LHV[4],LHV[5],LHV[6]];
			var cosNorth = vec3.dot(navigation.up, north);
			var radNorth = Math.acos(cosNorth);
			if ( isNaN(radNorth) )
			{
				console.error("North is NaN'ed...");
				return;
			}
			var degNorth = radNorth * 180/Math.PI;		
			
			// Depending on z component of east vector find if angle is positive or negative
		    if ( globe.renderContext.viewMatrix[8] < 0 ) {
		    	degNorth *= -1;
		    }

		    var cdelt1 = parseFloat( $('#cdelt1').val() );
		    var cdelt2 = parseFloat( $('#cdelt2').val() );

		    // Get choosen layer
		    var healpixLayer = globe.tileManager.imageryProvider;

		    if ( !context.fileName )
		    {
		    	ErrorDialog.open("FITS fileName isn't defined for HealpixCut service<br/>");
		    }

		    if ( isNaN(cdelt1) || isNaN(cdelt2) )
		    {
		    	$('#HEALPixCut').find('input').each(function(){
		    		if (!$(this).val())
		    		{
		    			$(this).addClass('inputError');
		    		}
		    	});
		    	return;
		    }

			var parameters = {
				long1: coords[0][0],
				lat1: coords[0][1],
				long2: coords[1][0],
				lat2: coords[1][1],
				long3: coords[2][0],
				lat3: coords[2][1],
				long4: coords[3][0],
				lat4: coords[3][1],
				rotation: degNorth,
				coordSystem: "EQUATORIAL",
				cdelt1: cdelt1,
				cdelt2: cdelt2,
				filename: context.fileName,
				PHASE: "RUN"
			}

			$('#HEALPixCut').find('.status').html('Healpix cut is in progress, be patient, it may take some time.').fadeIn().css('display: inline-block');
			UWSManager.post( 'healpixcut', parameters, {
				successCallback: function( response, jobId )
				{
					var name = 'Viewport ( '+ astro[0] + ' x '+ astro[1] +' )'; 
					var result = {
						name: name,
						url: response.results.result[0]['@xlink:href'],
						downloadName: name.replace('"','&quot;' ) + '.fits',
						jobId: jobId
					};
					results.push( result );

					$('#HEALPixCut').find('.status').hide();
					var healpixCutItem = healpixCutServiceItemTemplate({result: result});
					$(healpixCutItem)
						.appendTo( $('#HEALPixCut').find('.HEALPixCutResults ul') ).fadeIn();
				},
				failCallback: function(message){
					$('#HEALPixCut').find('.status').hide();
					ErrorDialog.open(message);
				},
				onloadCallback: function()
				{
					$('#HEALPixCut').find('.status').animate({opacity: 0.}, 400, function(){
						$(this).animate({opacity: 1.}, 400);
					});
				}
			} );

		});
	},

	removeService: function(tabs)
	{
		tabs.find( '.ui-tabs-nav li[aria-controls="HEALPixCut"]').css("opacity", 0.);
		var index = $(this).index();
		tabs.tabs("remove",index);
	}
}

});
/******************************************************************************* 
* Copyright 2012, 2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES 
* 
* This file is part of SITools2. 
* 
* SITools2 is free software: you can redistribute it and/or modify 
* it under the terms of the GNU General Public License as published by 
* the Free Software Foundation, either version 3 of the License, or 
* (at your option) any later version. 
* 
* SITools2 is distributed in the hope that it will be useful, 
* but WITHOUT ANY WARRANTY; without even the implied warranty of 
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
* GNU General Public License for more details. 
* 
* You should have received a copy of the GNU General Public License 
* along with SITools2. If not, see <http://www.gnu.org/licenses/>. 
******************************************************************************/ 

/**
 *	Layer service view
 *	The view representing the services for each layer
 */
define('LayerServiceView', [ "jquery", "./OpenSearchService", "./MocService", "./XMatchService", "./HEALPixCutService", "jquery.ui" ],
			function($, OpenSearchService, MocService, XMatchService, HEALPixCutService ) {

var layerServiceView = '<div id="layerServiceView" title="Available services">\
							<div id="layerServices">\
								<ul>\
								</ul>\
							</div>\
						</div>';

// jQuery selectors
var $layerServiceView;
var tabs;

var services = [ OpenSearchService, MocService, XMatchService ];

var serviceMapping = {
	"OpenSearch" : OpenSearchService,
	"Moc": MocService,
	"XMatch": XMatchService,
	"HEALPixCut" : HEALPixCutService
};

var currentLayer;

/**
 *	Get service object from configuration
 *	(could be string or object)
 */
function getServiceFromConf(service)
{
	if ( typeof service === "string" )
	{
		return serviceMapping[service];
	}
	else
	{
		if ( service.name )
		{
			return serviceMapping[service.name];
		}
		else
		{
			console.error("Service must have name property in configuration");
			return null;
		}
	}
}

return {
	/**
	 *	Initilize layer service view
	 */
	init: function(mizar, configuration)
	{
		// Create jQuery UI dialog to represent layer service view
		$layerServiceView = $(layerServiceView)
			.appendTo('body')
			.dialog({
				autoOpen: false,
				resizable: false,
				width: '600px',
				show: {
					effect: "fade",
					duration: 300
				},
				hide: {
					effect: "fade",
					duration: 300
				},
				minHeight: 'auto',
				position:['middle',20],
				open: function()
				{
					// Remove auto-focus
					$(this).find('li:first-child').blur();
				}
			});

		tabs = $layerServiceView.find('#layerServices').tabs({
			collapsible: true,
			hide: { effect: "slideUp", duration: 300 },
			show: { effect: "slideDown", duration: 300 }
		})

		MocService.init(mizar.sky, configuration);
		XMatchService.init(mizar.sky, configuration);
		HEALPixCutService.init(mizar.sky, mizar.navigation)
	},

	/**
	 *	Remove created dialog
	 */
	remove: function() {
		$layerServiceView.find('#layerServices').tabs("destroy");
		$layerServiceView.dialog("destroy").remove();
	},

	show: function(layer)
	{
		var service;

		// Remove previous services
		if ( currentLayer )
		{
			for ( var i=0; i<currentLayer.availableServices.length; i++)
			{
				service = getServiceFromConf(currentLayer.availableServices[i])
				if ( service.removeLayer )
					service.removeLayer(currentLayer);
				service.removeService(tabs, currentLayer.availableServices[i]);
			}
		}

		for ( var i=0; i<layer.availableServices.length; i++ )
		{
			service = getServiceFromConf( layer.availableServices[i] );
			if ( service )
			{
				service.addService(tabs, layer.availableServices[i]);
				if ( service.addLayer )
					service.addLayer(layer);
			}
			else
			{
				// Unrecognized service, remove it
				console.error("Mapping doesn't exist, service must be = { OpenSearch, Moc, XMatch or HEALPixCut }");
				layer.availableServices.splice(i,1);
			}
		}
		currentLayer = layer;

		tabs.tabs('refresh');
		tabs.tabs("option", "active", 0);

		$layerServiceView
			.dialog( "open" );
	}
}

});
/******************************************************************************* 
* Copyright 2012, 2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES 
* 
* This file is part of SITools2. 
* 
* SITools2 is free software: you can redistribute it and/or modify 
* it under the terms of the GNU General Public License as published by 
* the Free Software Foundation, either version 3 of the License, or 
* (at your option) any later version. 
* 
* SITools2 is distributed in the hope that it will be useful, 
* but WITHOUT ANY WARRANTY; without even the implied warranty of 
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
* GNU General Public License for more details. 
* 
* You should have received a copy of the GNU General Public License 
* along with SITools2. If not, see <http://www.gnu.org/licenses/>. 
******************************************************************************/ 

/**
 * BackgroundLayersView module
 */
define('BackgroundLayersView',["jquery", "underscore-min", "./LayerManager", "./DynamicImageView", "./PickingManager", "./HEALPixFITSLayer", "./LayerServiceView", "./Samp", "./ErrorDialog", "jquery.ui"],
		function($, _, LayerManager, DynamicImageView, PickingManager, HEALPixFITSLayer, LayerServiceView, Samp, ErrorDialog){

var nbBackgroundLayers = 0; // required because background id is always equal to 0
var sky;
var layerManager;

var backgroundDiv;
var selectedLayer;

/**************************************************************************************************************/

/**
 *	Update layout of background layer options (HEALPixFITSLayer only for now)
 */
function updateBackgroundOptions(layer)
{		
	if ( layer instanceof HEALPixFITSLayer )
	{
		$("#fitsType").removeAttr('disabled').removeAttr('checked').button("refresh");
		// Dynamic image view button visibility
		if ( layer.dataType == 'jpeg' )
		{
			$('#fitsView').button("disable");
		}
	}
	else
	{
		$("#fitsType").attr('disabled','disabled').button("refresh");
		$('#fitsView').button("disable");
	}

	var $layerServices = $('#backgroundLayers').find('.layerServices');
	if ( !layer.availableServices )
	{
		$layerServices.attr('disabled','disabled').button('refresh');
	}
	else
	{
		$layerServices.removeAttr('disabled').button('refresh');
	}
}

/**************************************************************************************************************/

/**
 *	Create the Html for the given background layer
 */
function createHtmlForBackgroundLayer( gwLayer )
{
	// Add HTML
	var $layerDiv = $('<option '+ (gwLayer.visible() ? "selected" : "") +'>'+ gwLayer.name + '</option>')
			.appendTo('#backgroundLayersSelect')
			.data("layer", gwLayer);
	
	if ( gwLayer.icon )
	{	
		$layerDiv.addClass('backgroundLayer_'+ nbBackgroundLayers)
					.attr("data-style", "background-image: url("+gwLayer.icon+")" );
	}
	else
	{
		// Use default style for icon
		$layerDiv.addClass('backgroundLayer_'+ nbBackgroundLayers)
					.attr("data-class", "unknown" );
	}

	if ( gwLayer.visible() )
	{
		// Update background options layout
		updateBackgroundOptions(gwLayer);
		selectedLayer = gwLayer;
	}

	$('#backgroundLayersSelect').iconselectmenu("refresh");	
	nbBackgroundLayers++;
}

/**************************************************************************************************************/

/**
 *	Show spinner on loading
 */
function onLoadStart(layer)
{
	$('#backgroundSpinner').fadeIn('fast');
}

/**************************************************************************************************************/

/**
 *	Hide spinner when layer is loaded
 */
function onLoadEnd(layer)
{
	$('#backgroundSpinner').fadeOut('fast');
}

/**************************************************************************************************************/

return {
	/**
	 *	Initialization options
	 */
	init : function(options)
	{
		this.mizar = options.mizar;
		
		sky = this.mizar.sky;
		this.updateUI();

		// Background spinner events
		sky.subscribe("startBackgroundLoad", onLoadStart);
		sky.subscribe("endBackgroundLoad", onLoadEnd);
		this.mizar.subscribe("backgroundLayer:change", this.selectLayer);
	},
	remove : function()
	{
		sky.unsubscribe("startBackgroundLoad", onLoadStart);
		sky.unsubscribe("endBackgroundLoad", onLoadEnd);
		this.mizar.unsubscribe("backgroundLayer:change", this.selectLayer);
		$('#backgroundDiv').dialog("destroy").remove();
	},
	addView : createHtmlForBackgroundLayer,

	/**
	 *	Select the given layer
	 */
	selectLayer: function(layer) {

		// Update selectmenu ui by choosen layer(if called programmatically)
		$('#backgroundLayersSelect').children().removeAttr("selected");
		var option = _.find($('#backgroundLayersSelect').children(), function(item) {
			return item.text == layer.name;
		});
		$(option).attr("selected","selected");

		selectedLayer = layer;

		// Show background loading spinner
		$('#loading').show(300);

		// Set shader callback for choosen layer
		backgroundDiv.changeShaderCallback = function(contrast){
			if ( contrast == "raw" )
			{
				layer.customShader.fragmentCode = layer.rawFragShader;
			} else {
				layer.customShader.fragmentCode = layer.colormapFragShader;
			}
		};

		// Change dynamic image view button
		updateBackgroundOptions(layer);

		$('#backgroundLayersSelect').iconselectmenu("refresh");	

	},

	/**
	 *	Create select menu
	 *	Synchonize background spinner with background survey events
	 */
	updateUI : function() {

		// Add custion icon select menu
		$.widget( "custom.iconselectmenu", $.ui.selectmenu, {
			_renderItem: function( ul, item ) {
				var li = $( "<li>", { text: item.label } );

				if ( item.disabled ) {
					li.addClass( "ui-state-disabled" );
				}

				$( "<span>", {
					style: item.element.attr( "data-style" ),
					"class": "ui-icon " + item.element.attr( "data-class" )
				}).appendTo( li );

				return li.appendTo( ul );
			}
		});

		$('#backgroundLayers').find('.layerServices').button({
			text: false,
			icons: {
				primary: "ui-icon-wrench"
			}
		}).click(function(event){
			LayerServiceView.show( selectedLayer );
		});

		$('#backgroundLayers').find('.exportLayer').button({
			text: false,
			icons: {
				primary: "ui-icon-extlink"
			}
		}).click(function(event){
			if ( Samp.isConnected() )
			{
				var healpixLayer = sky.tileManager.imageryProvider;
				for ( var i=0; i<sky.tileManager.tilesToRender.length; i++ )
				{
					var tile = sky.tileManager.tilesToRender[i];
					var url = window.location.origin + healpixLayer.getUrl( tile );
					Samp.sendImage(url);
				}
			}
			else
			{
				ErrorDialog.open('You must be connected to SAMP Hub');
			}
		});		

		var dialogId = "backgroundDiv";
		var $dialog = $('<div id="'+dialogId+'"></div>').appendTo('body').dialog({
			title: 'Image processing',
			autoOpen: false,
			show: {
				effect: "fade",
		    	duration: 300
			},
			hide: {
				effect: "fade",
				duration: 300
			},
			width: 400,
			resizable: false,
			minHeight: 'auto',
			close: function(event, ui)
			{
				$('#fitsView').removeAttr("checked").button("refresh");
				$(this).dialog("close");
			}
		});

		// Show/hide Dynamic image service
		$('#fitsView').button({
			text: false,
			icons: {
				primary: "ui-icon-image"
			}
		}).click(function(event){

			if ( $dialog.dialog( "isOpen" ) )
			{
				$dialog.dialog("close");
			}
			else
			{
				$dialog.dialog("open");
			}
		});

		backgroundDiv = new DynamicImageView(dialogId, {
			id : 'backgroundFitsView',
		});

		$('#fitsType')
			.button()
			.click(function(){

			isFits = $(this).is(':checked');

			selectedLayer.dataType = isFits ? 'fits' : 'jpg';
			if ( !isFits )
			{
				$('#fitsView').button('disable');
			}

			sky.setBaseImagery( null );
			sky.setBaseImagery( selectedLayer );
			$('#loading').show();
		});

		var self = this;
		$('#backgroundLayersSelect').iconselectmenu({
			select: function(event, ui)
			{
				var index = ui.item.index;
				var layer = $(this).children().eq(index).data("layer");
				if ( layer != sky.baseImagery ) {
					LayerManager.setBackgroundSurvey(layer.name);
				}
			}
		}).iconselectmenu( "menuWidget" )
				.addClass( "ui-menu-icons customicons" );
	},
	getDiv : function() {
		return backgroundDiv;
	}
}

});
define('text!../templates/additionalLayer.html',[],function () { return '<div class="ui-widget addLayer" id="addLayer_<%= shortName %>" >\n\n\t<span id="visible_<%= shortName %>" class="<% if (layer.visible()) print(\'ui-state-active\'); else print(\'ui-state-default\'); %> ui-corner-all ui-button">\n\t\t<span class="ui-icon <% if (layer.visible()) print(\'ui-icon-check\'); else print(\'ui-icon-empty\'); %>"></span>\n\t</span>\n\n\t<canvas width="20" height="10" class="legend"></canvas>\n\n\t<label title="<%= layer.description %>" for="addLayerInput_<%= shortName %>"><%= layer.name %></label>\n\n\t<span style="display: none;" class="spinner"></span>\n\n\t<div style="display: none;" class="layerTools" class="ui-widget-header ui-corner-all">\n\t\t\n\t\t<%\n\t\tif( layer.deletable )\n\t\t{\n\t\t%>\n\t\t\t\n\t\t\t<button class="deleteLayer">Delete</button>\n\t\t<%\n\t\t}\n\t\t%>\n\n\n\t\t<% if ( layer.type == "GeoJSON" )\n\t\t{\n\t\t%>\n\t\t\t\n\t\t\t<button class="zoomTo">zoomTo</button>\n\t\t<%\n\t\t}\n\n\t\tif ( layer.availableServices )\n\t\t{\n\t\t%>\n\t\t\t<button class="layerServices">Available services</button>\n\t\t<%\n\t\t}\n\t\tif ( layer instanceof OpenSearchLayer )\n\t\t{\n\t\t%>\n\t\t\t<button class="exportLayer">Export visible tiles by SAMP</button>\n\t\t\t<a href="" download=""><button class="downloadAsVO">Download visible tiles as VOTable</button></a>\n\t\t<%\n\t\t}\n\t\t%>\n\n\t\t<% if ( layer instanceof HEALPixFITSLayer && !isMobile )\n\t\t{\n\t\t%>\n\t\t\t<input type="checkbox" class="isFits" id="isFits_<%= shortName %>" /><label for="isFits_<%= shortName %>">Fits</label>\n\t\t\t<input type="checkbox" class="addFitsView" id="addFitsView_<%= shortName %>" disabled="disabled" /><label for="addFitsView_<%= shortName %>"></label>\n\t\t<%\n\t\t}\n\t\t%>\n\n\t\t<div id="opacity_<%= shortName %>">\n\t\t\t<div>\n\t\t\t\t<label for="percentInput_<%= shortName %>">Opacity: </label>\n\t\t\t\t<input class="percentInput" type="text" id="percentInput_<%= shortName %>" />\n\t\t\t</div>\n\t\t\t<div class="slider" id="slider_<%= shortName %>"></div>\n\t\t</div>\n\t</div>\n\n</div>';});

/******************************************************************************* 
* Copyright 2012, 2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES 
* 
* This file is part of SITools2. 
* 
* SITools2 is free software: you can redistribute it and/or modify 
* it under the terms of the GNU General Public License as published by 
* the Free Software Foundation, either version 3 of the License, or 
* (at your option) any later version. 
* 
* SITools2 is distributed in the hope that it will be useful, 
* but WITHOUT ANY WARRANTY; without even the implied warranty of 
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
* GNU General Public License for more details. 
* 
* You should have received a copy of the GNU General Public License 
* along with SITools2. If not, see <http://www.gnu.org/licenses/>. 
******************************************************************************/ 

/**
 * AdditionalLayersView module
 */
define('AdditionalLayersView',["jquery", "gw/CoordinateSystem", "gw/FeatureStyle", "gw/OpenSearchLayer", "./LayerManager", "./HEALPixFITSLayer", "./MocLayer", "gw/VectorLayer", "./PickingManager", "./DynamicImageView", "./LayerServiceView", "./Samp", "./ErrorDialog", "./Utils", "underscore-min", "text!../templates/additionalLayer.html", "jquery.nicescroll.min", "jquery.ui"],
		function($, CoordinateSystem, FeatureStyle, OpenSearchLayer, LayerManager, HEALPixFITSLayer, MocLayer, VectorLayer, PickingManager, DynamicImageView, LayerServiceView, Samp, ErrorDialog, Utils, _, additionalLayerHTMLTemplate){

var sky;
var navigation;
var categories = {
	"Other": 'otherLayers',
	"Coordinate systems": 'coordinateSystems'
};
var isMobile = false;

// Template generating the additional layer div in sidemenu
var additionalLayerTemplate = _.template(additionalLayerHTMLTemplate);

/**************************************************************************************************************/

/**
 *	Generate point legend in canvas 2d
 *
 *	@param gwLayer GlobWeb layer
 *	@param canvas Canvas
 *	@param imageUrl Image source url used for point texture
 */
function generatePointLegend( gwLayer, canvas, imageUrl )
{
	var context = canvas.getContext('2d');
	var icon = new Image();
	icon.onload = function() {
		// var width = (icon.width > canvas.width) ? canvas.width : icon.width;
		// var height = (icon.height > canvas.height) ? canvas.height : icon.height;
		context.drawImage(icon, 5, 0, 10, 10);

		// colorize icon
		var data = context.getImageData(0, 0, canvas.width, canvas.height);
		for (var i = 0, length = data.data.length; i < length; i+=4) {
			data.data[i] = gwLayer.style.fillColor[0]*255;
			data.data[i+1] = gwLayer.style.fillColor[1]*255;
			data.data[i+2] = gwLayer.style.fillColor[2]*255;
		}

		context.putImageData(data, 0, 0);
	};
	icon.src = imageUrl;
}

/**************************************************************************************************************/

/**
 *	Generate line legend in canvas 2d
 */
function generateLineLegend( gwLayer, canvas )
{
	var context = canvas.getContext('2d');

	var margin = 2;
	context.beginPath();
	context.moveTo(margin, canvas.height - margin);
	context.lineTo(canvas.width/2 - margin, margin);
	context.lineTo(canvas.width/2 + margin, canvas.height - margin);
	context.lineTo(canvas.width - margin, margin);
	context.lineWidth = 1;

	// set line color
	context.strokeStyle = FeatureStyle.fromColorToString(gwLayer.style.fillColor);
	context.stroke();
}

/**************************************************************************************************************/

/**
 *	Initialize nice scroll for the given category
 */
function initNiceScroll(categoryId)
{
	// Nice scrollbar initialization
	$('#'+categoryId).niceScroll({
		autohidemode: false
	});
	// Hide scroll while accordion animation
	$( "#accordion" ).on( "accordionbeforeactivate", function(event, ui) {
		$('#'+categoryId).niceScroll().hide();
	} );
	// Show&resize scroll on the end of accordion animation
	$( "#accordion" ).on( "accordionactivate", function( event, ui ) {
		$('#'+categoryId).niceScroll().show();
		updateScroll(categoryId);
	} );
}

/**************************************************************************************************************/

/**
 *	Update scroll event
 */
function updateScroll(categoryId)
{
	$('#accordion').find('#'+categoryId).getNiceScroll().resize();
}

/**************************************************************************************************************/

/**
 *	Add legend for the given layer if possible
 *	Legend represents the "line" for polygon data or image from "iconUrl" for point data
 */
function addLegend($layerDiv, gwLayer)
{
	var $canvas = $layerDiv.find('.legend');
	var canvas = $canvas[0];

	if ( gwLayer instanceof OpenSearchLayer || gwLayer instanceof MocLayer || gwLayer instanceof VectorLayer )
	{
		if ( gwLayer.dataType == "point")
		{
			generatePointLegend(gwLayer, canvas, gwLayer.style.iconUrl);
		} 
		else if ( gwLayer.dataType == "line")
		{
			generateLineLegend( gwLayer, canvas );
		} 
		else
		{
			$canvas.css("display", "none");			
		}
	}
	else
	{
		$canvas.css("display", "none");
	}
}

/**************************************************************************************************************/

/**
 *	Initialize UI of opacity slider for the given layer
 */
function initializeSlider( $layerDiv, gwLayer )
{
	var shortName = Utils.formatId( gwLayer.name );
	// Slider initialisation
	$layerDiv.find('#slider_'+shortName).slider({
		value: gwLayer.opacity()*100,
		min: 20,
		max: 100,
		step: 20,
		slide: function( event, ui ) {
			$( "#percentInput_"+shortName ).val( ui.value + "%" );
			gwLayer.opacity( ui.value/100. );

			if ( gwLayer.subLayers )
			{
				for ( var i=0; i<gwLayer.subLayers.length; i++ )
				{
					gwLayer.subLayers[i].opacity( ui.value/100.);
				}
			}
		}
	}).slider( "option", "disabled", !gwLayer.visible() );
	
	// Init percent input of slider
	$( "#percentInput_"+shortName ).val( $( "#slider_"+shortName ).slider( "value" ) + "%" );
}

/**************************************************************************************************************/

/**
 *	Update all toolbar buttons UI
 */
function updateButtonsUI($layerDiv)
{
	// Init buttons of tool bar
	$layerDiv
		.find('.deleteLayer').button({
			text: false,
			icons: {
				primary: "ui-icon-trash"
			}
		}).end()
		.find('.zoomTo').button({
			text: false,
			icons: {
				primary: "ui-icon-zoomin"
			}
		}).end()
		.find('.exportLayer').button({
			text: false,
			icons: {
				primary: "ui-icon-extlink"
			}
		}).end()
		.find('.downloadAsVO').button({
			text: false,
			icons: {
				primary: "ui-icon-arrowthickstop-1-s"
			}
		}).end()
		.find('.isFits').button().end()
		.find('.addFitsView').button({
			text: false,
			icons: {
				primary: "ui-icon-image"
			}
		}).end()
		.find('.layerServices').button({
			text: false,
			icons: {
				primary: "ui-icon-wrench"
			}
		});
}

/**************************************************************************************************************/

/**
 *	Create dialog to modify contrast/colormap of fits layers
 */
function createDynamicImageDialog( gwLayer )
{
	var shortName = Utils.formatId( gwLayer.name );
	// Supports fits, so create dynamic image view in dialog
	var dialogId = "addFitsViewDialog_"+shortName;
	var $dialog = $('<div id="'+dialogId+'"></div>').appendTo('body').dialog({
		title: 'Image processing',
		autoOpen: false,
		show: {
			effect: "fade",
	    	duration: 300
		},
		hide: {
			effect: "fade",
			duration: 300
		},
		resizable: false,
		width: 'auto',
		minHeight: 'auto',
		close: function(event, ui)
		{
			$('#addFitsView_'+shortName).removeAttr("checked").button("refresh");
			$(this).dialog("close");
		}
	});

	// Dialog activator
	$('#addFitsView_'+shortName).click(function(){

		if ( $dialog.dialog( "isOpen" ) )
		{
			$dialog.dialog("close");
		}
		else
		{
			$dialog.dialog("open");
		}
	});

	// Add dynamic image view content to dialog
	gwLayer.div = new DynamicImageView( dialogId, {
		id : shortName,
		changeShaderCallback: function(contrast)
		{
			if ( contrast == "raw" )
			{
				gwLayer.customShader.fragmentCode = gwLayer.rawFragShader;
			}
			else
			{
				gwLayer.customShader.fragmentCode = gwLayer.colormapFragShader;
			}
		}
	});
}

/**************************************************************************************************************/

/**
 *	Show/hide layer tools depending on layer visibility
 *	Set visibility event handlers
 */
function manageLayerVisibility($layerDiv, gwLayer, categoryId)
{
	var shortName = Utils.formatId( gwLayer.name );
	// Open tools div when the user clicks on the layer label
	var toolsDiv = $layerDiv.find('.layerTools');
	$layerDiv.children('label').click(function() {
		toolsDiv.slideToggle(updateScroll.bind(this, categoryId));
	});

	if ( gwLayer.visible() )
	{
		toolsDiv.slideDown();
	}

	// Layer visibility management
	$layerDiv.find('#visible_'+shortName).click(function(){
		// Manage 'custom' checkbox
		// jQuery UI button is not sexy enough :)
		// Toggle some classes when the user clicks on the visibility checkbox
		var isOn = !$(this).hasClass('ui-state-active');
		gwLayer.visible( isOn );
		if ( gwLayer.subLayers )
		{
			setSublayersVisibility(gwLayer, isOn);
		}

		$layerDiv.find('.slider').slider( isOn ? "enable" : "disable" );
		if ( isOn )
		{
			$('.layerTools').slideUp();
			toolsDiv.slideDown();
		}
		else
		{
			toolsDiv.slideUp();	
		}
		
		// Change button's state
		$('#visible_'+shortName).toggleClass('ui-state-active')
			   .toggleClass('ui-state-default')
			   .find('span')
			   	  .toggleClass('ui-icon-check')
			   	  .toggleClass('ui-icon-empty');

		// Synchronize with visibility button of ImageViewer if needed
		var $imageViewerBtn = $('#layerVisibility_'+gwLayer.id);
		if ( ($imageViewerBtn.button('option', 'icons').primary == "ui-icon-check") != isOn )
		{
			$imageViewerBtn.trigger('click');
		}

	});
}

/**************************************************************************************************************/

/**
 *	Set sublayers visibility
 */
function setSublayersVisibility(gwLayer, isOn)
{
	if ( isOn )
	{
		for ( var i=0; i<gwLayer.subLayers.length; i++ )
		{
			sky.addLayer( gwLayer.subLayers[i] );
		}
	}
	else
	{
		for ( var i=0; i<gwLayer.subLayers.length; i++ )
		{
			sky.removeLayer( gwLayer.subLayers[i] );
		}
	}
}

/**************************************************************************************************************/

/**
 *	Create the Html for addtionnal layer
 */
function createHtmlForAdditionalLayer( gwLayer, categoryId )
{
	var currentIndex = gwLayer.id;
	var shortName = Utils.formatId( gwLayer.name );
	var layerDiv = additionalLayerTemplate( {
		layer: gwLayer,
		OpenSearchLayer: OpenSearchLayer,
		HEALPixFITSLayer: HEALPixFITSLayer,
		shortName : shortName,
		isMobile: isMobile
	} );

	var $layerDiv = $(layerDiv)
		.appendTo('#'+categoryId)
		.data("layer", gwLayer);
	
	// Add legend
	addLegend($layerDiv, gwLayer);
	
	// Create UI of opacity slider
	initializeSlider($layerDiv, gwLayer);

	manageLayerVisibility($layerDiv, gwLayer, categoryId);
	
	updateButtonsUI($layerDiv);

	if ( gwLayer instanceof HEALPixFITSLayer && !isMobile )
	{
		createDynamicImageDialog(gwLayer);
	}
}

/**************************************************************************************************************/

/**
 * 	Create HTML for the given layer
 */
function addView ( gwLayer )
{
	var category = gwLayer.category;
	// Other as default
	if ( !category )
	{
		category = 'Other';
	}

	// Create new category if doesn't exists
	var categoryId;
	if ( !categories[category] )
	{
		categoryId = Utils.formatId( category );
		$('<div class="category"><h3>'+ category +'</h3>\
			<div id="'+categoryId+'"></div></div>')
				.insertBefore($('#otherLayers').parent());

		categories[category] = categoryId;

		// Refresh accordion
		$('#accordion').accordion("refresh");
		// Add scroll to the new category
		initNiceScroll(categoryId);
	}
	else
	{
		categoryId = categories[category];
	}

	// Add HTML
	createHtmlForAdditionalLayer( gwLayer, categoryId );
}

/**************************************************************************************************************/

/**
 *	Remove HTML view of the given layer
 *	Remove the category if the given layer is the last layer of category
 */
function removeView ( gwLayer ) {
	var shortName = Utils.formatId( gwLayer.name );
	var addLayerDiv = $('#accordion').find('#addLayer_'+shortName);
	if ( addLayerDiv.parent().children().length == 1 ) {
		// Last child to remove -> remove the category
		addLayerDiv.closest('.category').remove();
	} else {
		addLayerDiv.remove();
	}

	if ( gwLayer.div )
	{
		$('#addFitsView_'+gwLayer.div.id).dialog("destroy").remove();
		gwLayer.div = null;
	}
}

/**************************************************************************************************************/

/**
 *	Build visible tiles url
 */
function buildVisibleTilesUrl(layer)
{
	// Find max visible order & visible pixel indices
	var maxOrder = 3;
	var pixelIndices = "";
	for ( var i=0; i<sky.tileManager.visibleTiles.length; i++ )
	{
		var tile = sky.tileManager.visibleTiles[i];
		if ( maxOrder < tile.order )
			maxOrder = tile.order;

		pixelIndices+=tile.pixelIndex;
		if ( i < sky.tileManager.visibleTiles.length - 1 )
		{
			pixelIndices+=",";
		}
	}

	return layer.serviceUrl+"/search?order="+maxOrder+"&healpix="+pixelIndices+"&coordSystem=EQUATORIAL";
}

/**************************************************************************************************************/

/**
 *	Delete layer handler
 */
function deleteLayer()
{
	$(this).parent().parent().fadeOut(300, function(){
		$(this).remove();
	});

	var layer = $(this).closest(".addLayer").data("layer");
	LayerManager.removeLayer(layer);

	updateScroll('otherLayers');
}

/**************************************************************************************************************/

/**
 *	Show layer services popup
 */
function showLayerServices()
{
	var layer = $(this).closest(".addLayer").data("layer");
	LayerServiceView.show( layer );
}

/**************************************************************************************************************/

/**
 *	Export the given layer by SAMP
 */
function exportLayer()
{
	if ( Samp.isConnected() )
	{
		var layer = $(this).closest(".addLayer").data("layer");
		var url = buildVisibleTilesUrl(layer);
		var message = Samp.sendVOTable(layer, url);
	}
	else
	{
		ErrorDialog.open("You must be connected to SAMP Hub");
	}
}

/**************************************************************************************************************/

/**
 *	Download features on visible tiles of the given layer as VO table
 */
function downloadAsVO()
{
	var layer = $(this).closest(".addLayer").data("layer");
	var url = buildVisibleTilesUrl(layer);
	url+="&media=votable";
	var posGeo = CoordinateSystem.from3DToGeo( navigation.center3d );
	var astro = Utils.formatCoordinates( posGeo );
	$(this).parent().attr('href', url)
					.attr('download', layer.name+"_"+astro[0]+'_'+astro[1]);
}

/**************************************************************************************************************/

/**
 *	Zoom to barycenter of all features contained by layer
 *	(available for GlobWeb.VectorLayers only)
 */
function zoomTo()
{
	var layer = $(this).closest(".addLayer").data("layer");
	var sLon = 0;
	var sLat = 0;
	var nbGeometries = 0;

	for (var i=0; i<layer.features.length; i++)
	{
		var barycenter = Utils.computeGeometryBarycenter( layer.features[i].geometry );
		sLon += barycenter[0];
		sLat += barycenter[1];
		nbGeometries++;
	}

	navigation.zoomTo([sLon/nbGeometries, sLat/nbGeometries], 2.0, 2000);
}

/**************************************************************************************************************/

/**
 *	Toggle layer to fits rendering
 */
function toggleFits()
{
	var isFits = $(this).is(':checked');
	var layer = $(this).closest(".addLayer").data("layer");
	layer.dataType = isFits ? 'fits' : 'jpg';
	if ( !isFits )
	{
		$(this).nextAll('.addFitsView').button('disable');
	}

	// TODO: make reset function ?
	// layer.setDatatype( dataType );

	var prevId = layer.id;
	sky.removeLayer(layer);
	sky.addLayer(layer);

	// HACK : Layer id will be changed by remove/add so we need to change the html id
	$('#addLayer_'+prevId).attr('id','addLayer_'+layer.id);
}

/**************************************************************************************************************/

/**
 *	Initialize toolbar events
 */
function registerEvents()
{
	sky.subscribe("startLoad", onLoadStart);
	sky.subscribe("endLoad", onLoadEnd);

	$('#accordion')
		.on("click",'.category .deleteLayer', deleteLayer)
		.on('click', ".category .layerServices", showLayerServices)
		.on('click', ".category .exportLayer", exportLayer)
		.on('click', '.category .downloadAsVO', downloadAsVO)
		.on("click", ".category .zoomTo", zoomTo)
		.on('click', '.category .isFits', toggleFits);
}

/**************************************************************************************************************/

/**
 *	Show spinner on layer loading
 */
function onLoadStart(layer)
{
	var shortName = Utils.formatId( layer.name );
	$('#addLayer_'+shortName).find('.spinner').stop(true,true).fadeIn('fast');
}

/**************************************************************************************************************/

/**
 *	Hide spinner when layer is loaded	
 */
function onLoadEnd(layer)
{
	var shortName = Utils.formatId( layer.name );
	$('#addLayer_'+shortName).find('.spinner').fadeOut(500);
}

/**************************************************************************************************************/

return {
	/**
	 *	Initialize additional layers view
	 */
	init : function(options)
	{
		sky = options.mizar.sky;
		navigation = options.mizar.navigation;
		isMobile = options.configuration.isMobile;

		// Select default coordinate system event
		$('#defaultCoordSystem').selectmenu({
			select: function(e)
			{
				var newCoordSystem = $(this).children('option:selected').val();				
				options.mizar.setCoordinateSystem(newCoordSystem);
			},
			width: 100
		});

		registerEvents();
	},

	/**
	 *	Unregister all event handlers
	 */
	remove: function()
	{
		sky.unsubscribe("startLoad", onLoadStart);
		sky.unsubscribe("endLoad", onLoadEnd);

		$('#accordion')
			.off("click",'.category .deleteLayer', deleteLayer)
			.off('click', ".category .layerServices", showLayerServices)
			.off('click', ".category .exportLayer", exportLayer)
			.off('click', '.category .downloadAsVO', downloadAsVO)
			.off("click", ".category .zoomTo", zoomTo)
			.off('click', '.category .isFits', toggleFits);

		// Remove all created dialogs
		var layers = LayerManager.getLayers();
		for ( var i=0; i<layers.length; i++ )
		{
			var layer = layers[i];
			if ( layer.div )
			{
				$('#addFitsViewDialog_'+layer.div.id).dialog("destroy").remove();
			}
		}

		// Reinit categories
		categories = {
			"Other": 'otherLayers',
			"Coordinate systems": 'coordinateSystems'
		};
		
	},

	addView : addView,
	removeView: removeView,
	hideView: function(layer)
	{
		$('#addLayer_'+layer.id).hide();
	},
	showView: function(layer)
	{
		$('#addLayer_'+layer.id).show();
	}
};

});
define('text!../templates/layerManagerContent.html',[],function () { return '<div id="accordion" style="display: none;">\n\t<div>\n\t\t<h3>Background layer</h3>\n\t\t<div id="backgroundLayers">\n\t\t\t<fieldset>\n\t\t\t\t<select style="display: none;" id="backgroundLayersSelect">\n\t\t\t\t</select>\n\t\t\t</fieldset>\n\n\t\t\t<div style="display: none" id="backgroundSpinner"></div>\n\t\t\t<br/>\n\t\t\t<div id="backgroundOptions">\n\t\t\t\t<input type="checkbox" id="fitsType" /><label for="fitsType">Fits</label>\n\t\t\t\t<input type="checkbox" id="fitsView" /><label for="fitsView">Image processing</label>\n\t\t\t\t<button class="layerServices">Available services</button>\n\t\t\t\t<button class="exportLayer">Send viewport by SAMP</button>\n\t\t\t</div>\n\t\t</div>\n\t</div>\n\n\t<div class="category">\n\t\t<h3>Other</h3>\n\t\t<div id="otherLayers"></div>\n\t</div>\n\n\t<div class="category">\n\t\t<h3>Coordinate systems</h3>\n\t\t<div id="coordinateSystems">\n\t\t\t<em>Default coordinate system:</em>\n\t\t\t<select id="defaultCoordSystem">\n\t\t\t\t<option value="EQ">Equatorial</option>\n\t\t\t\t<option value="GAL">Galactic</option>\n\t\t\t</select>\n\t\t\t<div id="coordinateGrids">\n\t\t\t</div>\n\t\t</div>\n\t</div>\n</div>';});

/******************************************************************************* 
* Copyright 2012, 2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES 
* 
* This file is part of SITools2. 
* 
* SITools2 is free software: you can redistribute it and/or modify 
* it under the terms of the GNU General Public License as published by 
* the Free Software Foundation, either version 3 of the License, or 
* (at your option) any later version. 
* 
* SITools2 is distributed in the hope that it will be useful, 
* but WITHOUT ANY WARRANTY; without even the implied warranty of 
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
* GNU General Public License for more details. 
* 
* You should have received a copy of the GNU General Public License 
* along with SITools2. If not, see <http://www.gnu.org/licenses/>. 
******************************************************************************/ 

/**
 * Layer manager view module
 */
define('LayerManagerView', [ "jquery", "underscore-min", "LayerManager", "./ErrorDialog", "./LayerServiceView", "./BackgroundLayersView", "./AdditionalLayersView", "./FitsLoader", "./ImageManager", "text!../templates/layerManagerContent.html", "jquery.ui"], 
	function($, _, LayerManager, ErrorDialog, LayerServiceView, BackgroundLayersView, AdditionalLayersView, FitsLoader, ImageManager, layerManagerHTML) {

/**
 * Private variables
 */
var mizar;
var sky = null;

// GeoJSON data providers
var dataProviders = {};
var votable2geojsonBaseUrl;
var parentElement;


/**
 * Private functions
 */

/**************************************************************************************************************/

/**
 * 	Drop event
 */
function handleDrop(evt) {
	evt.stopPropagation();
	evt.preventDefault();

	var files = evt.dataTransfer.files; // FileList object.
	// Files is a FileList of File objects.
	$.each( files, function(index, f) {
		
		var name = f.name;
		var reader = new FileReader();
		$('#loading').show();

		if ( f.type == "image/fits" )
		{
			// Handle fits image
			reader.onloadend = function(e) {
				var arrayBuffer = this.result;
				var fits = FitsLoader.parseFits(arrayBuffer);

				var gwLayer = LayerManager.createLayerFromFits(name, fits);
				AdditionalLayersView.addView( gwLayer );

				// Add fits texture
				var featureData = {
					layer: gwLayer,
					feature: gwLayer.features[0],
					isFits: true
				};
				var fitsData = fits.getHDU().data;
				mizar.publish("image:add", featureData);
				ImageManager.handleFits( fitsData, featureData );

				$('#loading').hide();
			};
			reader.readAsArrayBuffer(f);
		}
		else
		{
			reader.onloadend = function(e) {

				if ( this.result.search('<?xml') > 0 )
				{
					$.ajax({
						type: "GET",
						url: votable2geojsonBaseUrl,
						data: {
							url: proxyUrl,
							coordSystem: "EQUATORIAL"
						},
						success: function(response)
						{

							var gwLayer = LayerManager.createLayerFromGeoJson(name, response);
							AdditionalLayersView.addView( gwLayer );
							$('#loading').hide();
						},
						error: function(thrownError)
						{
							console.error(thrownError);
						}
					});
				}
				else
				{
					// Handle as json if possible
					try {
						var response = $.parseJSON(this.result);
					} catch (e) {
						ErrorDialog.open("JSON parsing error : " + e.type + "<br/> For more details see http://jsonlint.com/.");
						$('#loading').hide();
						return false;
					}

					var gwLayer = LayerManager.createLayerFromGeoJson(name, response);
					AdditionalLayersView.addView( gwLayer );
					$('#loading').hide();
				}
				
			};
			reader.readAsText(f);
		}

	});
}

/**************************************************************************************************************/

/**
 * 	Drag over event
 */
function handleDragOver(evt)
{
	evt.stopPropagation();
	evt.preventDefault();
	evt.dataTransfer.dropEffect = 'copy'; // Explicitly show this is a copy.
}

/**************************************************************************************************************/

/**
 *	Initialize view with layers stored in <LayerManager>
 */
function initLayers() 
{
	var layers = LayerManager.getLayers();

	// Due to scroll initialization which corrumps accordion UI init in additional layers view,
	// accordion UI must be initialized before
	$( "#accordion" ).accordion( {
		header: "> div > h3",
		autoHeight: false,
		active: 0,
		collapsible: true,
		heightStyle: "content"
	} ).show().accordion("refresh");

	// Add view depending on category of each layer
	for ( var i=0; i<layers.length; i++ )
	{
		var layer = layers[i];
		if ( layer.category == "background" )
		{
			BackgroundLayersView.addView( layer );
		}
		else
		{
			AdditionalLayersView.addView( layer );
		}
	}
	
}

/**************************************************************************************************************/

return {
	/**
	 *	Init
	 *
	 *	@param mizar
	 *		Mizar API object
	 *	@param configuration
	 *		Mizar configuration 
 	 */
	init: function(mizar, configuration) {
		
		parentElement = configuration.element;
		$(layerManagerHTML).appendTo(parentElement);

		// Store the sky in the global module variable
		sky = mizar.sky;
		AdditionalLayersView.init({ mizar: mizar, configuration: configuration });
		BackgroundLayersView.init({ mizar: mizar });

		mizar.subscribe("backgroundLayer:add", BackgroundLayersView.addView);
		mizar.subscribe("additionalLayer:add", AdditionalLayersView.addView);

		// Necessary to drag&drop option while using jQuery
		$.event.props.push('dataTransfer');

		initLayers();
		LayerServiceView.init(mizar, configuration);

		// Setup the drag & drop listeners.
		$('canvas').on('dragover', handleDragOver);
		$('canvas').on('drop', handleDrop);

		if ( configuration.votable2geojson )
		{
			votable2geojsonBaseUrl = configuration.votable2geojson.baseUrl;
		}
	},

	/**
	 *	Unregister all event handlers and remove view
	 */
	remove: function() {
		AdditionalLayersView.remove();
		BackgroundLayersView.remove();
		LayerServiceView.remove();
		$(parentElement).empty();

		mizar.unsubscribe("backgroundLayer:add", BackgroundLayersView.addView);
		mizar.unsubscribe("additionalLayer:add", AdditionalLayersView.addView);
		$('canvas').off('dragover', handleDragOver);
		$('canvas').off('drop', handleDrop);
	},

	/**
	 *	Returns the state of view
	 */
	isInitialized: function()
	{
		return (sky != null)
	}
};

});
/******************************************************************************* 
* Copyright 2012, 2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES 
* 
* This file is part of SITools2. 
* 
* SITools2 is free software: you can redistribute it and/or modify 
* it under the terms of the GNU General Public License as published by 
* the Free Software Foundation, either version 3 of the License, or 
* (at your option) any later version. 
* 
* SITools2 is distributed in the hope that it will be useful, 
* but WITHOUT ANY WARRANTY; without even the implied warranty of 
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
* GNU General Public License for more details. 
* 
* You should have received a copy of the GNU General Public License 
* along with SITools2. If not, see <http://www.gnu.org/licenses/>. 
******************************************************************************/ 

/**
 * Name resolver module : API allowing to search object name and zoom to it
 */
define('NameResolver',["jquery", "gw/FeatureStyle", "gw/VectorLayer", "gw/HEALPixBase", "gw/CoordinateSystem", "./Utils", "jquery.ui"],
	function($, FeatureStyle, VectorLayer, HEALPixBase, CoordinateSystem, Utils) {

// Name resolver globals
var sky;
var astroNavigator;
var configuration = {
	"nameResolver": {
		zoomFov: 15.
	}
};

// Target layer
var targetLayer;
// Zooming destination feature
var targetFeature;

/**************************************************************************************************************/

/**
 *	Update targetFeature and add it to the target layer
 *
 *	@param lon Destination longitude/right ascension in degrees
 *	@param lat Destination latitude/declination in degrees
 */
function addTarget(lon, lat)
{
	targetFeature = {
		"geometry": {
			"coordinates": [
				lon,
				lat
			],
			"type": "Point"
		},
		"type": "Feature"
	};

	targetLayer.addFeature( targetFeature );
}

/**************************************************************************************************************/

/**
 *	Search for object name
 *	Object name could be:
 *		* Degree in "HMS DMS" or "deg deg"
 *		* Object name as "Mars", "m31", "Mizar"
 *		* For debug : healpix(order, pixelIndex)
 */
function search(objectName, onSuccess, onError, onComplete)
{
	// regexp used only to distinct equatorial coordinates and objects
	// TODO more accurate ( "x < 24h", "x < 60mn", etc.. )

	objectName = objectName.replace(/\s{2,}/g, ' '); // Replace multiple spaces by a single one
	var coordinatesExp = new RegExp("\\d{1,2}[h|:]\\d{1,2}[m|:]\\d{1,2}([\\.]\\d+)?s?\\s[-+]?[\\d]+[|:]\\d{1,2}['|:]\\d{1,2}([\\.]\\d+)?\"?", "g");
	var healpixRE = /^healpix\((\d)+,(\d+)\)/;
	var degRE = /^(\d+(\.\d+)?),?\s(-?\d+(\.\d+)?)/;
	var matchHealpix = healpixRE.exec(objectName);
	var matchDegree = degRE.exec(objectName);
	if ( matchHealpix ) 
	{
		var order = parseInt(matchHealpix[1]);
		var pixelIndex = parseInt(matchHealpix[2]);
		
		// Compute vertices
		var nside = Math.pow(2, order);
		var pix=pixelIndex&(nside*nside-1);
		var ix = HEALPixBase.compress_bits(pix);
		var iy = HEALPixBase.compress_bits(pix>>>1);
		var face = (pixelIndex>>>(2*order));

		var i = 0.5;
		var j = 0.5;
		var vert = HEALPixBase.fxyf( (ix+i)/nside, (iy+j)/nside, face);
		var geoPos = [];
		CoordinateSystem.from3DToGeo(vert, geoPos);
		zoomTo(geoPos[0],geoPos[1]);
	}
	else if ( objectName.match( coordinatesExp ) )
	{
		// Format to equatorial coordinates
		var word = objectName.split(" "); // [RA, Dec]

		word[0] = word[0].replace(/h|m|:/g," ");
		word[0] = word[0].replace("s", "");
		word[1] = word[1].replace(/|'|:/g," ");
		word[1] = word[1].replace("\"", "");
		
		// Convert to geo and zoom
		var geoPos = [];
		CoordinateSystem.fromEquatorialToGeo([word[0], word[1]], geoPos);

		if ( CoordinateSystem.type != "EQ" )
		{
			geoPos = CoordinateSystem.convert(geoPos, CoordinateSystem.type, 'EQ');
		}

		zoomTo(geoPos[0], geoPos[1]);
	}
	else if ( matchDegree ) {
		var lon = parseFloat(matchDegree[1]);
		var lat = parseFloat(matchDegree[3]);
		var geo = [lon, lat];

		if ( CoordinateSystem.type != "EQ" )
		{
			geo = CoordinateSystem.convert(geo, CoordinateSystem.type,  'EQ');
		}

		zoomTo(geo[0], geo[1]);
	}
	else
	{
		// Name of the object which could be potentially found by name resolver
		var url = configuration.baseUrl + "/" + objectName + "/EQUATORIAL";

		$.ajax({
			type: "GET",
			url: url,
			success: function(response){
				// Check if response contains features
				if(response.type == "FeatureCollection")
				{
					var firstFeature = response.features[0];
					zoomTo(firstFeature.geometry.coordinates[0], firstFeature.geometry.coordinates[1]);

					if ( onSuccess )
						onSuccess(response);
				} else {
					onError();
				}
			},
			error: function (xhr, ajaxOptions, thrownError) {
				if( onError )
					onError();
				console.error( xhr.responseText );
			},
			complete: function(xhr)
			{
				if ( onComplete )
					onComplete(xhr);
			}
		});
	}
}

/**************************************************************************************************************/

/**
 *	Zoom to the given longitude/latitude and add target at the end
 */
function zoomTo(lon, lat)
{
	astroNavigator.zoomTo([lon, lat], configuration.zoomFov, 3000, function() {
		addTarget(lon,lat);
	} );
}

/**************************************************************************************************************/

/**
 *	Delete target image
 */
function removeTarget()
{
	if ( targetFeature )
	{
		targetLayer.removeFeature( targetFeature );
		targetFeature = null;
	}
}

/**************************************************************************************************************/

return {
	init: function(mizar, conf) {
		if ( !sky ) {
			configuration = conf;
			var style = new FeatureStyle({
				iconUrl: configuration.mizarBaseUrl + "css/images/target.png",
				fillColor: [1., 1., 1., 1.]
			});
			targetLayer = new VectorLayer({ style: style });

			sky = mizar.sky;
			astroNavigator = mizar.navigation;
			configuration = $.extend(conf['nameResolver'], configuration['nameResolver']);

			sky.addLayer( targetLayer );
			astroNavigator.subscribe("modified", removeTarget);
		} else {
			console.error("Name resolver is already initialized");
		}
	},

	/**
	 *	Unregister all event handlers
	 */
	remove: function() {
		if ( sky )
		{
			sky.removeLayer( targetLayer );
			astroNavigator.unsubscribe("modified", removeTarget);
			sky = null;
		}
	},

	goTo: search,
	zoomTo: zoomTo
};

});

define('text!../templates/nameResolverResult.html',[],function () { return '<div class="nameResolverResult">\n\t<% if (properties.type)\n\t{ %>\n\t\t<em>Type:</em> <%= properties.type %><br/>\n\t<% } %>\n\t<em><% (type == "EQ") ? print("RA: ") : print("Longitude: ") %></em><%= lon %><br/>\n\t<em><% (type == "EQ") ? print("Dec: ") : print("Latitude: ") %></em><%= lat %><br/>\n\tFound in <%= properties.credits %> database</br>\n</div>';});

/******************************************************************************* 
* Copyright 2012, 2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES 
* 
* This file is part of SITools2. 
* 
* SITools2 is free software: you can redistribute it and/or modify 
* it under the terms of the GNU General Public License as published by 
* the Free Software Foundation, either version 3 of the License, or 
* (at your option) any later version. 
* 
* SITools2 is distributed in the hope that it will be useful, 
* but WITHOUT ANY WARRANTY; without even the implied warranty of 
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
* GNU General Public License for more details. 
* 
* You should have received a copy of the GNU General Public License 
* along with SITools2. If not, see <http://www.gnu.org/licenses/>. 
******************************************************************************/ 

/**
 * View for <NameResolver>
 */
define('NameResolverView',["jquery", "gw/CoordinateSystem", "./Utils", "./NameResolver", "underscore-min", "text!../templates/nameResolverResult.html", "jquery.ui"],
	function($, CoordinateSystem, Utils, NameResolver, _, nameResolverResultHTMLTemplate) {


var nameResolverHTML = '<form id="searchForm">\
				<fieldset>\
					<div class="searchInputDiv">\
						<input title="Enter an object name (e.g. m31) or coordinate (e.g 23h45m30.5s -45&#186;30\'30&rdquo;)" type="text" name="searchInput" id="searchInput" value="Object name or coordinates" />\
					</div>\
					<input type="submit" id="searchSubmit" value="" />\
					<div style="display: none" id="searchSpinner"></div>\
					<input type="button" id="searchClear" value="" style="display: none;"/>\
				</fieldset>\
			</form>\
			<div style="display: none" id="resolverSearchResult"></div>';


// Template generating the list of selected features
var nameResolverResultTemplate = _.template(nameResolverResultHTMLTemplate);

// jQuery selectors
var $nameResolver;
var $input;
var $clear;
var $resolverSearchResult;

// Name resolver globals
var response;
var animationDuration = 300;

/**************************************************************************************************************/

/**
 *	Update targetFeature and add it to the target layer
 *
 *	@param lon Destination longitude/right ascension in degrees
 *	@param lat Destination latitude/declination in degrees
 */
function addTarget(lon, lat)
{
	targetFeature = {
		"geometry": {
			"coordinates": [
				lon,
				lat
			],
			"type": "Point"
		},
	"type": "Feature"
	};

	targetLayer.addFeature( targetFeature );
}

/**************************************************************************************************************/

/**
 *	Stylized focus effect on input
 */
function _focusInput()
{
	var defaultText = $input.attr("value");
	if($input.val() === defaultText)
	{
		$input.val('');
	}

	$(this).animate({color: '#000'}, animationDuration).parent().animate({backgroundColor: '#fff'}, animationDuration, function(){
		if(!($input.val() === '' || $input.val() === defaultText)) 
		{
			$clear.fadeIn(animationDuration);
		}
	}).addClass('focus');
}

/**************************************************************************************************************/

/**
 *	Stylized blur effect on input
 */
function _blurInput(event)
{
	var defaultText = $input.attr("value");
	$(this).animate({color: '#b4bdc4'}, animationDuration, function() {
		if($input.val() === '')
		{
			$input.val(defaultText)
		}
	}).parent().animate({backgroundColor: '#e8edf1'}, animationDuration).removeClass('focus');
}

/**************************************************************************************************************/

/**
 *	Toggle visibility of clear button
 *	Designed to clear text in search input
 */
function _toggleClear()
{
	if($input.val() === '') {
		$clear.fadeOut(animationDuration);
	} else {
		$clear.fadeIn(animationDuration);
	}
}

/**************************************************************************************************************/

/**
 *	Show found results
 */
function _showResults(data)
{
	response = data;

	// Fill search result field
	var output = "";
	for ( var i=0; i<response.features.length; i++)
	{
		var astro = Utils.formatCoordinates([ response.features[i].geometry.coordinates[0], response.features[i].geometry.coordinates[1] ]);
		var result = nameResolverResultTemplate( { properties: response.features[i].properties, lon: astro[0], lat: astro[1], type: CoordinateSystem.type } );
		output+=result;
	}
	
	// Show it
	$resolverSearchResult.html(output).fadeIn(animationDuration);
	$resolverSearchResult.find('div:first-child').addClass('selected');

	$nameResolver.find("#searchSpinner").fadeOut(animationDuration);
	$clear.fadeIn(animationDuration);
}

/**************************************************************************************************************/

/**
 *	Show error message
 */
function _showError() {
	$resolverSearchResult
		.html("Bad input or object not found")
		.fadeIn(animationDuration);

	$nameResolver.find("#searchSpinner").fadeOut(animationDuration).end()
	$clear.fadeIn(animationDuration);
}

/**************************************************************************************************************/

/**
 *	Submit request with string from input
 */
function _submitRequest(event)
{
	event.preventDefault();
	$input.blur();

	var objectName = $input.val();

	if ( objectName != $input.attr("value") && objectName != '' )
	{
		$nameResolver
			.find("#searchSpinner").fadeIn(animationDuration).end()
			.find('#searchClear').fadeOut(animationDuration);
	
		$resolverSearchResult.fadeOut(animationDuration);
		NameResolver.goTo(objectName, _showResults, _showError);
	}
	else
	{
		$resolverSearchResult.html("Enter object name").fadeIn(animationDuration);
	}
}

/**************************************************************************************************************/

/**
 *	Zoom to result by clicking on item of #resolverSearchResult list
 */
function _zoomToResult(event)
{
	$('#resolverSearchResult').find('.selected').removeClass('selected');
	$(this).addClass('selected');

	var index = $(this).index();
	var selectedFeature = response.features[index];
	NameResolver.zoomTo(selectedFeature.geometry.coordinates[0], selectedFeature.geometry.coordinates[1]);
}

/**************************************************************************************************************/

/**
 *	Clear results list
 */
function _clearResults(){
	$('#resolverSearchResult').fadeOut(animationDuration);
}

/**************************************************************************************************************/

/**
 *	Clear search input
 */
function _clearInput()
{
	var defaultText = $input.attr("value");
	if($input.val() !== defaultText) {
		$input.val(defaultText);
	}
	$clear.fadeOut(animationDuration);
	$('#searchInput').animate({color: '#b4bdc4'}, animationDuration)
			.parent().animate({backgroundColor: '#e8edf1'}, animationDuration).removeClass('focus');
}

/**************************************************************************************************************/

/**
 *	Initialize events for name resolver
 */
function setSearchBehavior()
{
	// Set style animations
	$input.on('focus', _focusInput)
		.on('blur', _blurInput)
		.keyup(_toggleClear);
	
	// Submit event
	$('#searchDiv').find('#searchForm').submit(_submitRequest);
	
	// Clear search result field when pan
	$('canvas').on('click', _clearResults);
	
	$('#searchDiv').find('#resolverSearchResult').on("click", '.nameResolverResult', _zoomToResult);
	$nameResolver.find('#searchClear').on('click', _clearInput);
}

/**************************************************************************************************************/

/**
 *	Delete target image
 */
function removeTarget()
{
	if ( targetFeature )
	{
		targetLayer.removeFeature( targetFeature );
		targetFeature = null;
	}
}

/**************************************************************************************************************/

return {
	init: function() {
		if ( !$nameResolver ) {

			// TODO : replace searchDiv by "parentElement"
			$nameResolver = $(nameResolverHTML).appendTo('#searchDiv');
			$input = $nameResolver.find('#searchInput');
			$clear = $nameResolver.find('#searchClear');
			$resolverSearchResult = $nameResolver.siblings('#resolverSearchResult');

			setSearchBehavior();
		} else {
			console.error("Name resolver view is already initialized");
		}
	},

	/**
	 *	Unregister all event handlers
	 */
	remove: function() {
		if ( $nameResolver )
		{
			// Set style animations
			$input.off('focus', _focusInput)
				.off('blur', _blurInput)
				.unbind('keyup', _toggleClear);
					
			// Clear search result field when pan
			$('canvas').off('click', _clearResults);
			
			$('#searchDiv').find('#resolverSearchResult').off("click", '.nameResolverResult', _zoomToResult);
			$nameResolver.find('#searchClear').off('click', _clearInput);
			$nameResolver.remove();
			$nameResolver = null;
		}
	}
};

});

/******************************************************************************* 
* Copyright 2012, 2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES 
* 
* This file is part of SITools2. 
* 
* SITools2 is free software: you can redistribute it and/or modify 
* it under the terms of the GNU General Public License as published by 
* the Free Software Foundation, either version 3 of the License, or 
* (at your option) any later version. 
* 
* SITools2 is distributed in the hope that it will be useful, 
* but WITHOUT ANY WARRANTY; without even the implied warranty of 
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
* GNU General Public License for more details. 
* 
* You should have received a copy of the GNU General Public License 
* along with SITools2. If not, see <http://www.gnu.org/licenses/>. 
******************************************************************************/ 

/**
 * Name resolver module : search object name and zoom to them
 */
define('ReverseNameResolver',["jquery", "gw/CoordinateSystem", "gw/Numeric", "./IFrame", "./Utils", "./ErrorDialog", "underscore-min", "text!../templates/featureDescription.html", "text!../templates/descriptionTable.html", "jquery.ui"],
	function($, CoordinateSystem, Numeric, IFrame, Utils, ErrorDialog, _, featureDescriptionHTMLTemplate, descriptionTableHTMLTemplate) {

var sky;
var configuration = {};
var geoPick = [];
var navigation = null;
var isMobile = false;

// Template generating the detailed description of choosen feature
var featureDescriptionTemplate = _.template(featureDescriptionHTMLTemplate);

// Template generating the table of properties of choosen feature
var descriptionTableTemplate = _.template(descriptionTableHTMLTemplate);

var timeStart;
var mouseXStart;
var mouseYStart;

var reverseNameResolverHTML =
	'<div id="reverseNameResolver" class="contentBox ui-widget-content" style="display: none;">\
		<div id="reverseSearchField">\
			<input type="submit" value="Find Object Name" />\
			<div id="coordinatesInfo"></div>\
			<div id="healpixInfo"></div>\
		</div>\
		<div id="reverseSearchResult"></div>\
		<div class="closeBtn">\
			<span class="defaultImg"></span>\
			<span style="opacity: 0" class="hoverImg"></span>\
		</div>\
	</div>';

var $reverseNameResolver;

/**************************************************************************************************************/

/**
 *	Mouse down handler
 *	Registers the position of the mouse and time of click
 */
function _handleMouseDown(event)
{
	$reverseNameResolver.fadeOut();
	timeStart = new Date();

	if ( event.type.search("touch") >= 0 )
	{
		event.clientX = event.changedTouches[0].clientX;
		event.clientY = event.changedTouches[0].clientY;
	}

	mouseXStart = event.clientX;
	mouseYStart = event.clientY;
}

/**************************************************************************************************************/

/**
 *	Mouse up handler
 *	Opens reverse name resolver popup if mouse has been clicked at least 0.5s and hasn't been moved
 */
function _handleMouseUp(event)
{
	var epsilon = 5;

	var timeEnd = new Date();
	var diff = timeEnd - timeStart;
	var padding = 15;

	if ( event.type.search("touch") >= 0 )
	{
		event.clientX = event.changedTouches[0].clientX;
		event.clientY = event.changedTouches[0].clientY;
	}

	var mHeight = window.innerHeight - event.clientY - padding*2;
	$('#reverseSearchField').css('max-height', mHeight);
	$('#reverseSearchResult').css('max-height', mHeight);

	// More than 0.5 second and the mouse position is approximatively the same
	if ( diff > 500 && Math.abs(mouseXStart - event.clientX) < epsilon && Math.abs(mouseYStart - event.clientY) < epsilon )
	{
		$('#reverseSearchResult').css("display","none");

		var equatorial = [];
		geoPick = sky.getLonLatFromPixel(event.clientX, event.clientY);
		var astro = Utils.formatCoordinates([ geoPick[0], geoPick[1] ]);

		if ( CoordinateSystem.type == "EQ" ) {
			$("#coordinatesInfo").html("<em>Right ascension:</em><br/>&nbsp;&nbsp;&nbsp;&nbsp;" + astro[0] +
										"<br/><em>Declination :</em><br/>&nbsp;&nbsp;&nbsp;&nbsp;" + astro[1]);
		} else if ( CoordinateSystem.type == "GAL" ) {
			$("#coordinatesInfo").html("<em>Longitude:</em><br/>&nbsp;&nbsp;&nbsp;&nbsp;" + astro[0] +
										"<br/><em>Latitude:</em><br/>&nbsp;&nbsp;&nbsp;&nbsp;" + astro[1]);
		}

		var selectedTile = sky.tileManager.getVisibleTile(geoPick[0], geoPick[1]);
		if ( configuration.debug )
			$('#reverseSearchField #healpixInfo').html('<em>Healpix index/order: </em>&nbsp;&nbsp;&nbsp;&nbsp;'+selectedTile.pixelIndex + '/' + selectedTile.order);


		$('#reverseSearchField').css("display","block");
		$reverseNameResolver.css({
				position: 'absolute',
				left: event.clientX + 'px',
				top: event.clientY + 'px'
		}).fadeIn(100);
	}
}

/**************************************************************************************************************/

/**
 *	Initialize events for reverse name resolver
 */
function setBehavior()
{
	sky.renderContext.canvas.addEventListener("mousedown", _handleMouseDown);
	sky.renderContext.canvas.addEventListener("mouseup", _handleMouseUp);

	if ( isMobile )
	{
		sky.renderContext.canvas.addEventListener("touchstart", _handleMouseDown);
		sky.renderContext.canvas.addEventListener("touchend", _handleMouseUp);
	}

	// External link event
	$reverseNameResolver.on("click", '.propertiesTable a', _showIFrame);

	navigation.subscribe("modified", _hidePopup);
}

/**************************************************************************************************************/

/**
 *	Show feature information in popup
 */
function showFeature( feature )
{
	var output = featureDescriptionTemplate( { dictionary: {}, services: feature.services, properties: feature.properties, descriptionTableTemplate: descriptionTableTemplate } );
	var title = ( feature.properties.title ) ? feature.properties.title : feature.properties.identifier;
	output = '<div class="title">'+ title +'</div><div class="credit">Found in CDS database</div>' + output;
	$('#reverseSearchResult')
		.html( output )
		.find('#sendViewport').button();
	$('#reverseSearchField').fadeOut(300 , function(){
		$('#reverseSearchResult').fadeIn(300);
	});
}

/**************************************************************************************************************/

/**
 *	External link event handler
 */
function _showIFrame(event)
{
	event.preventDefault();
	IFrame.show(event.target.innerHTML);
}

/**************************************************************************************************************/

/**
 *	Hide reverse name resolver popup handler
 */
function _hidePopup(event)
{
	if ($reverseNameResolver.css('display') != 'none')
	{
		$reverseNameResolver.fadeOut(300);
	}
}

/**************************************************************************************************************/

return {
	init: function(mizar, conf) {
		if ( !$reverseNameResolver ) {
			sky = mizar.sky;
			navigation = mizar.navigation;
			$reverseNameResolver = $(reverseNameResolverHTML).appendTo('body');

			$( "#reverseNameResolver input[type=submit]")
			.button()
			.click(function( event ) {
				event.preventDefault();

				$('#reverseSearchField input[type="submit"]').attr('disabled', 'disabled');

				var equatorialCoordinates = [];
				CoordinateSystem.fromGeoToEquatorial( geoPick, equatorialCoordinates );

				// Format to equatorial coordinates
				equatorialCoordinates[0] = equatorialCoordinates[0].replace("h ",":");
				equatorialCoordinates[0] = equatorialCoordinates[0].replace("m ",":");
				equatorialCoordinates[0] = equatorialCoordinates[0].replace("s","");
				
				equatorialCoordinates[1] = equatorialCoordinates[1].replace(" ",":");
				equatorialCoordinates[1] = equatorialCoordinates[1].replace("' ",":");
				equatorialCoordinates[1] = equatorialCoordinates[1].replace("\"","");

				// Find max order
				var maxOrder = 3;
				sky.tileManager.visitTiles( function( tile ){ if ( maxOrder < tile.order ) maxOrder = tile.order} );

				var requestUrl = configuration.baseUrl + '/EQUATORIAL/' + equatorialCoordinates[0] + " " + equatorialCoordinates[1] + ";" + maxOrder;

				$.ajax({
					type: "GET",
					url: requestUrl,
					success: function(response){
						// Only one feature for the moment
						showFeature( response.features[0] );
					},
					error: function (xhr, ajaxOptions, thrownError) {
						switch (xhr.status)
						{
							case 503: 
								ErrorDialog.open("Please wait at least 6 seconds between each request to reverse name resolver");
								break;
							case 500:
								ErrorDialog.open("Internal server error");
								break;
							case 404:
								ErrorDialog.open("Object not found");
								break;
							case 400:
								ErrorDialog.open("Bad input");
							default:
								break;
						}
					},
					complete: function(xhr)
					{
						$('#reverseSearchField input[type="submit"]').removeAttr('disabled');
					}
				});
			});

			for( var x in conf.reverseNameResolver )
			{
				configuration[x] = conf.reverseNameResolver[x];
			}
			configuration.debug = conf.debug;
			isMobile = mizar.isMobile;
			setBehavior();
		} else {
			console.error("Reverse name resolver is already initialized");
		}
	},

	/**
	 *	Unregister all event handlers
	 */
	remove : function() {
		if ( $reverseNameResolver ) {
			sky.renderContext.canvas.removeEventListener("mousedown", _handleMouseDown);
			sky.renderContext.canvas.removeEventListener("mouseup", _handleMouseUp);

			if ( isMobile )
			{
				sky.renderContext.canvas.removeEventListener("touchstart", _handleMouseDown);
				sky.renderContext.canvas.removeEventListener("touchend", _handleMouseUp);
			}

			// External link event
			$reverseNameResolver.off("click", '.propertiesTable a', _showIFrame);

			navigation.unsubscribe("modified", _hidePopup);
			$reverseNameResolver.remove();
			$reverseNameResolver = null;
		}
	}
};

});

/******************************************************************************* 
* Copyright 2012, 2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES 
* 
* This file is part of SITools2. 
* 
* SITools2 is free software: you can redistribute it and/or modify 
* it under the terms of the GNU General Public License as published by 
* the Free Software Foundation, either version 3 of the License, or 
* (at your option) any later version. 
* 
* SITools2 is distributed in the hope that it will be useful, 
* but WITHOUT ANY WARRANTY; without even the implied warranty of 
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
* GNU General Public License for more details. 
* 
* You should have received a copy of the GNU General Public License 
* along with SITools2. If not, see <http://www.gnu.org/licenses/>. 
******************************************************************************/ 

/**
 * Compass module : map control with "north" composant
 */
define('Compass',["jquery", "gw/CoordinateSystem", "gw/glMatrix"], function($, CoordinateSystem) {

/**
 *	Private variables
 */
var parentElement = null;
var navigation = null;

/**
 *	Function updating the north position on compass
 */
var updateNorth = function() {

	var geo = [];
	CoordinateSystem.from3DToGeo(navigation.center3d, geo);

	if ( CoordinateSystem.type != "EQ" )
	{
		geo = CoordinateSystem.convert(geo, 'EQ', 'GAL');
	}

	var LHV = [];
	CoordinateSystem.getLHVTransform(geo, LHV);

	var temp = [];
	var north = [LHV[4],LHV[5],LHV[6]];
	var vertical = [LHV[8], LHV[9], LHV[10]];

	if ( CoordinateSystem.type != "EQ" )
	{
		north = CoordinateSystem.transformVec( [LHV[4],LHV[5],LHV[6]] );
		CoordinateSystem.from3DToGeo(north, temp);
		temp = CoordinateSystem.convert(temp, 'EQ', 'GAL');
		CoordinateSystem.fromGeoTo3D(temp, north);

		vertical = CoordinateSystem.transformVec( [LHV[8],LHV[9],LHV[10]] );
		CoordinateSystem.from3DToGeo(vertical, temp);
		temp = CoordinateSystem.convert(temp, 'EQ', 'GAL');
		CoordinateSystem.fromGeoTo3D(temp, vertical);
	}

	// Find angle between up and north
	var cosNorth = vec3.dot(navigation.up, north);
	var radNorth = Math.acos(cosNorth);
	if ( isNaN(radNorth) )
		return;
	var degNorth = radNorth * 180/Math.PI;
	
	// Find sign between up and north
	var sign;
	vec3.cross( navigation.up, north, temp );
	sign = vec3.dot( temp, [vertical[0], vertical[1], vertical[2]] );
    if ( sign < 0 )
    {
    	degNorth *= -1;
    }

    var northText = document.getElementById("objectCompass").contentDocument.getElementById("NorthText");
    northText.setAttribute("transform", "rotate(" + degNorth + " 40 40)");
};

var Compass = function(options){

	parentElement = options.element;
	var globe = options.globe;
	navigation = options.navigation;

	// Add compass object to parent element
	document.getElementById(parentElement).innerHTML = '<object id="objectCompass" width="100px" height="100px" data="'+ options.mizarBaseUrl +'css/images/compass.svg" type="image/svg+xml"></object>';

	// Initialize it on load
	document.getElementById('objectCompass').addEventListener('load', function(){
		initialize();
		// Publish modified event to update compass north
		navigation.publish('modified');
		$('#'+parentElement).css("display","block");
	});

	/**
	 *	Initialize interactive events
	 */
	var initialize = function() {
		/* Svg interactive elements */
		var compass = document.getElementById("objectCompass");
		var svgDoc = compass.contentDocument; //get the inner DOM of compass.svg
	    var east = svgDoc.getElementById("East"); //get the inner element by id
	    var west = svgDoc.getElementById("West"); //get the inner element by id
	    var south = svgDoc.getElementById("South"); //get the inner element by id
	    var north = svgDoc.getElementById("North"); //get the inner element by id
	    var northText = svgDoc.getElementById("NorthText");
	    var outerCircle = svgDoc.getElementById("OuterCircle");

	    var rotationFactor = options.rotationFactor ? options.rotationFactor : 8.;
	    var panFactor = options.panFactor ? options.panFactor : 30.;
	    
		var _lastMouseX = -1;
		var _lastMouseY = -1;
		var _dx = 0;
		var _dy = 0;
		var dragging = false;
		var _outerCircleRadius = outerCircle.ownerSVGElement.clientWidth / 2;

		var _handleMouseDown = function(event)
		{
			event.preventDefault();
			if ( event.type.search("touch") >= 0 )
			{
				event.clientX = event.changedTouches[0].clientX;
				event.clientY = event.changedTouches[0].clientY;
			}

			 dragging = true;
			_lastMouseX = event.clientX - _outerCircleRadius;
			_lastMouseY = event.clientY - _outerCircleRadius;
			_dx = 0;
			_dy = 0;
		}

	    svgDoc.addEventListener('mousedown', _handleMouseDown);


	    var _handleMouseMove = function(event)
	    {
	    	event.preventDefault();
	    	if ( event.type.search("touch") >= 0 )
			{
				event.clientX = event.changedTouches[0].clientX;
				event.clientY = event.changedTouches[0].clientY;
			}

	    	if (!dragging)
	    		return;

			var c = _lastMouseX*(event.clientY -_outerCircleRadius) - _lastMouseY*(event.clientX - _outerCircleRadius); // c>0 -> clockwise, counterclockwise otherwise
			navigation.rotate(c, 0);

			_lastMouseX = event.clientX - _outerCircleRadius;
			_lastMouseY = event.clientY - _outerCircleRadius;

	    	updateNorth();
	    }

	    svgDoc.addEventListener('mousemove', _handleMouseMove);

	    var _handleMouseUp = function(event)
	    {
	    	event.preventDefault();
	    	dragging = false;
	    	// TODO add inertia
	    }

		svgDoc.addEventListener('mouseup', _handleMouseUp);

		east.addEventListener("click", function(){
	    	navigation.pan( panFactor, 0. );
	    	updateNorth();
		});

		west.addEventListener("click", function(){
	    	navigation.pan( -panFactor, 0. );
	    	updateNorth();
		});

		north.addEventListener("click", function(){
	    	navigation.pan( 0, panFactor );
	    	updateNorth();
		});

	    south.addEventListener("click", function(){
	    	navigation.pan( 0, -panFactor );
	    	updateNorth();
		});

		var _alignWithNorth = function(event)
		{
			var up = [0,0,1];
			
			if ( CoordinateSystem.type != "EQ" )
			{
				var temp = [];
				CoordinateSystem.from3DToGeo(up, temp);
				temp = CoordinateSystem.convert(temp, 'GAL', 'EQ');
				CoordinateSystem.fromGeoTo3D(temp, up);
			}
			navigation.moveUpTo(up);
		}

		northText.addEventListener("click", _alignWithNorth);

		if ( options.isMobile )
		{
			svgDoc.addEventListener('touchstart', _handleMouseDown);
			svgDoc.addEventListener('touchup', _handleMouseUp);
			svgDoc.addEventListener('touchmove', _handleMouseMove);
			northText.addEventListener("touchstart", _alignWithNorth);
		}

	    // Update fov when moving
		navigation.subscribe("modified", updateNorth);
	}
};

/**
 *	Remove compass element
 */
Compass.prototype.remove = function() {
	navigation.unsubscribe("modified", updateNorth);
	document.getElementById(parentElement).innerHTML = '';
}

return Compass;

});
/******************************************************************************* 
* Copyright 2012, 2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES 
* 
* This file is part of SITools2. 
* 
* SITools2 is free software: you can redistribute it and/or modify 
* it under the terms of the GNU General Public License as published by 
* the Free Software Foundation, either version 3 of the License, or 
* (at your option) any later version. 
* 
* SITools2 is distributed in the hope that it will be useful, 
* but WITHOUT ANY WARRANTY; without even the implied warranty of 
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
* GNU General Public License for more details. 
* 
* You should have received a copy of the GNU General Public License 
* along with SITools2. If not, see <http://www.gnu.org/licenses/>. 
******************************************************************************/ 

/**
 * Mollweider viewer module : Sky representation in mollweide coordinate system
 */
define('MollweideViewer',["jquery", "gw/CoordinateSystem", "./Utils", "gw/glMatrix"], function($, CoordinateSystem, Utils) {

var mizarBaseUrl;

/**
 *  Newton-Raphson method to find auxiliary theta needed for mollweide x/y computation
 *  @see https://en.wikipedia.org/wiki/Mollweide_projection
 */
function _findTheta( lat )
{
    // Avoid divide by zero
    if ( lat == Math.PI || lat == -Math.PI )
        return lat;

    var epsilon = 0.001;
    var thetaN = lat;  // n
    var thetaN1;       // n+1

    do
    {
        var twoThetaN = 2*thetaN;
        thetaN = thetaN1;
        thetaN1 = twoThetaN/2 - (twoThetaN + Math.sin(twoThetaN) - Math.PI*Math.sin(lat)) / (2 + 2*Math.cos(twoThetaN));
    } while( Math.abs( thetaN1 - thetaN ) >= epsilon );

    return thetaN1;
}

/*************************************************************************/

/**
 *  Canvas 2D point
 */
var Point = function(options) {
    this.x = 0;
    this.y = 0;
    this.color = "rgb(255,0,0)";
    this.size = 2;
    for ( x in options )
    {
        this[x] = options[x];
    }
}

/*************************************************************************/

var MollweideViewer = function(options) {

    mizarBaseUrl = options.mizarBaseUrl;

    // Init options
    var globe = options.globe;
    var navigation = options.navigation;
    var halfPaddingX = 16;
    var halfPaddingY = 8;

    // Grid background dimensions
    var halfHeight = 50;
    var halfWidth = 100;

    // Interaction parameters
    var dragging = false;

    // Level of tesselation to represent fov
    var tesselation = 9; // Must be >= 2

    // Center of fov
    var center3d = new Point({
        size: 5,
        color: "rgb(255,255,0)"
    });

    // Init image background
    var canvas = document.getElementById('mollweideCanvas');
    var context = canvas.getContext('2d');
    this.imageObj = new Image();
    var self = this;
    this.imageObj.onload = function() {
        context.drawImage(self.imageObj, 0, 0);
        updateMollweideFov();
    };

    this.setCoordSystem( CoordinateSystem.type );

    /**********************************************************************************************/

    /**
     *  Compute mollweide position for given 3D position
     */
    function computeMollweidePosition( pos )
    {
        var geoPos = CoordinateSystem.from3DToGeo(pos);

        if ( CoordinateSystem.type != "EQ" )
        {
            geoPos = CoordinateSystem.convert(geoPos, 'EQ', CoordinateSystem.type)
            // Convert to geographic
            if ( geoPos[0]>180 )
            {
                geoPos[0]-=360;
            }
        }


        var lambda = geoPos[0] * Math.PI/180 ; // longitude
        var theta0 = geoPos[1] * Math.PI/180;  // latitude

        var auxTheta = _findTheta( theta0 );

        // Transfrom to Mollweide coordinate system
        var mollX = 2*Math.sqrt(2)/Math.PI * lambda * Math.cos(auxTheta);
        var mollY = Math.sqrt(2) * Math.sin(auxTheta);

        // Transform to image space
        //    2.8: max x value in Mollweide projection
        //    1.38: max y value in Mollweide projection
        var x = -mollX * halfWidth/2.8 + halfWidth + halfPaddingX;
        var y = -mollY * halfHeight/1.38 + halfHeight + halfPaddingY;

        return [x,y];
    }

    /**********************************************************************************************/

    /**
     *  Update navigation eye for the given mouse coordinates
     */
    function updateNavigation( moll )
    {
        // Transform to Mollweide space
        center3d.x = - ( moll[0] - halfWidth - halfPaddingX ) * 2.8 / halfWidth;
        center3d.y = - ( moll[1] - halfHeight - halfPaddingY ) * 1.38 / halfHeight;
        
        // Transform to geographic coordinate system
        // http://mathworld.wolfram.com/MollweideProjection.html
        var auxTheta = Math.asin( center3d.y / Math.sqrt(2) );

        var phi = Math.asin( (2*auxTheta + Math.sin(2*auxTheta))/Math.PI );
        var lambda = (Math.PI * center3d.x) / ( 2 * Math.sqrt(2) * Math.cos(auxTheta));

        var geo = [lambda*180/Math.PI, phi*180/Math.PI];
        if ( CoordinateSystem.type != "EQ" )
        {
            geo = CoordinateSystem.convert(geo, CoordinateSystem.type, "EQ");
        }

        // Update navigation
        CoordinateSystem.fromGeoTo3D(geo, navigation.center3d);

        navigation.computeViewMatrix();
    }

    /**********************************************************************************************/

    /**
     *  Function updating the position of center of camera on mollweide element
     */
    function updateMollweideFov()
    {
        // Reinit canvas
        context.clearRect(0,0, context.canvas.width, context.canvas.height);
        context.drawImage(self.imageObj, 0, 0);

        // Draw fov
        context.fillStyle = "rgb(255,0,0)";
        var stepX = globe.renderContext.canvas.clientWidth/(tesselation - 1);
        var stepY = globe.renderContext.canvas.clientHeight/(tesselation - 1);

        for ( var i=0; i<tesselation; i++ )
        {
            // Width
            for ( var j=0; j<tesselation; j++ )
            {
                // Height
                var pos3d = globe.renderContext.get3DFromPixel(i*stepX,j*stepY);
                var mPos = computeMollweidePosition( pos3d );

                // Draw on canvas 2d
                context.fillRect(mPos[0], mPos[1], 2, 2);
            }
        }

        // Draw center
        context.fillStyle = center3d.color;
        mPos = computeMollweidePosition ( navigation.center3d );
        center3d.x = mPos[0] - center3d.size/2;
        center3d.y = mPos[1] - center3d.size/2;

        // Draw on canvas 2d
        context.fillRect(mPos[0] - center3d.size/2, mPos[1]-center3d.size/2, center3d.size, center3d.size);

        // Update fov degrees
        var fov = navigation.getFov();
        var fovx = Utils.roundNumber( fov[0], 2 ) ;
        fovx = CoordinateSystem.fromDegreesToDMS( fovx );
        var fovy = Utils.roundNumber( fov[1], 2 ) ;
        fovy = CoordinateSystem.fromDegreesToDMS( fovy );
        $('#fov').html( "Fov : " + fovx + " x " + fovy );
    }

    /**********************************************************************************************/

    /**
     * Get mouse position on canvas
     */
    function getMousePos(event)
    {
        // Difference between chrome and firefox;
        var offX = (event.offsetX) ? event.offsetX : (event.layerX - event.target.offsetLeft);
        var offY = (event.offsetY) ? event.offsetY : (event.layerY - event.target.offsetTop);

        return [offX, offY];
    }

    /**********************************************************************************************/

    // Interact with mollweide projection
    canvas.addEventListener('mousedown', function(event){

        var mPos = getMousePos(event);
        updateNavigation(mPos);
        dragging = true;
        return true;
    });

    canvas.addEventListener('mousemove', function(event){

        if (!dragging)
            return;

        var mPos = getMousePos(event);
        updateNavigation(mPos);
    });

    canvas.addEventListener('mouseup', function(){
        dragging = false;
    })

    /**********************************************************************************************/

    // Show/hide mollweide projection
	$('#slideArrow').click(function(){

        if ( parseFloat($(this).parent().css('left')) < 0 )
        {
            // Show
            $('#mollweideContent').css({ boxShadow: "0px 0px 8px 1px rgba(255, 158, 82, 0.92)"});
            $(this).css('background-position', '0px 0px');
            $(this).parent().animate({left: '0px'}, 300);
            // Update fov when navigation modified
            navigation.subscribe("modified", updateMollweideFov);
			updateMollweideFov();
        }
        else
        {
            // Hide
            $('#mollweideContent').css({ boxShadow: "none"});
            $(this).css('background-position', '0px -20px');
            $(this).parent().animate({left: '-266px'}, 300);
            navigation.unsubscribe("modified", updateMollweideFov);
        }
	});

	// Fix for Google Chrome : avoid dragging
    canvas.addEventListener("dragstart", function(event){event.preventDefault(); return false;});
}

/**********************************************************************************************/

/**
 *  Change coordinate system background
 *
 *  @param coordSystem {String} Coordinate system to set
 *          <ul>
 *              <li>"EQ" : Equatorial</li>
 *              <li>"GAL" : Galactic</li>
 *          <ul>
 */
MollweideViewer.prototype.setCoordSystem = function(coordSystem)
{
    // Update mollweideViewer background image
    $(this.imageObj).attr("src", mizarBaseUrl + "css/images/MollweideSky_"+coordSystem+".png");
}

/**********************************************************************************************/

return MollweideViewer;

});
/******************************************************************************* 
* Copyright 2012, 2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES 
* 
* This file is part of SITools2. 
* 
* SITools2 is free software: you can redistribute it and/or modify 
* it under the terms of the GNU General Public License as published by 
* the Free Software Foundation, either version 3 of the License, or 
* (at your option) any later version. 
* 
* SITools2 is distributed in the hope that it will be useful, 
* but WITHOUT ANY WARRANTY; without even the implied warranty of 
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
* GNU General Public License for more details. 
* 
* You should have received a copy of the GNU General Public License 
* along with SITools2. If not, see <http://www.gnu.org/licenses/>. 
******************************************************************************/ 

/**
 * About dialog
 */
define('AboutDialog',["jquery", "jquery.ui"], function($) {

var aboutContent =
	'<div id="about" title="About">\
		<p>MIZAR has been developed and is maintained by the CENTRE NATIONAL d\'ETUDES SPATIALES (CNES).</p>\
		<p>Copyright CNES - MIZAR is a module of <a target="_blank" href="http://sitools2.sourceforge.net">SITools2</a>, distributed under GPLV3</p>\
		<p>MIZAR is based on <a target="_blank" href="https://github.com/TPZF/GlobWeb">GlobWeb</a> for rendering, developed by TPZF SSA.</p>\
		<p>Portions of the code related to Healpix and coordinates system transformation have been traduced in JavaScript from Healpix library <a target="_blank" href="http://sourceforge.net/projects/healpix/">Healpix library</a>.</p>\
		<p>The <a target="_blanc" href="http://astrojs.github.io/fitsjs/">FITS library</a> has been used to load FITS file.</p>\
		<p>The <a target="_blanc" href="http://astrojs.github.io/sampjs/">SAMP library</a> has been used for using the SAMP Web Profile from within web pages.</p>\
		<p>The <a target="_blanc" href="http://astrojs.github.io/wcsjs/">WCS library</a> has been used to localize recieved fits files on sky.</p>\
		<p>The <a target="_blanc" href="https://github.com/beatgammit/gzip-js">GZip library</a> has been used to decompress, g-zipped fits files.</p>\
		<p>ColorMap have been traduced in JavaScript from <a target="_blanc" href="http://aladin.u-strasbg.fr/aladin.gml">Aladin Sky Atlas</a>.</p>\
		<div>\
			<input id="showAbout" type="checkbox" />\n\
			<label style="font-size: 0.8em;top: -3px;position: relative;" for="showAbout">Don\'t show this message again</label>\
		</div>\
		<span style="font-size: 0.8em;bottom: 5px;right: 5px;position: absolute;">v1.0 - 26.11.2013 - nightly build</span>\
	</div>';

var $about = null;

return {
	/**
	 *	Show about dialog
	 */
	show: function(){
		if ( !$about ) {
			// Create dialog
			$about = $(aboutContent)
				.appendTo('body')
					.dialog({
						autoOpen: false,
						resizable: false,
						show: {
							effect: "fade",
							duration: 1000
						},
						hide: {
							effect: "fade",
							duration: 1000
						},
						width: '500px',
						minHeight: 'auto',
						draggable: false,
						open: function()
						{
							// Remove auto-focus
							$(this).find('a:first-child').blur();
						},
						close: function()
						{
							if ( $('#showAbout').is(':checked') )
							{
								// Don't show about for later sessions
								localStorage.showAbout = false;
							}
							$(this).remove();
						}
					});
		}
		$about.dialog( "open" );
	}
};

});
/******************************************************************************* 
* Copyright 2012, 2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES 
* 
* This file is part of SITools2. 
* 
* SITools2 is free software: you can redistribute it and/or modify 
* it under the terms of the GNU General Public License as published by 
* the Free Software Foundation, either version 3 of the License, or 
* (at your option) any later version. 
* 
* SITools2 is distributed in the hope that it will be useful, 
* but WITHOUT ANY WARRANTY; without even the implied warranty of 
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
* GNU General Public License for more details. 
* 
* You should have received a copy of the GNU General Public License 
* along with SITools2. If not, see <http://www.gnu.org/licenses/>. 
******************************************************************************/ 

/**
 * Share url module : creating url with current navigation properties
 */
define('Share',["jquery", "gw/CoordinateSystem", "./LayerManager", "./ErrorDialog"],
	function($, CoordinateSystem, LayerManager, ErrorDialog) {

var navigation;
var baseUrl;

/**
 *	Generate url with current navigation parameters as : fov, eye, visibility, rotation(TODO)
 */
function generateURL()
{
	var url = window.document.documentURI;

	var splitEndIndex = url.search( /[&|?]sharedParameters=/ );
	// If url is almost a shared link
	if ( splitEndIndex != -1 )
	{
		// Cut it
		url = url.substr( 0, splitEndIndex );
	}

	var splitIndex = url.indexOf( "?conf=" );
	if ( splitIndex != -1 )
	{
		// If configuration is defined by SiTools2
		if ( url != 'undefined' && url != '' ) {
			url += "&";
		}
		else
		{
			// Cut 'undefined'
			url = url.substr( 0, splitIndex );
			url += "?";
		}
	}
	else
	{
		url += "?";
	}

	// Get navigation parameters
	var geo = [];
	CoordinateSystem.from3DToGeo( navigation.center3d, geo );

	// Get layer visibility parameters
	var currentLayers = LayerManager.getLayers();
	var visibility = {};
	for ( var i=0; i<currentLayers.length; i++ )
	{
		visibility[currentLayers[i].name] = currentLayers[i].visible();
	}

	// Create shared parameters object to concat
	var sharedParameters = {
		initTarget: geo,
		fov: navigation.renderContext.fov,
		visibility: visibility,
		up: navigation.up
	}

	if ( baseUrl )
	{
		// Use SiTools shortener plugin
		$.ajax({
			type: "POST",
			url: baseUrl,
			async: false,
			data: { context: JSON.stringify( sharedParameters ) },
			success: function(response)
			{
				url+='sharedParameters='+response;
			},
			error: function(thrownError)
			{
				ErrorDialog.open("Shortener service: "+thrownError.statusText);
				console.error(thrownError);
			}
		});
	}
	else
	{
		// No shortener plugin, stringify shared parameters
		url+= "sharedParameters=" + JSON.stringify(sharedParameters);
	}

	return url;
}

function init(options)
{
	navigation = options.navigation;
	if ( options.configuration.hasOwnProperty('shortener') )
	{
		baseUrl = options.configuration.shortener.baseUrl;
	}

	$('#share').on('click', function(){
		var url = generateURL();
		$('#shareInput').val(url);
		$(this).fadeOut(300, function(){
			$(this).next().fadeIn();
			$('#shareInput').select();
		});
	});

	$('#shareClear').on('click', function(){
		$(this).parent().fadeOut(300, function(){
			$("#share").fadeIn();
		});
	});

	$('#share').hover(function(){
		$(this).animate({left: '-10px'}, 100);
	}, function() {
		$(this).animate({left: '-20px'}, 100);
	});
}

return {
	init: init
}

});
/******************************************************************************* 
* Copyright 2012, 2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES 
* 
* This file is part of SITools2. 
* 
* SITools2 is free software: you can redistribute it and/or modify 
* it under the terms of the GNU General Public License as published by 
* the Free Software Foundation, either version 3 of the License, or 
* (at your option) any later version. 
* 
* SITools2 is distributed in the hope that it will be useful, 
* but WITHOUT ANY WARRANTY; without even the implied warranty of 
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
* GNU General Public License for more details. 
* 
* You should have received a copy of the GNU General Public License 
* along with SITools2. If not, see <http://www.gnu.org/licenses/>. 
******************************************************************************/ 

/**
 * Simple progress bar
 */
define('SimpleProgressBar',["jquery"], function($) {

var SimpleProgressBar = function(options)
{
	var id = options.id;
	this.percentOutput = options.hasOwnProperty('percentOutput') ? options.percentOutput : false;

	this.$element = $('<div style="display: none;" class="progress"><div></div></div>')
    		.appendTo('#'+id)
    		.fadeIn();
}

SimpleProgressBar.prototype.onprogress = function(evt)
{
	if (evt.lengthComputable) 
	{				
		var percentComplete = Math.floor( (evt.loaded / evt.total)*100 );
		var progressBarWidth = percentComplete * this.$element.width() / 100;
		this.$element.find('div').css('width', progressBarWidth);

		if ( this.percentOut )
		{
			this.$element.find('div').html(percentComplete + "%&nbsp;");
		}

		if ( percentComplete >= 99 )
		{
			this.$element.delay(1000).fadeOut('slow');
		}
	}
	else
	{
		this.$element.fadeOut();
	}
}

return SimpleProgressBar;

});
define('text!../templates/imageViewer.html',[],function () { return '<div id="imageViewerContent">\n\t<span id="imageViewInvoker"></span>\n\t<div id="loadedImages">\n\t\t<h3>Images</h3>\n\t\t<div>\n\t\t\t<p style="color: white; text-align: center;">No image was loaded</p>\n\t\t\t<div class="imageLayers">\n\t\t\t</div>\n\t\t</div>\n\t</div>\n</div>';});

define('text!../templates/imageViewerLayerItem.html',[],function () { return '<div class="layer" id="imageLayer_<%= id %>" style="display: none;">\n\t<input class="layerVisibility" id="layerVisibility_<%= id %>" type="checkbox" checked />\n\t<label for="layerVisibility_<%= id %>"></label>\n\t<label class="layerName" title=<%= name %>><%= name %></label>\n\t<ul>\n\t</ul>\n</div>';});

define('text!../templates/imageViewerImageItem.html',[],function () { return '<li class="image" id="imageView_<%= id %>" style="display: none;">\n\t<input type="checkbox" name="imageView" id="<%= id %>" checked />\n\t<label style="width: 15px; height: 15px;" for="<%= id %>"></label>\n\t<label class="imageName" title="<%= name %>"><%= name %></label>\n\t<div style="display: none;" class="options">\n\t\t<button class="zoomTo">Zoom to..</button>\n\t\t<button class="<% if (!isFits) print(\'fitsUnavailable\') %> imageProcessing" id="imageProcessing_<%= id %>">Image processing</button>\n\t\t<button class="sampExport">Send image by SAMP</button>\n\t\t<button class="metadata">Show metadata</button>\n\t\t<button class="delete">Delete</button>\n\t</div>\n</li>';});

/******************************************************************************* 
* Copyright 2012, 2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES 
* 
* This file is part of SITools2. 
* 
* SITools2 is free software: you can redistribute it and/or modify 
* it under the terms of the GNU General Public License as published by 
* the Free Software Foundation, either version 3 of the License, or 
* (at your option) any later version. 
* 
* SITools2 is distributed in the hope that it will be useful, 
* but WITHOUT ANY WARRANTY; without even the implied warranty of 
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
* GNU General Public License for more details. 
* 
* You should have received a copy of the GNU General Public License 
* along with SITools2. If not, see <http://www.gnu.org/licenses/>. 
******************************************************************************/ 

define('ImageViewer',["require", "jquery", "gw/FeatureStyle", "./PickingManager", "./ImageManager", "./ImageProcessing", "./SimpleProgressBar", "./Utils", "./Samp", "./ErrorDialog", "underscore-min", "text!../templates/imageViewer.html", "text!../templates/imageViewerLayerItem.html", "text!../templates/imageViewerImageItem.html", "jquery.ui"],
	function(require, $, FeatureStyle, PickingManager, ImageManager, ImageProcessing, SimpleProgressBar, Utils, Samp, ErrorDialog, _, imageViewerHTML, imageViewerLayerItemHTMLTemplate, imageViewerImageItemHTMLTemplate){

var mizar;
var navigation;
var sky;

// jQuery selector
var $imageViewer;

var layers = [];
var featuresWithImages = [];

// Template generating the div representing layer which contains loaded images
var imageViewerLayerItemTemplate = _.template(imageViewerLayerItemHTMLTemplate);
// Template generating the li representing image
var imageViewerImageItemTemplate = _.template(imageViewerImageItemHTMLTemplate);

/**************************************************************************************************************/

/**
 *	Disable image toolbar inputs
 */
function disableImageUI(layer)
{
	$imageViewer.find('.imageLayers div[id="imageLayer_'+layer.id+'"] ul')
		.find('button, input').each(function(){
			$(this).attr('disabled','disabled').button('refresh');
		})
}

/**************************************************************************************************************/

/**
 *	Enable image toolbar inputs
 */
function enableImageUI(layer)
{
	$imageViewer.find('.imageLayers div[id="imageLayer_'+layer.id+'"] ul')
		.find('button, input').each(function(){
			// Don't enable image processing for not fits files
			if ( !$(this).hasClass('fitsUnavailable') )
			{
				$(this).removeAttr('disabled').button('refresh');
			}
		})
}

/**************************************************************************************************************/

/**
 *	Create layer view
 *	This view will contain all the loaded images for the given layer
 */
function createLayerView(layer)
{
	var imageViewerLayerItemContent = imageViewerLayerItemTemplate( { id: layer.id, name: layer.name });
	$layer = $(imageViewerLayerItemContent)
		.appendTo($imageViewer.find('.imageLayers'));

	// Slide loaded images for current layer onclick
	$layer.find('label.layerName').click(function(){
		$("#imageLayer_"+layer.id+ " > ul").slideToggle();
	});

	// Stylize layer visibility checkbox
	var $layerVisibility = $layer.find('#layerVisibility_'+layer.id);
	// Layer visibility management
	$layerVisibility.button({
		text: false,
		icons: {
        	primary: "ui-icon-check"
      	}
	}).click(function(){
		var isChecked = !($layerVisibility.button('option', 'icons').primary == "ui-icon-check");
		var shortName = Utils.formatId( layer.name );
		$layerVisibility.button("option", {
			icons: {
				primary: isChecked ? "ui-icon-check" : ""
			},
		}).button('refresh');

		if ( isChecked )
		{
			enableImageUI(layer);
		}
		else
		{
			disableImageUI(layer);
		}
		
		// Synchronize with visibility button of LayerManager if needed
		var $layerManagerBtn = $('#visible_'+shortName );
		if ( $layerManagerBtn.hasClass('ui-state-active') != isChecked )
		{
			// Trigger event on LayerManager visibility button
			$layerManagerBtn.trigger("click");
		}
	});

	if ( layers.length == 0 )
	{
		$imageViewer.find('#loadedImages p').fadeOut(function(){
			$layer.fadeIn();
		});
	}
	else
	{
		$layer.fadeIn();
	}

	layers.push(layer);

	return $layer;
}

/**************************************************************************************************************/

/**
 *	Show image viewer
 */
function showImageViewer()
{
	$imageViewer.find('#loadedImages').css({ boxShadow: "0px 0px 8px 1px rgba(255, 158, 82, 0.92)"});
	$imageViewer.find('#imageViewInvoker').css('background-position', '0px -20px')
		.parent().animate({right: '0px'}, 300);
}

/**************************************************************************************************************/

/**
 *	Hide image viewer
 */
function hideImageViewer()
{
	$imageViewer.find('#loadedImages').css({ boxShadow: "none"});
	$imageViewer.find('#imageViewInvoker').css('background-position', '0px 0px')
		.parent().animate({right: '-254px'}, 300);
}

/**************************************************************************************************************/

return {

	/**
	 *	Init image viewer
	 */
	init: function(m)
	{
		mizar = m;
		var self = this;
		mizar.subscribe("image:add", this.addView);
		mizar.subscribe("image:remove", this.removeView);
		mizar.subscribe("image:download", this.addProgressBar);
		mizar.subscribe("layer:remove", this.removeLayer);
		sky = mizar.sky;
		navigation = mizar.navigation;

		$imageViewer = $(imageViewerHTML).appendTo('#imageViewerDiv');

		// Show/hide image viewer
		$imageViewer.find('#imageViewInvoker').click(function(){
			if ( parseFloat($(this).parent().css('right')) < 0 )
			{
				showImageViewer();
			}
			else
			{
				hideImageViewer();
			}
		});
		// Create accordion
		$imageViewer.find( "#loadedImages" ).accordion( { heightStyle: "content", active: 0, collapsible: true } ).show();
	},

	/**
	 *	Remove UI and unregister all the events
	 */
	remove: function()
	{
		mizar.unsubscribe("image:add", this.addView );
		mizar.unsubscribe("image:remove", this.removeView);
		mizar.unsubscribe("image:download", this.addProgressBar);
		mizar.unsubscribe("layer:remove", this.removeLayer);
		$imageViewer.remove();
		sky = null;
		navigation = null;
	},

	/**
	 *	Add progress bar
	 *
	 *	@param data
	 *		Contains feature data(layer, feature) and its XMLHttpRequest
	 */
	addProgressBar: function(featureData)
	{
		var id = "imageView_" + Utils.formatId(featureData.feature.properties.identifier) + "_fits";
		var progressBar = new SimpleProgressBar( { id: id } );
		featureData.xhr.onprogress = progressBar.onprogress.bind(progressBar);
	},

	/**
	 *	Add view for the given feature
	 * 
	 *	@returns jQuery element of view
	 */
	addView: function(selectedData)
	{	
		showImageViewer();

		// Get or create layer view
		var $layer;
		var layer = selectedData.layer;
		if ( layers.indexOf(selectedData.layer) < 0 )
		{
			$layer = createLayerView(selectedData.layer)
		}
		else
		{
			$layer = $imageViewer.find('.imageLayers div[id="imageLayer_'+layer.id+'"]');
		}

		var feature = selectedData.feature;
		// Remove special caracters from feature id
		var id = Utils.formatId(selectedData.feature.properties.identifier);
		// Add isFits property for correct progress bar handling
		if ( selectedData.isFits )
		{
			id+="_fits";
		}

		var name = selectedData.feature.properties.identifier;
		var $li;
		var $metadataDialog;

		if ( $layer.find('ul li[id="'+id+'"]').length == 0 )
		{
			// Create only if not already added
			var imageViewerItemContent = imageViewerImageItemTemplate( { id: id, name: name, isFits: selectedData.isFits });
			$li = $(imageViewerItemContent)
				.appendTo($layer.find('ul'))
				// ZoomTo
				.find('.zoomTo').button({
					text: false,
					icons: {
						primary: "ui-icon-zoomin"
					}
				}).click(function(){

					var barycenter = Utils.computeGeometryBarycenter( feature.geometry );
					navigation.zoomTo([barycenter[0], barycenter[1]], 0.1, 2000, function(){
						// Update selection
						PickingManager.focusFeature(selectedData);
					});

				}).end()
				// Image visibility
				.find('input').button({
					text: false,
					icons: {
			        	primary: "ui-icon-check"
			      	}
				}).click(function(){

					$(this).button("option", {
						icons: {
							primary: $(this)[0].checked ? "ui-icon-check" : ""
						}
					});
					if ( $(this).is(':checked') )
					{
						ImageManager.showImage(selectedData);
					}
					else
					{
						ImageManager.hideImage(selectedData);
					}
					sky.renderContext.requestFrame();
				}).end()
				// Delete fits
				.find('.delete').button({
					text: false,
					icons: {
						primary: "ui-icon-trash"
					}
				}).click(function(){
					// Remove image
					ImageManager.removeImage(selectedData, selectedData.isFits);
					if ( selectedData.isFits )
						ImageProcessing.removeData(selectedData);
					sky.renderContext.requestFrame();
				}).end()
				// Image processing
				.find('.imageProcessing').button({
					text: false,
					icons: {
						primary: "ui-icon-image"
					}
				}).click(function(){
					ImageProcessing.setData(selectedData);
				}).end()
				.find('.metadata').button({
					text: false,
					icons: {
						primary: "ui-icon-info"
					}
				}).click(function(){

					// Create metadata dialog if doesn't exist
					if ( !$metadataDialog )
					{
						// TODO : refactor this circular dependency...
						var featurePopup = require("FeaturePopup");
						var output = featurePopup.generateFeatureMetadata( selectedData.layer, selectedData.feature );
						$metadataDialog = $('<div>'+output+'</div>').dialog({
							autoOpen: true,
							show: {
								effect: "fade",
								duration: 300
							},
							hide: {
								effect: "fade",
								duration: 300
							},
							title: "Metadata",
							width: 350,
							resizable: false,
							zIndex: 12,
							stack: false,
							close: function(){
								$(this).find('.featureProperties').getNiceScroll().remove();
								$(this).dialog("destroy").remove();
								$metadataDialog = null;
							},
							drag: function()
							{
								$(this).find('.featureProperties').getNiceScroll().resize();
							}
						});
						$metadataDialog.find('.featureProperties').niceScroll({
							autohidemode: false
						});
					}
					else
					{
						if ( $metadataDialog.dialog( "isOpen" ) )
						{
							$metadataDialog.dialog("close");
						}
					}
				}).end()
				.find('.sampExport').button({
					text: false,
					icons: {
						primary: "ui-icon-extlink"
					}
				}).click(function(){
					if ( Samp.isConnected() )
					{
						Samp.sendImage(feature.services.download.url);
					}
					else
					{
						ErrorDialog.open("You must be connected to SAMP Hub");
					}
				}).end()
				.fadeIn();
			
			$li.find('label.imageName').click(function(){
				$(this).siblings('.options').slideToggle();
			});

			// Disable image processing button for not fits images
			if ( !selectedData.isFits )
			{
				$li.find('.imageProcessing').button("disable");
			}

			featuresWithImages.push(selectedData);

			return $li;
		}
	},

	/**
	 *	Remove view of the given feature
	 */
	removeView: function(selectedData)
	{
		var id = "imageView_" + Utils.formatId(selectedData.feature.properties.identifier);
		if ( selectedData.isFits )
		{
			id+="_fits";
		}

		$imageViewer.find('#loadedImages').find('li.image[id="'+id+'"]').fadeOut(function(){

			// No more loaded image views for current layer
			if ( $(this).siblings().length == 0 )
			{
				// Remove layer view
				$imageViewer.find('.imageLayers div[id="imageLayer_'+selectedData.layer.id+'"]').fadeOut(300, function(){
					// Remove layer view
					$(this).remove();

					// Show "No image was loaded"
					if ( layers.length == 0 )
						$imageViewer.find('#loadedImages p').fadeIn();
				});

				var index = layers.indexOf(selectedData.layer);
				layers.splice(index, 1);
			}

			$(this).remove();
		})

		var featureIndex = featuresWithImages.indexOf(selectedData);
		featuresWithImages.splice(featureIndex, 1);
	},

	/**
	 *	Remove all image views of the given layer
	 */
	 removeLayer: function(layer)
	 {
	 	var $layer = $imageViewer.find('.imageLayers div[id="imageLayer_'+layer.id+'"]');
	 	$layer.find('ul li').each(function(){
	 		$(this).find('.delete').trigger("click");
	 	});
	 },

	getFeatures: function()
	{
		return featuresWithImages;
	}
}

});
/******************************************************************************* 
* Copyright 2012, 2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES 
* 
* This file is part of SITools2. 
* 
* SITools2 is free software: you can redistribute it and/or modify 
* it under the terms of the GNU General Public License as published by 
* the Free Software Foundation, either version 3 of the License, or 
* (at your option) any later version. 
* 
* SITools2 is distributed in the hope that it will be useful, 
* but WITHOUT ANY WARRANTY; without even the implied warranty of 
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
* GNU General Public License for more details. 
* 
* You should have received a copy of the GNU General Public License 
* along with SITools2. If not, see <http://www.gnu.org/licenses/>. 
******************************************************************************/ 

/**
 * Position tracker : show mouse position formated in default coordinate system
 */
define('PositionTracker',["gw/CoordinateSystem", "./Utils"],
	function(CoordinateSystem, Utils) {

var globe;
var navigation;
var element;

function updatePosition(event)
{
	if ( event.type.search("touch") >= 0 )
	{
		event.clientX = event.changedTouches[0].clientX;
		event.clientY = event.changedTouches[0].clientY;
	}

	var geoPos = globe.getLonLatFromPixel( event.clientX, event.clientY );
	var astro = Utils.formatCoordinates([ geoPos[0], geoPos[1] ]);
	document.getElementById(element).innerHTML = astro[0] + " x " + astro[1];
}

return {
	init: function(options)
	{
		globe = options.globe;
		navigation = options.navigation;
		element = options.element;

		globe.renderContext.canvas.addEventListener('mousemove', updatePosition);
		if ( options.isMobile )
		{
			globe.renderContext.canvas.addEventListener('touchmove', updatePosition);
		}
	}
}

});

/******************************************************************************* 
* Copyright 2012, 2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES 
* 
* This file is part of SITools2. 
* 
* SITools2 is free software: you can redistribute it and/or modify 
* it under the terms of the GNU General Public License as published by 
* the Free Software Foundation, either version 3 of the License, or 
* (at your option) any later version. 
* 
* SITools2 is distributed in the hope that it will be useful, 
* but WITHOUT ANY WARRANTY; without even the implied warranty of 
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
* GNU General Public License for more details. 
* 
* You should have received a copy of the GNU General Public License 
* along with SITools2. If not, see <http://www.gnu.org/licenses/>. 
******************************************************************************/ 

/**
 * Tool designed to measure the distance between two points
 */

define('MeasureTool', [ "jquery", "gw/VectorLayer", "gw/Numeric", "gw/CoordinateSystem", "gw/FeatureStyle", "gw/glMatrix", "jquery.ui" ],
		function($, VectorLayer, Numeric, CoordinateSystem, FeatureStyle){

/**
 *	@constructor
 *	@param options Configuration options
 *		<ul>
 *			<li>globe: Globe</li>
 *			<li>navigation: Navigation</li>
 *			<li>onselect: On select callback</li>
 *		</ul>
 */
var MeasureTool = function(options)
{
	// Required options
	var globe = options.globe;
	var navigation = options.navigation;
	var onselect = options.onselect;

	this.activated = false;
	this.renderContext = globe.renderContext;

	// Layer containing measure feature
	this.measureLayer = new VectorLayer();
	globe.addLayer(this.measureLayer);
	
	this.measureFeature = null;

	// Measure attributes
	this.distance;
	this.pickPoint; // Window pick point
	this.secondPickPoint; // Window second pick point
	this.geoDistance;
	this.geoPickPoint; // Pick point in geographic reference
	this.secondGeoPickPoint; // Pick point in geographic reference

	this.measureLabel;

	var self = this;
	var dragging = false;
	
	var _handleMouseDown = function(event)
	{
		event.preventDefault();
		if ( !self.activated )
			return;

		self.distance = 0.;
		// Desactivate standard navigation events
		navigation.stop();

		dragging = true;

		if ( event.type.search("touch") >= 0 )
		{
			self.pickPoint = [ event.changedTouches[0].clientX, event.changedTouches[0].clientY ];
		}
		else
		{
			self.pickPoint = [ event.clientX, event.clientY ];
		}

		self.geoPickPoint = globe.getLonLatFromPixel(self.pickPoint[0], self.pickPoint[1]);
	}

	var _handleMouseUp = function(event)
	{
		event.preventDefault();
		if ( !self.activated )
			return;

		// Compute geo radius
		var stopPickPoint;
		if ( event.type.search("touch") >= 0 )
		{
			stopPickPoint = globe.getLonLatFromPixel( event.changedTouches[0].clientX, event.changedTouches[0].clientY );
		}
		else
		{

			var stopPickPoint = globe.getLonLatFromPixel(event.clientX, event.clientY);
		}


		// Find angle between start and stop vectors which is in fact the radius
		var dotProduct = vec3.dot( CoordinateSystem.fromGeoTo3D(stopPickPoint), CoordinateSystem.fromGeoTo3D(self.geoPickPoint) );
		var theta = Math.acos(dotProduct);
		self.geoDistance = Numeric.toDegree(theta);

		if ( onselect )
		{
			onselect();
		}

		// Reactivate standard navigation events
		navigation.start();
		dragging = false;
	}

	var _handleMouseMove = function(event)
	{
		event.preventDefault();
		if ( !self.activated || !dragging )
			return;

		if ( event.type.search("touch") >= 0 )
		{
			self.secondPickPoint = [ event.changedTouches[0].clientX, event.changedTouches[0].clientY ];
		}
		else
		{
			self.secondPickPoint = [ event.clientX, event.clientY ];
		}

		self.secondGeoPickPoint = globe.getLonLatFromPixel(self.secondPickPoint[0], self.secondPickPoint[1]);
		// Update radius
		self.distance = Math.sqrt( Math.pow(self.secondPickPoint[0] - self.pickPoint[0], 2) + Math.pow(self.secondPickPoint[1] - self.pickPoint[1], 2) );
		var dotProduct = vec3.dot( CoordinateSystem.fromGeoTo3D(self.secondGeoPickPoint), CoordinateSystem.fromGeoTo3D(self.geoPickPoint) );
		var theta = Math.acos(dotProduct);
		self.geoDistance = Numeric.toDegree(theta);

		self.updateMeasure();
	}

	this.renderContext.canvas.addEventListener("mousedown", $.proxy(_handleMouseDown, this));
	this.renderContext.canvas.addEventListener("mousemove", $.proxy(_handleMouseMove, this));
	this.renderContext.canvas.addEventListener("mouseup", $.proxy(_handleMouseUp, this));

	if ( options.isMobile )
	{
		this.renderContext.canvas.addEventListener("touchend", $.proxy(_handleMouseUp, this));
		this.renderContext.canvas.addEventListener("touchmove", $.proxy(_handleMouseMove, this));
		this.renderContext.canvas.addEventListener("touchstart", $.proxy(_handleMouseDown, this));
	}
	$('#measureInvoker').on('click', function(){
		self.toggle();
	}).hover(function(){
		$(this).animate({left: '-10px'}, 100);
	}, function() {
		$(this).animate({left: '-20px'}, 100);
	});
}

/**********************************************************************************************/

MeasureTool.prototype.computeIntersection = function(points)
{
	var rc = this.renderContext;
	var tmpMat = mat4.create();
	
	// Compute eye in world space
	mat4.inverse(rc.viewMatrix, tmpMat);
	var eye = [tmpMat[12], tmpMat[13], tmpMat[14]];
	
	// Compute the inverse of view/proj matrix
	mat4.multiply(rc.projectionMatrix, rc.viewMatrix, tmpMat);
	mat4.inverse(tmpMat);

	// Transform the four corners of measure shape into world space
	// and then for each corner compute the intersection of ray starting from the eye with the sphere
	var tmpPt = vec3.create();
	var worldCenter = [ 0, 0, 0 ];
	for ( var i = 0; i < points.length; i++ )
	{
		mat4.multiplyVec4( tmpMat, points[i] );
		vec3.scale( points[i], 1.0 / points[i][3] );
		vec3.subtract(points[i], eye, points[i]);
		vec3.normalize( points[i] );
		
		var t = Numeric.raySphereIntersection( eye, points[i], worldCenter, CoordinateSystem.radius);
		if ( t < 0.0 )
			return null;

		points[i] = CoordinateSystem.from3DToGeo( Numeric.pointOnRay(eye, points[i], t, tmpPt) );
	}

	return points;
}

/**********************************************************************************************/

function rotateVector2D(vec, theta)
{
	theta = theta * Math.PI/ 180;
	var cs = Math.cos(theta);
	var sn = Math.sin(theta);

	return [ vec[0] * cs - vec[1]*sn, vec[0] * sn + vec[1]*cs ];
}

function normalize2D(vec, dest)
{
	if ( !dest )
	{
		dest = vec;
	}

	var length = Math.sqrt( vec[0]*vec[0] + vec[1]*vec[1] );
	dest[0] = vec[0]/length;
	dest[1] = vec[1]/length;
	return dest;
}

/**********************************************************************************************/

/**
 *	Compute measure for the given pick point depending on second point
 */
MeasureTool.prototype.computeMeasure = function()
{
	var rc = this.renderContext;
	// Scale to [-1,1]
	var widthScale = 2/rc.canvas.width;
	var heightScale = 2/rc.canvas.height;

	var diff = [this.secondPickPoint[0] - this.pickPoint[0], this.secondPickPoint[1] - this.pickPoint[1]];
	normalize2D(diff);

	// First arrow
	var arrow = rotateVector2D(diff, 30);
	var arrow2 = rotateVector2D(diff, -30);
	arrow = [ this.pickPoint[0] + 10*arrow[0], this.pickPoint[1] + 10*arrow[1] ];
	arrow2 = [ this.pickPoint[0] + 10*arrow2[0], this.pickPoint[1] + 10*arrow2[1] ];

	var diff2 = [-diff[0], -diff[1]];
	var arrow3 = rotateVector2D(diff2, 30);
	var arrow4 = rotateVector2D(diff2, -30);
	arrow3 = [ this.secondPickPoint[0] + 10*arrow3[0], this.secondPickPoint[1] + 10*arrow3[1] ];
	arrow4 = [ this.secondPickPoint[0] + 10*arrow4[0], this.secondPickPoint[1] + 10*arrow4[1] ];

	var points = [
		[ this.pickPoint[0]*widthScale-1., (rc.canvas.height-this.pickPoint[1])*heightScale-1., 1, 1 ],
		[ arrow[0]*widthScale-1., (rc.canvas.height-arrow[1])*heightScale-1., 1, 1 ],
		[ this.pickPoint[0]*widthScale-1., (rc.canvas.height-this.pickPoint[1])*heightScale-1., 1, 1 ],
		[ arrow2[0]*widthScale-1., (rc.canvas.height-arrow2[1])*heightScale-1., 1, 1 ],
		[ this.pickPoint[0]*widthScale-1., (rc.canvas.height-this.pickPoint[1])*heightScale-1., 1, 1 ],
		[ this.secondPickPoint[0]*widthScale-1., (rc.canvas.height-this.secondPickPoint[1])*heightScale-1., 1, 1 ],
		[ arrow3[0]*widthScale-1., (rc.canvas.height-arrow3[1])*heightScale-1., 1, 1 ],
		[ this.secondPickPoint[0]*widthScale-1., (rc.canvas.height-this.secondPickPoint[1])*heightScale-1., 1, 1 ],
		[ arrow4[0]*widthScale-1., (rc.canvas.height-arrow4[1])*heightScale-1., 1, 1 ],
		[ this.secondPickPoint[0]*widthScale-1., (rc.canvas.height-this.secondPickPoint[1])*heightScale-1., 1, 1 ]
	];

	this.computeIntersection(points);
	return points;
}

/**************************************************************************************************************/

/**
 *	Update measure coordinates
 */
MeasureTool.prototype.updateMeasure = function()
{
	if ( this.measureFeature )
	{
		this.measureLayer.removeFeature(this.measureFeature);
	}

	if ( this.measureLabel )
	{
		this.measureLayer.removeFeature(this.measureLabel);
	}

	var coordinates = this.computeMeasure();
	// Close the polygon
	coordinates.push(coordinates[0]);

	this.measureFeature = {
		"geometry": {
			"gid": "measureShape",
			"coordinates": [coordinates],
			"type": "Polygon",
		},
		"properties": {
			"style": new FeatureStyle({
				zIndex: 2,
				fillColor: [1.,0.,0.,1.]
			})
		},
		"type": "Feature"
	};

	var center = [ (this.secondPickPoint[0] + this.pickPoint[0])/2, (this.secondPickPoint[1] + this.pickPoint[1])/2 ];
	var center3d = this.renderContext.get3DFromPixel(center[0],center[1]);
	var geoCenter = CoordinateSystem.from3DToGeo(center3d);
	this.measureLabel = {
		geometry: {
			type: "Point",
			gid: "measureShape",
			coordinates: geoCenter
		},
		properties: {
			style: new FeatureStyle({
				label: CoordinateSystem.fromDegreesToDMS(this.geoDistance),
				fillColor: [1.,1.,1.,1.],
				zIndex: 2
			})
		}
	};
	
	this.measureLayer.addFeature( this.measureFeature );
	this.measureLayer.addFeature( this.measureLabel );
}

/**************************************************************************************************************/

/**
 *	Activate/desactivate the tool
 */
MeasureTool.prototype.toggle = function()
{
	this.activated = !this.activated;
	if ( this.activated )
	{
		$('#measureInvoker').css('background-image', 'url(css/images/measure_on.png)');
		// TODO : Find more sexy image for cursor
		$(this.renderContext.canvas).css('cursor', 'url(css/images/selectionCursor.png)');
	}
	else
	{
		$('#measureInvoker').css('background-image', 'url(css/images/measure_off.png)');
		$(this.renderContext.canvas).css('cursor', 'default');
	}
}

/**************************************************************************************************************/

/**
 *	Clear measure
 */
MeasureTool.prototype.clear = function()
{
	if ( this.measureFeature )
		this.measureLayer.removeFeature(this.measureFeature);

	this.pickPoint = null;
	this.geoPickPoint = null;
}

/**************************************************************************************************************/

return MeasureTool;

});

/******************************************************************************* 
* Copyright 2012, 2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES 
* 
* This file is part of SITools2. 
* 
* SITools2 is free software: you can redistribute it and/or modify 
* it under the terms of the GNU General Public License as published by 
* the Free Software Foundation, either version 3 of the License, or 
* (at your option) any later version. 
* 
* SITools2 is distributed in the hope that it will be useful, 
* but WITHOUT ANY WARRANTY; without even the implied warranty of 
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
* GNU General Public License for more details. 
* 
* You should have received a copy of the GNU General Public License 
* along with SITools2. If not, see <http://www.gnu.org/licenses/>. 
******************************************************************************/ 

/**
 * 	StarProvider module
 *
 *	Specific star catalogue provider of the Brightest Stars (Ochsenbein+ 1988) from VizieR database
 * 	@see Search Catalogue of the Brightest Stars (Ochsenbein+ 1988) in VizieR database for more details
 */
define('StarProvider', [ "jquery", "gw/CoordinateSystem", "gw/FeatureStyle", "./LayerManager" ],
	function($, CoordinateSystem, FeatureStyle, LayerManager) {

/**************************************************************************************************************/

var namesFile;
var catalogueFile;

/**
*	Asynchronous requests to load star database
*
* 	@param configuration Configuration options
* 		<ul>
*			<li>nameUrl : Url providing the stars name data(necessary option)</li>
*			<li>catalogueUrl : Url providing all information about each star(necessary option)</li>
*		</ul>
*/
function loadFiles(gwLayer, configuration)
{
	if ( configuration.nameUrl && configuration.catalogueUrl )
	{
		var nameRequest = {
			type: "GET",
			url: configuration.nameUrl,
			success: function(response){
				namesFile = response;
			},
			error: function (xhr, ajaxOptions, thrownError) {
				console.error( xhr.responseText );
			}
		};
		
		var catalogueRequest = {
			type: "GET",
			url: configuration.catalogueUrl,
			success: function(response){
			       catalogueFile = response;
			},
			error: function (xhr, ajaxOptions, thrownError) {
				console.error( xhr.responseText );
			}
		};
		
		// Synchronizing two asynchronious requests with the same callback
		var self = this;
		$.when($.ajax(nameRequest), $.ajax(catalogueRequest))
			.then(function(){ handleFeatures(gwLayer); },failure);
	}
	else
	{
		console.error("Not valid options");
		return null;
	}
}

/**************************************************************************************************************/

/**
 * 	Handle features on layer
 */
function handleFeatures(gwLayer)
{
	// Extract the table data
	var tmpTab = namesFile.slice(namesFile.indexOf("897;Acamar"), namesFile.indexOf('1231;Zaurak')+11);
	var namesTab = tmpTab.split("\n");
	tmpTab = catalogueFile.slice(catalogueFile.indexOf("001."), catalogueFile.indexOf("4.98;K3Ibv")+10);
	var catalogueTab = tmpTab.split("\n");
	var pois = [];
	
	// For each known star
	for ( var i=0; i<namesTab.length; i++ )
	{
		var word = namesTab[i].split(";"); // word[0] = HR, word[1] = name;
		var HR = parseInt(word[0]);
		var starName = word[1];
			
		// Search corresponding HR in catalogue
		for ( var j=0; j<catalogueTab.length; j++ )
		{
			word = catalogueTab[j].split(";");
			if (parseInt(word[2]) == HR){
				// Star found in the catalogue
				
				var raString = word[6];   // right ascension format : "hours minutes seconds"
				var declString = word[7]; // declinaton format : "degrees minutes seconds"
				
				var geo = [];
				CoordinateSystem.fromEquatorialToGeo([raString, declString], geo);
				
				// Add poi layer
				var poi = {
					geometry: {
						type: "Point",
						gid: "star_"+starName,
						coordinates: [geo[0],geo[1]]
					},
					properties: {
						name: starName,
						style: new FeatureStyle({ label: starName, fillColor: [1.,1.,1.,1.] })
					}
				};
				pois.push(poi);
			}
		}
	}
	
	// Create feature collection
	var poiFeatureCollection = {
		type: "FeatureCollection",
		features : pois
	};
	
	gwLayer.addFeatureCollection(poiFeatureCollection);
}

/*
 * 	Failure function
 */
function failure()
{
	console.error( "Failed to load files" );
}

/**************************************************************************************************************/

// Register the data provider
LayerManager.registerDataProvider("star", loadFiles);

});
/******************************************************************************* 
* Copyright 2012, 2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES 
* 
* This file is part of SITools2. 
* 
* SITools2 is free software: you can redistribute it and/or modify 
* it under the terms of the GNU General Public License as published by 
* the Free Software Foundation, either version 3 of the License, or 
* (at your option) any later version. 
* 
* SITools2 is distributed in the hope that it will be useful, 
* but WITHOUT ANY WARRANTY; without even the implied warranty of 
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
* GNU General Public License for more details. 
* 
* You should have received a copy of the GNU General Public License 
* along with SITools2. If not, see <http://www.gnu.org/licenses/>. 
******************************************************************************/ 

/**
 * ConstellationProvider module
 *
 * Specific constellation catalogue provider from VizieR database
 * @see http://vizier.cfa.harvard.edu/viz-bin/ftp-index?VI/49
 *
 */
define('ConstellationProvider', [ "jquery", "./LayerManager", "gw/CoordinateSystem", "gw/FeatureStyle" ], function($, LayerManager, CoordinateSystem, FeatureStyle) {

/**************************************************************************************************************/

var namesFile;
var catalogueFile;

var constellations = {};

/**
*	Asynchronous request to load constellation data 
*
* 	@param configuration Configuration options
* 		<ul>
*			<li>nameUrl : Url providing the constellations name data(necessary option)</li>
*			<li>catalogueUrl : Url providing all information about each constellation(necessary option)</li>
*		</ul>
*	@see http://vizier.cfa.harvard.edu/viz-bin/ftp-index?VI/49
*/
function loadFiles( gwLayer, configuration )
{
	if ( configuration.nameUrl && configuration.catalogueUrl )
	{
		// loadFiles( configuration.nameUrl, configuration.catalogueUrl );
		var nameRequest = {
			type: "GET",
			url: configuration.nameUrl,
			success: function(response){
				namesFile = response;
			},
			error: function (xhr, ajaxOptions, thrownError) {
				console.error( xhr.responseText );
			}
		};
		
		var catalogueRequest = {
			type: "GET",
			url: configuration.catalogueUrl,
			success: function(response){
		       catalogueFile = response;
			},
			error: function (xhr, ajaxOptions, thrownError) {
				console.error( xhr.responseText );
			}
		};
	
		var self = this;
		// Synchronizing two asynchronious requests with the same callback
		$.when($.ajax(nameRequest), $.ajax(catalogueRequest))
			.then( function() { extractDatabase(); handleFeatures(gwLayer); },failure);
	}
	else
	{
		console.error("Not valid options");
		return false;
	}
}

/**************************************************************************************************************/

/**
*	Extract information in "constellation" variables
*/
function extractDatabase()
{
	var constellationNamesTab = namesFile.split("\n");
	var catalogueTab = catalogueFile.split("\n");
	
	// For each constellation point
	for ( var i=0; i<catalogueTab.length; i++ )
	{
		var word = catalogueTab[i].replace("  ", " ");
		word = word.split(" "); // word = "RA Decl Abbreviation "I"/"O"(Inerpolated/Original(Corner))"
		var RA = parseFloat(word[0]);
		var Decl = parseFloat(word[1]);
		var currentAbb = word[2];
		var IO = word[3];
		
		// Convert hours to degrees
		RA*=15;
		
		// If abbreviation doesn't exist
		if ( !constellations[ currentAbb ] ){
			// Find constellation name
			for( j=0; j<constellationNamesTab.length; j++ ){
				var word = constellationNamesTab[j].split(";"); // word[0] = abbreviation, word[1] = name;
				var abb = word[0];
				
				if( abb == currentAbb ){
					var name = word[1];
					
					// Add new constellation as a property
					constellations[ currentAbb ] = {
						coord : [],
						name : name,
						
						// Values used to calculate the position of the center of constellation
						x : 0.,
						y : 0.,
						z : 0.,
						nbStars : 0
					}
					break;
				}
			}
		}
		
		// Convert to default coordinate system
		var posGeo = [RA, Decl];

		// Calculate the center of constillation
		var pos3d = [];
		// Need to convert to 3D because of 0h -> 24h notation
		CoordinateSystem.fromGeoTo3D(posGeo, pos3d);
		constellations[ currentAbb ].x+=pos3d[0];
		constellations[ currentAbb ].y+=pos3d[1];
		constellations[ currentAbb ].z+=pos3d[2];
		constellations[ currentAbb ].nbStars++;

		constellations[ currentAbb ].coord.push(posGeo);
	}
}

/**************************************************************************************************************/

/**
* 	Create geoJson features
*/
function handleFeatures(gwLayer)
{
	
	var constellationNamesFeatures = [];
	var constellationShapesFeatures = [];
	
	// Fill constellationShapes & constellationNames
	for ( var i in constellations)
	{
		var current = constellations[i];
		
		// Close the polygon
		current.coord.push( current.coord[0] );
		
		var constellationShape = {
			geometry: {
				type: "Polygon",
				gid: "constellationShape_"+current.name,
				coordinates: [current.coord]
			},
			properties: {
				name: current.name,
			}
		};
		
		constellationShapesFeatures.push( constellationShape );
			
		// Compute mean value to show the constellation name in the center of constellation..
		// .. sometimes out of constellation's perimeter because of the awkward constellation's shape(ex. "Hydra" or "Draco" constellations)
		var geoPos = [];
		CoordinateSystem.from3DToGeo([current.x/current.nbStars, current.y/current.nbStars, current.z/current.nbStars], geoPos);
		
		var constellationName = {
			geometry: {
				type: "Point",
				gid: "constellationName_"+current.name,
				coordinates: [geoPos[0], geoPos[1]]
			},
			properties: {
				name: current.name,
				style: new FeatureStyle({ textColor: '#083BA8', fillColor: [1.,1.,1.,1.], label: current.name })
			}
		};
		constellationNamesFeatures.push( constellationName );
	}
	
	// Create feature collections
	var constellationShapesFeatureCollection = {
		type: "FeatureCollection",
		features : constellationShapesFeatures
	};
	var constellationNameFeatureCollection = {
		type: "FeatureCollection",
		features : constellationNamesFeatures
	};
	
	// Add shapes&names to the layer
	gwLayer.addFeatureCollection( constellationShapesFeatureCollection );
	gwLayer.addFeatureCollection( constellationNameFeatureCollection );
}

/**************************************************************************************************************/

/*
 * 	Failure function
 */
function failure(){
	console.error( "Failed to load files" );
}

/**************************************************************************************************************/

// Register the data provider
LayerManager.registerDataProvider("constellation", loadFiles);

});
/******************************************************************************* 
* Copyright 2012, 2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES 
* 
* This file is part of SITools2. 
* 
* SITools2 is free software: you can redistribute it and/or modify 
* it under the terms of the GNU General Public License as published by 
* the Free Software Foundation, either version 3 of the License, or 
* (at your option) any later version. 
* 
* SITools2 is distributed in the hope that it will be useful, 
* but WITHOUT ANY WARRANTY; without even the implied warranty of 
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
* GNU General Public License for more details. 
* 
* You should have received a copy of the GNU General Public License 
* along with SITools2. If not, see <http://www.gnu.org/licenses/>. 
******************************************************************************/ 

/**
 * 	JSON provider module
 *
 *	Module providing JSON file in GeoJSON format from equatorial
 *
 */
define('JsonProvider', [ "jquery", "./LayerManager", "./JsonProcessor" ], function($, LayerManager, JsonProcessor) {

/**
 * 	Load JSON file, transform it in GeoJSON format and add to the layer
 *
 *	@param gwLayer GlobWeb layer
 *	@param url Url to JSON containing feature collection in equatorial coordinates
 *
 */
function handleJSONFeature( gwLayer, configuration )
{
	$.ajax({
		type: "GET",
		url: configuration.url,
		success: function(response){
			JsonProcessor.handleFeatureCollection( gwLayer, response );
			gwLayer.addFeatureCollection( response );
		},
		error: function (xhr, ajaxOptions, thrownError) {
			console.error( xhr.responseText );
		}
	});
}

/***************************************************************************************************/

// Register the data provider
LayerManager.registerDataProvider("JSON", handleJSONFeature);

});
/******************************************************************************* 
* Copyright 2012, 2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES 
* 
* This file is part of SITools2. 
* 
* SITools2 is free software: you can redistribute it and/or modify 
* it under the terms of the GNU General Public License as published by 
* the Free Software Foundation, either version 3 of the License, or 
* (at your option) any later version. 
* 
* SITools2 is distributed in the hope that it will be useful, 
* but WITHOUT ANY WARRANTY; without even the implied warranty of 
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
* GNU General Public License for more details. 
* 
* You should have received a copy of the GNU General Public License 
* along with SITools2. If not, see <http://www.gnu.org/licenses/>. 
******************************************************************************/ 

/**
 * 	OpenSearch provider module
 *
 *	Module providing JSON file in GeoJSON format from OpenSearch response
 */
define('OpenSearchProvider', [ "jquery", "./LayerManager", "./JsonProcessor"], function($, LayerManager, JsonProcessor ) {

/**
 * 	Load JSON file, transform it in GeoJSON format and add to the layer
 *
 *	@param gwLayer GlobWeb layer
 *	@param url Url to JSON containing feature collection in equatorial coordinates
 */
function handleJSONFeatureFromOpenSearch( gwLayer, configuration, startIndex )
{
	$.ajax({
		type: "GET",
		url: configuration.url + "startIndex=" + startIndex + "&count=500",
		success: function(response){
			JsonProcessor.handleFeatureCollection( gwLayer, response );
			gwLayer.addFeatureCollection( response );
			if ( startIndex + response.features.length < response.totalResults ) {
				handleJSONFeatureFromOpenSearch( gwLayer, configuration.url, startIndex + response.features.length );
			}
		},
		error: function (xhr, ajaxOptions, thrownError) {
			console.error( xhr.responseText );
		}
	});
}

/***************************************************************************************************/

// Register the data provider
LayerManager.registerDataProvider("OpenSearch", function(gwLayer, configuration) {
	handleJSONFeatureFromOpenSearch( gwLayer, configuration, 1 );
});

});
/******************************************************************************* 
* Code taken from "Virtual Sky" project
*        (c) Stuart Lowe, Las Cumbres Observatory Global Telescope
*
* Copyright 2012, 2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES 
*
* This file is part of SITools2. 
* 
* SITools2 is free software: you can redistribute it and/or modify 
* it under the terms of the GNU General Public License as published by 
* the Free Software Foundation, either version 3 of the License, or 
* (at your option) any later version. 
* 
* SITools2 is distributed in the hope that it will be useful, 
* but WITHOUT ANY WARRANTY; without even the implied warranty of 
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
* GNU General Public License for more details. 
* 
* You should have received a copy of the GNU General Public License 
* along with SITools2. If not, see <http://www.gnu.org/licenses/>. 
******************************************************************************/ 

/**
 * 	Planet provider module
 *
 *	Providing planet positions based on ephemeris computations
 * 	@see https://github.com/slowe/VirtualSky/blob/master/virtualsky.js
 */
define('PlanetProvider', [ "jquery", "gw/FeatureStyle", "./LayerManager" ],
	function($, FeatureStyle, LayerManager) {

/**************************************************************************************************************/

var poiFeatureCollection;

var getJD = function(today) {
        // The Julian Date of the Unix Time epoch is 2440587.5
        if(!today) today = new Date();
        return ( (today.getTime() + today.getTimezoneOffset() * 60000) / 86400000.0 ) + 2440587.5;
}

// TODO: update ephemeris data...
var data = {
        "planets" : [
        	["Mercury","rgb(170,150,170)",[2456474.5,113.62579,18.47100,3.23,2456475.0,113.42810,18.37483,3.37,2456475.5,113.21445,18.28334,3.51,2456476.0,112.98555,18.19668,3.67,2456476.5,112.74219,18.11498,3.82,2456477.0,112.48519,18.03835,3.98,2456477.5,112.21546,17.96692,4.14,2456478.0,111.93396,17.90078,4.31,2456478.5,111.64170,17.84003,4.47,2456479.0,111.33977,17.78476,4.64,2456479.5,111.02929,17.73503,4.80,2456480.0,110.71144,17.69090,4.96,2456480.5,110.38744,17.65243,5.11,2456481.0,110.05858,17.61965,5.25,2456481.5,109.72614,17.59258,5.37,2456482.0,109.39146,17.57125,5.46,2456482.5,109.05591,17.55563,5.52,2456483.0,108.72085,17.54573,5.54,2456483.5,108.38768,17.54151,5.52,2456484.0,108.05779,17.54293,5.47,2456484.5,107.73256,17.54994,5.37,2456485.0,107.41338,17.56248,5.25,2456485.5,107.10161,17.58045,5.11,2456486.0,106.79859,17.60377,4.95,2456486.5,106.50564,17.63234,4.77,2456487.0,106.22404,17.66603,4.60,2456487.5,105.95502,17.70471,4.41,2456488.0,105.69980,17.74824,4.23,2456488.5,105.45951,17.79647,4.04,2456489.0,105.23525,17.84924,3.86,2456489.5,105.02808,17.90636,3.68,2456490.0,104.83898,17.96764,3.50,2456490.5,104.66889,18.03290,3.32,2456491.0,104.51866,18.10192,3.15,2456491.5,104.38913,18.17448,2.98,2456492.0,104.28104,18.25036,2.81,2456492.5,104.19509,18.32933,2.66,2456493.0,104.13191,18.41114,2.50,2456493.5,104.09208,18.49553,2.35,2456494.0,104.07613,18.58224,2.20,2456494.5,104.08453,18.67102,2.06,2456495.0,104.11770,18.76157,1.92,2456495.5,104.17601,18.85361,1.79,2456496.0,104.25977,18.94686,1.66,2456496.5,104.36927,19.04101,1.53,2456497.0,104.50474,19.13575,1.41,2456497.5,104.66637,19.23078,1.29,2456498.0,104.85433,19.32577,1.18,2456498.5,105.06872,19.42040,1.07,2456499.0,105.30964,19.51434,0.96,2456499.5,105.57713,19.60724,0.86,2456500.0,105.87122,19.69877,0.76,2456500.5,106.19189,19.78857,0.66,2456501.0,106.53910,19.87629,0.57,2456501.5,106.91279,19.96156,0.48,2456502.0,107.31286,20.04402,0.39,2456502.5,107.73918,20.12330,0.31,2456503.0,108.19161,20.19902,0.23,2456503.5,108.66996,20.27080,0.15,2456504.0,109.17404,20.33826,0.07,2456504.5,109.70360,20.40100,0.07,2456505.0,110.25838,20.45865,-0.07,2456505.5,110.83809,20.51081,-0.14,2456506.0,111.44240,20.55708,-0.21,2456506.5,112.07095,20.59709,-0.27,2456507.0,112.72336,20.63043,-0.33,2456507.5,113.39919,20.65673,-0.39,2456508.0,114.09797,20.67561,-0.45,2456508.5,114.81922,20.68668,-0.50,2456509.0,115.56237,20.68960,-0.56,2456509.5,116.32686,20.68399,-0.61,2456510.0,117.11205,20.66953,-0.66,2456510.5,117.91728,20.64589,-0.70,2456511.0,118.74185,20.61275,-0.75,2456511.5,119.58500,20.56982,-0.79,2456512.0,120.44595,20.51685,-0.83,2456512.5,121.32388,20.45357,-0.88,2456513.0,122.21791,20.37978,-0.91,2456513.5,123.12714,20.29528,-0.95,2456514.0,124.05065,20.19991,-0.99,2456514.5,124.98748,20.09355,-1.03,2456515.0,125.93665,19.97608,-1.06,2456515.5,126.89715,19.84746,-1.09,2456516.0,127.86797,19.70765,-1.13,2456516.5,128.84809,19.55666,-1.16,2456517.0,129.83648,19.39453,-1.19,2456517.5,130.83211,19.22133,-1.23,2456518.0,131.83397,19.03716,-1.26,2456518.5,132.84106,18.84218,-1.29,2456519.0,133.85239,18.63655,-1.33,2456519.5,134.86701,18.42046,-1.36,2456520.0,135.88398,18.19416,-1.39,2456520.5,136.90242,17.95787,-1.43,2456521.0,137.92147,17.71189,-1.46,2456521.5,138.94031,17.45649,-1.50,2456522.0,139.95817,17.19199,-1.53,2456522.5,140.97432,16.91870,-1.57,2456523.0,141.98809,16.63697,-1.60,2456523.5,142.99884,16.34713,-1.64,2456524.0,144.00599,16.04954,-1.68,2456524.5,145.00901,15.74454,-1.72,2456525.0,146.00741,15.43249,-1.75,2456525.5,147.00077,15.11374,-1.79,2456526.0,147.98868,14.78865,-1.83,2456526.5,148.97080,14.45757,-1.87,2456527.0,149.94682,14.12083,-1.90,2456527.5,150.91648,13.77879,-1.93,2456528.0,151.87956,13.43176,-1.96,2456528.5,152.83586,13.08008,-1.97,2456529.0,153.78523,12.72405,-1.98,2456529.5,154.72753,12.36398,-1.96,2456530.0,155.66267,12.00017,-1.93,2456530.5,156.59057,11.63290,-1.88,2456531.0,157.51118,11.26245,-1.83,2456531.5,158.42447,10.88910,-1.77,2456532.0,159.33045,10.51308,-1.71,2456532.5,160.22913,10.13465,-1.64,2456533.0,161.12052,9.75405,-1.58,2456533.5,162.00467,9.37149,-1.52,2456534.0,162.88164,8.98719,-1.46,2456534.5,163.75149,8.60137,-1.40,2456535.0,164.61430,8.21421,-1.35,2456535.5,165.47016,7.82591,-1.29,2456536.0,166.31915,7.43664,-1.24,2456536.5,167.16138,7.04657,-1.19,2456537.0,167.99694,6.65588,-1.14,2456537.5,168.82596,6.26471,-1.09,2456538.0,169.64854,5.87321,-1.05,2456538.5,170.46479,5.48153,-1.00,2456539.0,171.27485,5.08980,-0.96,2456539.5,172.07881,4.69815,-0.92,2456540.0,172.87681,4.30671,-0.88,2456540.5,173.66897,3.91559,-0.84,2456541.0,174.45541,3.52491,-0.81,2456541.5,175.23625,3.13477,-0.77,2456542.0,176.01161,2.74528,-0.74,2456542.5,176.78161,2.35654,-0.71,2456543.0,177.54636,1.96863,-0.68,2456543.5,178.30599,1.58166,-0.65,2456544.0,179.06061,1.19571,-0.62,2456544.5,179.81033,0.81086,-0.59,2456545.0,180.55527,0.42720,-0.56,2456545.5,181.29551,0.04480,-0.54,2456546.0,182.03118,-0.33626,-0.51,2456546.5,182.76238,-0.71592,-0.49,2456547.0,183.48920,-1.09409,-0.46,2456547.5,184.21173,-1.47071,-0.44,2456548.0,184.93007,-1.84571,-0.42,2456548.5,185.64431,-2.21903,-0.40,2456549.0,186.35454,-2.59061,-0.38,2456549.5,187.06082,-2.96039,-0.36,2456550.0,187.76325,-3.32830,-0.34,2456550.5,188.46190,-3.69428,-0.33,2456551.0,189.15683,-4.05828,-0.31,2456551.5,189.84812,-4.42024,-0.30,2456552.0,190.53583,-4.78011,-0.28,2456552.5,191.22002,-5.13784,-0.27,2456553.0,191.90075,-5.49335,-0.25,2456553.5,192.57806,-5.84662,-0.24,2456554.0,193.25201,-6.19757,-0.23,2456554.5,193.92263,-6.54616,-0.22,2456555.0,194.58998,-6.89234,-0.20,2456555.5,195.25407,-7.23605,-0.19,2456556.0,195.91495,-7.57724,-0.18,2456556.5,196.57263,-7.91586,-0.17,2456557.0,197.22713,-8.25186,-0.16,2456557.5,197.87847,-8.58518,-0.16,2456558.0,198.52664,-8.91576,-0.15,2456558.5,199.17166,-9.24356,-0.14,2456559.0,199.81350,-9.56851,-0.13,2456559.5,200.45217,-9.89057,-0.13,2456560.0,201.08763,-10.20967,-0.12,2456560.5,201.71986,-10.52575,-0.12,2456561.0,202.34883,-10.83876,-0.11,2456561.5,202.97449,-11.14863,-0.11,2456562.0,203.59679,-11.45531,-0.10,2456562.5,204.21567,-11.75872,-0.10,2456563.0,204.83107,-12.05880,-0.09,2456563.5,205.44290,-12.35549,-0.09,2456564.0,206.05108,-12.64871,-0.09,2456564.5,206.65551,-12.93840,-0.09,2456565.0,207.25609,-13.22447,-0.08,2456565.5,207.85269,-13.50686,-0.08,2456566.0,208.44519,-13.78548,-0.08,2456566.5,209.03344,-14.06026,-0.08,2456567.0,209.61728,-14.33110,-0.08,2456567.5,210.19656,-14.59793,-0.08,2456568.0,210.77108,-14.86064,-0.08,2456568.5,211.34064,-15.11916,-0.08,2456569.0,211.90504,-15.37337,-0.07,2456569.5,212.46404,-15.62318,-0.07,2456570.0,213.01740,-15.86848,-0.07,2456570.5,213.56485,-16.10916,-0.07,2456571.0,214.10609,-16.34510,-0.07,2456571.5,214.64084,-16.57619,-0.07,2456572.0,215.16875,-16.80229,-0.07,2456572.5,215.68948,-17.02328,-0.07,2456573.0,216.20266,-17.23901,-0.07,2456573.5,216.70787,-17.44934,-0.07,2456574.0,217.20471,-17.65411,-0.07,2456574.5,217.69272,-17.85317,-0.07,2456575.0,218.17141,-18.04635,-0.07,2456575.5,218.64027,-18.23346,-0.06,2456576.0,219.09877,-18.41432,-0.06,2456576.5,219.54633,-18.58873,-0.06,2456577.0,219.98234,-18.75649,-0.05,2456577.5,220.40616,-18.91737,-0.04,2456578.0,220.81711,-19.07114,-0.04,2456578.5,221.21449,-19.21756,-0.03,2456579.0,221.59754,-19.35636,-0.02,2456579.5,221.96547,-19.48728,-0.01,2456580.0,222.31746,-19.61003,-0.01,2456580.5,222.65264,-19.72430,0.02,2456581.0,222.97012,-19.82978,0.04,2456581.5,223.26894,-19.92612,0.06,2456582.0,223.54814,-20.01296,0.08,2456582.5,223.80669,-20.08995,0.10,2456583.0,224.04356,-20.15667,0.13,2456583.5,224.25766,-20.21271,0.16,2456584.0,224.44790,-20.25765,0.20,2456584.5,224.61314,-20.29103,0.24,2456585.0,224.75227,-20.31237,0.29,2456585.5,224.86412,-20.32118,0.34,2456586.0,224.94757,-20.31697,0.40,2456586.5,225.00149,-20.29920,0.46,2456587.0,225.02479,-20.26736,0.54,2456587.5,225.01642,-20.22090,0.62,2456588.0,224.97539,-20.15928,0.71,2456588.5,224.90081,-20.08199,0.81,2456589.0,224.79188,-19.98850,0.92,2456589.5,224.64794,-19.87833,1.04,2456590.0,224.46848,-19.75102,1.18,2456590.5,224.25319,-19.60617,1.33,2456591.0,224.00197,-19.44344,1.50,2456591.5,223.71498,-19.26260,1.69,2456592.0,223.39266,-19.06348,1.89,2456592.5,223.03575,-18.84607,2.11,2456593.0,222.64534,-18.61050,2.36,2456593.5,222.22287,-18.35704,2.63,2456594.0,221.77019,-18.08618,2.92,2456594.5,221.28951,-17.79861,3.24,2456595.0,220.78346,-17.49523,3.59,2456595.5,220.25505,-17.17719,3.97,2456596.0,219.70765,-16.84586,4.38,2456596.5,219.14500,-16.50288,4.82,2456597.0,218.57113,-16.15009,4.82,2456597.5,217.99033,-15.78957,4.82,2456598.0,217.40708,-15.42358,4.82,2456598.5,216.82599,-15.05455,4.82,2456599.0,216.25172,-14.68502,4.82,2456599.5,215.68889,-14.31761,4.82,2456600.0,215.14204,-13.95496,4.98,2456600.5,214.61552,-13.59970,4.48,2456601.0,214.11344,-13.25438,4.01,2456601.5,213.63960,-12.92141,3.57,2456602.0,213.19743,-12.60306,3.16,2456602.5,212.78998,-12.30139,2.78,2456603.0,212.41988,-12.01823,2.42,2456603.5,212.08932,-11.75514,2.10,2456604.0,211.80002,-11.51345,1.80,2456604.5,211.55331,-11.29421,1.52,2456605.0,211.35007,-11.09818,1.27,2456605.5,211.19080,-10.92590,1.04,2456606.0,211.07562,-10.77763,0.84,2456606.5,211.00433,-10.65344,0.65,2456607.0,210.97645,-10.55317,0.48,2456607.5,210.99120,-10.47649,0.33,2456608.0,211.04762,-10.42290,0.20,2456608.5,211.14456,-10.39178,0.08,2456609.0,211.28070,-10.38240,-0.03,2456609.5,211.45464,-10.39392,-0.12,2456610.0,211.66485,-10.42544,-0.21,2456610.5,211.90979,-10.47602,-0.28,2456611.0,212.18786,-10.54466,-0.34,2456611.5,212.49744,-10.63037,-0.40,2456612.0,212.83693,-10.73211,-0.45,2456612.5,213.20475,-10.84889,-0.49,2456613.0,213.59934,-10.97969,-0.52,2456613.5,214.01918,-11.12353,-0.55,2456614.0,214.46282,-11.27946,-0.58,2456614.5,214.92885,-11.44653,-0.60,2456615.0,215.41592,-11.62384,-0.62,2456615.5,215.92275,-11.81055,-0.63,2456616.0,216.44812,-12.00581,-0.64,2456616.5,216.99088,-12.20884,-0.65,2456617.0,217.54993,-12.41889,-0.66,2456617.5,218.12426,-12.63524,-0.66,2456618.0,218.71290,-12.85723,-0.67,2456618.5,219.31495,-13.08420,-0.67,2456619.0,219.92957,-13.31557,-0.67,2456619.5,220.55597,-13.55076,-0.67,2456620.0,221.19343,-13.78924,-0.67,2456620.5,221.84126,-14.03051,-0.67,2456621.0,222.49882,-14.27409,-0.67,2456621.5,223.16554,-14.51955,-0.67,2456622.0,223.84087,-14.76647,-0.66,2456622.5,224.52431,-15.01446,-0.66,2456623.0,225.21538,-15.26315,-0.66,2456623.5,225.91366,-15.51220,-0.66,2456624.0,226.61876,-15.76130,-0.65,2456624.5,227.33030,-16.01014,-0.65,2456625.0,228.04795,-16.25844,-0.65,2456625.5,228.77139,-16.50593,-0.65,2456626.0,229.50033,-16.75237,-0.65,2456626.5,230.23452,-16.99753,-0.64,2456627.0,230.97370,-17.24118,-0.64,2456627.5,231.71765,-17.48312,-0.64,2456628.0,232.46616,-17.72316,-0.64,2456628.5,233.21904,-17.96111,-0.64,2456629.0,233.97611,-18.19681,-0.64,2456629.5,234.73722,-18.43009,-0.64,2456630.0,235.50220,-18.66081,-0.64,2456630.5,236.27092,-18.88880,-0.65,2456631.0,237.04325,-19.11395,-0.65,2456631.5,237.81907,-19.33612,-0.65,2456632.0,238.59827,-19.55519,-0.65,2456632.5,239.38076,-19.77103,-0.66,2456633.0,240.16644,-19.98355,-0.66,2456633.5,240.95522,-20.19263,-0.67,2456634.0,241.74703,-20.39818,-0.67,2456634.5,242.54179,-20.60009,-0.68,2456635.0,243.33944,-20.79828,-0.68,2456635.5,244.13992,-20.99265,-0.69,2456636.0,244.94317,-21.18313,-0.70,2456636.5,245.74914,-21.36964,-0.70,2456637.0,246.55777,-21.55209,-0.71,2456637.5,247.36903,-21.73041,-0.72,2456638.0,248.18286,-21.90453,-0.73,2456638.5,248.99923,-22.07438,-0.74,2456639.0,249.81810,-22.23990,-0.75,2456639.5,250.63943,-22.40101,-0.76,2456640.0,251.46317,-22.55765,-0.77,2456640.5,252.28931,-22.70976,-0.78,2456641.0,253.11780,-22.85728,-0.79,2456641.5,253.94860,-23.00016,-0.81,2456642.0,254.78170,-23.13833,-0.82,2456642.5,255.61704,-23.27174,-0.84,2456643.0,256.45461,-23.40033,-0.85,2456643.5,257.29436,-23.52405,-0.87,2456644.0,258.13626,-23.64285,-0.88,2456644.5,258.98029,-23.75668,-0.90,2456645.0,259.82641,-23.86548,-0.91,2456645.5,260.67458,-23.96920,-0.93,2456646.0,261.52478,-24.06780,-0.95,2456646.5,262.37696,-24.16122,-0.97,2456647.0,263.23109,-24.24942,-0.99,2456647.5,264.08713,-24.33236,-1.01,2456648.0,264.94506,-24.40998,-1.03,2456648.5,265.80482,-24.48223,-1.05,2456649.0,266.66639,-24.54908,-1.07,2456649.5,267.52972,-24.61048,-1.09,2456650.0,268.39478,-24.66639,-1.11,2456650.5,269.26151,-24.71675,-1.14,2456651.0,270.12988,-24.76153,-1.16,2456651.5,270.99984,-24.80069,-1.18,2456652.0,271.87135,-24.83419,-1.20,2456652.5,272.74435,-24.86198,-1.23,2456653.0,273.61881,-24.88402,-1.25,2456653.5,274.49467,-24.90027,-1.27,2456654.0,275.37187,-24.91070,-1.29,2456654.5,276.25037,-24.91526,-1.30,2456655.0,277.13011,-24.91392,-1.31,2456655.5,278.01103,-24.90664,-1.32,2456656.0,278.89307,-24.89338,-1.32,2456656.5,279.77617,-24.87411,-1.32,2456657.0,280.66025,-24.84880,-1.32,2456657.5,281.54526,-24.81740,-1.31,2456658.0,282.43113,-24.77989,-1.30,2456658.5,283.31777,-24.73623,-1.29,2456659.0,284.20512,-24.68640,-1.27,2456659.5,285.09311,-24.63036,-1.26,2456660.0,285.98164,-24.56808,-1.25,2456660.5,286.87064,-24.49953,-1.23,2456661.0,287.76002,-24.42470,-1.22,2456661.5,288.64970,-24.34354,-1.20,2456662.0,289.53959,-24.25603,-1.19,2456662.5,290.42959,-24.16216,-1.18,2456663.0,291.31961,-24.06189,-1.16,2456663.5,292.20955,-23.95522,-1.15,2456664.0,293.09931,-23.84211,-1.13,2456664.5,293.98879,-23.72255,-1.12,2456665.0,294.87786,-23.59654,-1.11,2456665.5,295.76642,-23.46405,-1.10,2456666.0,296.65434,-23.32507,-1.09,2456666.5,297.54150,-23.17961,-1.08,2456667.0,298.42776,-23.02765,-1.06,2456667.5,299.31299,-22.86920,-1.05,2456668.0,300.19703,-22.70425,-1.04,2456668.5,301.07974,-22.53282,-1.03,2456669.0,301.96094,-22.35491,-1.03,2456669.5,302.84048,-22.17054,-1.02,2456670.0,303.71816,-21.97973,-1.01,2456670.5,304.59379,-21.78250,-1.00,2456671.0,305.46717,-21.57888,-0.99,2456671.5,306.33809,-21.36891,-0.99,2456672.0,307.20631,-21.15263,-0.98,2456672.5,308.07160,-20.93010,-0.97,2456673.0,308.93369,-20.70137,-0.97,2456673.5,309.79230,-20.46650,-0.96,2456674.0,310.64716,-20.22558,-0.96,2456674.5,311.49793,-19.97869,-0.95,2456675.0,312.34429,-19.72592,-0.95,2456675.5,313.18589,-19.46739,-0.95,2456676.0,314.02233,-19.20322,-0.94,2456676.5,314.85323,-18.93355,-0.94,2456677.0,315.67814,-18.65851,-0.94,2456677.5,316.49660,-18.37829,-0.93,2456678.0,317.30812,-18.09307,-0.93,2456678.5,318.11217,-17.80305,-0.93,2456679.0,318.90819,-17.50845,-0.93,2456679.5,319.69558,-17.20952,-0.92,2456680.0,320.47369,-16.90653,-0.92,2456680.5,321.24185,-16.59977,-0.92,2456681.0,321.99933,-16.28956,-0.92,2456681.5,322.74537,-15.97624,-0.91,2456682.0,323.47913,-15.66019,-0.91,2456682.5,324.19977,-15.34182,-0.90,2456683.0,324.90635,-15.02155,-0.90,2456683.5,325.59792,-14.69988,-0.89,2456684.0,326.27345,-14.37729,-0.88,2456684.5,326.93188,-14.05432,-0.87,2456685.0,327.57207,-13.73156,-0.86,2456685.5,328.19287,-13.40962,-0.84,2456686.0,328.79304,-13.08914,-0.82,2456686.5,329.37133,-12.77081,-0.80,2456687.0,329.92643,-12.45535,-0.78,2456687.5,330.45698,-12.14352,-0.75,2456688.0,330.96163,-11.83610,-0.72,2456688.5,331.43896,-11.53393,-0.68,2456689.0,331.88756,-11.23784,-0.64,2456689.5,332.30602,-10.94872,-0.59,2456690.0,332.69291,-10.66746,-0.54,2456690.5,333.04684,-10.39499,-0.48,2456691.0,333.36645,-10.13221,-0.41,2456691.5,333.65040,-9.88007,-0.33,2456692.0,333.89745,-9.63951,-0.24,2456692.5,334.10642,-9.41144,-0.15,2456693.0,334.27622,-9.19678,-0.04,2456693.5,334.40590,-8.99641,0.08,2456694.0,334.49463,-8.81119,0.21,2456694.5,334.54177,-8.64192,0.35,2456695.0,334.54683,-8.48935,0.50,2456695.5,334.50953,-8.35418,0.67,2456696.0,334.42983,-8.23702,0.86,2456696.5,334.30791,-8.13840,1.06,2456697.0,334.14423,-8.05875,1.27,2456697.5,333.93949,-7.99840,1.50,2456698.0,333.69472,-7.95756,1.74,2456698.5,333.41120,-7.93632,2.01,2456699.0,333.09054,-7.93463,2.28,2456699.5,332.73462,-7.95231,2.58,2456700.0,332.34563,-7.98904,2.88,2456700.5,331.92602,-8.04437,3.20,2456701.0,331.47852,-8.11770,3.53,2456701.5,331.00608,-8.20829,3.87,2456702.0,330.51185,-8.31529,4.20,2456702.5,329.99917,-8.43772,4.53,2456703.0,329.47150,-8.57451,4.82,2456703.5,328.93242,-8.72449,5.06,2456704.0,328.38553,-8.88640,5.21,2456704.5,327.83446,-9.05896,5.25,2456705.0,327.28278,-9.24082,5.17,2456705.5,326.73400,-9.43063,4.99,2456706.0,326.19150,-9.62702,4.76,2456706.5,325.65852,-9.82865,4.49,2456707.0,325.13809,-10.03421,4.21,2456707.5,324.63306,-10.24241,3.93,2456708.0,324.14603,-10.45206,3.66,2456708.5,323.67934,-10.66200,3.40,2456709.0,323.23511,-10.87115,3.15,2456709.5,322.81518,-11.07853,2.91,2456710.0,322.42112,-11.28323,2.69,2456710.5,322.05428,-11.48440,2.49,2456711.0,321.71573,-11.68132,2.30,2456711.5,321.40633,-11.87330,2.12,2456712.0,321.12673,-12.05977,1.95,2456712.5,320.87734,-12.24022,1.80,2456713.0,320.65843,-12.41420,1.65,2456713.5,320.47007,-12.58133,1.52,2456714.0,320.31219,-12.74129,1.40,2456714.5,320.18459,-12.89383,1.29,2456715.0,320.08695,-13.03872,1.18,2456715.5,320.01884,-13.17580,1.09,2456716.0,319.97977,-13.30493,1.00,2456716.5,319.96914,-13.42601,0.92,2456717.0,319.98634,-13.53898,0.85,2456717.5,320.03067,-13.64379,0.78,2456718.0,320.10142,-13.74042,0.72,2456718.5,320.19784,-13.82886,0.66,2456719.0,320.31916,-13.90914,0.61,2456719.5,320.46462,-13.98128,0.56,2456720.0,320.63342,-14.04532,0.51,2456720.5,320.82479,-14.10131,0.47,2456721.0,321.03795,-14.14931,0.44,2456721.5,321.27212,-14.18938,0.40,2456722.0,321.52656,-14.22159,0.37,2456722.5,321.80051,-14.24601,0.34,2456723.0,322.09325,-14.26272,0.32,2456723.5,322.40407,-14.27180,0.29,2456724.0,322.73228,-14.27331,0.27,2456724.5,323.07721,-14.26735,0.25,2456725.0,323.43821,-14.25398,0.23,2456725.5,323.81465,-14.23330,0.22,2456726.0,324.20592,-14.20538,0.20,2456726.5,324.61145,-14.17029,0.19,2456727.0,325.03067,-14.12811,0.17,2456727.5,325.46305,-14.07893,0.16,2456728.0,325.90805,-14.02281,0.15,2456728.5,326.36519,-13.95982,0.14,2456729.0,326.83400,-13.89005,0.13,2456729.5,327.31401,-13.81355,0.12,2456730.0,327.80478,-13.73041,0.11,2456730.5,328.30592,-13.64068,0.10,2456731.0,328.81701,-13.54443,0.10,2456731.5,329.33767,-13.44173,0.09,2456732.0,329.86755,-13.33264,0.08,2456732.5,330.40631,-13.21722,0.07,2456733.0,330.95361,-13.09553,0.07,2456733.5,331.50914,-12.96762,0.06,2456734.0,332.07262,-12.83357,0.06,2456734.5,332.64375,-12.69341,0.05,2456735.0,333.22227,-12.54721,0.04,2456735.5,333.80793,-12.39502,0.04,2456736.0,334.40049,-12.23690,0.03,2456736.5,334.99972,-12.07289,0.03,2456737.0,335.60542,-11.90304,0.02,2456737.5,336.21737,-11.72740,0.01,2456738.0,336.83539,-11.54603,0.01,2456738.5,337.45929,-11.35897,0.01,2456739.0,338.08892,-11.16626,-0.01,2456739.5,338.72411,-10.96795,-0.01,2456740.0,339.36470,-10.76410,-0.02,2456740.5,340.01057,-10.55473,-0.03,2456741.0,340.66158,-10.33990,-0.03,2456741.5,341.31762,-10.11965,-0.04,2456742.0,341.97856,-9.89402,-0.05,2456742.5,342.64431,-9.66305,-0.06,2456743.0,343.31477,-9.42679,-0.07,2456743.5,343.98986,-9.18527,-0.08,2456744.0,344.66950,-8.93854,-0.09,2456744.5,345.35362,-8.68663,-0.10,2456745.0,346.04216,-8.42959,-0.11,2456745.5,346.73505,-8.16745,-0.12,2456746.0,347.43227,-7.90025,-0.13,2456746.5,348.13375,-7.62804,-0.14,2456747.0,348.83949,-7.35084,-0.15,2456747.5,349.54944,-7.06869,-0.17,2456748.0,350.26359,-6.78165,-0.18,2456748.5,350.98192,-6.48973,-0.19,2456749.0,351.70444,-6.19298,-0.21,2456749.5,352.43114,-5.89145,-0.22,2456750.0,353.16202,-5.58516,-0.24,2456750.5,353.89710,-5.27415,-0.25,2456751.0,354.63640,-4.95847,-0.27,2456751.5,355.37995,-4.63816,-0.29,2456752.0,356.12776,-4.31325,-0.31,2456752.5,356.87988,-3.98379,-0.33,2456753.0,357.63635,-3.64982,-0.35,2456753.5,358.39722,-3.31139,-0.37,2456754.0,359.16253,-2.96853,-0.39,2456754.5,359.93234,-2.62130,-0.41,2456755.0,0.70672,-2.26973,-0.43,2456755.5,1.48574,-1.91389,-0.46,2456756.0,2.26945,-1.55382,-0.48,2456756.5,3.05794,-1.18958,-0.51,2456757.0,3.85130,-0.82122,-0.54,2456757.5,4.64959,-0.44879,-0.56,2456758.0,5.45292,-0.07237,-0.59,2456758.5,6.26137,0.30799,-0.62,2456759.0,7.07504,0.69222,-0.65,2456759.5,7.89403,1.08024,-0.69,2456760.0,8.71844,1.47198,-0.72,2456760.5,9.54838,1.86737,-0.76,2456761.0,10.38394,2.26631,-0.79,2456761.5,11.22524,2.66871,-0.83,2456762.0,12.07238,3.07448,-0.87,2456762.5,12.92547,3.48352,-0.91,2456763.0,13.78462,3.89571,-0.95,2456763.5,14.64995,4.31094,-1.00,2456764.0,15.52154,4.72909,-1.04,2456764.5,16.39951,5.15003,-1.09,2456765.0,17.28395,5.57360,-1.14,2456765.5,18.17496,5.99966,-1.19,2456766.0,19.07262,6.42806,-1.25,2456766.5,19.97702,6.85860,-1.30,2456767.0,20.88823,7.29112,-1.36,2456767.5,21.80631,7.72542,-1.42,2456768.0,22.73131,8.16128,-1.49,2456768.5,23.66327,8.59849,-1.55,2456769.0,24.60222,9.03681,-1.62,2456769.5,25.54816,9.47599,-1.70,2456770.0,26.50110,9.91577,-1.77,2456770.5,27.46100,10.35587,-1.85,2456771.0,28.42781,10.79599,-1.93,2456771.5,29.40146,11.23583,-2.02,2456772.0,30.38186,11.67505,-2.11,2456772.5,31.36889,12.11333,-2.20,2456773.0,32.36239,12.55030,-2.29,2456773.5,33.36221,12.98557,-2.29,2456774.0,34.36816,13.41890,-2.29,2456774.5,35.37988,13.84975,-2.32,2456775.0,36.39717,14.27774,-2.25,2456775.5,37.41974,14.70247,-2.18,2456776.0,38.44723,15.12352,-2.12,2456776.5,39.47926,15.54046,-2.05,2456777.0,40.51541,15.95287,-1.99,2456777.5,41.55526,16.36031,-1.92,2456778.0,42.59830,16.76234,-1.86,2456778.5,43.64405,17.15854,-1.80,2456779.0,44.69196,17.54847,-1.74,2456779.5,45.74146,17.93173,-1.69,2456780.0,46.79198,18.30790,-1.63,2456780.5,47.84290,18.67660,-1.58,2456781.0,48.89361,19.03745,-1.53,2456781.5,49.94345,19.39009,-1.48,2456782.0,50.99179,19.73418,-1.43,2456782.5,52.03796,20.06941,-1.38,2456783.0,53.08130,20.39548,-1.34,2456783.5,54.12115,20.71213,-1.29,2456784.0,55.15686,21.01911,-1.25,2456784.5,56.18777,21.31622,-1.20,2456785.0,57.21324,21.60328,-1.16,2456785.5,58.23263,21.88011,-1.12,2456786.0,59.24533,22.14660,-1.08,2456786.5,60.25074,22.40263,-1.04,2456787.0,61.24827,22.64814,-0.99,2456787.5,62.23735,22.88307,-0.95,2456788.0,63.21744,23.10739,-0.91,2456788.5,64.18802,23.32110,-0.87,2456789.0,65.14857,23.52423,-0.83,2456789.5,66.09861,23.71680,-0.79,2456790.0,67.03768,23.89889,-0.75,2456790.5,67.96533,24.07056,-0.71,2456791.0,68.88114,24.23191,-0.67,2456791.5,69.78470,24.38304,-0.63,2456792.0,70.67563,24.52409,-0.59,2456792.5,71.55356,24.65517,-0.55,2456793.0,72.41813,24.77644,-0.51,2456793.5,73.26900,24.88805,-0.47,2456794.0,74.10585,24.99016,-0.43,2456794.5,74.92837,25.08294,-0.39,2456795.0,75.73626,25.16656,-0.34,2456795.5,76.52922,25.24121,-0.30,2456796.0,77.30699,25.30706,-0.26,2456796.5,78.06929,25.36430,-0.21,2456797.0,78.81587,25.41313,-0.17,2456797.5,79.54646,25.45374,-0.13,2456798.0,80.26083,25.48632,-0.08,2456798.5,80.95873,25.51106,-0.03,2456799.0,81.63992,25.52816,0.01,2456799.5,82.30418,25.53782,0.06,2456800.0,82.95128,25.54023,0.11,2456800.5,83.58099,25.53558,0.15,2456801.0,84.19310,25.52407,0.20,2456801.5,84.78738,25.50590,0.25,2456802.0,85.36362,25.48125,0.30,2456802.5,85.92161,25.45032,0.35,2456803.0,86.46113,25.41329,0.41,2456803.5,86.98198,25.37035,0.46,2456804.0,87.48395,25.32169,0.51,2456804.5,87.96683,25.26750,0.57,2456805.0,88.43042,25.20795,0.63,2456805.5,88.87453,25.14322,0.69,2456806.0,89.29895,25.07350,0.75,2456806.5,89.70351,24.99896,0.81,2456807.0,90.08802,24.91978,0.87,2456807.5,90.45229,24.83612,0.94,2456808.0,90.79617,24.74818,1.00,2456808.5,91.11949,24.65610,1.07,2456809.0,91.42210,24.56007,1.14,2456809.5,91.70386,24.46024,1.22,2456810.0,91.96465,24.35680,1.29,2456810.5,92.20436,24.24990,1.37,2456811.0,92.42288,24.13971,1.45,2456811.5,92.62015,24.02639,1.53,2456812.0,92.79611,23.91012,1.62,2456812.5,92.95073,23.79105,1.71,2456813.0,93.08400,23.66936,1.80,2456813.5,93.19593,23.54520,1.90,2456814.0,93.28659,23.41875,2.00,2456814.5,93.35605,23.29018,2.10,2456815.0,93.40442,23.15966,2.20,2456815.5,93.43186,23.02735,2.31,2456816.0,93.43856,22.89344,2.43,2456816.5,93.42477,22.75811,2.55,2456817.0,93.39075,22.62154,2.67,2456817.5,93.33684,22.48391,2.80,2456818.0,93.26342,22.34542,2.93,2456818.5,93.17091,22.20626,3.07,2456819.0,93.05979,22.06663,3.21,2456819.5,92.93061,21.92674,3.35,2456820.0,92.78396,21.78679,3.50,2456820.5,92.62048,21.64701,3.66,2456821.0,92.44088,21.50762,3.82,2456821.5,92.24593,21.36885,3.98,2456822.0,92.03645,21.23092,4.15,2456822.5,91.81331,21.09408,4.33,2456823.0,91.57744,20.95858,4.50,2456823.5,91.32982,20.82466,4.68,2456824.0,91.07148,20.69258,4.86,2456824.5,90.80351,20.56259,5.04,2456825.0,90.52700,20.43496,5.21,2456825.5,90.24313,20.30995,5.38,2456826.0,89.95307,20.18783,5.54,2456826.5,89.65805,20.06885,5.54,2456827.0,89.35929,19.95328,5.54,2456827.5,89.05805,19.84139,5.54,2456828.0,88.75560,19.73342,5.54,2456828.5,88.45321,19.62963,5.54,2456829.0,88.15213,19.53027,5.54,2456829.5,87.85363,19.43557,5.54,2456830.0,87.55895,19.34576,5.54,2456830.5,87.26932,19.26105,5.45,2456831.0,86.98594,19.18164,5.28,2456831.5,86.70999,19.10774,5.10,2456832.0,86.44260,19.03950,4.92,2456832.5,86.18487,18.97708,4.74,2456833.0,85.93786,18.92064,4.55,2456833.5,85.70259,18.87029,4.37,2456834.0,85.48002,18.82613,4.19,2456834.5,85.27107,18.78825,4.01,2456835.0,85.07661,18.75673,3.84,2456835.5,84.89745,18.73159,3.67,2456836.0,84.73436,18.71288,3.51,2456836.5,84.58804,18.70059,3.34,2456837.0,84.45916,18.69472,3.19,2456837.5,84.34832,18.69524,3.04,2456838.0,84.25607,18.70209,2.89,2456838.5,84.18293,18.71521,2.75,2456839.0,84.12936,18.73452,2.61,2456839.5,84.09577,18.75991,2.48]],
            ["Venus","rgb(245,222,179)",[2456474.5,126.71878,20.82026,-3.85,2456475.5,127.97871,20.53742,-3.85,2456476.5,129.23341,20.24516,-3.85,2456477.5,130.48282,19.94367,-3.85,2456478.5,131.72688,19.63312,-3.85,2456479.5,132.96554,19.31371,-3.85,2456480.5,134.19874,18.98562,-3.85,2456481.5,135.42647,18.64905,-3.85,2456482.5,136.64869,18.30418,-3.85,2456483.5,137.86538,17.95121,-3.86,2456484.5,139.07654,17.59034,-3.86,2456485.5,140.28217,17.22176,-3.86,2456486.5,141.48229,16.84567,-3.86,2456487.5,142.67692,16.46228,-3.86,2456488.5,143.86608,16.07177,-3.86,2456489.5,145.04983,15.67436,-3.86,2456490.5,146.22821,15.27024,-3.87,2456491.5,147.40128,14.85962,-3.87,2456492.5,148.56911,14.44269,-3.87,2456493.5,149.73176,14.01966,-3.87,2456494.5,150.88932,13.59072,-3.87,2456495.5,152.04186,13.15609,-3.88,2456496.5,153.18948,12.71596,-3.88,2456497.5,154.33228,12.27052,-3.88,2456498.5,155.47040,11.81996,-3.88,2456499.5,156.60394,11.36448,-3.88,2456500.5,157.73305,10.90426,-3.89,2456501.5,158.85787,10.43951,-3.89,2456502.5,159.97852,9.97041,-3.89,2456503.5,161.09514,9.49716,-3.89,2456504.5,162.20788,9.01995,-3.90,2456505.5,163.31686,8.53898,-3.90,2456506.5,164.42222,8.05445,-3.90,2456507.5,165.52409,7.56655,-3.91,2456508.5,166.62262,7.07547,-3.91,2456509.5,167.71794,6.58142,-3.91,2456510.5,168.81020,6.08458,-3.91,2456511.5,169.89952,5.58515,-3.92,2456512.5,170.98606,5.08332,-3.92,2456513.5,172.06997,4.57929,-3.92,2456514.5,173.15138,4.07324,-3.93,2456515.5,174.23044,3.56537,-3.93,2456516.5,175.30731,3.05586,-3.94,2456517.5,176.38212,2.54491,-3.94,2456518.5,177.45503,2.03270,-3.94,2456519.5,178.52619,1.51943,-3.95,2456520.5,179.59574,1.00528,-3.95,2456521.5,180.66382,0.49043,-3.95,2456522.5,181.73059,-0.02491,-3.96,2456523.5,182.79619,-0.54058,-3.96,2456524.5,183.86077,-1.05637,-3.97,2456525.5,184.92449,-1.57212,-3.97,2456526.5,185.98754,-2.08764,-3.98,2456527.5,187.05007,-2.60277,-3.98,2456528.5,188.11227,-3.11731,-3.99,2456529.5,189.17431,-3.63110,-3.99,2456530.5,190.23636,-4.14396,-4.00,2456531.5,191.29858,-4.65570,-4.00,2456532.5,192.36113,-5.16616,-4.01,2456533.5,193.42416,-5.67514,-4.01,2456534.5,194.48782,-6.18246,-4.02,2456535.5,195.55225,-6.68794,-4.02,2456536.5,196.61761,-7.19139,-4.03,2456537.5,197.68402,-7.69264,-4.03,2456538.5,198.75162,-8.19148,-4.04,2456539.5,199.82053,-8.68775,-4.04,2456540.5,200.89090,-9.18124,-4.05,2456541.5,201.96283,-9.67178,-4.05,2456542.5,203.03645,-10.15917,-4.06,2456543.5,204.11186,-10.64323,-4.07,2456544.5,205.18918,-11.12377,-4.07,2456545.5,206.26850,-11.60061,-4.08,2456546.5,207.34991,-12.07355,-4.08,2456547.5,208.43349,-12.54241,-4.09,2456548.5,209.51931,-13.00700,-4.10,2456549.5,210.60745,-13.46712,-4.10,2456550.5,211.69796,-13.92259,-4.11,2456551.5,212.79092,-14.37322,-4.12,2456552.5,213.88637,-14.81882,-4.13,2456553.5,214.98440,-15.25920,-4.13,2456554.5,216.08507,-15.69418,-4.14,2456555.5,217.18844,-16.12359,-4.15,2456556.5,218.29458,-16.54723,-4.15,2456557.5,219.40354,-16.96494,-4.16,2456558.5,220.51536,-17.37654,-4.17,2456559.5,221.63008,-17.78185,-4.18,2456560.5,222.74772,-18.18069,-4.18,2456561.5,223.86829,-18.57288,-4.19,2456562.5,224.99178,-18.95825,-4.20,2456563.5,226.11818,-19.33662,-4.21,2456564.5,227.24748,-19.70781,-4.22,2456565.5,228.37963,-20.07166,-4.22,2456566.5,229.51459,-20.42799,-4.23,2456567.5,230.65230,-20.77664,-4.24,2456568.5,231.79269,-21.11743,-4.25,2456569.5,232.93566,-21.45021,-4.26,2456570.5,234.08114,-21.77481,-4.27,2456571.5,235.22898,-22.09107,-4.28,2456572.5,236.37907,-22.39886,-4.28,2456573.5,237.53124,-22.69802,-4.29,2456574.5,238.68532,-22.98840,-4.30,2456575.5,239.84111,-23.26986,-4.31,2456576.5,240.99841,-23.54227,-4.32,2456577.5,242.15698,-23.80550,-4.33,2456578.5,243.31659,-24.05941,-4.34,2456579.5,244.47699,-24.30389,-4.35,2456580.5,245.63795,-24.53882,-4.36,2456581.5,246.79920,-24.76409,-4.37,2456582.5,247.96048,-24.97960,-4.38,2456583.5,249.12153,-25.18525,-4.39,2456584.5,250.28207,-25.38097,-4.40,2456585.5,251.44182,-25.56668,-4.41,2456586.5,252.60046,-25.74231,-4.42,2456587.5,253.75770,-25.90780,-4.43,2456588.5,254.91319,-26.06309,-4.44,2456589.5,256.06660,-26.20814,-4.45,2456590.5,257.21757,-26.34291,-4.46,2456591.5,258.36573,-26.46737,-4.47,2456592.5,259.51071,-26.58151,-4.48,2456593.5,260.65212,-26.68530,-4.49,2456594.5,261.78954,-26.77876,-4.51,2456595.5,262.92257,-26.86188,-4.52,2456596.5,264.05078,-26.93468,-4.53,2456597.5,265.17373,-26.99720,-4.54,2456598.5,266.29097,-27.04947,-4.55,2456599.5,267.40203,-27.09154,-4.56,2456600.5,268.50642,-27.12347,-4.57,2456601.5,269.60363,-27.14535,-4.58,2456602.5,270.69311,-27.15726,-4.59,2456603.5,271.77432,-27.15928,-4.61,2456604.5,272.84669,-27.15153,-4.62,2456605.5,273.90963,-27.13411,-4.63,2456606.5,274.96256,-27.10715,-4.64,2456607.5,276.00490,-27.07078,-4.65,2456608.5,277.03604,-27.02513,-4.66,2456609.5,278.05541,-26.97035,-4.67,2456610.5,279.06242,-26.90660,-4.68,2456611.5,280.05646,-26.83404,-4.70,2456612.5,281.03695,-26.75286,-4.71,2456613.5,282.00326,-26.66324,-4.72,2456614.5,282.95479,-26.56538,-4.73,2456615.5,283.89092,-26.45947,-4.74,2456616.5,284.81100,-26.34573,-4.75,2456617.5,285.71440,-26.22437,-4.76,2456618.5,286.60045,-26.09563,-4.77,2456619.5,287.46849,-25.95973,-4.78,2456620.5,288.31784,-25.81692,-4.79,2456621.5,289.14781,-25.66744,-4.80,2456622.5,289.95767,-25.51154,-4.81,2456623.5,290.74670,-25.34951,-4.82,2456624.5,291.51415,-25.18159,-4.83,2456625.5,292.25927,-25.00807,-4.84,2456626.5,292.98125,-24.82924,-4.84,2456627.5,293.67929,-24.64539,-4.85,2456628.5,294.35252,-24.45683,-4.86,2456629.5,295.00006,-24.26388,-4.86,2456630.5,295.62098,-24.06684,-4.87,2456631.5,296.21429,-23.86606,-4.87,2456632.5,296.77899,-23.66187,-4.88,2456633.5,297.31405,-23.45459,-4.88,2456634.5,297.81842,-23.24456,-4.89,2456635.5,298.29105,-23.03212,-4.89,2456636.5,298.73087,-22.81760,-4.89,2456637.5,299.13684,-22.60133,-4.89,2456638.5,299.50790,-22.38364,-4.89,2456639.5,299.84301,-22.16488,-4.88,2456640.5,300.14113,-21.94536,-4.88,2456641.5,300.40128,-21.72542,-4.87,2456642.5,300.62246,-21.50538,-4.87,2456643.5,300.80376,-21.28557,-4.86,2456644.5,300.94430,-21.06629,-4.85,2456645.5,301.04326,-20.84786,-4.83,2456646.5,301.09992,-20.63058,-4.82,2456647.5,301.11366,-20.41475,-4.80,2456648.5,301.08396,-20.20066,-4.78,2456649.5,301.01045,-19.98860,-4.76,2456650.5,300.89292,-19.77884,-4.73,2456651.5,300.73133,-19.57166,-4.71,2456652.5,300.52585,-19.36733,-4.68,2456653.5,300.27686,-19.16610,-4.64,2456654.5,299.98499,-18.96825,-4.60,2456655.5,299.65112,-18.77402,-4.56,2456656.5,299.27640,-18.58368,-4.52,2456657.5,298.86226,-18.39750,-4.47,2456658.5,298.41043,-18.21573,-4.42,2456659.5,297.92292,-18.03864,-4.37,2456660.5,297.40208,-17.86649,-4.31,2456661.5,296.85059,-17.69956,-4.26,2456662.5,296.27145,-17.53809,-4.25,2456663.5,295.66800,-17.38234,-4.28,2456664.5,295.04390,-17.23258,-4.31,2456665.5,294.40305,-17.08905,-4.34,2456666.5,293.74962,-16.95201,-4.34,2456667.5,293.08793,-16.82170,-4.34,2456668.5,292.42243,-16.69835,-4.34,2456669.5,291.75763,-16.58220,-4.34,2456670.5,291.09805,-16.47344,-4.34,2456671.5,290.44814,-16.37227,-4.34,2456672.5,289.81221,-16.27885,-4.31,2456673.5,289.19442,-16.19332,-4.28,2456674.5,288.59869,-16.11576,-4.25,2456675.5,288.02867,-16.04625,-4.23,2456676.5,287.48769,-15.98479,-4.29,2456677.5,286.97879,-15.93137,-4.35,2456678.5,286.50462,-15.88590,-4.40,2456679.5,286.06748,-15.84828,-4.45,2456680.5,285.66933,-15.81835,-4.50,2456681.5,285.31176,-15.79588,-4.54,2456682.5,284.99602,-15.78065,-4.58,2456683.5,284.72302,-15.77237,-4.62,2456684.5,284.49337,-15.77071,-4.65,2456685.5,284.30739,-15.77533,-4.68,2456686.5,284.16514,-15.78584,-4.71,2456687.5,284.06646,-15.80185,-4.73,2456688.5,284.01097,-15.82291,-4.75,2456689.5,283.99819,-15.84860,-4.77,2456690.5,284.02746,-15.87843,-4.79,2456691.5,284.09808,-15.91194,-4.81,2456692.5,284.20922,-15.94865,-4.82,2456693.5,284.36004,-15.98807,-4.83,2456694.5,284.54959,-16.02971,-4.84,2456695.5,284.77691,-16.07308,-4.85,2456696.5,285.04098,-16.11770,-4.85,2456697.5,285.34078,-16.16309,-4.86,2456698.5,285.67523,-16.20877,-4.86,2456699.5,286.04327,-16.25428,-4.86,2456700.5,286.44381,-16.29916,-4.86,2456701.5,286.87579,-16.34297,-4.86,2456702.5,287.33813,-16.38528,-4.86,2456703.5,287.82977,-16.42566,-4.86,2456704.5,288.34966,-16.46373,-4.85,2456705.5,288.89676,-16.49907,-4.85,2456706.5,289.47005,-16.53133,-4.84,2456707.5,290.06853,-16.56015,-4.84,2456708.5,290.69121,-16.58517,-4.83,2456709.5,291.33713,-16.60609,-4.83,2456710.5,292.00533,-16.62258,-4.82,2456711.5,292.69487,-16.63437,-4.81,2456712.5,293.40483,-16.64118,-4.80,2456713.5,294.13430,-16.64275,-4.79,2456714.5,294.88241,-16.63884,-4.78,2456715.5,295.64827,-16.62923,-4.78,2456716.5,296.43105,-16.61370,-4.77,2456717.5,297.22995,-16.59204,-4.76,2456718.5,298.04420,-16.56408,-4.75,2456719.5,298.87307,-16.52962,-4.74,2456720.5,299.71587,-16.48851,-4.73,2456721.5,300.57193,-16.44060,-4.72,2456722.5,301.44063,-16.38574,-4.71,2456723.5,302.32134,-16.32379,-4.69,2456724.5,303.21350,-16.25465,-4.68,2456725.5,304.11653,-16.17820,-4.67,2456726.5,305.02990,-16.09434,-4.66,2456727.5,305.95307,-16.00298,-4.65,2456728.5,306.88555,-15.90405,-4.64,2456729.5,307.82685,-15.79748,-4.63,2456730.5,308.77651,-15.68321,-4.62,2456731.5,309.73406,-15.56119,-4.61,2456732.5,310.69909,-15.43140,-4.59,2456733.5,311.67118,-15.29379,-4.58,2456734.5,312.64992,-15.14836,-4.57,2456735.5,313.63493,-14.99510,-4.56,2456736.5,314.62583,-14.83401,-4.55,2456737.5,315.62226,-14.66511,-4.54,2456738.5,316.62386,-14.48843,-4.53,2456739.5,317.63027,-14.30399,-4.52,2456740.5,318.64116,-14.11186,-4.51,2456741.5,319.65619,-13.91208,-4.49,2456742.5,320.67503,-13.70472,-4.48,2456743.5,321.69737,-13.48985,-4.47,2456744.5,322.72290,-13.26754,-4.46,2456745.5,323.75136,-13.03788,-4.45,2456746.5,324.78247,-12.80094,-4.44,2456747.5,325.81600,-12.55683,-4.43,2456748.5,326.85172,-12.30564,-4.42,2456749.5,327.88943,-12.04747,-4.41,2456750.5,328.92893,-11.78242,-4.40,2456751.5,329.97005,-11.51061,-4.39,2456752.5,331.01262,-11.23213,-4.38,2456753.5,332.05650,-10.94712,-4.37,2456754.5,333.10156,-10.65568,-4.36,2456755.5,334.14767,-10.35795,-4.35,2456756.5,335.19472,-10.05403,-4.34,2456757.5,336.24263,-9.74407,-4.33,2456758.5,337.29130,-9.42818,-4.32,2456759.5,338.34067,-9.10652,-4.31,2456760.5,339.39067,-8.77920,-4.30,2456761.5,340.44125,-8.44637,-4.29,2456762.5,341.49238,-8.10817,-4.28,2456763.5,342.54402,-7.76474,-4.27,2456764.5,343.59615,-7.41624,-4.26,2456765.5,344.64874,-7.06281,-4.25,2456766.5,345.70176,-6.70462,-4.25,2456767.5,346.75521,-6.34182,-4.24,2456768.5,347.80906,-5.97458,-4.23,2456769.5,348.86330,-5.60307,-4.22,2456770.5,349.91791,-5.22745,-4.21,2456771.5,350.97288,-4.84791,-4.20,2456772.5,352.02822,-4.46460,-4.19,2456773.5,353.08394,-4.07771,-4.19,2456774.5,354.14006,-3.68741,-4.18,2456775.5,355.19659,-3.29387,-4.17,2456776.5,356.25356,-2.89726,-4.16,2456777.5,357.31102,-2.49777,-4.15,2456778.5,358.36901,-2.09555,-4.15,2456779.5,359.42757,-1.69080,-4.14,2456780.5,0.48677,-1.28368,-4.13,2456781.5,1.54665,-0.87436,-4.12,2456782.5,2.60730,-0.46303,-4.12,2456783.5,3.66879,-0.04986,-4.11,2456784.5,4.73121,0.36498,-4.10,2456785.5,5.79463,0.78131,-4.10,2456786.5,6.85916,1.19897,-4.09,2456787.5,7.92490,1.61777,-4.08,2456788.5,8.99194,2.03754,-4.08,2456789.5,10.06040,2.45810,-4.07,2456790.5,11.13040,2.87930,-4.06,2456791.5,12.20205,3.30094,-4.06,2456792.5,13.27546,3.72285,-4.05,2456793.5,14.35075,4.14485,-4.04,2456794.5,15.42804,4.56677,-4.04,2456795.5,16.50741,4.98842,-4.03,2456796.5,17.58899,5.40961,-4.03,2456797.5,18.67286,5.83015,-4.02,2456798.5,19.75913,6.24985,-4.01,2456799.5,20.84789,6.66853,-4.01,2456800.5,21.93926,7.08600,-4.00,2456801.5,23.03332,7.50206,-4.00,2456802.5,24.13017,7.91652,-3.99,2456803.5,25.22992,8.32920,-3.99,2456804.5,26.33265,8.73991,-3.98,2456805.5,27.43846,9.14846,-3.98,2456806.5,28.54743,9.55465,-3.97,2456807.5,29.65966,9.95829,-3.97,2456808.5,30.77524,10.35919,-3.96,2456809.5,31.89425,10.75716,-3.96,2456810.5,33.01679,11.15200,-3.95,2456811.5,34.14295,11.54353,-3.95,2456812.5,35.27282,11.93155,-3.94,2456813.5,36.40650,12.31588,-3.94,2456814.5,37.54407,12.69631,-3.94,2456815.5,38.68562,13.07267,-3.93,2456816.5,39.83126,13.44475,-3.93,2456817.5,40.98105,13.81238,-3.92,2456818.5,42.13509,14.17535,-3.92,2456819.5,43.29347,14.53349,-3.92,2456820.5,44.45625,14.88660,-3.91,2456821.5,45.62351,15.23449,-3.91,2456822.5,46.79531,15.57698,-3.91,2456823.5,47.97170,15.91387,-3.90,2456824.5,49.15272,16.24497,-3.90,2456825.5,50.33841,16.57008,-3.90,2456826.5,51.52880,16.88900,-3.89,2456827.5,52.72391,17.20156,-3.89,2456828.5,53.92376,17.50755,-3.89,2456829.5,55.12835,17.80680,-3.89,2456830.5,56.33768,18.09910,-3.88,2456831.5,57.55174,18.38429,-3.88,2456832.5,58.77049,18.66217,-3.88,2456833.5,59.99390,18.93257,-3.87,2456834.5,61.22192,19.19531,-3.87,2456835.5,62.45450,19.45020,-3.87,2456836.5,63.69159,19.69708,-3.87,2456837.5,64.93311,19.93578,-3.87,2456838.5,66.17899,20.16611,-3.86,2456839.5,67.42916,20.38792,-3.86]],
            ["Mars","rgb(255,50,50)",[2456474.5,80.64099,23.54688,1.53,2456475.5,81.38904,23.59991,1.53,2456476.5,82.13678,23.64934,1.53,2456477.5,82.88417,23.69519,1.54,2456478.5,83.63116,23.73746,1.54,2456479.5,84.37771,23.77615,1.54,2456480.5,85.12376,23.81128,1.55,2456481.5,85.86927,23.84284,1.55,2456482.5,86.61418,23.87085,1.55,2456483.5,87.35845,23.89531,1.56,2456484.5,88.10203,23.91623,1.56,2456485.5,88.84488,23.93362,1.56,2456486.5,89.58696,23.94749,1.57,2456487.5,90.32823,23.95785,1.57,2456488.5,91.06864,23.96471,1.57,2456489.5,91.80818,23.96807,1.57,2456490.5,92.54680,23.96797,1.58,2456491.5,93.28448,23.96441,1.58,2456492.5,94.02118,23.95740,1.58,2456493.5,94.75687,23.94698,1.59,2456494.5,95.49152,23.93314,1.59,2456495.5,96.22510,23.91592,1.59,2456496.5,96.95756,23.89532,1.59,2456497.5,97.68888,23.87136,1.60,2456498.5,98.41903,23.84405,1.60,2456499.5,99.14799,23.81341,1.60,2456500.5,99.87574,23.77946,1.60,2456501.5,100.60225,23.74222,1.61,2456502.5,101.32750,23.70172,1.61,2456503.5,102.05144,23.65797,1.61,2456504.5,102.77405,23.61100,1.61,2456505.5,103.49529,23.56083,1.61,2456506.5,104.21513,23.50750,1.62,2456507.5,104.93351,23.45103,1.62,2456508.5,105.65041,23.39144,1.62,2456509.5,106.36579,23.32876,1.62,2456510.5,107.07960,23.26302,1.62,2456511.5,107.79182,23.19423,1.62,2456512.5,108.50241,23.12244,1.63,2456513.5,109.21134,23.04766,1.63,2456514.5,109.91858,22.96992,1.63,2456515.5,110.62411,22.88924,1.63,2456516.5,111.32791,22.80566,1.63,2456517.5,112.02995,22.71921,1.63,2456518.5,112.73022,22.62990,1.63,2456519.5,113.42871,22.53778,1.64,2456520.5,114.12539,22.44288,1.64,2456521.5,114.82025,22.34522,1.64,2456522.5,115.51327,22.24484,1.64,2456523.5,116.20444,22.14176,1.64,2456524.5,116.89374,22.03602,1.64,2456525.5,117.58115,21.92763,1.64,2456526.5,118.26669,21.81663,1.64,2456527.5,118.95035,21.70304,1.64,2456528.5,119.63212,21.58690,1.64,2456529.5,120.31201,21.46823,1.64,2456530.5,120.99000,21.34708,1.64,2456531.5,121.66609,21.22346,1.64,2456532.5,122.34026,21.09743,1.65,2456533.5,123.01250,20.96901,1.65,2456534.5,123.68278,20.83825,1.65,2456535.5,124.35109,20.70517,1.65,2456536.5,125.01742,20.56981,1.65,2456537.5,125.68175,20.43220,1.65,2456538.5,126.34406,20.29239,1.65,2456539.5,127.00434,20.15041,1.65,2456540.5,127.66258,20.00628,1.65,2456541.5,128.31876,19.86005,1.64,2456542.5,128.97288,19.71175,1.64,2456543.5,129.62494,19.56141,1.64,2456544.5,130.27493,19.40907,1.64,2456545.5,130.92284,19.25476,1.64,2456546.5,131.56870,19.09852,1.64,2456547.5,132.21247,18.94038,1.64,2456548.5,132.85418,18.78037,1.64,2456549.5,133.49382,18.61854,1.64,2456550.5,134.13138,18.45492,1.64,2456551.5,134.76687,18.28953,1.64,2456552.5,135.40030,18.12241,1.64,2456553.5,136.03168,17.95359,1.63,2456554.5,136.66102,17.78310,1.63,2456555.5,137.28835,17.61097,1.63,2456556.5,137.91368,17.43723,1.63,2456557.5,138.53701,17.26191,1.63,2456558.5,139.15837,17.08505,1.63,2456559.5,139.77776,16.90668,1.62,2456560.5,140.39517,16.72685,1.62,2456561.5,141.01061,16.54559,1.62,2456562.5,141.62407,16.36293,1.62,2456563.5,142.23556,16.17892,1.62,2456564.5,142.84507,15.99359,1.61,2456565.5,143.45259,15.80697,1.61,2456566.5,144.05813,15.61911,1.61,2456567.5,144.66168,15.43003,1.61,2456568.5,145.26325,15.23978,1.60,2456569.5,145.86284,15.04839,1.60,2456570.5,146.46044,14.85589,1.60,2456571.5,147.05606,14.66231,1.59,2456572.5,147.64971,14.46770,1.59,2456573.5,148.24140,14.27208,1.59,2456574.5,148.83112,14.07550,1.58,2456575.5,149.41887,13.87798,1.58,2456576.5,150.00468,13.67957,1.58,2456577.5,150.58852,13.48029,1.57,2456578.5,151.17043,13.28018,1.57,2456579.5,151.75040,13.07926,1.57,2456580.5,152.32845,12.87757,1.56,2456581.5,152.90460,12.67513,1.56,2456582.5,153.47887,12.47198,1.55,2456583.5,154.05129,12.26813,1.55,2456584.5,154.62188,12.06362,1.55,2456585.5,155.19064,11.85849,1.54,2456586.5,155.75759,11.65276,1.54,2456587.5,156.32274,11.44647,1.53,2456588.5,156.88609,11.23965,1.53,2456589.5,157.44765,11.03234,1.52,2456590.5,158.00740,10.82457,1.52,2456591.5,158.56536,10.61638,1.51,2456592.5,159.12152,10.40781,1.51,2456593.5,159.67588,10.19888,1.50,2456594.5,160.22843,9.98964,1.50,2456595.5,160.77918,9.78012,1.49,2456596.5,161.32811,9.57035,1.48,2456597.5,161.87524,9.36037,1.48,2456598.5,162.42055,9.15020,1.47,2456599.5,162.96404,8.93989,1.47,2456600.5,163.50572,8.72946,1.46,2456601.5,164.04558,8.51895,1.45,2456602.5,164.58361,8.30839,1.45,2456603.5,165.11980,8.09783,1.44,2456604.5,165.65415,7.88729,1.43,2456605.5,166.18665,7.67679,1.43,2456606.5,166.71732,7.46639,1.42,2456607.5,167.24614,7.25609,1.41,2456608.5,167.77315,7.04592,1.41,2456609.5,168.29833,6.83592,1.40,2456610.5,168.82172,6.62611,1.39,2456611.5,169.34332,6.41651,1.38,2456612.5,169.86314,6.20716,1.37,2456613.5,170.38117,5.99807,1.37,2456614.5,170.89743,5.78929,1.36,2456615.5,171.41190,5.58084,1.35,2456616.5,171.92458,5.37276,1.34,2456617.5,172.43546,5.16509,1.33,2456618.5,172.94452,4.95785,1.32,2456619.5,173.45175,4.75107,1.32,2456620.5,173.95713,4.54480,1.31,2456621.5,174.46065,4.33907,1.30,2456622.5,174.96229,4.13391,1.29,2456623.5,175.46203,3.92935,1.28,2456624.5,175.95985,3.72543,1.27,2456625.5,176.45573,3.52218,1.26,2456626.5,176.94965,3.31963,1.25,2456627.5,177.44158,3.11782,1.24,2456628.5,177.93150,2.91679,1.23,2456629.5,178.41938,2.71655,1.22,2456630.5,178.90518,2.51716,1.21,2456631.5,179.38887,2.31864,1.20,2456632.5,179.87042,2.12102,1.19,2456633.5,180.34980,1.92435,1.18,2456634.5,180.82700,1.72864,1.16,2456635.5,181.30200,1.53393,1.15,2456636.5,181.77478,1.34023,1.14,2456637.5,182.24535,1.14757,1.13,2456638.5,182.71367,0.95598,1.12,2456639.5,183.17974,0.76549,1.11,2456640.5,183.64354,0.57611,1.09,2456641.5,184.10504,0.38789,1.08,2456642.5,184.56420,0.20085,1.07,2456643.5,185.02100,0.01502,1.06,2456644.5,185.47540,-0.16957,1.04,2456645.5,185.92735,-0.35288,1.03,2456646.5,186.37681,-0.53487,1.02,2456647.5,186.82373,-0.71552,1.00,2456648.5,187.26806,-0.89479,0.99,2456649.5,187.70975,-1.07264,0.98,2456650.5,188.14875,-1.24905,0.96,2456651.5,188.58500,-1.42397,0.95,2456652.5,189.01844,-1.59738,0.93,2456653.5,189.44901,-1.76923,0.92,2456654.5,189.87664,-1.93950,0.90,2456655.5,190.30127,-2.10815,0.89,2456656.5,190.72282,-2.27513,0.87,2456657.5,191.14121,-2.44043,0.86,2456658.5,191.55635,-2.60400,0.84,2456659.5,191.96817,-2.76579,0.83,2456660.5,192.37658,-2.92579,0.81,2456661.5,192.78151,-3.08395,0.79,2456662.5,193.18290,-3.24024,0.78,2456663.5,193.58068,-3.39464,0.76,2456664.5,193.97479,-3.54713,0.74,2456665.5,194.36518,-3.69767,0.73,2456666.5,194.75177,-3.84624,0.71,2456667.5,195.13450,-3.99281,0.69,2456668.5,195.51329,-4.13736,0.67,2456669.5,195.88806,-4.27984,0.66,2456670.5,196.25872,-4.42024,0.64,2456671.5,196.62518,-4.55851,0.62,2456672.5,196.98733,-4.69461,0.60,2456673.5,197.34509,-4.82853,0.58,2456674.5,197.69833,-4.96021,0.56,2456675.5,198.04695,-5.08961,0.54,2456676.5,198.39083,-5.21672,0.52,2456677.5,198.72986,-5.34147,0.51,2456678.5,199.06392,-5.46384,0.49,2456679.5,199.39286,-5.58379,0.46,2456680.5,199.71657,-5.70128,0.44,2456681.5,200.03490,-5.81626,0.42,2456682.5,200.34772,-5.92871,0.40,2456683.5,200.65486,-6.03857,0.38,2456684.5,200.95618,-6.14581,0.36,2456685.5,201.25151,-6.25038,0.34,2456686.5,201.54068,-6.35224,0.32,2456687.5,201.82354,-6.45135,0.29,2456688.5,202.09991,-6.54766,0.27,2456689.5,202.36965,-6.64114,0.25,2456690.5,202.63261,-6.73175,0.23,2456691.5,202.88865,-6.81946,0.20,2456692.5,203.13764,-6.90424,0.18,2456693.5,203.37944,-6.98606,0.16,2456694.5,203.61390,-7.06488,0.13,2456695.5,203.84087,-7.14067,0.11,2456696.5,204.06020,-7.21341,0.08,2456697.5,204.27172,-7.28304,0.06,2456698.5,204.47527,-7.34953,0.04,2456699.5,204.67067,-7.41284,0.01,2456700.5,204.85775,-7.47293,-0.01,2456701.5,205.03632,-7.52976,-0.04,2456702.5,205.20621,-7.58328,-0.07,2456703.5,205.36722,-7.63346,-0.09,2456704.5,205.51917,-7.68024,-0.12,2456705.5,205.66187,-7.72359,-0.14,2456706.5,205.79512,-7.76346,-0.17,2456707.5,205.91872,-7.79981,-0.20,2456708.5,206.03246,-7.83259,-0.22,2456709.5,206.13616,-7.86176,-0.25,2456710.5,206.22960,-7.88728,-0.28,2456711.5,206.31258,-7.90910,-0.31,2456712.5,206.38489,-7.92718,-0.33,2456713.5,206.44633,-7.94148,-0.36,2456714.5,206.49670,-7.95196,-0.39,2456715.5,206.53581,-7.95858,-0.42,2456716.5,206.56349,-7.96130,-0.45,2456717.5,206.57960,-7.96010,-0.48,2456718.5,206.58401,-7.95496,-0.50,2456719.5,206.57660,-7.94586,-0.53,2456720.5,206.55728,-7.93280,-0.56,2456721.5,206.52597,-7.91576,-0.59,2456722.5,206.48259,-7.89473,-0.62,2456723.5,206.42707,-7.86973,-0.65,2456724.5,206.35935,-7.84074,-0.68,2456725.5,206.27938,-7.80777,-0.71,2456726.5,206.18713,-7.77081,-0.73,2456727.5,206.08257,-7.72989,-0.76,2456728.5,205.96569,-7.68501,-0.79,2456729.5,205.83651,-7.63620,-0.82,2456730.5,205.69505,-7.58347,-0.85,2456731.5,205.54135,-7.52685,-0.88,2456732.5,205.37548,-7.46639,-0.91,2456733.5,205.19752,-7.40212,-0.94,2456734.5,205.00758,-7.33410,-0.97,2456735.5,204.80578,-7.26238,-0.99,2456736.5,204.59228,-7.18704,-1.02,2456737.5,204.36725,-7.10815,-1.05,2456738.5,204.13089,-7.02580,-1.08,2456739.5,203.88343,-6.94008,-1.10,2456740.5,203.62513,-6.85109,-1.13,2456741.5,203.35629,-6.75897,-1.16,2456742.5,203.07723,-6.66382,-1.18,2456743.5,202.78835,-6.56581,-1.21,2456744.5,202.49005,-6.46509,-1.24,2456745.5,202.18281,-6.36183,-1.26,2456746.5,201.86714,-6.25622,-1.29,2456747.5,201.54359,-6.14848,-1.31,2456748.5,201.21273,-6.03880,-1.33,2456749.5,200.87516,-5.92742,-1.36,2456750.5,200.53151,-5.81456,-1.38,2456751.5,200.18242,-5.70045,-1.40,2456752.5,199.82854,-5.58535,-1.42,2456753.5,199.47053,-5.46948,-1.44,2456754.5,199.10907,-5.35311,-1.46,2456755.5,198.74484,-5.23646,-1.47,2456756.5,198.37853,-5.11982,-1.48,2456757.5,198.01083,-5.00341,-1.48,2456758.5,197.64243,-4.88751,-1.48,2456759.5,197.27404,-4.77236,-1.47,2456760.5,196.90633,-4.65822,-1.46,2456761.5,196.54000,-4.54534,-1.45,2456762.5,196.17570,-4.43396,-1.44,2456763.5,195.81410,-4.32433,-1.43,2456764.5,195.45585,-4.21670,-1.41,2456765.5,195.10158,-4.11128,-1.40,2456766.5,194.75190,-4.00830,-1.38,2456767.5,194.40742,-3.90799,-1.37,2456768.5,194.06872,-3.81056,-1.35,2456769.5,193.73639,-3.71621,-1.34,2456770.5,193.41097,-3.62515,-1.32,2456771.5,193.09304,-3.53756,-1.30,2456772.5,192.78312,-3.45364,-1.29,2456773.5,192.48174,-3.37356,-1.27,2456774.5,192.18940,-3.29750,-1.25,2456775.5,191.90655,-3.22561,-1.23,2456776.5,191.63365,-3.15804,-1.21,2456777.5,191.37109,-3.09491,-1.19,2456778.5,191.11924,-3.03634,-1.17,2456779.5,190.87841,-2.98243,-1.15,2456780.5,190.64888,-2.93327,-1.13,2456781.5,190.43092,-2.88892,-1.11,2456782.5,190.22473,-2.84944,-1.09,2456783.5,190.03048,-2.81488,-1.06,2456784.5,189.84834,-2.78528,-1.04,2456785.5,189.67842,-2.76065,-1.02,2456786.5,189.52082,-2.74101,-1.00,2456787.5,189.37559,-2.72636,-0.98,2456788.5,189.24278,-2.71671,-0.96,2456789.5,189.12242,-2.71204,-0.93,2456790.5,189.01449,-2.71232,-0.91,2456791.5,188.91897,-2.71754,-0.89,2456792.5,188.83582,-2.72766,-0.87,2456793.5,188.76497,-2.74265,-0.84,2456794.5,188.70637,-2.76245,-0.82,2456795.5,188.65992,-2.78703,-0.80,2456796.5,188.62554,-2.81633,-0.78,2456797.5,188.60315,-2.85032,-0.76,2456798.5,188.59266,-2.88893,-0.73,2456799.5,188.59398,-2.93212,-0.71,2456800.5,188.60704,-2.97984,-0.69,2456801.5,188.63173,-3.03204,-0.67,2456802.5,188.66797,-3.08867,-0.65,2456803.5,188.71565,-3.14968,-0.62,2456804.5,188.77465,-3.21499,-0.60,2456805.5,188.84484,-3.28455,-0.58,2456806.5,188.92608,-3.35829,-0.56,2456807.5,189.01823,-3.43614,-0.54,2456808.5,189.12114,-3.51803,-0.52,2456809.5,189.23463,-3.60388,-0.50,2456810.5,189.35853,-3.69360,-0.48,2456811.5,189.49269,-3.78713,-0.46,2456812.5,189.63692,-3.88439,-0.44,2456813.5,189.79105,-3.98528,-0.42,2456814.5,189.95490,-4.08974,-0.40,2456815.5,190.12829,-4.19769,-0.38,2456816.5,190.31106,-4.30905,-0.36,2456817.5,190.50301,-4.42373,-0.34,2456818.5,190.70398,-4.54166,-0.32,2456819.5,190.91380,-4.66276,-0.30,2456820.5,191.13228,-4.78696,-0.28,2456821.5,191.35925,-4.91417,-0.27,2456822.5,191.59454,-5.04431,-0.25,2456823.5,191.83800,-5.17733,-0.23,2456824.5,192.08947,-5.31313,-0.21,2456825.5,192.34882,-5.45165,-0.19,2456826.5,192.61592,-5.59283,-0.18,2456827.5,192.89067,-5.73661,-0.16,2456828.5,193.17295,-5.88293,-0.14,2456829.5,193.46266,-6.03174,-0.13,2456830.5,193.75972,-6.18296,-0.11,2456831.5,194.06401,-6.33656,-0.09,2456832.5,194.37543,-6.49246,-0.08,2456833.5,194.69389,-6.65061,-0.06,2456834.5,195.01926,-6.81094,-0.04,2456835.5,195.35145,-6.97339,-0.03,2456836.5,195.69035,-7.13791,-0.01,2456837.5,196.03584,-7.30441,-0.01,2456838.5,196.38783,-7.47285,0.02,2456839.5,196.74620,-7.64316,0.03]],
            ["Jupiter","rgb(255,150,150)",[2456474.5,91.22580,23.22051,-1.91,2456484.5,93.69042,23.19678,-1.91,2456494.5,96.10542,23.13593,-1.92,2456504.5,98.44898,23.04153,-1.93,2456514.5,100.69851,22.91853,-1.96,2456524.5,102.82743,22.77329,-1.99,2456534.5,104.81110,22.61314,-2.02,2456544.5,106.62191,22.44687,-2.07,2456554.5,108.22942,22.28406,-2.12,2456564.5,109.60500,22.13459,-2.17,2456574.5,110.71640,22.00919,-2.23,2456584.5,111.53287,21.91768,-2.30,2456594.5,112.02888,21.86830,-2.37,2456604.5,112.18092,21.86758,-2.43,2456614.5,111.97878,21.91776,-2.50,2456624.5,111.42877,22.01666,-2.56,2456634.5,110.55452,22.15723,-2.62,2456644.5,109.40875,22.32703,-2.66,2456654.5,108.06771,22.51118,-2.69,2456664.5,106.62721,22.69384,-2.70,2456674.5,105.19885,22.86087,-2.67,2456684.5,103.88882,23.00306,-2.64,2456694.5,102.79196,23.11523,-2.58,2456704.5,101.98294,23.19611,-2.52,2456714.5,101.50553,23.24708,-2.45,2456724.5,101.38248,23.26957,-2.38,2456734.5,101.61476,23.26483,-2.31,2456744.5,102.18511,23.23278,-2.23,2456754.5,103.07011,23.17190,-2.16,2456764.5,104.23760,23.08036,-2.10,2456774.5,105.65303,22.95539,-2.04,2456784.5,107.28421,22.79405,-1.99,2456794.5,109.09615,22.59428,-1.94,2456804.5,111.05785,22.35409,-1.90,2456814.5,113.14144,22.07230,-1.86,2456824.5,115.31775,21.74897,-1.84,2456834.5,117.56260,21.38470,-1.82]],
            ["Saturne","rgb(200,150,150)",[2456474.5,213.43924,-10.77595,1.18,2456484.5,213.38929,-10.80570,1.23,2456494.5,213.49677,-10.89043,1.27,2456504.5,213.75872,-11.02768,1.31,2456514.5,214.17001,-11.21397,1.34,2456524.5,214.72219,-11.44448,1.36,2456534.5,215.40312,-11.71336,1.38,2456544.5,216.20117,-12.01481,1.39,2456554.5,217.10234,-12.34229,1.38,2456564.5,218.09096,-12.68900,1.37,2456574.5,219.15230,-13.04860,1.36,2456584.5,220.26942,-13.41441,1.33,2456594.5,221.42526,-13.78004,1.30,2456604.5,222.60273,-14.13941,1.28,2456614.5,223.78251,-14.48665,1.31,2456624.5,224.94632,-14.81634,1.34,2456634.5,226.07506,-15.12344,1.37,2456644.5,227.14762,-15.40312,1.38,2456654.5,228.14501,-15.65157,1.39,2456664.5,229.04744,-15.86518,1.39,2456674.5,229.83488,-16.04081,1.38,2456684.5,230.49048,-16.17633,1.36,2456694.5,230.99789,-16.27000,1.33,2456704.5,231.34423,-16.32088,1.30,2456714.5,231.52159,-16.32898,1.25,2456724.5,231.52511,-16.29505,1.21,2456734.5,231.35810,-16.22129,1.15,2456744.5,231.03051,-16.11104,1.09,2456754.5,230.55788,-15.96885,1.03,2456764.5,229.96565,-15.80136,0.97,2456774.5,229.28418,-15.61629,0.92,2456784.5,228.54825,-15.42258,0.87,2456794.5,227.79726,-15.23036,0.88,2456804.5,227.06876,-15.04966,0.93,2456814.5,226.39954,-14.89033,0.99,2456824.5,225.82256,-14.76116,1.05,2456834.5,225.36295,-14.66905,1.11]],
            ["Uranus","rgb(130,150,255)",[2456474.5,11.68524,4.26131,5.84,2456494.5,11.78993,4.29416,5.80,2456514.5,11.60000,4.20364,5.77,2456534.5,11.14671,4.00416,5.74,2456554.5,10.49986,3.72606,5.72,2456574.5,9.76319,3.41372,5.72,2456594.5,9.05949,3.11949,5.73,2456614.5,8.50801,2.89391,5.76,2456634.5,8.20411,2.77688,5.79,2456654.5,8.20303,2.79070,5.83,2456674.5,8.51624,2.93862,5.87,2456694.5,9.11473,3.20643,5.90,2456714.5,9.94140,3.56795,5.92,2456734.5,10.92070,3.98954,5.93,2456754.5,11.96871,4.43457,5.93,2456774.5,12.99963,4.86656,5.93,2456794.5,13.93188,5.25163,5.91,2456814.5,14.69128,5.56008,5.89,2456834.5,15.21530,5.76768,5.85]],
            ["Neptune","rgb(100,100,255)",[2456474.5,337.29849,-10.21336,7.86,2456494.5,336.98802,-10.34344,7.84,2456514.5,336.54551,-10.52194,7.83,2456534.5,336.03597,-10.72256,7.82,2456554.5,335.53577,-10.91563,7.83,2456574.5,335.12211,-11.07201,7.84,2456594.5,334.86154,-11.16764,7.86,2456614.5,334.79872,-11.18692,7.89,2456634.5,334.95207,-11.12412,7.91,2456654.5,335.31179,-10.98356,7.94,2456674.5,335.84461,-10.77793,7.95,2456694.5,336.49809,-10.52693,7.97,2456714.5,337.21013,-10.25415,7.97,2456734.5,337.91508,-9.98489,7.96,2456754.5,338.55008,-9.74378,7.95,2456774.5,339.05963,-9.55294,7.93,2456794.5,339.40083,-9.42944,7.91,2456814.5,339.54669,-9.38388,7.89,2456834.5,339.48931,-9.41868,7.86]]
        ]
};

/**************************************************************************************************************/

var interpolate = function(jd,data){
		var mindt = jd;        // Arbitrary starting value in days
		var mini = 0;        // index where we find the minimum
		for(var i = 0 ; i < data.length ; i+=4){
			// Find the nearest point to now
			var dt = (jd-data[i]);
			if(Math.abs(dt) < Math.abs(mindt)){ mindt = dt; mini = i; }
		}
		var dra,ddec,dmag,pos_2,pos_1,fract;
		if(mindt >= 0){
			pos_2 = mini+1+4;
			pos_1 = mini+1;
			fract = mindt/Math.abs(data[pos_2-1]-data[pos_1-1]);
		}else{
			pos_2 = mini+1;
			pos_1 = mini+1-4;
			fract = (1+(mindt)/Math.abs(data[pos_2-1]-data[pos_1-1]));
		}
		// We don't want to attempt to find positions beyond the edges of the array
		if(pos_2 > data.length || pos_1 < 0){
			dra = data[mini+1];
			ddec = data[mini+2];
			dmag = data[mini+3];
		}else{
			dra = (Math.abs(data[pos_2]-data[pos_1]) > 180) ? (data[pos_1]+(data[pos_2]+360-data[pos_1])*fract)%360 : (data[pos_1]+(data[pos_2]-data[pos_1])*fract)%360;
			ddec = data[pos_1+1]+(data[pos_2+1]-data[pos_1+1])*fract;
			dmag = data[pos_1+2]+(data[pos_2+2]-data[pos_1+2])*fract;
		}
		return { ra: dra, dec:ddec, mag:dmag }
}

/**************************************************************************************************************/

/**
 * 	Handle features on layer
 */
var computePositions = function(gwLayer)
{
	var jd = getJD();
	var ra, dec, name, color;
	var pois = [];
	for ( p=0; p<data.planets.length; p++ )
	{
		name = data.planets[p][0];
		color = data.planets[p][1];
		if(data.planets[p].length == 3){
			// Find nearest JD
			if(data.planets[p][2].length%4 == 0){
				if(jd > data.planets[p][2][0] && jd < data.planets[p][2][(data.planets[p][2].length-4)]){
					var interp = interpolate(jd,data.planets[p][2]);
					ra = interp.ra;
					dec = interp.dec;
					mag = interp.mag;
				}else{
					continue;	// We don't have data for this planet so skip to the next
				}
			}
		} else {
			ra = data.planets[p][2];
			dec = data.planets[p][3];
		}

		// Add label
		var poi = {
			geometry: {
				type: "Point",
				gid: "planetLabel_"+name,
				coordinates: [ra,dec]
			},
			properties: {
				name: name,
				style: new FeatureStyle({
					label: name,
					strokeColor: FeatureStyle.fromStringToColor(color),
					fillColor: FeatureStyle.fromStringToColor(color)
				})
			}
		};

		pois.push(poi);

		// Add point itself
		poi = {
			geometry: {
				type: "Point",
				gid: "planetPoint_"+name,
				coordinates: [ra,dec]
			},
			properties: {
				name: name,
				style: new FeatureStyle({
					// TODO: replace relative url to mizar script's one..
					iconUrl: "css/images/star.png",
					strokeColor: FeatureStyle.fromStringToColor(color),
					fillColor: FeatureStyle.fromStringToColor(color)
				})
			}
		};
		
		pois.push(poi);		
	}
	
	// Create feature collection
	poiFeatureCollection = {
		type: "FeatureCollection",
		features : pois
	};
	
	gwLayer.addFeatureCollection(poiFeatureCollection);
}

/**************************************************************************************************************/

// Register the data provider
LayerManager.registerDataProvider("planets", function(gwLayer, configuration){

	var interval = configuration.interval ? configuration.interval : 60000; // Recompute planet position every minute if not defined
	computePositions(gwLayer);
	setInterval( function(){
		gwLayer.removeFeatureCollection(poiFeatureCollection);
		computePositions(gwLayer);
	}, interval );
});

});
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('gw/VectorRenderer',['./RendererTileData','./Tile'],
	function(RendererTileData, Tile) {

/**************************************************************************************************************/

/** @constructor
	VectorRenderer constructor
 */
var VectorRenderer = function(globe)
{
	this.tileManager = globe.tileManager;
	this.globe = globe;
	this.buckets = [];
	this.maxTilePerGeometry = 100;
	this.levelZeroTiledGeometries = [];
}

/**************************************************************************************************************/

/**
	Find a compatible bucket
 */
VectorRenderer.prototype.findBucket = function(layer,style)
{
	// Find an existing bucket for the given style
	for ( var i = 0; i < this.buckets.length; i++ )
	{
		var bucket = this.buckets[i];
		if ( bucket.layer == layer 
			&& bucket.isCompatible(style) )
		{
			return bucket;
		}
	}

	return null;
}


/**************************************************************************************************************/

/**
 	Generate the level zero for a tile
 */
VectorRenderer.prototype.generateLevelZero = function(tile)
{
	for ( var i=0; i < this.levelZeroTiledGeometries.length; i++ )
	{
		var geometry = this.levelZeroTiledGeometries[i];
		
		// Check that the geometry is on this tile
		var isFound = false;
		for ( var n = 0; n < geometry._tileIndices.length && !isFound; n++ )
		{
			var t = this.tileManager.level0Tiles[ geometry._tileIndices[n] ];
			isFound = ( t == tile );
		}
		
		// Found the tile, so add it
		if ( isFound )
		{
			this._addGeometryToTile(geometry._bucket, geometry, tile);
		}
	}
}

/**************************************************************************************************************/

/**
 	Recursively add a geometry to a tile
*/
VectorRenderer.prototype._recursiveAddGeometryToTile = function(bucket, geometry, tile)
{
	var renderable = this._addGeometryToTile(bucket, geometry, tile);
	
	if ( renderable && renderable.generateChild && tile.children)
	{
		for ( var i = 0; i < 4; i++ )
		{
			if ( tile.children[i].state == Tile.State.LOADED )
			{
				renderable.hasChildren = true;
				this._recursiveAddGeometryToTile( bucket, geometry, tile.children[i] );
			}
		}
	}
}

/**************************************************************************************************************/

/**
 	Add a geometry to a vector renderer
 */
VectorRenderer.prototype.addGeometry = function(layer, geometry, style)
{
	var bucket = this.getOrCreateBucket(layer, geometry, style);
	geometry._bucket = bucket;
	
	var tileIndices = this.maxTilePerGeometry > 0 ? this.tileManager.getOverlappedLevelZeroTiles(geometry) : null;
	if ( tileIndices && tileIndices.length < this.maxTilePerGeometry )
	{
		// Add geometry to each tile in range
		for ( var i=0; i < tileIndices.length; i++ )
		{
			var tile = this.tileManager.level0Tiles[ tileIndices[i] ];
			if ( tile.state == Tile.State.LOADED )
			{
				this._recursiveAddGeometryToTile(bucket, geometry, tile);
			}
		}
		
		geometry._tileIndices = tileIndices;
		this.levelZeroTiledGeometries.push(geometry);
	}
	else
	{
		// Attach to mainRenderable
		if (!bucket.mainRenderable)
		{
			bucket.mainRenderable = bucket.createRenderable();
		}
		bucket.mainRenderable.add(geometry);
	}
}

/**************************************************************************************************************/

/**
 	Remove a geometry from a vector renderer
 */
VectorRenderer.prototype.removeGeometry = function(geometry)
{
	var tileIndices = geometry._tileIndices;

	if ( tileIndices )
	{
		// Remove from tile
		for ( var i = 0; i < tileIndices.length; i++ )
		{
			var tile = this.tileManager.level0Tiles[ tileIndices[i] ];
			this.removeGeometryFromTile(geometry, tile);
		}
		// Remove from geometry arrays
		this.levelZeroTiledGeometries.splice( this.levelZeroTiledGeometries.indexOf(geometry), 1 );
		
		 geometry._tileIndices = null;
	}
	else
	{
		var bucket = geometry._bucket;
		if ( bucket.mainRenderable )
		{
			var numGeometries = bucket.mainRenderable.remove(geometry);
			if ( numGeometries == 0 )
			{
				bucket.mainRenderable.dispose(this.renderContext);
				bucket.mainRenderable = null;
			}
		}
	}
}

/**************************************************************************************************************/

/**
 	Get or create a bucket for the given configuration
 */
VectorRenderer.prototype.getOrCreateBucket = function(layer, geometry, style )
{		
	// Then find an existing bucket
	var bucket = this.findBucket(layer,style);
	if (!bucket)
	{
		bucket = this.createBucket(layer,style);
		bucket.renderer = this;
		bucket.id = this.globe.vectorRendererManager.bucketId++;
		this.buckets.push( bucket );
	}
	return bucket;
}

/**************************************************************************************************************/

/**
	Add a geometry to a tile
 */
VectorRenderer.prototype.addGeometryToTile = function(layer, geometry, style, tile)
{
	var bucket = this.getOrCreateBucket(layer, geometry, style);
	geometry._bucket = bucket;
	return this._addGeometryToTile( bucket, geometry, tile );
}
	
/**************************************************************************************************************/

/**
	Internal method to add a geometry to a tile
 */
VectorRenderer.prototype._addGeometryToTile = function(bucket, geometry, tile)
{	
	var tileData = tile.extension.renderer;
	if (!tileData)
	{
		tileData = tile.extension.renderer = new RendererTileData(this.globe.vectorRendererManager);
	}
	
	var renderable = tileData.getRenderable(bucket);
	var needsToAdd = false;
	if (!renderable) 
	{
		renderable = bucket.createRenderable();
		needsToAdd = true;
	}
	
	if ( renderable.add(geometry, tile) )
	{
		if (needsToAdd)
		{
			tileData.renderables.push(renderable);
		}
		return renderable;
	}
	
	return null;
}

/**************************************************************************************************************/

/**
	Remove a geometry from a tile
 */
VectorRenderer.prototype.removeGeometryFromTile = function(geometry,tile)
{
	var tileData = tile.extension.renderer;
	if (tileData)
	{
		var i = 0;
		while ( i < tileData.renderables.length )
		{
			var renderable = tileData.renderables[i];
			var renderer = renderable.bucket.renderer;
			if ( renderer == this )
			{
				// Remove renderable
				var numGeometries = renderable.remove(geometry);
				if ( numGeometries == 0 )
				{
					tileData.renderables.splice(i,1);
				}
				else
				{
					i++;
				}
	
				// Remove geoemtry from children if needed
				if ( renderable.hasChildren && tile.children)
				{
					for ( var n = 0; n < 4; n++ )
					{
						if ( tile.children[n].state == Tile.State.LOADED )
						{
							this.removeGeometryFromTile( geometry, tile.children[n] );
						}
					}
				}
			}
			else
			{
				i++;
			}
		}
	}
}

/**************************************************************************************************************/

return VectorRenderer;

});
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/
 
 define('gw/Triangulator',[], function() {
 
 /**
  Triangulator code taken from http://www.flipcode.com/archives/Efficient_Polygon_Triangulation.shtml
  Does not manage holes
  Seems to be O(n^3)!
 */
var EPSILON = 0.0000000001;

/*
 Compute the signed area of a polygon
*/
var Area = function(contour)
{
	var n = contour.length;
	var A=0.0;
	for(var p=n-1,q=0; q<n; p=q++)
	{
		A+= contour[p][0]*contour[q][1] - contour[q][0]*contour[p][1];
	}
	return A*0.5;
}

/*
 InsideTriangle decides if a point P is Inside of the triangle
 defined by A, B, C.
*/
var InsideTriangle = function(Ax, Ay,
					  Bx, By,
					  Cx, Cy,
					  Px, Py)

{
  var ax, ay, bx, by, cx, cy, apx, apy, bpx, bpy, cpx, cpy;
  var cCROSSap, bCROSScp, aCROSSbp;

  ax = Cx - Bx;  ay = Cy - By;
  bx = Ax - Cx;  by = Ay - Cy;
  cx = Bx - Ax;  cy = By - Ay;
  apx= Px - Ax;  apy= Py - Ay;
  bpx= Px - Bx;  bpy= Py - By;
  cpx= Px - Cx;  cpy= Py - Cy;

  aCROSSbp = ax*bpy - ay*bpx;
  cCROSSap = cx*apy - cy*apx;
  bCROSScp = bx*cpy - by*cpx;

  return ((aCROSSbp >= 0.0) && (bCROSScp >= 0.0) && (cCROSSap >= 0.0));
};

/*
 Check if the giben triangle (u,v,w) is a ear : not other vertex inside
*/
var Snip = function(contour, u, v, w, n, V)
{
  var p;
  var Ax, Ay, Bx, By, Cx, Cy, Px, Py;

  Ax = contour[V[u]][0];
  Ay = contour[V[u]][1];

  Bx = contour[V[v]][0];
  By = contour[V[v]][1];

  Cx = contour[V[w]][0];
  Cy = contour[V[w]][1];

  if ( EPSILON > (((Bx-Ax)*(Cy-Ay)) - ((By-Ay)*(Cx-Ax))) ) return false;

  for (p=0;p<n;p++)
  {
	if( (p == u) || (p == v) || (p == w) ) continue;
	Px = contour[V[p]][0];
	Py = contour[V[p]][1];
	if (InsideTriangle(Ax,Ay,Bx,By,Cx,Cy,Px,Py)) return false;
  }

  return true;
}
			
/*
 Process triangulation on the given contour
*/
var Process = function( contour )
{
  /* allocate and initialize list of Vertices in polygon */

  var n = contour.length; 
  if ( contour[0][0] == contour[n-1][0] && contour[0][1] == contour[n-1][1] )
	n--;
	
  if ( n < 3 ) return null;

  var V = new Array(n);

  /* we want a counter-clockwise polygon in V */

  if ( 0.0 < Area(contour) )
	for (var v=0; v<n; v++) V[v] = v;
  else
	for(var v=0; v<n; v++) V[v] = (n-1)-v;

  var nv = n;
  
  var results = [];

  /*  remove nv-2 Vertices, creating 1 triangle every time */
  var count = 2*nv;   /* error detection */

  for (var m=0, v=nv-1; nv>2; )
  {
	/* if we loop, it is probably a non-simple polygon */
	if (0 >= (count--))
	{
	  //** Triangulate: ERROR - probable bad polygon!
	  return null;
	}

	/* three consecutive vertices in current polygon, <u,v,w> */
	var u = v  ; if (nv <= u) u = 0;     /* previous */
	v = u+1; if (nv <= v) v = 0;     /* new v    */
	var w = v+1; if (nv <= w) w = 0;     /* next     */

	if ( Snip(contour,u,v,w,nv,V) )
	{
	  var a,b,c,s,t;

	  /* true names of the vertices */
	  a = V[u]; b = V[v]; c = V[w];

	  /* output Triangle */
	  results.push( a );
	  results.push( b );
	  results.push( c );
	  
	  m++;

	  /* remove v from remaining polygon */
	  for(s=v,t=v+1;t<nv;s++,t++) V[s] = V[t]; nv--;

	  /* resest error detection counter */
	  count = 2*nv;
	}
  }

  return results;
}
	
var Triangulator = 	{
	process: Process
};

return Triangulator;

});

/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('gw/ConvexPolygonRenderer',['./Utils','./VectorRenderer','./Program','./CoordinateSystem','./FeatureStyle', './VectorRendererManager', './Triangulator', './glMatrix'],
	function(Utils,VectorRenderer,Program,CoordinateSystem,FeatureStyle,VectorRendererManager, Triangulator) {

/**************************************************************************************************************/

/** @constructor
	ConvexPolygonRenderer constructor
 */
var ConvexPolygonRenderer = function(globe)
{
	VectorRenderer.prototype.constructor.call( this, globe );
	this.maxTilePerGeometry = 2;
	
	// Store object for rendering
	this.renderContext = globe.tileManager.renderContext;
	this.tileConfig = globe.tileManager.tileConfig;
	
	this.programs = [];

	this.basicVertexShader = "\
	attribute vec3 vertex;\n\
	uniform mat4 viewProjectionMatrix;\n\
	\n\
	void main(void)\n\
	{\n\
		gl_Position = viewProjectionMatrix * vec4(vertex, 1.0);\n\
	}\n\
	";
	
	this.basicFragmentShader = "\
	precision lowp float; \n\
	uniform vec4 color; \n\
	\n\
	void main(void) \n\
	{ \n\
		gl_FragColor = color; \n\
	} \n\
	";
	
	this.texVertexShader = "\
	attribute vec3 vertex;\n\
	attribute vec2 tcoord;\n\
	uniform mat4 viewProjectionMatrix;\n\
	\n\
	varying vec2 vTextureCoord;\n\
	\n\
	void main(void) \n\
	{\n\
		vTextureCoord = tcoord;\n\
		vTextureCoord.y = 1.0 - vTextureCoord.y; \n\
		gl_Position = viewProjectionMatrix * vec4(vertex, 1.0);\n\
	}\n\
	";


	this.texFragmentShader = "\
		precision lowp float; \n\
		uniform vec4 color;\n\
		varying vec2 vTextureCoord;\n\
		uniform sampler2D texture; \n\
		void main(void)\n\
		{\n\
			gl_FragColor = texture2D(texture, vTextureCoord) * color;\n\
		}\n\
		";

	this.basicFillShader = {
		vertexCode: this.basicVertexShader,
		fragmentCode: this.basicFragmentShader,
		updateUniforms: null
	};

	this.texFillShader = {
		vertexCode: this.texVertexShader,
		fragmentCode: this.texFragmentShader,
		updateUniforms: null
	};


	this.basicProgram = this.createProgram(this.basicFillShader);
	this.texProgram = this.createProgram(this.texFillShader);

	var gl = this.renderContext.gl;
	// Parameters used to implement ONE shader for color xor texture rendering
	this.whiteTexture = gl.createTexture();
	gl.bindTexture(gl.TEXTURE_2D, this.whiteTexture);
	var whitePixel = new Uint8Array([255, 255, 255, 255]);
	gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, whitePixel);

	// Shared buffer
	// Create texCoord buffer
	this.tcoordBuffer = gl.createBuffer();
	gl.bindBuffer(gl.ARRAY_BUFFER, this.tcoordBuffer);
	
	var textureCoords = [
		0.0, 0.0,
		1.0, 0.0,
		1.0, 1.0,
		0.0, 1.0,
		0.0, 0.0
	];
	
	gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(textureCoords), gl.STATIC_DRAW);
	this.tcoordBuffer.itemSize = 2;
	this.tcoordBuffer.numItems = 5;
}

Utils.inherits(VectorRenderer,ConvexPolygonRenderer);

/**************************************************************************************************************/

/**
	Renderable constructor
	Attach to a bucket
 */
var Renderable = function(bucket) 
{
	this.bucket = bucket;
	this.geometry2vb = {};
	this.vertices = [];
	this.lineIndices = [];
	this.triangleIndices = [];
	this.vertexBuffer = null;
	this.lineIndexBuffer = null;
	this.triangleIndexBuffer = null;
	this.bufferDirty = false;
	this.triBufferDirty = false;
	this.tcoords = [];
}

/**************************************************************************************************************/

/**
 *	Add the geometry to the renderable
 * @return if the geometry has been successfully added to the renderable
 */
Renderable.prototype.add = function(geometry)
{
	var rings = [];
	if ( geometry['type'] == 'MultiPolygon' )
	{
		for ( var i=0; i<geometry['coordinates'].length; i++ )
		{
			rings.push( geometry['coordinates'][i][0] );
		}
	}
	else
	{
		rings.push( geometry['coordinates'][0] );
	}

	for ( var r=0; r<rings.length; r++ )
	{
		var coords = rings[r];
		// var coords = geometry['coordinates'][0];
		var numPoints = coords.length-1;
		
		// Store information for the geometry in the buffers used for rendering
		var data = {
			vertexStart: this.vertices.length,
			vertexCount: 3 * numPoints,
			lineIndexStart: this.lineIndices.length,
			lineIndexCount: 2 * numPoints,
			triIndexStart: 0,
			triIndexCount: 0
		};

		// Compute texture coordinates if defined
		if ( geometry._imageCoordinates )
		{
			data.tcoordsStart = this.tcoords.length;
			data.tcoordsCount = 2 * numPoints;

			// Initialize variables used for texture coordinates computation
			var p0 = CoordinateSystem.fromGeoTo3D( geometry._imageCoordinates[0][0] ); // origin
			var p1 = CoordinateSystem.fromGeoTo3D( geometry._imageCoordinates[0][1] );
			var p3 = CoordinateSystem.fromGeoTo3D( geometry._imageCoordinates[0][3] ); 
			var v01 = [];
			vec3.subtract( p1, p0, v01 ); // U-axis
			var v03 = [];
			vec3.subtract( p3, p0, v03 ); // V-axis
			var squaredU = vec3.length(v01) * vec3.length(v01);
			var squaredV = vec3.length(v03) * vec3.length(v03);

			for ( var i=0; i<numPoints; i++ )
			{
				var pt = CoordinateSystem.fromGeoTo3D( coords[i] );
				var v0P = [];
				vec3.subtract( pt, p0, v0P );

				var uDotProduct = vec3.dot( v0P, v01 );
				var vDotProduct = vec3.dot( v0P, v03 );
				var u = uDotProduct / squaredU;
				var v = vDotProduct / squaredV;
				this.tcoords.push( u );
				this.tcoords.push( v );		
			}

		}
		
		// Compute vertices and indices and store them in the buffers
		var startIndex = this.vertices.length / 3;
		for ( var i = 0; i < numPoints; i++ ) 
		{
			var pt = CoordinateSystem.fromGeoTo3D( coords[i] );
			this.vertices.push( pt[0], pt[1], pt[2] );
			this.lineIndices.push( startIndex + i, startIndex + ((i+1) % numPoints) );
		}
		
		// If fill, build the triangle indices
		if ( this.bucket.style.fill ) 
		{
			data.triIndexStart = this.triangleIndices.length;
			data.triIndexCount = 3 * (numPoints-2);
			
			var triangleIndices = Triangulator.process( coords );
			if ( triangleIndices != null  )
			{
				this.triangleIndices = triangleIndices;
			}
			else
			{
				// HACK for not trivial polygons
				for ( var i = 0; i < numPoints-2; i++ ) 
				{
					this.triangleIndices.push( startIndex, startIndex + i+1, startIndex + i+2 );
				}
			}
		}

		if ( this.geometry2vb[ geometry.gid ] )
		{
			this.geometry2vb[ geometry.gid ].vertexCount += data.vertexCount;
			this.geometry2vb[ geometry.gid ].lineIndexCount += data.lineIndexCount;
			this.geometry2vb[ geometry.gid ].triIndexCount += data.triIndexCount;
		}
		else
		{
			this.geometry2vb[ geometry.gid ] = data;
		}
		
		this.bufferDirty = true;
		this.triBufferDirty = true;
	}
	
	return true;
}

/**************************************************************************************************************/

/**
	Remove the geometry from the renderable
 */
Renderable.prototype.remove = function(geometry)
{
	if ( this.geometry2vb.hasOwnProperty(geometry.gid) )
	{
		// retreive the render data for the geometry
		var data = this.geometry2vb[ geometry.gid ];
		delete this.geometry2vb[ geometry.gid ];

		// Remove geometry vertex
		this.vertices.splice( data.vertexStart, data.vertexCount );
		
		// Update indices after vertex removal
		for ( var i = data.lineIndexStart+data.lineIndexCount; i < this.lineIndices.length; i++ ) 
		{
			this.lineIndices[i] -= (data.vertexCount/3);
		}
		for ( var i = data.triIndexStart+data.triIndexCount; i < this.triangleIndices.length; i++ ) 
		{
			this.triangleIndices[i] -= (data.vertexCount/3);
		}

		this.lineIndices.splice( data.lineIndexStart, data.lineIndexCount );
		this.triangleIndices.splice( data.triIndexStart, data.triIndexCount );
		if ( data.tcoordsStart >= 0 )
		{
			this.tcoords.splice( data.tcoordsStart, data.tcoordsCount );
		}
		
		// Update render data for all other geometries
		for ( var g in this.geometry2vb ) 
		{
			if ( g ) 
			{
				var d = this.geometry2vb[g];
				if ( d.vertexStart > data.vertexStart ) 
				{
					d.vertexStart -= data.vertexCount;
					d.lineIndexStart -= data.lineIndexCount;
					d.triIndexStart -= data.triIndexCount;
					if ( d.tcoordsStart >= 0 )
					{
						d.tcoordsStart -= data.tcoordsCount;
					}
				}
			}
		}
		
		this.bufferDirty = true;
		this.triBufferDirty = true;
	}
	return this.vertices.length;
}

/**************************************************************************************************************/

/**
	Dispose the renderable : remove all buffers
 */
Renderable.prototype.dispose = function(renderContext)
{
	if ( this.vertexBuffer ) 
	{
		renderContext.gl.deleteBuffer( this.vertexBuffer );
	}
	if ( this.lineIndexBuffer ) 
	{
		renderContext.gl.deleteBuffer( this.lineIndexBuffer );
	}
	if ( this.triangleIndexBuffer ) 
	{
		renderContext.gl.deleteBuffer( this.triangleIndexBuffer );
	}
	if ( this.tcoordBuffer )
	{
		renderContext.gl.deleteBuffer( this.tcoordBuffer );
	}
}

/**************************************************************************************************************/

/**
	Check if renderer is applicable
 */
ConvexPolygonRenderer.prototype.canApply = function(type,style)
{
	return type == "Polygon" || type == "MultiPolygon" || type == "LineString" || type == "MultiLineString"; 
}

/**************************************************************************************************************/

/**
 	Create program from fillShader object	
 */
ConvexPolygonRenderer.prototype.createProgram = function(fillShader)
{
	var program = new Program(this.renderContext);
	program.createFromSource(fillShader.vertexCode, fillShader.fragmentCode);
	
    // Add program
    program.id = this.programs.length;
    this.programs.push({ 
    	fillShader: fillShader,
    	program: program
	});
	return program;
}

/**************************************************************************************************************/

/**
 	Get program if known by renderer, create otherwise
 */
ConvexPolygonRenderer.prototype.getProgram = function(fillShader) {

	var program;

    for(var id=0; id<this.programs.length; id++)
    {
        if( this.programs[id].fillShader == fillShader )
        {
        	program = this.programs[id].program;
        }
    }

    if ( !program )
    {
    	program = this.createProgram(fillShader);
    }
    return program;
}

/**************************************************************************************************************/

/**
	Bucket constructor for ConvexPolygonRenderer
 */
var Bucket = function(layer,style)
{
	this.layer = layer;
	this.style = new FeatureStyle(style);
	this.texture = null;
	this.polygonProgram = null;
	this.renderer = null;
	this.mainRenderable = null;
}

/**************************************************************************************************************/

/**
	Create a renderable for this bucket
 */
Bucket.prototype.createRenderable = function()
{
	return new Renderable(this);
}

/**************************************************************************************************************/

/**
	Check if a bucket is compatible
 */
Bucket.prototype.isCompatible = function(style)
{
	if ( this.style.strokeColor[0] == style.strokeColor[0]
		&& this.style.strokeColor[1] == style.strokeColor[1]
		&& this.style.strokeColor[2] == style.strokeColor[2]
		&& this.style.fill == style.fill
		&& this.style.fillTexture == style.fillTexture
		&& this.style.fillTextureUrl == style.fillTextureUrl
		&& this.style.fillShader == style.fillShader )
	{
		return true;
	}
	
	return false;
}

/**************************************************************************************************************/

/**
	Create bucket to render a polygon
 */
ConvexPolygonRenderer.prototype.createBucket = function(layer,style)
{
	var gl = this.renderContext.gl;
	var vb = gl.createBuffer();

	// Create a bucket
	var bucket = new Bucket(layer,style);

	// Create texture
	var self = this;
	if ( style.fill )
	{
		var hasTexture = false;
		if ( style.fillTextureUrl )
		{
			var image = new Image();
			image.crossOrigin = '';
			image.onload = function () 
			{
				bucket.texture = self.renderContext.createNonPowerOfTwoTextureFromImage(image, layer.invertY);
			}
			
			image.onerror = function(event)
			{
				console.log("Cannot load " + image.src );
			}
			
			image.src = style.fillTextureUrl;
			hasTexture = true;
		}
		else if ( style.fillTexture )
		{
			bucket.texture = style.fillTexture;
			hasTexture = true;
		}
			
		if ( style.fillShader&& style.fillShader.fragmentCode )
		{
			// User defined texture program
			if ( !style.fillShader.vertexCode )
				style.fillShader.vertexCode = this.texVertexShader;
			if ( !style.fillShader.vertexCode )
				style.fillShader.fragmentCode = this.texFragmentShader;

			bucket.polygonProgram = this.getProgram(style.fillShader);
		}
		else
		{
			// Default program
			bucket.polygonProgram = hasTexture ? this.texProgram : this.basicProgram;
		}
	}
		
	return bucket;
}

/**************************************************************************************************************/

/**
	Render all the POIs
 */
ConvexPolygonRenderer.prototype.render = function(renderables,start,end)
{	
	var renderContext = this.renderContext;
	var gl = this.renderContext.gl;
	
	// Setup states
	gl.disable(gl.DEPTH_TEST);
	gl.depthMask(false);
	gl.enable(gl.BLEND);
	gl.blendEquation(gl.FUNC_ADD);
	gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
	
	// Setup the basic program
	this.basicProgram.apply();
	mat4.multiply(renderContext.projectionMatrix, renderContext.viewMatrix, renderContext.modelViewMatrix)
	gl.uniformMatrix4fv(this.basicProgram.uniforms["viewProjectionMatrix"], false, renderContext.modelViewMatrix);
	
	// Render each renderables
	var currentBucket = null;
	for ( var n = start; n < end; n++ )
	{
		var renderable = renderables[n];
		var bucket = renderable.bucket;
		
		// Set the color
		var color = bucket.style.strokeColor;
		gl.uniform4f(this.basicProgram.uniforms["color"], color[0], color[1], color[2], color[3] * bucket.layer.opacity() );
					
		// Update vertex buffer
		if ( !renderable.vertexBuffer )
		{
			renderable.vertexBuffer = gl.createBuffer();
			renderable.lineIndexBuffer = gl.createBuffer();
		}
		
		gl.bindBuffer(gl.ARRAY_BUFFER, renderable.vertexBuffer);
		gl.vertexAttribPointer(this.basicProgram.attributes['vertex'], 3, gl.FLOAT, false, 0, 0);
	
		gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, renderable.lineIndexBuffer);
		
		if ( renderable.bufferDirty )
		{
			gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(renderable.vertices), gl.STATIC_DRAW);
			gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(renderable.lineIndices), gl.STATIC_DRAW);
			renderable.bufferDirty = false;
		}

		gl.drawElements( gl.LINES, renderable.lineIndices.length, gl.UNSIGNED_SHORT, 0);

		if ( bucket.polygonProgram )
		{
			var program = bucket.polygonProgram;
			
			program.apply();
			gl.uniformMatrix4fv(program.uniforms["viewProjectionMatrix"], false, renderContext.modelViewMatrix);
			
			gl.uniform1i(program.uniforms["texture"], 0);
			if ( renderable.tcoords.length > 0 )
			{
				// Use tcoord buffer defined by _imageCoordinates
				if ( !renderable.tcoordBuffer )
				{
					renderable.tcoordBuffer = gl.createBuffer();
					gl.bindBuffer(gl.ARRAY_BUFFER, renderable.tcoordBuffer);
								
					gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(renderable.tcoords), gl.STATIC_DRAW);
					renderable.tcoordBuffer.itemSize = 2;
					renderable.tcoordBuffer.numItems = renderable.tcoords.length / 2;
				}

				gl.bindBuffer(gl.ARRAY_BUFFER, renderable.tcoordBuffer);
			}
			else
			{
				// Use default tcoord buffer
				gl.bindBuffer(gl.ARRAY_BUFFER, this.tcoordBuffer);
			}
			gl.vertexAttribPointer(program.attributes['tcoord'], 2, gl.FLOAT, false, 0, 0);
			
			gl.bindBuffer(gl.ARRAY_BUFFER, renderable.vertexBuffer);
			gl.vertexAttribPointer(program.attributes['vertex'], 3, gl.FLOAT, false, 0, 0);
			
			if ( bucket.style.fillShader && bucket.style.fillShader.updateUniforms )
				bucket.style.fillShader.updateUniforms(gl, renderable.bucket, program);
				
			if ( !renderable.triangleIndexBuffer )
			{
				renderable.triangleIndexBuffer = gl.createBuffer();
			}
			gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, renderable.triangleIndexBuffer);
			if ( renderable.triBufferDirty )
			{
				gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(renderable.triangleIndices), gl.STATIC_DRAW);
				renderable.triBufferDirty = false;
			}
			// Add texture
			gl.activeTexture(gl.TEXTURE0);
			if ( renderable.bucket.texture ) 
			{
				gl.bindTexture(gl.TEXTURE_2D, renderable.bucket.texture); // use texture of renderable
				gl.uniform4f(program.uniforms["color"], 1.0, 1.0, 1.0, color[3] * bucket.layer.opacity());  // use whiteColor
			}
			else
			{
				gl.bindTexture(gl.TEXTURE_2D, this.whiteTexture);  // use white texture
				color = renderable.bucket.style.fillColor;
				gl.uniform4f(program.uniforms["color"], color[0], color[1], color[2], color[3] * bucket.layer.opacity() );
			}
			
			gl.drawElements( gl.TRIANGLES, renderable.triangleIndices.length, gl.UNSIGNED_SHORT, 0);
			
			this.basicProgram.apply();
		}
	}

    gl.enable(gl.DEPTH_TEST);
	gl.depthMask(true);
    gl.disable(gl.BLEND);
}


/**************************************************************************************************************/

// Register the renderer
VectorRendererManager.factory.push( function(globe) { return new ConvexPolygonRenderer(globe); } );

/**************************************************************************************************************/

return ConvexPolygonRenderer;

});
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('gw/PointSpriteRenderer',['./Utils','./VectorRenderer','./Program','./CoordinateSystem','./FeatureStyle', './VectorRendererManager'],
	function(Utils,VectorRenderer,Program,CoordinateSystem,FeatureStyle,VectorRendererManager) {

/**************************************************************************************************************/

/** @constructor
	PointSpriteRenderer constructor
 */
var PointSpriteRenderer = function(globe)
{
	VectorRenderer.prototype.constructor.call( this, globe );
	
	// For stats
	this.numberOfRenderPoints = 0;
 	
	var vertexShader = "\
	attribute vec3 vertex; \n\
	uniform mat4 viewProjectionMatrix; \n\
	uniform float pointSize; \n\
	void main(void)  \n\
	{ \n\
		gl_Position = viewProjectionMatrix * vec4(vertex,1.0); \n\
		gl_PointSize = pointSize; \n\
	} \n\
	";
	
	var fragmentShader = "\
	precision lowp float; \n\
	uniform sampler2D texture; \n\
	uniform float alpha; \n\
	uniform vec3 color; \n\
	\n\
	void main(void) \n\
	{ \n\
		vec4 textureColor = texture2D(texture, gl_PointCoord); \n\
		gl_FragColor = vec4(textureColor.rgb * color, textureColor.a * alpha); \n\
		if (gl_FragColor.a <= 0.0) discard; \n\
		//gl_FragColor = vec4(1.0); \n\
	} \n\
	";

    this.program = new Program(globe.renderContext);
    this.program.createFromSource(vertexShader, fragmentShader);
	
	this.defaultTexture = null;
}

Utils.inherits(VectorRenderer,PointSpriteRenderer);

/**************************************************************************************************************/

/**
 * Renderable constructor for PointSprite
 */
var Renderable = function(bucket) 
{
	this.bucket = bucket;
	this.geometry2vb = {};
	this.vertices = [];
	this.vertexBuffer = null;
	this.vertexBufferDirty = false;
}

/**************************************************************************************************************/

/**
 * Add a geometry to the renderbale
 * @return if the geometry has been successfully added to the renderable
 */
Renderable.prototype.add = function(geometry)
{
	this.geometry2vb[ geometry.gid ] = this.vertices.length;
	var pt = CoordinateSystem.fromGeoTo3D( geometry['coordinates'] );
	// Hack : push away the point, only works for AstroWeb, sufficient for now
	this.vertices.push( 0.99 * pt[0], 0.99 * pt[1], 0.99 * pt[2] );
	this.vertexBufferDirty = true;
	
	return true;
}

/**************************************************************************************************************/

/**
 * Remove a geometry from the renderable
 */
Renderable.prototype.remove = function(geometry)
{
	if ( this.geometry2vb.hasOwnProperty(geometry.gid) )
	{
		var vbIndex = this.geometry2vb[ geometry.gid ];
		delete this.geometry2vb[ geometry.gid ];
		this.vertices.splice( vbIndex, 3 );
		this.vertexBufferDirty = true;
		
		// Update render data for all other geometries
		for ( var g in this.geometry2vb ) 
		{
			if ( g ) 
			{
				if ( this.geometry2vb[g] > vbIndex ) 
				{
					this.geometry2vb[g] -= 3;
				}
			}
		}
	}
	return this.vertices.length;
}

/**************************************************************************************************************/

/**
 * Dispose the renderable
 */
Renderable.prototype.dispose = function(renderContext)
{
	if ( this.vertexBuffer ) 
	{
		renderContext.gl.deleteBuffer( this.vertexBuffer );
	}
}

/**************************************************************************************************************/

/**
	Build a default texture
 */
PointSpriteRenderer.prototype._buildDefaultTexture = function(bucket)
{  	
	if ( !this.defaultTexture )
	{
		var gl = this.globe.renderContext.gl;
		this.defaultTexture = gl.createTexture();
		gl.bindTexture(gl.TEXTURE_2D, this.defaultTexture);
		var whitePixel = new Uint8Array([255, 255, 255, 255]);
		gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, whitePixel);
	}

	bucket.texture = this.defaultTexture;
	bucket.textureWidth = 10;
	bucket.textureHeight = 10;
}

/**************************************************************************************************************/

/**
	Build a texture from an image and store in a bucket
 */
PointSpriteRenderer.prototype._buildTextureFromImage = function(bucket,image)
{  	
	bucket.texture = this.globe.renderContext.createNonPowerOfTwoTextureFromImage(image);
	bucket.textureWidth = image.width;
	bucket.textureHeight = image.height;
}

/**************************************************************************************************************/

/**
	Check if renderer is applicable
 */
PointSpriteRenderer.prototype.canApply = function(type,style)
{
	return type == "Point"&& !style.label; 
}

/**************************************************************************************************************/

/**
	Bucket constructor for PointSpriteRenderer
 */
 var Bucket = function(layer,style)
{
	this.layer = layer;
	this.style = new FeatureStyle(style);
	this.texture = null;
	this.renderer = null;
}

/**************************************************************************************************************/

/**
	Create a renderable for this bucket
 */
Bucket.prototype.createRenderable = function()
{
	return new Renderable(this);
}

/**************************************************************************************************************/

/**
	Check if a bucket is compatible
 */
Bucket.prototype.isCompatible = function(style)
{
	if ( this.style.iconUrl == style.iconUrl
		&& this.style.icon == style.icon
		&& this.style.fillColor[0] == style.fillColor[0]
		&& this.style.fillColor[1] == style.fillColor[1]
		&& this.style.fillColor[2] == style.fillColor[2] )
	{
		return true;
	}
	
	return false;
}

/**************************************************************************************************************/

/**
	Create bucket to render a point
 */
PointSpriteRenderer.prototype.createBucket = function(layer,style)
{
	var gl = this.globe.renderContext.gl;
	var vb = gl.createBuffer();

	// Create a bucket
	var bucket = new Bucket(layer,style);
	bucket.renderer = this;
		
	// Initialize bucket : create the texture	
	if ( style['iconUrl'] )
	{
		var image = new Image();
		var self = this;
		image.onload = function() {self._buildTextureFromImage(bucket,image); self.globe.renderContext.requestFrame(); }
		image.onerror = function() { self._buildDefaultTexture(bucket); }
		image.src = style.iconUrl;
	}
	else if ( style['icon'] )
	{
		this._buildTextureFromImage(bucket,style.icon);
	}
	else
	{
		this._buildDefaultTexture(bucket);
	}
	
	return bucket;
}

/**************************************************************************************************************/

/**
	Render
 */
PointSpriteRenderer.prototype.render = function(renderables,start,end)
{	
	var renderContext = this.globe.renderContext;
	var gl = renderContext.gl;
	
	// Setup states
	gl.disable(gl.DEPTH_TEST);
	gl.enable(gl.BLEND);
	gl.blendEquation(gl.FUNC_ADD);
	gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

	// Setup program
	this.program.apply();
	
	// The shader only needs the viewProjection matrix, use GlobWeb.modelViewMatrix as a temporary storage
	mat4.multiply(renderContext.projectionMatrix, renderContext.viewMatrix, renderContext.modelViewMatrix)
	gl.uniformMatrix4fv(this.program.uniforms["viewProjectionMatrix"], false, renderContext.modelViewMatrix);
	gl.uniform1i(this.program.uniforms["texture"], 0);
	
	// Render each renderables
	var currentBucket = null;
	for ( var n = start; n < end; n++ )
	{
		var renderable = renderables[n];
		var bucket = renderable.bucket;
		
		if ( currentBucket != bucket )
		{
			gl.uniform1f(this.program.uniforms["alpha"], bucket.layer._opacity);
			var color = bucket.style.fillColor;
			gl.uniform3f(this.program.uniforms["color"], color[0], color[1], color[2] );
			gl.uniform1f(this.program.uniforms["pointSize"], bucket.textureWidth);
			
			// Bind point texture
			gl.activeTexture(gl.TEXTURE0);
			gl.bindTexture(gl.TEXTURE_2D, bucket.texture);
			
			currentBucket = bucket;
		}
		
			
		if ( !renderable.vertexBuffer )
		{
			renderable.vertexBuffer = gl.createBuffer();
		}
		
		gl.bindBuffer(gl.ARRAY_BUFFER, renderable.vertexBuffer);
		gl.vertexAttribPointer(this.program.attributes['vertex'], 3, gl.FLOAT, false, 0, 0);
		
		if ( renderable.vertexBufferDirty )
		{
			gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(renderable.vertices), gl.STATIC_DRAW);
			renderable.vertexBufferDirty = false;
		}

							
		gl.drawArrays(gl.POINTS, 0, renderable.vertices.length/3);
	}

    gl.enable(gl.DEPTH_TEST);
    gl.disable(gl.BLEND);
}


/**************************************************************************************************************/

// Register the renderer
VectorRendererManager.factory.push( function(globe) { return new PointSpriteRenderer(globe); } );

return PointSpriteRenderer;

});
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

 define('gw/PointRenderer', ['./Utils','./VectorRenderer','./CoordinateSystem','./VectorRendererManager','./FeatureStyle','./Program'], 
	function(Utils,VectorRenderer,CoordinateSystem,VectorRendererManager,FeatureStyle,Program) {

/**************************************************************************************************************/

/** @constructor
	Basic module to generate texture from text
 */	
var Text = (function()
{
	var fontSize = 18;
	var margin = 1;
	var canvas2d = null;
	
	var initialize = function()
	{
		canvas2d = document.createElement("canvas");
		canvas2d.width = 512;
		canvas2d.height = fontSize  + 2 * margin;
	}
	
	var generateImageData = function(text, textColor)
	{
		if (!canvas2d)
			initialize();
		
		var fillColor = textColor;
		if (!fillColor)
			fillColor = '#fff';
		else if ( fillColor instanceof Array )
			fillColor = FeatureStyle.fromColorToString(textColor);
		
		var ctx = canvas2d.getContext("2d");
		ctx.clearRect(0,0,canvas2d.width,canvas2d.height);
		ctx.fillStyle = fillColor;
		ctx.font = fontSize + 'px sans-serif';
		ctx.textBaseline = 'top';
		ctx.shadowColor = '#000';
		ctx.shadowOffsetX = 1;
		ctx.shadowOffsetY = 1;
		ctx.shadowBlur = 2;
		ctx.fillText(text, margin, margin);
		//ctx.lineWidth = 1.0;
		//ctx.strokeText(text, margin, margin);
		
		var metrics = ctx.measureText(text);
		return ctx.getImageData(0,0, Math.floor(metrics.width)+2*margin,canvas2d.height)
	}
	
	
	return { generateImageData: generateImageData };
})();

/**************************************************************************************************************/

/** @constructor
	POI Renderer constructor
 */
var PointRenderer = function(globe)
{
	VectorRenderer.prototype.constructor.call( this, globe );

	// Store object for rendering
	this.renderContext = globe.tileManager.renderContext;
	this.tileConfig = globe.tileManager.tileConfig;
	
	// For stats
	this.numberOfRenderPoints = 0;
 	
	var vertexShader = "\
	attribute vec3 vertex; // vertex have z = 0, spans in x,y from -0.5 to 0.5 \n\
	uniform mat4 viewProjectionMatrix; \n\
	uniform vec3 poiPosition; // world position \n\
	uniform vec2 poiScale; // x,y scale \n\
	uniform vec2 tst; \n\
	\n\
	varying vec2 texCoord; \n\
	\n\
	void main(void)  \n\
	{ \n\
		// Generate texture coordinates, input vertex goes from -0.5 to 0.5 (on x,y) \n\
		texCoord = vertex.xy + vec2(0.5) + tst; \n\
		// Invert y \n\
		texCoord.y = 1.0 - texCoord.y; \n\
		\n\
		// Compute poi position in clip coordinate \n\
		gl_Position = viewProjectionMatrix * vec4(poiPosition, 1.0); \n\
		gl_Position.xy += vertex.xy * gl_Position.w * poiScale; \n\
	} \n\
	";
	
	var fragmentShader = "\
	precision lowp float; \n\
	varying vec2 texCoord; \n\
	uniform sampler2D texture; \n\
	uniform float alpha; \n\
	uniform vec3 color; \n\
	\n\
	void main(void) \n\
	{ \n\
		vec4 textureColor = texture2D(texture, texCoord); \n\
		gl_FragColor = vec4(textureColor.rgb * color, textureColor.a * alpha); \n\
		if (gl_FragColor.a <= 0.0) discard; \n\
	} \n\
	";

    this.program = new Program(this.renderContext);
    this.program.createFromSource(vertexShader, fragmentShader);

	var vertices = new Float32Array([-0.5, -0.5, 0.0,
                     0.5,  -0.5, 0.0,
                     0.5,  0.5, 0.0,
                     -0.5, 0.5, 0.0]);
					 
	var gl = this.renderContext.gl;
	this.vertexBuffer = gl.createBuffer();
	gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
	gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

	this.defaultTexture = null;
}

Utils.inherits(VectorRenderer,PointRenderer);

/**************************************************************************************************************/

/*
	Build a default texture
 */
PointRenderer.prototype._buildDefaultTexture = function(bucket)
{  	
	if ( !this.defaultTexture )
	{
		var gl = this.renderContext.gl;
		this.defaultTexture = gl.createTexture();
		gl.bindTexture(gl.TEXTURE_2D, this.defaultTexture);
		var whitePixel = new Uint8Array([255, 255, 255, 255]);
		gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, whitePixel);
	}

	bucket.texture = this.defaultTexture;
	bucket.textureWidth = 10;
	bucket.textureHeight = 10;
}

/**************************************************************************************************************/

/*
	Build a texture from an image and store in a bucket
 */
PointRenderer.prototype._buildTextureFromImage = function(bucket,image)
{  	
	bucket.texture = this.renderContext.createNonPowerOfTwoTextureFromImage(image);
	bucket.textureWidth = image.width;
	bucket.textureHeight = image.height;
}

/**************************************************************************************************************/

/**
 * Renderable constructor for Point
 */
var PointRenderable = function(bucket) 
{
	this.bucket = bucket;
	this.points = [];
}

/**************************************************************************************************************/

/**
 * Add a geometry to the renderable
 * @return if the geometry has been successfully added to the renderable
 */
PointRenderable.prototype.add = function(geometry)
{
	var posGeo = geometry['coordinates'];
	var pos3d = CoordinateSystem.fromGeoTo3D( posGeo );
	var vertical = vec3.create();
	vec3.normalize(pos3d, vertical);

	// Hack : push away the point, only works for AstroWeb, sufficient for now
	pos3d = [ 0.99 * pos3d[0], 0.99 * pos3d[1], 0.99 * pos3d[2] ];

	this.points.push({
		pos3d: pos3d,
		vertical: vertical,
		geometry: geometry
	});
	
	// Always add the geometry
	return true;
}

/**************************************************************************************************************/

/**
 * Remove a geometry from the renderable
 */
PointRenderable.prototype.remove = function(geometry)
{
	for ( var j = 0; j < this.points.length; j++ )
	{
		if ( this.points[j].geometry == geometry )
		{
			this.points.splice( j, 1 );
			return this.points.length;
		}
	}
	return this.points.length;
}

/**************************************************************************************************************/

/**
 * Dispose the renderable
 */
PointRenderable.prototype.dispose = function(renderContext)
{
	// Nothing to do
}


/**************************************************************************************************************/

/**
	Bucket constructor for PointRenderer
 */
var PointBucket = function(layer,style)
{
	this.layer = layer;
	this.style = new FeatureStyle(style);
	this.renderer = null;
	this.texture = null;
}

/**************************************************************************************************************/

/**
	Create a renderable for this bucket
 */
PointBucket.prototype.createRenderable = function()
{
	return new PointRenderable(this);
}

/**************************************************************************************************************/

/**
	Check if a bucket is compatible
 */
PointBucket.prototype.isCompatible = function(style)
{
	return this.style.iconUrl == style.iconUrl
		&& this.style.icon == style.icon
		&& this.style.label == style.label;
}

/**************************************************************************************************************/

/**
	Create bucket to render a point
 */
PointRenderer.prototype.createBucket = function(layer,style)
{
	// Create a bucket
	var bucket = new PointBucket(layer,style);
	
	// Initialize bucket : create the texture	
	if ( style['label'] )
	{
		var imageData = Text.generateImageData(style['label'], style['textColor']);
		this._buildTextureFromImage(bucket,imageData);
	}
	else if ( style['iconUrl'] )
	{
		var image = new Image();
		var self = this;
		image.onload = function() {self._buildTextureFromImage(bucket,image); self.renderContext.requestFrame(); }
		image.onerror = function() { self._buildDefaultTexture(bucket); }
		image.src = style.iconUrl;
	}
	else if ( style['icon'] )
	{
		this._buildTextureFromImage(bucket,style.icon);
	}
	else
	{
		this._buildDefaultTexture(bucket);
	}
		
	return bucket;
}

/**************************************************************************************************************/

/*
	Render all the POIs
 */
PointRenderer.prototype.render = function(renderables,start,end)
{
	this.numberOfRenderPoints = 0;
	
	var renderContext = this.renderContext;
	var gl = this.renderContext.gl;
	
	// Setup states
	// gl.disable(gl.DEPTH_TEST);
	gl.enable(gl.BLEND);
	gl.blendEquation(gl.FUNC_ADD);
	gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

	// Setup program
	this.program.apply();
	
	// The shader only needs the viewProjection matrix, use modelViewMatrix as a temporary storage
	mat4.multiply(renderContext.projectionMatrix, renderContext.viewMatrix, renderContext.modelViewMatrix)
	gl.uniformMatrix4fv(this.program.uniforms["viewProjectionMatrix"], false, renderContext.modelViewMatrix);
	gl.uniform1i(this.program.uniforms["texture"], 0);

	// Compute eye direction from inverse view matrix
	mat4.inverse(renderContext.viewMatrix, renderContext.modelViewMatrix);
	var camZ = [renderContext.modelViewMatrix[8], renderContext.modelViewMatrix[9], renderContext.modelViewMatrix[10]];
	vec3.normalize(camZ);
	vec3.scale(camZ, this.tileConfig.cullSign, camZ);
	
	// Compute pixel size vector to offset the points from the earth
	var pixelSizeVector = renderContext.computePixelSizeVector();
	
	// Warning : use quoted strings to access properties of the attributes, to work correclty in advanced mode with closure compiler
	gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
	gl.vertexAttribPointer(this.program.attributes['vertex'], 3, gl.FLOAT, false, 0, 0);

	var currentBucket = null;
	for ( var n = start; n < end; n++ )
	{
		var renderable = renderables[n];
		var bucket = renderable.bucket;
		
		if ( renderable.points.length == 0 )
			continue;
			
		if ( bucket != currentBucket )
		{
			// Bind point texture
			gl.activeTexture(gl.TEXTURE0);
			gl.bindTexture(gl.TEXTURE_2D, bucket.texture);

			// 2.0 * because normalized device coordinates goes from -1 to 1
			var scale = [2.0 * bucket.textureWidth / renderContext.canvas.width,
						 2.0 * bucket.textureHeight / renderContext.canvas.height];
			gl.uniform2fv(this.program.uniforms["poiScale"], scale);
			gl.uniform2fv(this.program.uniforms["tst"], [ 0.5 / (bucket.textureWidth), 0.5 / (bucket.textureHeight)  ]);
		}
		
		for ( var i = 0; i < renderable.points.length; i++ )
		{	
			// Poi culling
			var worldPoi = renderable.points[i].pos3d;
			var poiVec = renderable.points[i].vertical;
			var scale = bucket.textureHeight * ( pixelSizeVector[0] * worldPoi[0] + pixelSizeVector[1] * worldPoi[1] + pixelSizeVector[2] * worldPoi[2] + pixelSizeVector[3] );
			scale *= this.tileConfig.cullSign;
			var scaleInKm = (scale / CoordinateSystem.heightScale) * 0.001;
			if ( scaleInKm > bucket.style.pointMaxSize )
				continue;
				
			if ( vec3.dot(poiVec, camZ) > 0 
				&& renderContext.worldFrustum.containsSphere(worldPoi,scale) >= 0 )
			{
				var x = poiVec[0] * scale + worldPoi[0];
				var y = poiVec[1] * scale + worldPoi[1];
				var z = poiVec[2] * scale + worldPoi[2];
				
				gl.uniform3f(this.program.uniforms["poiPosition"], x, y, z);
				gl.uniform1f(this.program.uniforms["alpha"], bucket.layer._opacity);
				var color = bucket.style.fillColor;
				gl.uniform3f(this.program.uniforms["color"], color[0], color[1], color[2] );
				
				gl.drawArrays(gl.TRIANGLE_FAN, 0, 4);
				
				this.numberOfRenderPoints++;
			}
		}
	}

//    gl.enable(gl.DEPTH_TEST);
    gl.disable(gl.BLEND);
}

/**************************************************************************************************************/

/**
 * Check if renderer is applicable
 */
PointRenderer.prototype.canApply = function(type,style)
{
	return type == "Point" && style.label;
}

/**************************************************************************************************************/

// Register the renderer
VectorRendererManager.factory.push( function(globe) { return new PointRenderer(globe); } );
									
return PointRenderer;

});

/******************************************************************************* 
* Copyright 2012, 2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES 
* 
* This file is part of SITools2. 
* 
* SITools2 is free software: you can redistribute it and/or modify 
* it under the terms of the GNU General Public License as published by 
* the Free Software Foundation, either version 3 of the License, or 
* (at your option) any later version. 
* 
* SITools2 is distributed in the hope that it will be useful, 
* but WITHOUT ANY WARRANTY; without even the implied warranty of 
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
* GNU General Public License for more details. 
* 
* You should have received a copy of the GNU General Public License 
* along with SITools2. If not, see <http://www.gnu.org/licenses/>. 
******************************************************************************/ 

/**
 * Mizar widget
 */
define('MizarWidget', [ "jquery", "underscore-min", "gw/EquatorialCoordinateSystem", "gw/Sky", "gw/Stats", "gw/AstroNavigation", "gw/AttributionHandler", "gw/VectorLayer", "gw/TouchNavigationHandler", "gw/MouseNavigationHandler", "gw/KeyboardNavigationHandler", "gw/Event", "text!../templates/mizarCore.html", "text!../data/backgroundSurveys.json",
	"./LayerManager", "./LayerManagerView", "./BackgroundLayersView", "./NameResolver", "./NameResolverView", "./ReverseNameResolver", "./Utils", "./PickingManager", "./FeaturePopup", "./IFrame", "./Compass", "./MollweideViewer", "./ErrorDialog", "./AboutDialog", "./Share", "./Samp", "./AdditionalLayersView", "./ImageManager", "./ImageViewer", "./UWSManager", "./PositionTracker", "./MeasureTool", "./StarProvider", "./ConstellationProvider", "./JsonProvider", "./OpenSearchProvider", "./PlanetProvider",
	"gw/ConvexPolygonRenderer", "gw/PointSpriteRenderer", "gw/PointRenderer", "jquery.ui"],
	function($, _, CoordinateSystem, Sky, Stats, AstroNavigation, AttributionHandler, VectorLayer, TouchNavigationHandler, MouseNavigationHandler, KeyboardNavigationHandler, Event, mizarCoreHTML, backgroundSurveys,
			LayerManager, LayerManagerView, BackgroundLayersView, NameResolver, NameResolverView, ReverseNameResolver, Utils, PickingManager, FeaturePopup, IFrame, Compass, MollweideViewer, ErrorDialog, AboutDialog, Share, Samp, AdditionalLayersView, ImageManager, ImageViewer, UWSManager, PositionTracker, MeasureTool) {

	/**
	 *	Private functions
	 */
	var aboutShowed = false;
	var parentElement;
	var options;

	/**
	 *	Apply shared parameters to options if exist
	 */
	var _applySharedParameters = function(options) {
		var documentURI =  window.document.documentURI;
		// Retrieve shared parameters
		var sharedParametersIndex = documentURI.indexOf( "sharedParameters=" );
		if ( sharedParametersIndex != -1 )
		{
			var startIndex = sharedParametersIndex + "sharedParameters=".length;
			var sharedString = documentURI.substr(startIndex);
			if ( options.shortener )
			{
				$.ajax({
					type: "GET",
					url: options.shortener.baseUrl +'/'+ sharedString,
					async: false, // TODO: create callback
					success: function(sharedConf)
					{
						_setSharedParameters(options, sharedConf);
					},
					error: function(thrownError)
					{
						console.error(thrownError);
					}
				});
			}
			else
			{
				console.log("Shortener plugin isn't defined, try to extract as a string");
				var sharedParameters = JSON.parse( unescape(sharedString) );
				_setSharedParameters(options, sharedParameters);
			}
		}
	}

	/**
	 *	Retrieve SiTools2 configuration from URI
	 *	(to be removed ?)
	 */
	var _retrieveConfiguration = function() {
		var confURL = 'js/conf.json'; // default
		var documentURI =  window.document.documentURI;

		// If configuration is defined by SiTools2
		var splitStartIndex = documentURI.indexOf( "?conf=" );
		if ( splitStartIndex != -1 )
		{
			// Shared url exist
			var splitEndIndex = documentURI.search( /[&|?]sharedParameters=/ );
			if ( splitEndIndex != -1 )
			{
				// Compute length of configuration url
				var confURLLength = splitEndIndex - splitStartIndex - "?conf=".length;
			}

			var url = documentURI.substr( splitStartIndex + "?conf=".length, confURLLength );
			if ( url != 'undefined' && url != '' ) {
				confURL = url;
			}
		}
		return confURL;
	}

	/**************************************************************************************************************/

	/**
	 *	Hide loading and show about on first connection
	 */
	var _showAbout = function()
	{
		// Show about information only at the end of first loading
		if ( localStorage.showAbout == undefined && !aboutShowed )
		{
			AboutDialog.show();
			aboutShowed = true;
		}

		$(parentElement).find('#loading').hide(300);
	}

	/**************************************************************************************************************/

	/**
	 *	Remove "C"-like comment lines from string
	 */
	var _removeComments = function(string)
	{
		var starCommentRe = new RegExp("/\\\*(.|[\r\n])*?\\\*/", "g");
		var slashCommentRe = new RegExp("[^:]//.*[\r\n]", "g");
		string = string.replace(slashCommentRe, "");
		string = string.replace(starCommentRe, "");

		return string;
	}

	/**************************************************************************************************************/

	/**
	 *	Modify data according to shared parameters
	 */
	var _setSharedParameters = function(data, sharedParameters)
	{
		// Init navigation parameters
		data.navigation.initTarget = sharedParameters.initTarget;
		data.navigation.initFov = sharedParameters.fov;
		data.navigation.up = sharedParameters.up;

		// Set visibility of layers
		if ( data.layers ) {
			for ( var x in sharedParameters.visibility )
			{
				var name = x;
				for ( var i=0; i<data.layers.length; i++ )
				{
					var currentLayer = data.layers[i];
					if ( name == currentLayer.name )
					{
						currentLayer.visible = sharedParameters.visibility[name];
						continue;
					}
				}
			}
		}
	}

	/**************************************************************************************************************/

	/**
	 *	Store the mizar base url
	 *	Used to access to images(Compass, Mollweide, Target icon for name resolver)
	 *	Also used to define "star" icon for point data on-fly
	 *	NB: Not the best solution of my life.... TODO: think how to improve it..
	 */
	// Search throught all the loaded scripts for minified version
	var scripts= document.getElementsByTagName('script');
	var mizarMin = _.find(scripts, function(script){
		return script.src.indexOf("MizarWidget.min") != -1;
	});
	
	// Depending on its presence decide if Mizar is used on prod or on dev
	var mizarBaseUrl;
	if ( mizarMin )
	{
		// Prod
		// Extract mizar's url
		mizarBaseUrl = mizarMin.src.split('/').slice(0, -1).join('/')+'/';
	}
	else
	{
		// Dev
		// Basically use the relative path from index page
		mizarBaseUrl = "./";
	}

	/**
	 *	Mizar widget constructor
	 */
	var MizarWidget = function(div, userOptions) {
		Event.prototype.constructor.call( this );

		parentElement = div;
		var sitoolsBaseUrl = userOptions.sitoolsBaseUrl ? userOptions.sitoolsBaseUrl : "http://demonstrator.telespazio.com/sitools";
		this.isMobile = (('ontouchstart' in window && window.ontouchstart != null) || window.DocumentTouch && document instanceof DocumentTouch);
		options = {
			"sitoolsBaseUrl" : sitoolsBaseUrl,
			"mizarBaseUrl": mizarBaseUrl,
			"continuousRendering" : userOptions.hasOwnProperty('continuousRendering') ? userOptions.continuousRendering : true,
			"coordSystem" : userOptions.hasOwnProperty('coordSystem') ? userOptions.coordSystem : "EQ",
			"debug" : userOptions.hasOwnProperty('debug') ? userOptions.debug : false,
			"nameResolver" : {
				"baseUrl" : sitoolsBaseUrl + '/project/mizar/plugin/nameResolver',
				"zoomFov": 15
			},
			"reverseNameResolver" : {
				"baseUrl" : sitoolsBaseUrl + '/project/mizar/plugin/reverseNameResolver',
			},
			"coverageService": {
				"baseUrl": sitoolsBaseUrl + "/project/mizar/plugin/coverage?moc="
			},
			"solarObjects": {
				"baseUrl": sitoolsBaseUrl + "/project/mizar/plugin/solarObjects/"
			},
			"votable2geojson": {
				"baseUrl": sitoolsBaseUrl + "/project/mizar/plugin/votable2geojson"
			},
			"cutOut": {
				"baseUrl": sitoolsBaseUrl + "/cutout"
			},
			"zScale": {
				"baseUrl": sitoolsBaseUrl + "/zscale"
			},
			"healpixcut": {
				"baseUrl": sitoolsBaseUrl + "/healpixcut"
			},
			"shortener": {
			 	"baseUrl": sitoolsBaseUrl + "/shortener"
			},
			"navigation" : {
				"initTarget": [85.2500, -2.4608],
				"initFov": 20,
				"inertia": true,
				"minFov": 0.001,
				"zoomFactor": 0,
				"handlers": [
					new MouseNavigationHandler({
						zoomOnDblClick: true
					}),
					new KeyboardNavigationHandler()
				]
			},
			"stats": {
				"verbose": false,
				"visible": false
			},
			"isMobile" : this.isMobile
		};

		var extendableOptions = [ "navigation", "nameResolver", "stats" ];
		// Merge default options with user ones
		for ( var i=0; i<extendableOptions.length; i++ ) {
			var option = extendableOptions[i];
			$.extend(options[option], userOptions[option]);
		}

		// Create mizar core HTML
		var mizarContent = _.template(mizarCoreHTML,{});
		$(mizarContent).appendTo(div);

		this.sky = null;
		this.navigation = null;

		var confURL = _retrieveConfiguration();

		var canvas = $(div).find('#GlobWebCanvas')[0];
		
		// Set canvas dimensions from width/height attributes
		var width = $(div).attr("width");
		if ( !width )
		{
			// Use window width by default if not defined
			width = window.innerWidth;
		}

		var height = $(div).attr("height");
		if ( !height )
		{
			// Use window height if not defined
			height = window.innerHeight;
		}
		canvas.width = width;
		canvas.height = height;
		
		// Add some useful css properties to parent element
		$(parentElement).css({
			position: "relative",
			width: canvas.width,
			height: canvas.height,
			overflow: "hidden"
		});
		
		// Take into account window resize
		$(window).resize(function() {
			if ( canvas.width !=  window.innerWidth ) 
				canvas.width = window.innerWidth;
			if ( canvas.height != window.innerHeight )
				canvas.height = window.innerHeight;
		});
		
		// Initialize sky
		try
		{
			this.sky = new Sky( { 
				canvas: canvas, 
				tileErrorTreshold: 1.5,
				continuousRendering: this.isMobile ? false : options.continuousRendering
			} );
		}
		catch (err)
		{
			document.getElementById('GlobWebCanvas').style.display = "none";
			document.getElementById('loading').style.display = "none";
			document.getElementById('webGLNotAvailable').style.display = "block";
		}

		// When base layer is ready, hide loading
		this.sky.subscribe("baseLayersReady", _showAbout);

		// When base layer failed to load, open error dialog
		this.sky.subscribe("baseLayersError", function(layer){

			$(parentElement).find('#loading').hide();
			// TODO : handle multiple errors !
			var layerType = layer.id == 0 ? " background layer " : " additional layer ";
			ErrorDialog.open("<p>The"+ layerType + "<span style='color: orange'>"+layer.name+"</span> can not be displayed.</p>\
			 <p>First check if data source related to this layer is still accessible. Otherwise, check your Sitools2 configuration.</p>");
		});
		
		// Context lost listener
		canvas.addEventListener("webglcontextlost", function(event) {
			// TODO
			event.preventDefault();
			document.getElementById('loading').style.display = "none";
			document.getElementById('webGLContextLost').style.display = "block";
		}, false);
				
		_applySharedParameters(options);

		// Add stats
		var self = this;
		if ( options.stats.visible ) {
			new Stats( self.sky.renderContext, { element: "fps", verbose: options.stats.verbose });
			$("#fps").show();
		}

		CoordinateSystem.type = options.coordSystem;

		// Add touch navigation handler if client supports touch events
		if( this.isMobile ) {
		    // Mobile
			options.navigation.handlers = [ new TouchNavigationHandler({ inversed: true, zoomOnDblClick: true }) ];
			window.addEventListener("orientationchange", function() {
				self.sky.renderContext.requestFrame();
			}, false);
		}

		// Initialize navigation
		this.navigation = new AstroNavigation(this.sky, options.navigation);

		// Add attribution handler
		new AttributionHandler( this.sky, {element: 'attributions'});		
		
		// Initialize name resolver
		NameResolver.init(this, options);

		// Create layers from configuration file
		LayerManager.init(this, options);
		
		// Create data manager
		PickingManager.init(this, options);

		// Share configuration module init
		Share.init({navigation : this.navigation, configuration: options});

		// Initialize SAMP component
		// TODO : Bear in mind that a website may already implement specific SAMP logics, so check that
		// current samp component doesn't break existing SAMP functionality
		Samp.init(this, LayerManager, ImageManager, options);

		// Eye position tracker initialization
		PositionTracker.init({ element: "posTracker", globe: this.sky, navigation : this.navigation, isMobile: this.isMobile });

		// UWS services initialization
		UWSManager.init(options);

		// Initialization of tools useful for different modules
		Utils.init(this.sky);
		
		// Get background surveys only
		// Currently in background surveys there are not only background layers but also catalog ones
		// TODO : Refactor it !
		backgroundSurveys = _removeComments(backgroundSurveys);
		try
		{
			var layers = $.parseJSON(backgroundSurveys);
		}
		catch (e) {
			ErrorDialog.open("Background surveys parsing error<br/> For more details see http://jsonlint.com/.");
			console.error(e.message);
			return false;
		}
		// Add surveys
		for( var i=0; i<layers.length; i++ ) {
			self.addLayer( layers[i] );
		}

		// Ajax request to retrieve background 
		// $.ajax({
		// 	type: "GET",
		// 	url: mizarBaseUrl + "data/backgroundSurveys.json",
		// 	dataType: "text",
		// 	success: function(response) {
		// 		response = _removeComments(response);
		// 		try
		// 		{
		// 			var layers = $.parseJSON(response);
		// 		}
		// 		catch (e) {
		// 			ErrorDialog.open("Background surveys parsing error<br/> For more details see http://jsonlint.com/.");
		// 			console.error(e.message);
		// 			return false;
		// 		}

		// 		// Add surveys
		// 		for( var i=0; i<layers.length; i++ ) {
		// 			self.addLayer( layers[i] );
		// 		}
		// 		self.publish("backgroundSurveysReady");
		// 	},
		// 	error: function(thrownError) {
		// 		console.error(thrownError);
		// 	}
		// });
		
		// Fullscreen mode
		document.addEventListener("keydown", function(event){
			// Ctrl + Space
			if ( event.ctrlKey == true && event.keyCode == 32 )
			{
				$('.canvas > canvas').siblings().each(function(){
					$(this).fadeToggle();
				});
			}
		});
		
		/*** Refactor into common ? ***/
		// Fade hover styled image effect
		$("body").on("mouseenter", "span.defaultImg", function () {
			//stuff to do on mouseover
			$(this).stop().animate({"opacity": "0"}, 100);
			$(this).siblings('.hoverImg').stop().animate({"opacity": "1"}, 100);
		});
		$("body").on("mouseleave", "span.defaultImg", function () {
			//stuff to do on mouseleave
			$(this).stop().animate({"opacity": "1"}, 100);
			$(this).siblings('.hoverImg').stop().animate({"opacity": "0"}, 100);
		});

		// Close button event
		$('body').on("click",'.closeBtn', function(event){
			switch($(this).parent().attr("id"))
			{
				case "externalIFrame":
					IFrame.hide();
					break;
				case "selectedFeatureDiv":
					FeaturePopup.hide();
					break;
				default:
					$(this).parent().fadeOut(300);	
			}
		});
	}

	/**************************************************************************************************************/

	Utils.inherits( Event, MizarWidget );

	/**************************************************************************************************************/

	/**
	 *	Set a predefined background survey
	 */
	MizarWidget.prototype.setBackgroundSurvey = function(survey) {
		LayerManager.setBackgroundSurvey(survey);
	}

	/**************************************************************************************************************/

	/**
	 *	Set a custom background survey
	 */
	MizarWidget.prototype.setCustomBackgroundSurvey = function(layerDesc) {
		layerDesc.background = true; // Ensure that background option is set to true
		var layer = LayerManager.addLayer(layerDesc);
		LayerManager.setBackgroundSurvey(layerDesc.name);
		return layer;
	}

	/**************************************************************************************************************/

	/**
	 *	Add additional layer(OpenSearch, GeoJSON, HIPS, grid coordinates)
	 *	@param layerDesc
	 *		Layer description
	 *	@return
	 *		The created layer
	 */
	MizarWidget.prototype.addLayer = function(layerDesc) {

		if ( layerDesc.fitsSupported ) {
			// TODO : Move it..
			layerDesc.onready = function( fitsLayer ) {
				if ( fitsLayer.dataType == "fits" && fitsLayer.levelZeroImage )
				{
					if ( fitsLayer.div )
					{
						// Additional layer
						// Using name as identifier, because we must know it before attachment to globe
						// .. but identfier is assigned after layer creation.
						var shortName = Utils.formatId( fitsLayer.name );
						$('#addFitsView_'+shortName).button("enable");
						fitsLayer.div.setImage(fitsLayer.levelZeroImage);
					}
					else
					{
						// Background fits layer
						$('#fitsView').button("enable");
						var backgroundDiv = BackgroundLayersView.getDiv();
						backgroundDiv.setImage(fitsLayer.levelZeroImage);
					}
				}
			}
		}

		return LayerManager.addLayer(layerDesc);
	}

	/**************************************************************************************************************/

	/**
	 *	Remove the given layer
	 *	@param layer
	 *		Layer returned by addLayer()
	 */
	MizarWidget.prototype.removeLayer = function(layer) {
		LayerManager.removeLayer(layer);
	}

	/**************************************************************************************************************/

	/**
	 *	Point to a given location
	 *
	 *	@param location
	 *		Could be:
	 *			1) Coordinates in hms/dms : "0:42:14.33 41:16:7.5"
	 *			2) Coordinates in decimal degree : "11.11 41.3"
	 *			3) Astronomical object name : m31, Mars, Polaris
	 */
	MizarWidget.prototype.goTo = function(location) {
		NameResolver.goTo(location);
	}

	/**************************************************************************************************************/

	/**
	 *	Return current fov
	 */
	MizarWidget.prototype.getCurrentFov = function() {
		return this.navigation.getFov();
	}

	/**************************************************************************************************************/

	/**
	 *	Set zoom(in other words fov)
	 */
	MizarWidget.prototype.setZoom = function(fovInDegrees) {
		var geoPos = CoordinateSystem.from3DToGeo(this.navigation.center3d);
		this.navigation.zoomTo(geoPos, fovInDegrees, 1000);
	}

	/**************************************************************************************************************/

	/**
	 *	Add/remove compass GUI
	 */
	MizarWidget.prototype.setCompassGui = function(visible) {
		if ( visible ) {
			this.compass = new Compass({
				element : "compassDiv",
				globe : this.sky,
				navigation : this.navigation,
				coordSystem : CoordinateSystem.type,
				isMobile : this.isMobile,
				mizarBaseUrl : mizarBaseUrl
			});
		} else {
			this.compass.remove();
		}
	}

	/**************************************************************************************************************/

	/**
	 *	Add/remove angle distance GUI
	 */
	MizarWidget.prototype.setAngleDistanceGui = function(visible) {
	 	if ( visible ) {
	 		// Distance measure tool lazy initialization
	 		if ( !this.measureTool )
				this.measureTool = new MeasureTool({ globe: this.sky, navigation: this.navigation, isMobile: this.isMobile } );
			$(parentElement).find("#measureContainer").show();
	 	} else {
	 		$(parentElement).find("#measureContainer").hide();
	 	}
	}

	 /**************************************************************************************************************/

	/**
	 *	Add/remove samp GUI
	 */
	MizarWidget.prototype.setSampGui = function(visible) {
	 	if ( visible ) {
			$(parentElement).find("#sampContainer").show();
	 	} else {
	 		$(parentElement).find("#sampContainer").hide();
	 	}
	}

	 /**************************************************************************************************************/
	 
	/**
	 *	Add/remove shortener GUI
	 */
	MizarWidget.prototype.setShortenerUrlGui = function(visible) {
	 	if ( visible ) {
			$(parentElement).find("#shareContainer").show();
	 	} else {
	 		$(parentElement).find("#shareContainer").hide();
	 	}
	}

	/**************************************************************************************************************/

	/**
	 *	Add/remove 2d map GUI
	 */
	MizarWidget.prototype.set2dMapGui = function(visible) {
	 	if ( visible ) {
	 		// Mollweide viewer lazy initialization
	 		if ( !this.mollweideViewer )
				this.mollweideViewer = new MollweideViewer({ globe : this.sky, navigation : this.navigation, mizarBaseUrl: mizarBaseUrl });

			$(parentElement).find("#2dMapContainer").show();
	 	} else {
	 		$(parentElement).find("#2dMapContainer").hide();
	 	}
	}

	/**************************************************************************************************************/

	/**
	 *	Add/remove reverse name resolver GUI
	 */
	MizarWidget.prototype.setReverseNameResolverGui = function(visible) {
	 	if ( visible ) {
	 		ReverseNameResolver.init(this, options);
	 	} else {
	 		ReverseNameResolver.remove();
	 	}
	}

	/**************************************************************************************************************/

	/**
	 *	Add/remove name resolver GUI
	 */
	MizarWidget.prototype.setNameResolverGui = function(visible) {
	 	if ( visible ) {
	 		NameResolverView.init();
	 	} else {
	 		NameResolverView.remove();
	 	}
	}

	/**************************************************************************************************************/

	/**
	 *	Add/remove jQueryUI layer manager view
	 */
	MizarWidget.prototype.setCategoryGui = function(visible) {
		if ( visible ) {
	 		LayerManagerView.init(this, $.extend({element: $(parentElement).find(".sidebar")}, options));
	 	} else {
	 		LayerManagerView.remove();
	 	}
	}

	/**************************************************************************************************************/

	/**
	 *	Add/remove jQueryUI image viewer GUI
	 */
	MizarWidget.prototype.setImageViewerGui = function(visible) {
		if ( visible ) {
	 		ImageViewer.init(this);
	 	} else {
	 		ImageViewer.remove();
	 	}
	}

	/**************************************************************************************************************/
	
	/**
	 *	Set coordinate system
	 *	@param newCoordSystem
	 *		"EQ" or "GAL"(respectively equatorial or galactic)
	 */
	MizarWidget.prototype.setCoordinateSystem = function(newCoordSystem) {
		CoordinateSystem.type = newCoordSystem;

		if (this.mollweideViewer)
			this.mollweideViewer.setCoordSystem( newCoordSystem );

		// Publish modified event to update compass north
		this.navigation.publish('modified');
	}

	return MizarWidget;

});return require('MizarWidget');}));